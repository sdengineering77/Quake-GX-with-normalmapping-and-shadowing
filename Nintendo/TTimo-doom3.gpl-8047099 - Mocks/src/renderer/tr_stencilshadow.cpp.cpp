/*
===========================================================================

Doom 3 GPL Source Code
Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. 

This file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).  

Doom 3 Source Code is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Doom 3 Source Code is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Doom 3 Source Code.  If not, see <http://www.gnu.org/licenses/>.

In addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.

If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.

===========================================================================
*/

#include "../idlib/precompiled.h"
#pragma hdrstop

#include "tr_local.h"

// tr_stencilShadow.c -- creaton of stencil shadow volumes

/*

  Should we split shadow volume surfaces when they exceed max verts
  or max indexes?

  a problem is that the number of vertexes needed for the
  shadow volume will be twice the number in the original,
  and possibly up to 8/3 when near plane clipped.

  The maximum index count is 7x when not clipped and all
  triangles are completely discrete.  Near plane clipping
  can increase this to 10x.

  The maximum expansions are always with discrete triangles.
  Meshes of triangles will result in less index expansion because
  there will be less silhouette edges, although it will always be
  greater than the source if a cap is present.

  can't just project onto a plane if some surface points are
  behind the light.

  The cases when a face is edge on to a light is robustly handled
  with closed volumes, because only a single one of it's neighbors
  will pass the edge test.  It may be an issue with non-closed models.

  It is crucial that the shadow volumes be completely enclosed.
  The triangles identified as shadow sources will be projected
  directly onto the light far plane.
  The sil edges must be handled carefully.
  A partially clipped explicit sil edge will still generate a sil
  edge.
  EVERY new edge generated by clipping the triangles to the view
  will generate a sil edge.

  If a triangle has no points inside the frustum, it is completely
  culled away.  If a sil edge is either in or on the frustum, it is
  added.
  If a triangle has no points outside the frustum, it does not
  need to be clipped.

  

  USING THE STENCIL BUFFER FOR SHADOWING

  basic triangle property

  view plane inside shadow volume problem

  quad triangulation issue

  issues with silhouette optimizations

  the shapes of shadow projections are poor for sphere or box culling
  
  the gouraud shading problem


  // epsilon culling rules:

// the positive side of the frustum is inside
d = tri->verts[i].xyz * frustum[j].Normal() + frustum[j][3];
if ( d < LIGHT_CLIP_EPSILON ) {
	pointCull[i] |= ( 1 << j );
}
if ( d > -LIGHT_CLIP_EPSILON ) {
	pointCull[i] |= ( 1 << (6+j) );
}

If a low order bit is set, the point is on or outside the plane
If a high order bit is set, the point is on or inside the plane
If a low order bit is clear, the point is inside the plane (definately positive)
If a high order bit is clear, the point is outside the plane (definately negative)


*/

#define TRIANGLE_CULLED(p1,p2,p3) ( pointCull[p1] & pointCull[p2] & pointCull[p3] & 0x3f )

//#define TRIANGLE_CLIPPED(p1,p2,p3) ( ( pointCull[p1] | pointCull[p2] | pointCull[p3] ) & 0xfc0 )
#define TRIANGLE_CLIPPED(p1,p2,p3) ( ( ( pointCull[p1] & pointCull[p2] & pointCull[p3] ) & 0xfc0 ) != 0xfc0 )

// an edge that is on the plane is NOT culled
#define EDGE_CULLED(p1,p2) ( ( pointCull[p1] ^ 0xfc0 ) & ( pointCull[p2] ^ 0xfc0 ) & 0xfc0 )

#define EDGE_CLIPPED(p1,p2) ( ( pointCull[p1] & pointCull[p2] & 0xfc0 ) != 0xfc0 )

// a point that is on the plane is NOT culled
//#define	POINT_CULLED(p1) ( ( pointCull[p1] ^ 0xfc0 ) & 0xfc0 )
#define	POINT_CULLED(p1) ( ( pointCull[p1] & 0xfc0 ) != 0xfc0 )

//#define	LIGHT_CLIP_EPSILON	0.001f
#define	LIGHT_CLIP_EPSILON		0.1f

#define	MAX_CLIP_SIL_EDGES		2048
static int	numClipSilEdges;
static int	clipSilEdges[MAX_CLIP_SIL_EDGES][2];

// facing will be 0 if forward facing, 1 if backwards facing
// grabbed with alloca
static byte	*globalFacing;

// faceCastsShadow will be 1 if the face is in the projection
// and facing the apropriate direction
static byte	*faceCastsShadow;

static int	*remap;

#define	MAX_SHADOW_INDEXES		0x18000
#define	MAX_SHADOW_VERTS		0x18000
static int	numShadowIndexes;
static glIndex_t	shadowIndexes[MAX_SHADOW_INDEXES];
static int	numShadowVerts;
static idVec4	shadowVerts[MAX_SHADOW_VERTS];
static bool overflowed;

idPlane	pointLightFrustums[6][6] = {
	{
		idPlane( 1,0,0,0 ),
		idPlane( 1,1,0,0 ),
		idPlane( 1,-1,0,0 ),
		idPlane( 1,0,1,0 ),
		idPlane( 1,0,-1,0 ),
		idPlane( -1,0,0,0 ),
	},
	{
		idPlane( -1,0,0,0 ),
		idPlane( -1,1,0,0 ),
		idPlane( -1,-1,0,0 ),
		idPlane( -1,0,1,0 ),
		idPlane( -1,0,-1,0 ),
		idPlane( 1,0,0,0 ),
	},

	{
		idPlane( 0,1,0,0 ),
		idPlane( 0,1,1,0 ),
		idPlane( 0,1,-1,0 ),
		idPlane( 1,1,0,0 ),
		idPlane( -1,1,0,0 ),
		idPlane( 0,-1,0,0 ),
	},
	{
		idPlane( 0,-1,0,0 ),
		idPlane( 0,-1,1,0 ),
		idPlane( 0,-1,-1,0 ),
		idPlane( 1,-1,0,0 ),
		idPlane( -1,-1,0,0 ),
		idPlane( 0,1,0,0 ),
	},

	{
		idPlane( 0,0,1,0 ),
		idPlane( 1,0,1,0 ),
		idPlane( -1,0,1,0 ),
		idPlane( 0,1,1,0 ),
		idPlane( 0,-1,1,0 ),
		idPlane( 0,0,-1,0 ),
	},
	{
		idPlane( 0,0,-1,0 ),
		idPlane( 1,0,-1,0 ),
		idPlane( -1,0,-1,0 ),
		idPlane( 0,1,-1,0 ),
		idPlane( 0,-1,-1,0 ),
		idPlane( 0,0,1,0 ),
	},
};

int	c_caps, c_sils;

static bool	callOptimizer;			// call the preprocessor optimizer after clipping occluders

typedef struct {
	int		frontCapStart;
	int		rearCapStart;
	int		silStart;
	int		end;
} indexRef_t;
static indexRef_t	indexRef[6];
static int indexFrustumNumber;		// which shadow generating side of a light the indexRef is for

/*
===============
PointsOrdered

To make sure the triangulations of the sil edges is consistant,
we need to be able to order two points.  We don't care about how
they compare with any other points, just that when the same two
points are passed in (in either order), they will always specify
the same one as leading.

Currently we need to have separate faces in different surfaces
order the same way, so we must look at the actual coordinates.
If surfaces are ever guaranteed to not have to edge match with
other surfaces, we could just compare indexes.
===============
*/
static bool PointsOrdered( const idVec3 &a, const idVec3 &b ) {
    bool retVal;
    memset(&retVal, 0, sizeof(bool));
    Sys_Printf("bool PointsOrdered( const idVec3 &a, const idVec3 &b )\r\n");
    return retVal;
}


/*
====================
R_LightProjectionMatrix

====================
*/
void R_LightProjectionMatrix( const idVec3 &origin, const idPlane &rearPlane, idVec4 mat[4] ) {
    Sys_Printf("void R_LightProjectionMatrix( const idVec3 &origin, const idPlane &rearPlane, idVec4 mat[4] )\r\n");
}


/*
===================
R_ProjectPointsToFarPlane

make a projected copy of the even verts into the odd spots
that is on the far light clip plane
===================
*/
static void R_ProjectPointsToFarPlane( const idRenderEntityLocal *ent, const idRenderLightLocal *light,
									const idPlane &lightPlaneLocal,
									int firstShadowVert, int numShadowVerts ) {
    Sys_Printf("void R_ProjectPointsToFarPlane( const idRenderEntityLocal *ent, const idRenderLightLocal *light,const idPlane &lightPlaneLocal,int firstShadowVert, int numShadowVerts )\r\n");
}




#define	MAX_CLIPPED_POINTS	20
typedef struct {
	int		numVerts;
	idVec3	verts[MAX_CLIPPED_POINTS];
	int		edgeFlags[MAX_CLIPPED_POINTS];
} clipTri_t;

/*
=============
R_ChopWinding

Clips a triangle from one buffer to another, setting edge flags
The returned buffer may be the same as inNum if no clipping is done
If entirely clipped away, clipTris[returned].numVerts == 0

I have some worries about edge flag cases when polygons are clipped
multiple times near the epsilon.
=============
*/
static int R_ChopWinding( clipTri_t clipTris[2], int inNum, const idPlane &plane ) {
    int retVal;
    memset(&retVal, 0, sizeof(int));
    Sys_Printf("int R_ChopWinding( clipTri_t clipTris[2], int inNum, const idPlane &plane )\r\n");
    return retVal;
}


/*
===================
R_ClipTriangleToLight

Returns false if nothing is left after clipping
===================
*/
static bool	R_ClipTriangleToLight( const idVec3 &a, const idVec3 &b, const idVec3 &c, int planeBits,
							  const idPlane frustum[6] ) {
    bool retVal;
    memset(&retVal, 0, sizeof(bool));
    Sys_Printf("boolR_ClipTriangleToLight( const idVec3 &a, const idVec3 &b, const idVec3 &c, int planeBits, const idPlane frustum[6] )\r\n");
    return retVal;
}


/*
===================
R_ClipLineToLight

If neither point is clearly behind the clipping
plane, the edge will be passed unmodified.  A sil edge that
is on a border plane must be drawn.

If one point is clearly clipped by the plane and the
other point is on the plane, it will be completely removed.
===================
*/
static bool R_ClipLineToLight(	const idVec3 &a, const idVec3 &b, const idPlane frustum[4], 
						   idVec3 &p1, idVec3 &p2 ) {
    bool retVal;
    memset(&retVal, 0, sizeof(bool));
    Sys_Printf("bool R_ClipLineToLight(const idVec3 &a, const idVec3 &b, const idPlane frustum[4], idVec3 &p1, idVec3 &p2 )\r\n");
    return retVal;
}



/*
==================
R_AddClipSilEdges

Add sil edges for each triangle clipped to the side of
the frustum.

Only done for simple projected lights, not point lights.
==================
*/
static void R_AddClipSilEdges( void ) {
    Sys_Printf("void R_AddClipSilEdges( void )\r\n");
}


/*
=================
R_AddSilEdges

Add quads from the front points to the projected points
for each silhouette edge in the light
=================
*/
static void R_AddSilEdges( const srfTriangles_t *tri, unsigned short *pointCull, const idPlane frustum[6] ) {
    Sys_Printf("void R_AddSilEdges( const srfTriangles_t *tri, unsigned short *pointCull, const idPlane frustum[6] )\r\n");
}


/*
================
R_CalcPointCull

Also inits the remap[] array to all -1
================
*/
static void R_CalcPointCull( const srfTriangles_t *tri, const idPlane frustum[6], unsigned short *pointCull ) {
    Sys_Printf("void R_CalcPointCull( const srfTriangles_t *tri, const idPlane frustum[6], unsigned short *pointCull )\r\n");
}


/*
=================
R_CreateShadowVolumeInFrustum

Adds new verts and indexes to the shadow volume.

If the frustum completely defines the projected light,
makeClippedPlanes should be true, which will cause sil quads to
be added along all clipped edges.

If the frustum is just part of a point light, clipped planes don't
need to be added.
=================
*/
static void R_CreateShadowVolumeInFrustum( const idRenderEntityLocal *ent, 
										  const srfTriangles_t *tri,
										  const idRenderLightLocal *light,									
										  const idVec3 lightOrigin,
										  const idPlane frustum[6],
										  const idPlane &farPlane,
										  bool makeClippedPlanes ) {
    Sys_Printf("void R_CreateShadowVolumeInFrustum( const idRenderEntityLocal *ent, const srfTriangles_t *tri, const idRenderLightLocal *light, const idVec3 lightOrigin, const idPlane frustum[6], const idPlane &farPlane, bool makeClippedPlanes )\r\n");
}


/*
===================
R_MakeShadowFrustums

Called at definition derivation time
===================
*/
void R_MakeShadowFrustums( idRenderLightLocal *light ) {
    Sys_Printf("void R_MakeShadowFrustums( idRenderLightLocal *light )\r\n");
}


/*
=================
R_CreateShadowVolume

The returned surface will have a valid bounds and radius for culling.

Triangles are clipped to the light frustum before projecting.

A single triangle can clip to as many as 7 vertexes, so
the worst case expansion is 2*(numindexes/3)*7 verts when counting both
the front and back caps, although it will usually only be a modest
increase in vertexes for closed modesl

The worst case index count is much larger, when the 7 vertex clipped triangle
needs 15 indexes for the front, 15 for the back, and 42 (a quad on seven sides)
for the sides, for a total of 72 indexes from the original 3.  Ouch.

NULL may be returned if the surface doesn't create a shadow volume at all,
as with a single face that the light is behind.

If an edge is within an epsilon of the border of the volume, it must be treated
as if it is clipped for triangles, generating a new sil edge, and act
as if it was culled for edges, because the sil edge will have been
generated by the triangle irregardless of if it actually was a sil edge.
=================
*/
srfTriangles_t *R_CreateShadowVolume( const idRenderEntityLocal *ent,
									 const srfTriangles_t *tri, const idRenderLightLocal *light,
									 shadowGen_t optimize, srfCullInfo_t &cullInfo ) {
    Sys_Printf("srfTriangles_t *R_CreateShadowVolume( const idRenderEntityLocal *ent, const srfTriangles_t *tri, const idRenderLightLocal *light, shadowGen_t optimize, srfCullInfo_t &cullInfo )\r\n");
    return NULL;
}

