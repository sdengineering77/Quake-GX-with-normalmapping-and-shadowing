# 1 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
# 1 "d:\\Data\\Nintendo\\DoomGX\\build//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
# 29 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 1
# 96 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h"
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 1 3
# 29 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 1 3
# 15 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/newlib.h" 1 3
# 16 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 1 3



# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/ieeefp.h" 1 3
# 5 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 1 3
# 25 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 3
extern "C" {
# 209 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 3
}
# 6 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 2 3
# 17 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 2 3
# 30 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3




# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 212 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef unsigned int size_t;
# 35 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 1 3 4
# 40 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 38 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3







# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 1 3
# 9 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
extern "C" {



# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 1 3
# 14 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 1 3
# 12 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_types.h" 1 3






# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 1 3
# 9 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
extern "C" {
# 26 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 118 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
}
# 8 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_types.h" 2 3


typedef long long _fpos_t;


typedef long long _off_t;
# 13 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 47 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/lock.h" 3
extern int __libc_lock_init(int*,int);
extern int __libc_lock_close(int*);
extern int __libc_lock_acquire(int*);
extern int __libc_lock_try_acquire(int*);
extern int __libc_lock_release(int*);
# 14 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3
# 24 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
typedef short __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;
# 56 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 353 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 169 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                     ;
  int (* _write) (struct _reent *, void *, const char *, int)
                            ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _fpos_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 273 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 305 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 580 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 818 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr __attribute__((__section__(".sdata")));
extern struct _reent *const _global_impure_ptr __attribute__((__section__(".sdata")));

void _reclaim_reent (struct _reent *);
# 841 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
}
# 46 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 1 3
# 69 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 150 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 70 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/types.h" 1 3
# 19 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 92 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;



typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;



typedef unsigned long clock_t;




typedef long time_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;
typedef char * caddr_t;






typedef unsigned int ino_t;
# 163 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;





typedef int pid_t;







typedef long key_t;

typedef _ssize_t ssize_t;
# 196 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 223 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 254 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;

typedef __uint32_t fsblkcnt_t;
typedef __uint32_t fsfilcnt_t;
# 47 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3

extern "C" {

typedef __FILE FILE;




typedef _fpos_t fpos_t;





# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 1 3
# 9 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 3
     extern void __flockfile(FILE *fp);
# 18 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 3
     extern void __funlockfile(FILE *fp);
# 62 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3
# 171 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *, const char *, FILE *);
void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);
int fprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int printf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int scanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int sscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int vfprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int vsprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int fgetc (FILE *);
char * fgets (char *, int, FILE *);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *, size_t _size, size_t _n, FILE *);
size_t fwrite (const void * , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *, fpos_t *);

int fseek (FILE *, off_t, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *_name, const char *_type);
int sprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int remove (const char *);
int rename (const char *, const char *);






int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);




int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * asnprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int asprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int fcloseall (void);
int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int snprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vfscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsnprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
# 313 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE * fdopen (int, const char *);

int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 338 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
int dprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

FILE * fmemopen (void *, size_t, const char *);


FILE * open_memstream (char **, size_t *);



int vdprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;







int _asiprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
char * _asnprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _asprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _diprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _dprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *, int, FILE *);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
FILE * _fmemopen_r (struct _reent *, void *, size_t, const char *);
FILE * _fopen_r (struct _reent *, const char *, const char *);
FILE * _freopen_r (struct _reent *, const char *, const char *, FILE *);
int _fprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *, FILE *);
size_t _fread_r (struct _reent *, void *, size_t _size, size_t _n, FILE *);
int _fscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _fseek_r (struct _reent *, FILE *, off_t, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * , size_t _size, size_t _n, FILE *);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new)
                                          ;
int _scanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int _siprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _snprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _sprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _sscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vfprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _vscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsnprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 515 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 535 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE *funopen (const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))



                                   ;
FILE *_funopen_r (struct _reent *, const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))



                                   ;







typedef ssize_t cookie_read_function_t(void *__cookie, char *__buf, size_t __n);
typedef ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
     size_t __n);




typedef int cookie_seek_function_t(void *__cookie, off_t *__off, int __whence);

typedef int cookie_close_function_t(void *__cookie);
typedef struct
{


  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
FILE *fopencookie (void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
FILE *_fopencookie_r (struct _reent *, void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
# 683 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
}
# 97 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 1 3
# 15 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 16 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/stdlib.h" 1 3
# 19 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3

# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/alloca.h" 1 3
# 21 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3






extern "C" {

typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;


typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;
# 58 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
int __locale_mb_cur_max (void);



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);

float atoff (const char *__nptr);

int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *))



                                                         ;
void * calloc (size_t __nmemb, size_t __size) __attribute__ ((nothrow));
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) __attribute__ ((nothrow));
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);

extern char *suboptarg;
int getsubopt (char **, char * const *, char **);

long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) __attribute__ ((nothrow));
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);


char * mkdtemp (char *);
int mkostemp (char *, int);
int mkostemps (char *, int, int);
int mkstemp (char *);
int mkstemps (char *, int);
char * mktemp (char *) __attribute__ ((__warning__ ("the use of `mktemp' is dangerous; use `mkstemp' instead")));

char * _mkdtemp_r (struct _reent *, char *);
int _mkostemp_r (struct _reent *, char *, int);
int _mkostemps_r (struct _reent *, char *, int, int);
int _mkstemp_r (struct _reent *, char *);
int _mkstemps_r (struct _reent *, char *, int);
char * _mktemp_r (struct _reent *, char *) __attribute__ ((__warning__ ("the use of `mktemp' is dangerous; use `mkstemp' instead")));

void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size) __attribute__ ((nothrow));

void * reallocf (void * __r, size_t __size);

void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);


long a64l (const char *__input);
char * l64a (long __input);
char * _l64a_r (struct _reent *,long __input);
int on_exit (void (*__func)(int, void *),void * __arg);
void _Exit (int __status) __attribute__ ((noreturn));
int putenv (char *__string);
int _putenv_r (struct _reent *, char *__string);
void * _reallocf_r (struct _reent *, void *, size_t);
int setenv (const char *__string, const char *__value, int __overwrite);
int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);

char * gcvt (double,int,char *);
char * gcvtf (float,int,char *);
char * fcvt (double,int,int *,int *);
char * fcvtf (float,int,int *,int *);
char * ecvt (double,int,int *,int *);
char * ecvtbuf (double, int, int*, int*, char *);
char * fcvtbuf (double, int, int*, int*, char *);
char * ecvtf (float,int,int *,int *);
char * dtoa (double, int, int, int *, int*, char**);
int rand_r (unsigned *__seed);

double drand48 (void);
double _drand48_r (struct _reent *);
double erand48 (unsigned short [3]);
double _erand48_r (struct _reent *, unsigned short [3]);
long jrand48 (unsigned short [3]);
long _jrand48_r (struct _reent *, unsigned short [3]);
void lcong48 (unsigned short [7]);
void _lcong48_r (struct _reent *, unsigned short [7]);
long lrand48 (void);
long _lrand48_r (struct _reent *);
long mrand48 (void);
long _mrand48_r (struct _reent *);
long nrand48 (unsigned short [3]);
long _nrand48_r (struct _reent *, unsigned short [3]);
unsigned short *
       seed48 (unsigned short [3]);
unsigned short *
       _seed48_r (struct _reent *, unsigned short [3]);
void srand48 (long);
void _srand48_r (struct _reent *, long);
long long atoll (const char *__nptr);
long long _atoll_r (struct _reent *, const char *__nptr);
long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *__n, char **__end_PTR, int __base);
long long _strtoll_r (struct _reent *, const char *__n, char **__end_PTR, int __base);
unsigned long long strtoull (const char *__n, char **__end_PTR, int __base);
unsigned long long _strtoull_r (struct _reent *, const char *__n, char **__end_PTR, int __base);


void cfree (void *);
int unsetenv (const char *__string);
int _unsetenv_r (struct _reent *, const char *__string);
# 206 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) __attribute__ ((nothrow));
void * _calloc_r (struct _reent *, size_t, size_t) __attribute__ ((nothrow));
void _free_r (struct _reent *, void *) __attribute__ ((nothrow));
void * _realloc_r (struct _reent *, void *, size_t) __attribute__ ((nothrow));
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);



extern long double strtold (const char *, char **);
extern long double wcstold (const wchar_t *, wchar_t **);


}
# 98 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 1 3 4
# 102 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 99 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 1 3
# 12 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/cdefs.h" 1 3
# 13 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 16 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3





extern "C" {

void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *, const void *, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *, const char *);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *, const char *, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);


char *strtok (char *, const char *);


size_t strxfrm (char *, const char *, size_t);


char *strtok_r (char *, const char *, char **);

int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
int ffs (int);
char *index (const char *, int);
void * memccpy (void *, const void *, int, size_t);
void * mempcpy (void *, const void *, size_t);
void * memmem (const void *, size_t, const void *, size_t);
char *rindex (const char *, int);
char *stpcpy (char *, const char *);
char *stpncpy (char *, const char *, size_t);
int strcasecmp (const char *, const char *);
char *strcasestr (const char *, const char *);
char *strchrnul (const char *, int);
char *strdup (const char *);
char *_strdup_r (struct _reent *, const char *);
char *strndup (const char *, size_t);
char *_strndup_r (struct _reent *, const char *, size_t);
# 79 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
int strerror_r (int, char *, size_t) __asm__ ("" "__xpg_strerror_r");





size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
int strncasecmp (const char *, const char *, size_t);
size_t strnlen (const char *, size_t);
char *strsep (char **, const char *);
char *strlwr (char *);
char *strupr (char *);

char *strsignal (int __signo);






char * _strerror_r (struct _reent *, int, int, int *);
# 132 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/string.h" 1 3
# 133 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3

}
# 100 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/assert.h" 1 3





extern "C" {
# 39 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/assert.h" 3
void __assert (const char *, int, const char *) __attribute__ ((__noreturn__))
                                 ;
void __assert_func (const char *, int, const char *, const char *) __attribute__ ((__noreturn__))
                                 ;


}
# 101 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 1 3
# 18 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/time.h" 1 3
# 19 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3
# 27 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 28 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3



extern "C" {

struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
};

clock_t clock (void);
double difftime (time_t _time2, time_t _time1);
time_t mktime (struct tm *_timeptr);
time_t time (time_t *_timer);

char *asctime (const struct tm *_tblock);
char *ctime (const time_t *_time);
struct tm *gmtime (const time_t *_timer);
struct tm *localtime (const time_t *_timer);

size_t strftime (char *_s, size_t _maxsize, const char *_fmt, const struct tm *_t);

char *asctime_r (const struct tm *, char *);
char *ctime_r (const time_t *, char *);
struct tm *gmtime_r (const time_t *, struct tm *);
struct tm *localtime_r (const time_t *, struct tm *);

}


extern "C" {



char *strptime (const char *, const char *, struct tm *);
void tzset (void);
void _tzset_r (struct _reent *);

typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  long offset;
} __tzrule_type;

typedef struct __tzinfo_struct
{
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo (void);
# 118 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
extern long _timezone;
extern int _daylight;
extern char *_tzname[2];
# 129 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
}
# 195 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
extern "C" {
# 273 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
}
# 102 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 1 3





extern "C" {

int isalnum (int __c);
int isalpha (int __c);
int iscntrl (int __c);
int isdigit (int __c);
int isgraph (int __c);
int islower (int __c);
int isprint (int __c);
int ispunct (int __c);
int isspace (int __c);
int isupper (int __c);
int isxdigit (int __c);
int tolower (int __c);
int toupper (int __c);


int isblank (int __c);



int isascii (int __c);
int toascii (int __c);
# 45 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 3
extern char *__ctype_ptr__;
# 109 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 3
extern const char _ctype_[];

}
# 103 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 1 3
# 34 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
       
# 35 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3

# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 1 3
# 35 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
       
# 36 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3

#pragma GCC visibility push(default)

# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 1 3
# 153 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 3
namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;




}
# 393 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/os_defines.h" 1 3
# 394 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 2 3


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/cpu_defines.h" 1 3
# 397 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 2 3
# 40 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 2 3

extern "C++" {

namespace std
{
# 61 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 118 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 143 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
# 37 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 2 3





#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 83 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name[0] == '*' ? __name + 1 : __name; }
# 118 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
    bool before(const type_info& __arg) const
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 139 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
# 155 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 104 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/errno.h" 1 3




typedef int error_t;



# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/errno.h" 1 3






extern "C" {







extern int *__errno (void);




extern const char * const _sys_errlist[];
extern int _sys_nerr;
# 190 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/errno.h" 3
}
# 10 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/errno.h" 2 3
# 105 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 1 3
# 9 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern "C" {




union __dmath
{
  double d;
  __ULong i[2];
};

union __fmath
{
  float f;
  __ULong i[1];
};


union __ldmath
{
  long double ld;
  __ULong i[4];
};
# 111 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double atan (double);
extern double cos (double);
extern double sin (double);
extern double tan (double);
extern double tanh (double);
extern double frexp (double, int *);
extern double modf (double, double *);
extern double ceil (double);
extern double fabs (double);
extern double floor (double);






extern double acos (double);
extern double asin (double);
extern double atan2 (double, double);
extern double cosh (double);
extern double sinh (double);
extern double exp (double);
extern double ldexp (double, int);
extern double log (double);
extern double log10 (double);
extern double pow (double, double);
extern double sqrt (double);
extern double fmod (double, double);
# 148 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 175 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern int __isinff (float x);
extern int __isinfd (double x);
extern int __isnanf (float x);
extern int __isnand (double x);
extern int __fpclassifyf (float x);
extern int __fpclassifyd (double x);
extern int __signbitf (float x);
extern int __signbitd (double x);
# 235 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double infinity (void);
extern double nan (const char *);
extern int finite (double);
extern double copysign (double, double);
extern double logb (double);
extern int ilogb (double);

extern double asinh (double);
extern double cbrt (double);
extern double nextafter (double, double);
extern double rint (double);
extern double scalbn (double, int);

extern double exp2 (double);
extern double scalbln (double, long int);
extern double tgamma (double);
extern double nearbyint (double);
extern long int lrint (double);
extern long long int llrint (double);
extern double round (double);
extern long int lround (double);
extern long long int llround (double);
extern double trunc (double);
extern double remquo (double, double, int *);
extern double fdim (double, double);
extern double fmax (double, double);
extern double fmin (double, double);
extern double fma (double, double, double);


extern double log1p (double);
extern double expm1 (double);



extern double acosh (double);
extern double atanh (double);
extern double remainder (double, double);
extern double gamma (double);
extern double lgamma (double);
extern double erf (double);
extern double erfc (double);
extern double log2 (double);





extern double hypot (double, double);






extern float atanf (float);
extern float cosf (float);
extern float sinf (float);
extern float tanf (float);
extern float tanhf (float);
extern float frexpf (float, int *);
extern float modff (float, float *);
extern float ceilf (float);
extern float fabsf (float);
extern float floorf (float);


extern float acosf (float);
extern float asinf (float);
extern float atan2f (float, float);
extern float coshf (float);
extern float sinhf (float);
extern float expf (float);
extern float ldexpf (float, int);
extern float logf (float);
extern float log10f (float);
extern float powf (float, float);
extern float sqrtf (float);
extern float fmodf (float, float);




extern float exp2f (float);
extern float scalblnf (float, long int);
extern float tgammaf (float);
extern float nearbyintf (float);
extern long int lrintf (float);
extern long long llrintf (float);
extern float roundf (float);
extern long int lroundf (float);
extern long long int llroundf (float);
extern float truncf (float);
extern float remquof (float, float, int *);
extern float fdimf (float, float);
extern float fmaxf (float, float);
extern float fminf (float, float);
extern float fmaf (float, float, float);

extern float infinityf (void);
extern float nanf (const char *);
extern int finitef (float);
extern float copysignf (float, float);
extern float logbf (float);
extern int ilogbf (float);

extern float asinhf (float);
extern float cbrtf (float);
extern float nextafterf (float, float);
extern float rintf (float);
extern float scalbnf (float, int);
extern float log1pf (float);
extern float expm1f (float);


extern float acoshf (float);
extern float atanhf (float);
extern float remainderf (float, float);
extern float gammaf (float);
extern float lgammaf (float);
extern float erff (float);
extern float erfcf (float);
extern float log2f (float);



extern float hypotf (float, float);






extern long double atanl (long double);
extern long double cosl (long double);
extern long double sinl (long double);
extern long double tanl (long double);
extern long double tanhl (long double);
extern long double frexpl (long double value, int *);
extern long double modfl (long double, long double *);
extern long double ceill (long double);
extern long double fabsl (long double);
extern long double floorl (long double);
extern long double log1pl (long double);
extern long double expm1l (long double);




extern long double acosl (long double);
extern long double asinl (long double);
extern long double atan2l (long double, long double);
extern long double coshl (long double);
extern long double sinhl (long double);
extern long double expl (long double);
extern long double ldexpl (long double, int);
extern long double logl (long double);
extern long double log10l (long double);
extern long double powl (long double, long double);
extern long double sqrtl (long double);
extern long double fmodl (long double, long double);
extern long double hypotl (long double, long double);


extern long double copysignl (long double, long double);
extern long double nanl (const char *);
extern int ilogbl (long double);
extern long double asinhl (long double);
extern long double cbrtl (long double);
extern long double nextafterl (long double, long double);
extern long double rintl (long double);
extern long double scalbnl (long double, int);
extern long double exp2l (long double);
extern long double scalblnl (long double, long);
extern long double tgammal (long double);
extern long double nearbyintl (long double);
extern long int lrintl (long double);
extern long long int llrintl (long double);
extern long double roundl (long double);
extern long lroundl (long double);
extern long long int llroundl (long double);
extern long double truncl (long double);
extern long double remquol (long double, long double, int *);
extern long double fdiml (long double, long double);
extern long double fmaxl (long double, long double);
extern long double fminl (long double, long double);
extern long double fmal (long double, long double, long double);

extern long double acoshl (long double);
extern long double atanhl (long double);
extern long double remainderl (long double, long double);
extern long double lgammal (long double);
extern long double erfl (long double);
extern long double erfcl (long double);
# 443 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double drem (double, double);
extern void sincos (double, double *, double *);
extern double gamma_r (double, int *);
extern double lgamma_r (double, int *);

extern double y0 (double);
extern double y1 (double);
extern double yn (int, double);
extern double j0 (double);
extern double j1 (double);
extern double jn (int, double);

extern float dremf (float, float);
extern void sincosf (float, float *, float *);
extern float gammaf_r (float, int *);
extern float lgammaf_r (float, int *);

extern float y0f (float);
extern float y1f (float);
extern float ynf (int, float);
extern float j0f (float);
extern float j1f (float);
extern float jnf (int, float);



extern double exp10 (double);


extern double pow10 (double);


extern float exp10f (float);


extern float pow10f (float);
# 488 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern int *__signgam (void);
# 497 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
struct __exception



{
  int type;
  char *name;
  double arg1;
  double arg2;
  double retval;
  int err;
};


extern int matherr (struct __exception *e);
# 554 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
enum __fdlibm_version
{
  __fdlibm_ieee = -1,
  __fdlibm_svid,
  __fdlibm_xopen,
  __fdlibm_posix
};




extern enum __fdlibm_version __fdlib_version;
# 574 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
}
# 106 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2




# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sys/sys_public.h" 1
# 174 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sys/sys_public.h"
typedef enum {
 CPUID_NONE = 0x00000,
 CPUID_UNSUPPORTED = 0x00001,
 CPUID_GENERIC = 0x00002,
 CPUID_INTEL = 0x00004,
 CPUID_AMD = 0x00008,
 CPUID_MMX = 0x00010,
 CPUID_3DNOW = 0x00020,
 CPUID_SSE = 0x00040,
 CPUID_SSE2 = 0x00080,
 CPUID_SSE3 = 0x00100,
 CPUID_ALTIVEC = 0x00200,
 CPUID_HTT = 0x01000,
 CPUID_CMOV = 0x02000,
 CPUID_FTZ = 0x04000,
 CPUID_DAZ = 0x08000
} cpuid_t;

typedef enum {
 FPU_EXCEPTION_INVALID_OPERATION = 1,
 FPU_EXCEPTION_DENORMALIZED_OPERAND = 2,
 FPU_EXCEPTION_DIVIDE_BY_ZERO = 4,
 FPU_EXCEPTION_NUMERIC_OVERFLOW = 8,
 FPU_EXCEPTION_NUMERIC_UNDERFLOW = 16,
 FPU_EXCEPTION_INEXACT_RESULT = 32
} fpuExceptions_t;

typedef enum {
 FPU_PRECISION_SINGLE = 0,
 FPU_PRECISION_DOUBLE = 1,
 FPU_PRECISION_DOUBLE_EXTENDED = 2
} fpuPrecision_t;

typedef enum {
 FPU_ROUNDING_TO_NEAREST = 0,
 FPU_ROUNDING_DOWN = 1,
 FPU_ROUNDING_UP = 2,
 FPU_ROUNDING_TO_ZERO = 3
} fpuRounding_t;

typedef enum {
 AXIS_SIDE,
 AXIS_FORWARD,
 AXIS_UP,
 AXIS_ROLL,
 AXIS_YAW,
 AXIS_PITCH,
 MAX_JOYSTICK_AXIS
} joystickAxis_t;

typedef enum {
 SE_NONE,
 SE_KEY,
 SE_CHAR,
 SE_MOUSE,
 SE_JOYSTICK_AXIS,
 SE_CONSOLE
} sysEventType_t;

typedef enum {
 M_ACTION1,
 M_ACTION2,
 M_ACTION3,
 M_ACTION4,
 M_ACTION5,
 M_ACTION6,
 M_ACTION7,
 M_ACTION8,
 M_DELTAX,
 M_DELTAY,
 M_DELTAZ
} sys_mEvents;
# 258 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sys/sys_public.h"
typedef struct {
    int evTime;
    sysEventType_t evType;
    int evValue;
    int evValue2;
    int evPtrLength;
    void *evPtr;
} sysEvent_t;


typedef struct sysMemoryStats_s {
 int memoryLoad;
 int totalPhysical;
 int availPhysical;
 int totalPageFile;
 int availPageFile;
 int totalVirtual;
 int availVirtual;
 int availExtendedVirtual;
} sysMemoryStats_t;

typedef unsigned long address_t;

template<class type> class idList;


void Sys_Init( void );
void Sys_Shutdown( void );
void Sys_Error( const char *error, ...);
void Sys_Quit( void );

bool Sys_AlreadyRunning( void );


char * Sys_GetClipboardData( void );
void Sys_SetClipboardData( const char *string );



void Sys_Printf( const char *msg, ... )__attribute__((format(printf,1,2)));


void Sys_DebugPrintf( const char *fmt, ... )__attribute__((format(printf,1,2)));
void Sys_DebugVPrintf( const char *fmt, va_list arg );






void Sys_Sleep( int msec );



int Sys_Milliseconds( void );


double Sys_GetClockTicks( void );
double Sys_ClockTicksPerSecond( void );


cpuid_t Sys_GetProcessorId( void );
const char * Sys_GetProcessorString( void );


bool Sys_FPU_StackIsEmpty( void );


void Sys_FPU_ClearStack( void );


const char * Sys_FPU_GetState( void );


void Sys_FPU_EnableExceptions( int exceptions );


void Sys_FPU_SetPrecision( int precision );


void Sys_FPU_SetRounding( int rounding );


void Sys_FPU_SetFTZ( bool enable );


void Sys_FPU_SetDAZ( bool enable );


int Sys_GetSystemRam( void );


int Sys_GetVideoRam( void );


int Sys_GetDriveFreeSpace( const char *path );


void Sys_GetCurrentMemoryStatus( sysMemoryStats_t &stats );
void Sys_GetExeLaunchMemoryStatus( sysMemoryStats_t &stats );


bool Sys_LockMemory( void *ptr, int bytes );
bool Sys_UnlockMemory( void *ptr, int bytes );


void Sys_SetPhysicalWorkMemory( int minBytes, int maxBytes );


void Sys_GetCallStack( address_t *callStack, const int callStackSize );
const char * Sys_GetCallStackStr( const address_t *callStack, const int callStackSize );
const char * Sys_GetCallStackCurStr( int depth );
const char * Sys_GetCallStackCurAddressStr( int depth );
void Sys_ShutdownSymbols( void );


int Sys_DLL_Load( const char *dllName );
void * Sys_DLL_GetProcAddress( int dllHandle, const char *procName );
void Sys_DLL_Unload( int dllHandle );


void Sys_GenerateEvents( void );
sysEvent_t Sys_GetEvent( void );
void Sys_ClearEvents( void );



void Sys_InitInput( void );
void Sys_ShutdownInput( void );
void Sys_InitScanTable( void );
const unsigned char *Sys_GetScanTable( void );
unsigned char Sys_GetConsoleKey( bool shifted );



unsigned char Sys_MapCharForKey( int key );


int Sys_PollKeyboardInputEvents( void );
int Sys_ReturnKeyboardInputEvent( const int n, int &ch, bool &state );
void Sys_EndKeyboardInputEvents( void );


int Sys_PollMouseInputEvents( void );
int Sys_ReturnMouseInputEvent( const int n, int &action, int &value );
void Sys_EndMouseInputEvents( void );




void Sys_GrabMouseCursor( bool grabIt );

void Sys_ShowWindow( bool show );
bool Sys_IsWindowVisible( void );
void Sys_ShowConsole( int visLevel, bool quitOnClose );


void Sys_Mkdir( const char *path );
time_t Sys_FileTimeStamp( FILE *fp );

const char * Sys_TimeStampToStr( time_t timeStamp );
const char * Sys_DefaultCDPath( void );
const char * Sys_DefaultBasePath( void );
const char * Sys_DefaultSavePath( void );
const char * Sys_EXEPath( void );



int Sys_ListFiles( const char *directory, const char *extension, idList<class idStr> &list );


void Sys_SetFatalError( const char *error );


void Sys_DoPreferences( void );

void Sys_Printf (char const *fmt, ...);
void Sys_PrintBacktrace(void);
# 445 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sys/sys_public.h"
typedef enum {
 NA_BAD,
 NA_LOOPBACK,
 NA_BROADCAST,
 NA_IP
} netadrtype_t;

typedef struct {
 netadrtype_t type;
 unsigned char ip[4];
 unsigned short port;
} netadr_t;



class idPort {
public:
    idPort();
 virtual ~idPort();


 bool InitForPort( int portNumber );
 int GetPort( void ) const { return bound_to.port; }
 netadr_t GetAdr( void ) const { return bound_to; }
 void Close();

 bool GetPacket( netadr_t &from, void *data, int &size, int maxSize );
 bool GetPacketBlocking( netadr_t &from, void *data, int &size, int maxSize, int timeout );
 void SendPacket( const netadr_t to, const void *data, int size );

 int packetsRead;
 int bytesRead;

 int packetsWritten;
 int bytesWritten;

private:
 netadr_t bound_to;
 int netSocket;
};

class idTCP {
public:
    idTCP();
 virtual ~idTCP();


 bool Init( const char *host, short port );
 void Close();





 int Read( void *data, int size );
 int Write( void *data, int size );

private:
 netadr_t address;
 int fd;
};





bool Sys_StringToNetAdr( const char *s, netadr_t *a, bool doDNSResolve );
const char * Sys_NetAdrToString( const netadr_t a );
bool Sys_IsLANAddress( const netadr_t a );
bool Sys_CompareNetAdrBase( const netadr_t a, const netadr_t b );

void Sys_InitNetworking( void );
void Sys_ShutdownNetworking( void );
# 528 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sys/sys_public.h"
typedef unsigned int (*xthread_t)( void * );

typedef enum {
 THREAD_NORMAL,
 THREAD_ABOVE_NORMAL,
 THREAD_HIGHEST
} xthreadPriority;

typedef struct {
 const char * name;
 int threadHandle;
 unsigned long threadId;
} xthreadInfo;

const int MAX_THREADS = 10;
extern xthreadInfo *g_threads[MAX_THREADS];
extern int g_thread_count;

void Sys_CreateThread( xthread_t function, void *parms, xthreadPriority priority, xthreadInfo &info, const char *name, xthreadInfo *threads[MAX_THREADS], int *thread_count );
void Sys_DestroyThread( xthreadInfo& info );



const char * Sys_GetThreadName( int *index = 0 );

const int MAX_CRITICAL_SECTIONS = 4;

enum {
 CRITICAL_SECTION_ZERO = 0,
 CRITICAL_SECTION_ONE,
 CRITICAL_SECTION_TWO,
 CRITICAL_SECTION_THREE
};

void Sys_EnterCriticalSection( int index = CRITICAL_SECTION_ZERO );
void Sys_LeaveCriticalSection( int index = CRITICAL_SECTION_ZERO );

const int MAX_TRIGGER_EVENTS = 4;

enum {
 TRIGGER_EVENT_ZERO = 0,
 TRIGGER_EVENT_ONE,
 TRIGGER_EVENT_TWO,
 TRIGGER_EVENT_THREE
};

void Sys_WaitForEvent( int index = TRIGGER_EVENT_ZERO );
void Sys_TriggerEvent( int index = TRIGGER_EVENT_ZERO );
# 585 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sys/sys_public.h"
class idSys {
public:
 virtual void DebugPrintf( const char *fmt, ... )__attribute__((format(printf,2,3))) = 0;
 virtual void DebugVPrintf( const char *fmt, va_list arg ) = 0;

 virtual double GetClockTicks( void ) = 0;
 virtual double ClockTicksPerSecond( void ) = 0;
 virtual cpuid_t GetProcessorId( void ) = 0;
 virtual const char * GetProcessorString( void ) = 0;
 virtual const char * FPU_GetState( void ) = 0;
 virtual bool FPU_StackIsEmpty( void ) = 0;
 virtual void FPU_SetFTZ( bool enable ) = 0;
 virtual void FPU_SetDAZ( bool enable ) = 0;

 virtual void FPU_EnableExceptions( int exceptions ) = 0;

 virtual bool LockMemory( void *ptr, int bytes ) = 0;
 virtual bool UnlockMemory( void *ptr, int bytes ) = 0;

 virtual void GetCallStack( address_t *callStack, const int callStackSize ) = 0;
 virtual const char * GetCallStackStr( const address_t *callStack, const int callStackSize ) = 0;
 virtual const char * GetCallStackCurStr( int depth ) = 0;
 virtual void ShutdownSymbols( void ) = 0;

 virtual int DLL_Load( const char *dllName ) = 0;
 virtual void * DLL_GetProcAddress( int dllHandle, const char *procName ) = 0;
 virtual void DLL_Unload( int dllHandle ) = 0;
 virtual void DLL_GetFileName( const char *baseName, char *dllName, int maxLength ) = 0;

 virtual sysEvent_t GenerateMouseButtonEvent( int button, bool down ) = 0;
 virtual sysEvent_t GenerateMouseMoveEvent( int deltax, int deltay ) = 0;

 virtual void OpenURL( const char *url, bool quit ) = 0;
 virtual void StartProcess( const char *exePath, bool quit ) = 0;
};

extern idSys * sys;

bool Sys_LoadOpenAL( void );
void Sys_FreeOpenAL( void );
# 111 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 1
# 50 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h"
class idLib {
public:
 static class idSys * sys;
 static class idCommon * common;
 static class idCVarSystem * cvarSystem;
 static class idFileSystem * fileSystem;
 static int frameNumber;

 static void Init( void );
 static void ShutDown( void );


 static void Error( const char *fmt, ... );
 static void Warning( const char *fmt, ... );
};
# 75 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h"
typedef unsigned char byte;
typedef unsigned short word;
typedef unsigned int dword;
typedef unsigned int uint;
typedef unsigned long ulong;

typedef int qhandle_t;

class idFile;
class idVec3;
class idVec4;
# 103 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h"
extern idVec4 colorBlack;
extern idVec4 colorWhite;
extern idVec4 colorRed;
extern idVec4 colorGreen;
extern idVec4 colorBlue;
extern idVec4 colorYellow;
extern idVec4 colorMagenta;
extern idVec4 colorCyan;
extern idVec4 colorOrange;
extern idVec4 colorPurple;
extern idVec4 colorPink;
extern idVec4 colorBrown;
extern idVec4 colorLtGrey;
extern idVec4 colorMdGrey;
extern idVec4 colorDkGrey;


dword PackColor( const idVec3 &color );
void UnpackColor( const dword color, idVec3 &unpackedColor );
dword PackColor( const idVec4 &color );
void UnpackColor( const dword color, idVec4 &unpackedColor );


short BigShort( short l );
short LittleShort( short l );
int BigLong( int l );
int LittleLong( int l );
float BigFloat( float l );
float LittleFloat( float l );
void BigRevBytes( void *bp, int elsize, int elcount );
void LittleRevBytes( void *bp, int elsize, int elcount );
void LittleBitField( void *bp, int elsize );
void Swap_Init( void );

bool Swap_IsBigEndian( void );


void SixtetsForInt( byte *out, int src);
int IntForSixtets( byte *in );
# 150 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h"
class idException {
public:
 char error[1024];

 idException( const char *text = "" ) { strcpy( error, text ); }
};


template<class T> inline T Max( T x, T y ) { return ( x > y ) ? x : y; }
template<class T> inline T Min( T x, T y ) { return ( x < y ) ? x : y; }
# 170 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h"
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h"
typedef struct {
 int num;
 int minSize;
 int maxSize;
 int totalSize;
} memoryStats_t;

void Mem_Init( void );
void Mem_Shutdown( void );
void Mem_EnableLeakTest( const char *name );
void Mem_ClearFrameStats( void );
void Mem_GetFrameStats( memoryStats_t &allocs, memoryStats_t &frees );
void Mem_GetStats( memoryStats_t &stats );
void Mem_Dump_f( const class idCmdArgs &args );
void Mem_DumpCompressed_f( const class idCmdArgs &args );
void Mem_AllocDefragBlock( void );




void * Mem_Alloc( const int size );
void * Mem_ClearedAlloc( const int size );
void Mem_Free( void *ptr );
char * Mem_CopyString( const char *in );
void * Mem_Alloc16( const int size );
void Mem_Free16( void *ptr );
void * Mem_Alloc32( const int size );
void Mem_Free32( void *ptr );
# 154 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h"
template<class type, int blockSize>
class idBlockAlloc {
public:
       idBlockAlloc( void );
       ~idBlockAlloc( void );

 void Shutdown( void );

 type * Alloc( void );
 void Free( type *element );

 int GetTotalCount( void ) const { return total; }
 int GetAllocCount( void ) const { return active; }
 int GetFreeCount( void ) const { return total - active; }

private:
 typedef struct element_s {
  struct element_s * next;
  type t;
 } element_t;
 typedef struct block_s {
  element_t elements[blockSize];
  struct block_s * next;
 } block_t;

 block_t * blocks;
 element_t * free;
 int total;
 int active;
};

template<class type, int blockSize>
idBlockAlloc<type,blockSize>::idBlockAlloc( void ) {
 blocks = __null;
 free = __null;
 total = active = 0;
}

template<class type, int blockSize>
idBlockAlloc<type,blockSize>::~idBlockAlloc( void ) {
 Shutdown();
}

template<class type, int blockSize>
type *idBlockAlloc<type,blockSize>::Alloc( void ) {
# 215 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h"
 active++;
 element_t *element = new element_t;

 return &element->t;
}

template<class type, int blockSize>
void idBlockAlloc<type,blockSize>::Free( type *t ) {
 element_t *element = (element_t *)( ( (unsigned char *) t ) - ( (int) &((element_t *)0)->t ) );




 delete element;

 active--;

}

template<class type, int blockSize>
void idBlockAlloc<type,blockSize>::Shutdown( void ) {
# 245 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h"
 total = active = 0;
}
# 260 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h"
template<class type, int baseBlockSize, int minBlockSize>
class idDynamicAlloc {
public:
         idDynamicAlloc( void );
         ~idDynamicAlloc( void );

 void Init( void );
 void Shutdown( void );
 void SetFixedBlocks( int numBlocks ) {}
 void SetLockMemory( bool lock ) {}
 void FreeEmptyBaseBlocks( void ) {}

 type * Alloc( const int num );
 type * Resize( type *ptr, const int num );
 void Free( type *ptr );
 const char * CheckMemory( const type *ptr ) const;

 int GetNumBaseBlocks( void ) const { return 0; }
 int GetBaseBlockMemory( void ) const { return 0; }
 int GetNumUsedBlocks( void ) const { return numUsedBlocks; }
 int GetUsedBlockMemory( void ) const { return usedBlockMemory; }
 int GetNumFreeBlocks( void ) const { return 0; }
 int GetFreeBlockMemory( void ) const { return 0; }
 int GetNumEmptyBaseBlocks( void ) const { return 0; }

private:
 int numUsedBlocks;
 int usedBlockMemory;

 int numAllocs;
 int numResizes;
 int numFrees;

 void Clear( void );
};

template<class type, int baseBlockSize, int minBlockSize>
idDynamicAlloc<type, baseBlockSize, minBlockSize>::idDynamicAlloc( void ) {
 Clear();
}

template<class type, int baseBlockSize, int minBlockSize>
idDynamicAlloc<type, baseBlockSize, minBlockSize>::~idDynamicAlloc( void ) {
 Shutdown();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicAlloc<type, baseBlockSize, minBlockSize>::Init( void ) {
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicAlloc<type, baseBlockSize, minBlockSize>::Shutdown( void ) {
 Clear();
}

template<class type, int baseBlockSize, int minBlockSize>
type *idDynamicAlloc<type, baseBlockSize, minBlockSize>::Alloc( const int num ) {
 numAllocs++;
 if ( num <= 0 ) {
  return __null;
 }
 numUsedBlocks++;
 usedBlockMemory += num * sizeof( type );
 return Mem_Alloc16( num * sizeof( type ) );
}

template<class type, int baseBlockSize, int minBlockSize>
type *idDynamicAlloc<type, baseBlockSize, minBlockSize>::Resize( type *ptr, const int num ) {

 numResizes++;

 if ( ptr == __null ) {
  return Alloc( num );
 }

 if ( num <= 0 ) {
  Free( ptr );
  return __null;
 }

 ((void)0);
 return ptr;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicAlloc<type, baseBlockSize, minBlockSize>::Free( type *ptr ) {
 numFrees++;
 if ( ptr == __null ) {
  return;
 }
 Mem_Free16( ptr );
}

template<class type, int baseBlockSize, int minBlockSize>
const char *idDynamicAlloc<type, baseBlockSize, minBlockSize>::CheckMemory( const type *ptr ) const {
 return __null;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicAlloc<type, baseBlockSize, minBlockSize>::Clear( void ) {
 numUsedBlocks = 0;
 usedBlockMemory = 0;
 numAllocs = 0;
 numResizes = 0;
 numFrees = 0;
}
# 379 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h"
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/BTree.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/BTree.h"
template< class objType, class keyType >
class idBTreeNode {
public:
 keyType key;
 objType * object;
 idBTreeNode * parent;
 idBTreeNode * next;
 idBTreeNode * prev;
 int numChildren;
 idBTreeNode * firstChild;
 idBTreeNode * lastChild;
};


template< class objType, class keyType, int maxChildrenPerNode >
class idBTree {
public:
         idBTree( void );
         ~idBTree( void );

 void Init( void );
 void Shutdown( void );

 idBTreeNode<objType,keyType> * Add( objType *object, keyType key );
 void Remove( idBTreeNode<objType,keyType> *node );

 objType * Find( keyType key ) const;
 objType * FindSmallestLargerEqual( keyType key ) const;
 objType * FindLargestSmallerEqual( keyType key ) const;

 idBTreeNode<objType,keyType> * GetRoot( void ) const;
 int GetNodeCount( void ) const;
 idBTreeNode<objType,keyType> * GetNext( idBTreeNode<objType,keyType> *node ) const;
 idBTreeNode<objType,keyType> * GetNextLeaf( idBTreeNode<objType,keyType> *node ) const;

private:
 idBTreeNode<objType,keyType> * root;
 idBlockAlloc<idBTreeNode<objType,keyType>,128> nodeAllocator;

 idBTreeNode<objType,keyType> * AllocNode( void );
 void FreeNode( idBTreeNode<objType,keyType> *node );
 void SplitNode( idBTreeNode<objType,keyType> *node );
 idBTreeNode<objType,keyType> * MergeNodes( idBTreeNode<objType,keyType> *node1, idBTreeNode<objType,keyType> *node2 );

 void CheckTree_r( idBTreeNode<objType,keyType> *node, int &numNodes ) const;
 void CheckTree( void ) const;
};


template< class objType, class keyType, int maxChildrenPerNode >
inline idBTree<objType,keyType,maxChildrenPerNode>::idBTree( void ) {
 ((void)0);
 root = __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTree<objType,keyType,maxChildrenPerNode>::~idBTree( void ) {
 Shutdown();
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::Init( void ) {
 root = AllocNode();
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::Shutdown( void ) {
 nodeAllocator.Shutdown();
 root = __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::Add( objType *object, keyType key ) {
 idBTreeNode<objType,keyType> *node, *child, *newNode;

 if ( root->numChildren >= maxChildrenPerNode ) {
  newNode = AllocNode();
  newNode->key = root->key;
  newNode->firstChild = root;
  newNode->lastChild = root;
  newNode->numChildren = 1;
  root->parent = newNode;
  SplitNode( root );
  root = newNode;
 }

 newNode = AllocNode();
 newNode->key = key;
 newNode->object = object;

 for ( node = root; node->firstChild != __null; node = child ) {

  if ( key > node->key ) {
   node->key = key;
  }


  for( child = node->firstChild; child->next; child = child->next ) {
   if ( key <= child->key ) {
    break;
   }
  }

  if ( child->object ) {

   if ( key <= child->key ) {

    if ( child->prev ) {
     child->prev->next = newNode;
    } else {
     node->firstChild = newNode;
    }
    newNode->prev = child->prev;
    newNode->next = child;
    child->prev = newNode;
   } else {

    if ( child->next ) {
     child->next->prev = newNode;
    } else {
     node->lastChild = newNode;
    }
    newNode->prev = child;
    newNode->next = child->next;
    child->next = newNode;
   }

   newNode->parent = node;
   node->numChildren++;





   return newNode;
  }


  if ( child->numChildren >= maxChildrenPerNode ) {
   SplitNode( child );
   if ( key <= child->prev->key ) {
    child = child->prev;
   }
  }
 }


 newNode->parent = root;
 root->key = key;
 root->firstChild = newNode;
 root->lastChild = newNode;
 root->numChildren++;





 return newNode;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::Remove( idBTreeNode<objType,keyType> *node ) {
 idBTreeNode<objType,keyType> *parent;

 ((void)0);


 if ( node->prev ) {
  node->prev->next = node->next;
 } else {
  node->parent->firstChild = node->next;
 }
 if ( node->next ) {
  node->next->prev = node->prev;
 } else {
  node->parent->lastChild = node->prev;
 }
 node->parent->numChildren--;


 for ( parent = node->parent; parent != root && parent->numChildren <= 1; parent = parent->parent ) {

  if ( parent->next ) {
   parent = MergeNodes( parent, parent->next );
  } else if ( parent->prev ) {
   parent = MergeNodes( parent->prev, parent );
  }


  if ( parent->key > parent->lastChild->key ) {
   parent->key = parent->lastChild->key;
  }

  if ( parent->numChildren > maxChildrenPerNode ) {
   SplitNode( parent );
   break;
  }
 }
 for ( ; parent != __null && parent->lastChild != __null; parent = parent->parent ) {

  if ( parent->key > parent->lastChild->key ) {
   parent->key = parent->lastChild->key;
  }
 }


 FreeNode( node );


 if ( root->numChildren == 1 && root->firstChild->object == __null ) {
  idBTreeNode<objType,keyType> *oldRoot = root;
  root->firstChild->parent = __null;
  root = root->firstChild;
  FreeNode( oldRoot );
 }




}

template< class objType, class keyType, int maxChildrenPerNode >
inline objType *idBTree<objType,keyType,maxChildrenPerNode>::Find( keyType key ) const {
 idBTreeNode<objType,keyType> *node;

 for ( node = root->firstChild; node != __null; node = node->firstChild ) {
  while( node->next ) {
   if ( node->key >= key ) {
    break;
   }
   node = node->next;
  }
  if ( node->object ) {
   if ( node->key == key ) {
    return node->object;
   } else {
    return __null;
   }
  }
 }
 return __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline objType *idBTree<objType,keyType,maxChildrenPerNode>::FindSmallestLargerEqual( keyType key ) const {
 idBTreeNode<objType,keyType> *node;

 for ( node = root->firstChild; node != __null; node = node->firstChild ) {
  while( node->next ) {
   if ( node->key >= key ) {
    break;
   }
   node = node->next;
  }
  if ( node->object ) {
   if ( node->key >= key ) {
    return node->object;
   } else {
    return __null;
   }
  }
 }
 return __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline objType *idBTree<objType,keyType,maxChildrenPerNode>::FindLargestSmallerEqual( keyType key ) const {
 idBTreeNode<objType,keyType> *node;

 for ( node = root->lastChild; node != __null; node = node->lastChild ) {
  while( node->prev ) {
   if ( node->key <= key ) {
    break;
   }
   node = node->prev;
  }
  if ( node->object ) {
   if ( node->key <= key ) {
    return node->object;
   } else {
    return __null;
   }
  }
 }
 return __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::GetRoot( void ) const {
 return root;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline int idBTree<objType,keyType,maxChildrenPerNode>::GetNodeCount( void ) const {
 return nodeAllocator.GetAllocCount();
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::GetNext( idBTreeNode<objType,keyType> *node ) const {
 if ( node->firstChild ) {
  return node->firstChild;
 } else {
  while( node && node->next == __null ) {
   node = node->parent;
  }
  return node;
 }
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::GetNextLeaf( idBTreeNode<objType,keyType> *node ) const {
 if ( node->firstChild ) {
  while ( node->firstChild ) {
   node = node->firstChild;
  }
  return node;
 } else {
  while( node && node->next == __null ) {
   node = node->parent;
  }
  if ( node ) {
   node = node->next;
   while ( node->firstChild ) {
    node = node->firstChild;
   }
   return node;
  } else {
   return __null;
  }
 }
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::AllocNode( void ) {
 idBTreeNode<objType,keyType> *node = nodeAllocator.Alloc();
 node->key = 0;
 node->parent = __null;
 node->next = __null;
 node->prev = __null;
 node->numChildren = 0;
 node->firstChild = __null;
 node->lastChild = __null;
 node->object = __null;
 return node;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::FreeNode( idBTreeNode<objType,keyType> *node ) {
 nodeAllocator.Free( node );
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::SplitNode( idBTreeNode<objType,keyType> *node ) {
 int i;
 idBTreeNode<objType,keyType> *child, *newNode;


 newNode = AllocNode();
 newNode->parent = node->parent;


 child = node->firstChild;
 child->parent = newNode;
 for ( i = 3; i < node->numChildren; i += 2 ) {
  child = child->next;
  child->parent = newNode;
 }

 newNode->key = child->key;
 newNode->numChildren = node->numChildren / 2;
 newNode->firstChild = node->firstChild;
 newNode->lastChild = child;

 node->numChildren -= newNode->numChildren;
 node->firstChild = child->next;

 child->next->prev = __null;
 child->next = __null;


 ((void)0);

 if ( node->prev ) {
  node->prev->next = newNode;
 } else {
  node->parent->firstChild = newNode;
 }
 newNode->prev = node->prev;
 newNode->next = node;
 node->prev = newNode;

 node->parent->numChildren++;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::MergeNodes( idBTreeNode<objType,keyType> *node1, idBTreeNode<objType,keyType> *node2 ) {
 idBTreeNode<objType,keyType> *child;

 ((void)0);
 ((void)0);
 ((void)0);
 ((void)0);

 for ( child = node1->firstChild; child->next; child = child->next ) {
  child->parent = node2;
 }
 child->parent = node2;
 child->next = node2->firstChild;
 node2->firstChild->prev = child;
 node2->firstChild = node1->firstChild;
 node2->numChildren += node1->numChildren;


 if ( node1->prev ) {
  node1->prev->next = node2;
 } else {
  node1->parent->firstChild = node2;
 }
 node2->prev = node1->prev;
 node2->parent->numChildren--;

 FreeNode( node1 );

 return node2;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::CheckTree_r( idBTreeNode<objType,keyType> *node, int &numNodes ) const {
 int numChildren;
 idBTreeNode<objType,keyType> *child;

 numNodes++;


 ((void)0);

 ((void)0);

 numChildren = 0;
 for ( child = node->firstChild; child; child = child->next ) {
  numChildren++;

  if ( child->prev == __null ) {
   ((void)0);
  } else {
   ((void)0);
  }
  if ( child->next == __null ) {
   ((void)0);
  } else {
   ((void)0);
  }

  CheckTree_r( child, numNodes );
 }

 ((void)0);
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::CheckTree( void ) const {
 int numNodes = 0;
 idBTreeNode<objType,keyType> *node, *lastNode;

 CheckTree_r( root, numNodes );


 ((void)0);


 lastNode = GetNextLeaf( GetRoot() );
 if ( lastNode ) {
  for ( node = GetNextLeaf( lastNode ); node; lastNode = node, node = GetNextLeaf( node ) ) {
   ((void)0);
  }
 }
}
# 380 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h" 2



template<class type>
class idDynamicBlock {
public:
 type * GetMemory( void ) const { return (type *)( ( (byte *) this ) + sizeof( idDynamicBlock<type> ) ); }
 int GetSize( void ) const { return abs( size ); }
 void SetSize( int s, bool isBaseBlock ) { size = isBaseBlock ? -s : s; }
 bool IsBaseBlock( void ) const { return ( size < 0 ); }






 int size;
 idDynamicBlock<type> * prev;
 idDynamicBlock<type> * next;
 idBTreeNode<idDynamicBlock<type>,int> *node;
};

template<class type, int baseBlockSize, int minBlockSize>
class idDynamicBlockAlloc {
public:
         idDynamicBlockAlloc( void );
         ~idDynamicBlockAlloc( void );

 void Init( void );
 void Shutdown( void );
 void SetFixedBlocks( int numBlocks );
 void SetLockMemory( bool lock );
 void FreeEmptyBaseBlocks( void );

 type * Alloc( const int num );
 type * Resize( type *ptr, const int num );
 void Free( type *ptr );
 const char * CheckMemory( const type *ptr ) const;

 int GetNumBaseBlocks( void ) const { return numBaseBlocks; }
 int GetBaseBlockMemory( void ) const { return baseBlockMemory; }
 int GetNumUsedBlocks( void ) const { return numUsedBlocks; }
 int GetUsedBlockMemory( void ) const { return usedBlockMemory; }
 int GetNumFreeBlocks( void ) const { return numFreeBlocks; }
 int GetFreeBlockMemory( void ) const { return freeBlockMemory; }
 int GetNumEmptyBaseBlocks( void ) const;

private:
 idDynamicBlock<type> * firstBlock;
 idDynamicBlock<type> * lastBlock;
 idBTree<idDynamicBlock<type>,int,4>freeTree;
 bool allowAllocs;
 bool lockMemory;





 int numBaseBlocks;
 int baseBlockMemory;
 int numUsedBlocks;
 int usedBlockMemory;
 int numFreeBlocks;
 int freeBlockMemory;

 int numAllocs;
 int numResizes;
 int numFrees;

 void Clear( void );
 idDynamicBlock<type> * AllocInternal( const int num );
 idDynamicBlock<type> * ResizeInternal( idDynamicBlock<type> *block, const int num );
 void FreeInternal( idDynamicBlock<type> *block );
 void LinkFreeInternal( idDynamicBlock<type> *block );
 void UnlinkFreeInternal( idDynamicBlock<type> *block );
 void CheckMemory( void ) const;
};

template<class type, int baseBlockSize, int minBlockSize>
idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::idDynamicBlockAlloc( void ) {
 Clear();
}

template<class type, int baseBlockSize, int minBlockSize>
idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::~idDynamicBlockAlloc( void ) {
 Shutdown();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Init( void ) {
 freeTree.Init();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Shutdown( void ) {
 idDynamicBlock<type> *block;

 for ( block = firstBlock; block != __null; block = block->next ) {
  if ( block->node == __null ) {
   FreeInternal( block );
  }
 }

 for ( block = firstBlock; block != __null; block = firstBlock ) {
  firstBlock = block->next;
  ((void)0);
  if ( lockMemory ) {
   idLib::sys->UnlockMemory( block, block->GetSize() + (int)sizeof( idDynamicBlock<type> ) );
  }
  Mem_Free16( block );
 }

 freeTree.Shutdown();

 Clear();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::SetFixedBlocks( int numBlocks ) {
 idDynamicBlock<type> *block;

 for ( int i = numBaseBlocks; i < numBlocks; i++ ) {
  block = ( idDynamicBlock<type> * ) Mem_Alloc16( baseBlockSize );
  if ( lockMemory ) {
   idLib::sys->LockMemory( block, baseBlockSize );
  }




  block->SetSize( baseBlockSize - (int)sizeof( idDynamicBlock<type> ), true );
  block->next = __null;
  block->prev = lastBlock;
  if ( lastBlock ) {
   lastBlock->next = block;
  } else {
   firstBlock = block;
  }
  lastBlock = block;
  block->node = __null;

  FreeInternal( block );

  numBaseBlocks++;
  baseBlockMemory += baseBlockSize;
 }

 allowAllocs = false;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::SetLockMemory( bool lock ) {
 lockMemory = lock;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::FreeEmptyBaseBlocks( void ) {
 idDynamicBlock<type> *block, *next;

 for ( block = firstBlock; block != __null; block = next ) {
  next = block->next;

  if ( block->IsBaseBlock() && block->node != __null && ( next == __null || next->IsBaseBlock() ) ) {
   UnlinkFreeInternal( block );
   if ( block->prev ) {
    block->prev->next = block->next;
   } else {
    firstBlock = block->next;
   }
   if ( block->next ) {
    block->next->prev = block->prev;
   } else {
    lastBlock = block->prev;
   }
   if ( lockMemory ) {
    idLib::sys->UnlockMemory( block, block->GetSize() + (int)sizeof( idDynamicBlock<type> ) );
   }
   numBaseBlocks--;
   baseBlockMemory -= block->GetSize() + (int)sizeof( idDynamicBlock<type> );
   Mem_Free16( block );
  }
 }




}

template<class type, int baseBlockSize, int minBlockSize>
int idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::GetNumEmptyBaseBlocks( void ) const {
 int numEmptyBaseBlocks;
 idDynamicBlock<type> *block;

 numEmptyBaseBlocks = 0;
 for ( block = firstBlock; block != __null; block = block->next ) {
  if ( block->IsBaseBlock() && block->node != __null && ( block->next == __null || block->next->IsBaseBlock() ) ) {
   numEmptyBaseBlocks++;
  }
 }
 return numEmptyBaseBlocks;
}

template<class type, int baseBlockSize, int minBlockSize>
type *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Alloc( const int num ) {
 idDynamicBlock<type> *block;

 numAllocs++;

 if ( num <= 0 ) {
  return __null;
 }

 block = AllocInternal( num );
 if ( block == __null ) {
  return __null;
 }
 block = ResizeInternal( block, num );
 if ( block == __null ) {
  return __null;
 }





 numUsedBlocks++;
 usedBlockMemory += block->GetSize();

 return block->GetMemory();
}

template<class type, int baseBlockSize, int minBlockSize>
type *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Resize( type *ptr, const int num ) {

 numResizes++;

 if ( ptr == __null ) {
  return Alloc( num );
 }

 if ( num <= 0 ) {
  Free( ptr );
  return __null;
 }

 idDynamicBlock<type> *block = ( idDynamicBlock<type> * ) ( ( (byte *) ptr ) - (int)sizeof( idDynamicBlock<type> ) );

 usedBlockMemory -= block->GetSize();

 block = ResizeInternal( block, num );
 if ( block == __null ) {
  return __null;
 }





 usedBlockMemory += block->GetSize();

 return block->GetMemory();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Free( type *ptr ) {

 numFrees++;

 if ( ptr == __null ) {
  return;
 }

 idDynamicBlock<type> *block = ( idDynamicBlock<type> * ) ( ( (byte *) ptr ) - (int)sizeof( idDynamicBlock<type> ) );

 numUsedBlocks--;
 usedBlockMemory -= block->GetSize();

 FreeInternal( block );




}

template<class type, int baseBlockSize, int minBlockSize>
const char *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::CheckMemory( const type *ptr ) const {
 idDynamicBlock<type> *block;

 if ( ptr == __null ) {
  return __null;
 }

 block = ( idDynamicBlock<type> * ) ( ( (byte *) ptr ) - (int)sizeof( idDynamicBlock<type> ) );

 if ( block->node != __null ) {
  return "memory has been freed";
 }
# 701 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Heap.h"
 return __null;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Clear( void ) {
 firstBlock = lastBlock = __null;
 allowAllocs = true;
 lockMemory = false;
 numBaseBlocks = 0;
 baseBlockMemory = 0;
 numUsedBlocks = 0;
 usedBlockMemory = 0;
 numFreeBlocks = 0;
 freeBlockMemory = 0;
 numAllocs = 0;
 numResizes = 0;
 numFrees = 0;






}

template<class type, int baseBlockSize, int minBlockSize>
idDynamicBlock<type> *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::AllocInternal( const int num ) {
 idDynamicBlock<type> *block;
 int alignedBytes = ( num * sizeof( type ) + 15 ) & ~15;

 block = freeTree.FindSmallestLargerEqual( alignedBytes );
 if ( block != __null ) {
  UnlinkFreeInternal( block );
 } else if ( allowAllocs ) {
  int allocSize = Max( baseBlockSize, alignedBytes + (int)sizeof( idDynamicBlock<type> ) );
Sys_Printf(">>> Alloc size: %d\r\n", allocSize);
  block = ( idDynamicBlock<type> * ) Mem_Alloc16( allocSize );
if (!block) {
 Sys_Error(">>> ::AllocInternal FAIL FOR ALLOCSIZE %d\r\n", allocSize);
}
  if ( lockMemory ) {
   idLib::sys->LockMemory( block, baseBlockSize );
  }




  block->SetSize( allocSize - (int)sizeof( idDynamicBlock<type> ), true );
  block->next = __null;
  block->prev = lastBlock;
  if ( lastBlock ) {
   lastBlock->next = block;
  } else {
   firstBlock = block;
  }
  lastBlock = block;
  block->node = __null;

  numBaseBlocks++;
  baseBlockMemory += allocSize;
 }

 return block;
}

template<class type, int baseBlockSize, int minBlockSize>
idDynamicBlock<type> *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::ResizeInternal( idDynamicBlock<type> *block, const int num ) {
 int alignedBytes = ( num * sizeof( type ) + 15 ) & ~15;






 if ( alignedBytes > block->GetSize() ) {

  idDynamicBlock<type> *nextBlock = block->next;


  if ( nextBlock && !nextBlock->IsBaseBlock() && nextBlock->node != __null &&
    block->GetSize() + (int)sizeof( idDynamicBlock<type> ) + nextBlock->GetSize() >= alignedBytes ) {

   UnlinkFreeInternal( nextBlock );
   block->SetSize( block->GetSize() + (int)sizeof( idDynamicBlock<type> ) + nextBlock->GetSize(), block->IsBaseBlock() );
   block->next = nextBlock->next;
   if ( nextBlock->next ) {
    nextBlock->next->prev = block;
   } else {
    lastBlock = block;
   }
  } else {

   idDynamicBlock<type> *oldBlock = block;
   block = AllocInternal( num );
   if ( block == __null ) {
    return __null;
   }
   memcpy( block->GetMemory(), oldBlock->GetMemory(), oldBlock->GetSize() );
   FreeInternal( oldBlock );
  }
 }


 if ( block->GetSize() - alignedBytes - (int)sizeof( idDynamicBlock<type> ) < Max( minBlockSize, (int)sizeof( type ) ) ) {
  return block;
 }

 idDynamicBlock<type> *newBlock;

 newBlock = ( idDynamicBlock<type> * ) ( ( (byte *) block ) + (int)sizeof( idDynamicBlock<type> ) + alignedBytes );




 newBlock->SetSize( block->GetSize() - alignedBytes - (int)sizeof( idDynamicBlock<type> ), false );
 newBlock->next = block->next;
 newBlock->prev = block;
 if ( newBlock->next ) {
  newBlock->next->prev = newBlock;
 } else {
  lastBlock = newBlock;
 }
 newBlock->node = __null;
 block->next = newBlock;
 block->SetSize( alignedBytes, block->IsBaseBlock() );

 FreeInternal( newBlock );

 return block;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::FreeInternal( idDynamicBlock<type> *block ) {

 ((void)0);






 idDynamicBlock<type> *nextBlock = block->next;
 if ( nextBlock && !nextBlock->IsBaseBlock() && nextBlock->node != __null ) {
  UnlinkFreeInternal( nextBlock );
  block->SetSize( block->GetSize() + (int)sizeof( idDynamicBlock<type> ) + nextBlock->GetSize(), block->IsBaseBlock() );
  block->next = nextBlock->next;
  if ( nextBlock->next ) {
   nextBlock->next->prev = block;
  } else {
   lastBlock = block;
  }
 }


 idDynamicBlock<type> *prevBlock = block->prev;
 if ( prevBlock && !block->IsBaseBlock() && prevBlock->node != __null ) {
  UnlinkFreeInternal( prevBlock );
  prevBlock->SetSize( prevBlock->GetSize() + (int)sizeof( idDynamicBlock<type> ) + block->GetSize(), prevBlock->IsBaseBlock() );
  prevBlock->next = block->next;
  if ( block->next ) {
   block->next->prev = prevBlock;
  } else {
   lastBlock = prevBlock;
  }
  LinkFreeInternal( prevBlock );
 } else {
  LinkFreeInternal( block );
 }
}

template<class type, int baseBlockSize, int minBlockSize>
inline void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::LinkFreeInternal( idDynamicBlock<type> *block ) {
 block->node = freeTree.Add( block, block->GetSize() );
 numFreeBlocks++;
 freeBlockMemory += block->GetSize();
}

template<class type, int baseBlockSize, int minBlockSize>
inline void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::UnlinkFreeInternal( idDynamicBlock<type> *block ) {
 freeTree.Remove( block->node );
 block->node = __null;
 numFreeBlocks--;
 freeBlockMemory -= block->GetSize();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::CheckMemory( void ) const {
 idDynamicBlock<type> *block;

 for ( block = firstBlock; block != __null; block = block->next ) {

  if ( block->prev == __null ) {
   ((void)0);
  } else {
   ((void)0);
  }
  if ( block->next == __null ) {
   ((void)0);
  } else {
   ((void)0);
  }
 }
}
# 171 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
typedef struct myTestNode_s {
 int symbol;
 int frequency;
 struct myTestNode_s * next;
 struct myTestNode_s * children[2];
} myTestNode_t;
# 63 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idListSortCompare( const type *a, const type *b ) {
 return *a - *b;
}







template< class type >
inline type *idListNewElement( void ) {
 return new type;
}






template< class type >
inline void idSwap( type &a, type &b ) {
 type c = a;
 a = b;
 b = c;
}

template< class type >
class idList {
public:

 typedef int cmp_t( const type *, const type * );
 typedef type new_t( void );

     idList( int newgranularity = 16 );
     idList( const idList<type> &other );
     ~idList<type>( void );

 void Clear( void );
 int Num( void ) const;
 int NumAllocated( void ) const;
 void SetGranularity( int newgranularity );
 int GetGranularity( void ) const;

 size_t Allocated( void ) const;
 size_t Size( void ) const;
 size_t MemoryUsed( void ) const;

 idList<type> & operator=( const idList<type> &other );
 const type & operator[]( int index ) const;
 type & operator[]( int index );

 void Condense( void );
 void Resize( int newsize );
 void Resize( int newsize, int newgranularity );
 void SetNum( int newnum, bool resize = true );
 void AssureSize( int newSize);
 void AssureSize( int newSize, const type &initValue );
 void AssureSizeAlloc( int newSize, new_t *allocator );

 type * Ptr( void );
 const type * Ptr( void ) const;
 type & Alloc( void );
 int Append( const type & obj );
 int Append( const idList<type> &other );
 int AddUnique( const type & obj );
 int Insert( const type & obj, int index = 0 );
 int FindIndex( const type & obj ) const;
 type * Find( type const & obj ) const;
 int FindNull( void ) const;
 int IndexOf( const type *obj ) const;
 bool RemoveIndex( int index );
 bool Remove( const type & obj );
 void Sort( cmp_t *compare = ( cmp_t * )&idListSortCompare<type> );
 void SortSubSection( int startIndex, int endIndex, cmp_t *compare = ( cmp_t * )&idListSortCompare<type> );
 void Swap( idList<type> &other );
 void DeleteContents( bool clear );

private:
 int num;
 int size;
 int granularity;
 type * list;
};






template< class type >
inline idList<type>::idList( int newgranularity ) {
 ((void)0);

 list = __null;
 granularity = newgranularity;
 Clear();
}






template< class type >
inline idList<type>::idList( const idList<type> &other ) {
 list = __null;
 *this = other;
}






template< class type >
inline idList<type>::~idList( void ) {
 Clear();
}
# 191 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Clear( void ) {
 if ( list ) {
  delete[] list;
 }

 list = __null;
 num = 0;
 size = 0;
}
# 214 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::DeleteContents( bool clear ) {
 int i;

 for( i = 0; i < num; i++ ) {
  delete list[ i ];
  list[ i ] = __null;
 }

 if ( clear ) {
  Clear();
 } else {
  memset( list, 0, size * sizeof( type ) );
 }
}
# 237 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline size_t idList<type>::Allocated( void ) const {
 return size * sizeof( type );
}
# 249 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline size_t idList<type>::Size( void ) const {
 return sizeof( idList<type> ) + Allocated();
}






template< class type >
inline size_t idList<type>::MemoryUsed( void ) const {
 return num * sizeof( *list );
}
# 272 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::Num( void ) const {
 return num;
}
# 284 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::NumAllocated( void ) const {
 return size;
}
# 296 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::SetNum( int newnum, bool resize ) {
 ((void)0);
 if ( resize || newnum > size ) {
  Resize( newnum );
 }
 num = newnum;
}
# 312 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::SetGranularity( int newgranularity ) {
 int newsize;

 ((void)0);
 granularity = newgranularity;

 if ( list ) {

  newsize = num + granularity - 1;
  newsize -= newsize % granularity;
  if ( newsize != size ) {
   Resize( newsize );
  }
 }
}
# 336 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::GetGranularity( void ) const {
 return granularity;
}
# 348 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Condense( void ) {
 if ( list ) {
  if ( num ) {
   Resize( num );
  } else {
   Clear();
  }
 }
}
# 367 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Resize( int newsize ) {
 type *temp;
 int i;

 ((void)0);


 if ( newsize <= 0 ) {
  Clear();
  return;
 }

 if ( newsize == size ) {

  return;
 }

 temp = list;
 size = newsize;
 if ( size < num ) {
  num = size;
 }


 list = new type[ size ];
 for( i = 0; i < num; i++ ) {
  list[ i ] = temp[ i ];
 }


 if ( temp ) {
  delete[] temp;
 }
}
# 411 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Resize( int newsize, int newgranularity ) {
 type *temp;
 int i;

 ((void)0);

 ((void)0);
 granularity = newgranularity;


 if ( newsize <= 0 ) {
  Clear();
  return;
 }

 temp = list;
 size = newsize;
 if ( size < num ) {
  num = size;
 }


 list = new type[ size ];
 for( i = 0; i < num; i++ ) {
  list[ i ] = temp[ i ];
 }


 if ( temp ) {
  delete[] temp;
 }
}
# 452 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::AssureSize( int newSize ) {
 int newNum = newSize;

 if ( newSize > size ) {

  if ( granularity == 0 ) {
   granularity = 16;
  }

  newSize += granularity - 1;
  newSize -= newSize % granularity;
  Resize( newSize );
 }

 num = newNum;
}
# 477 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::AssureSize( int newSize, const type &initValue ) {
 int newNum = newSize;

 if ( newSize > size ) {

  if ( granularity == 0 ) {
   granularity = 16;
  }

  newSize += granularity - 1;
  newSize -= newSize % granularity;
  num = size;
  Resize( newSize );

  for ( int i = num; i < newSize; i++ ) {
   list[i] = initValue;
  }
 }

 num = newNum;
}
# 510 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::AssureSizeAlloc( int newSize, new_t *allocator ) {
 int newNum = newSize;

 if ( newSize > size ) {

  if ( granularity == 0 ) {
   granularity = 16;
  }

  newSize += granularity - 1;
  newSize -= newSize % granularity;
  num = size;
  Resize( newSize );

  for ( int i = num; i < newSize; i++ ) {
   list[i] = (*allocator)();
  }
 }

 num = newNum;
}
# 540 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline idList<type> &idList<type>::operator=( const idList<type> &other ) {
 int i;

 Clear();

 num = other.num;
 size = other.size;
 granularity = other.granularity;

 if ( size ) {
  list = new type[ size ];
  for( i = 0; i < num; i++ ) {
   list[ i ] = other.list[ i ];
  }
 }

 return *this;
}
# 568 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline const type &idList<type>::operator[]( int index ) const {
 ((void)0);
 ((void)0);

 return list[ index ];
}
# 584 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline type &idList<type>::operator[]( int index ) {
 ((void)0);
 ((void)0);

 return list[ index ];
}
# 603 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline type *idList<type>::Ptr( void ) {
 return list;
}
# 619 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
const inline type *idList<type>::Ptr( void ) const {
 return list;
}
# 631 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline type &idList<type>::Alloc( void ) {
 if ( !list ) {
  Resize( granularity );
 }

 if ( num == size ) {
  Resize( size + granularity );
 }

 return list[ num++ ];
}
# 653 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::Append( type const & obj ) {
 if ( !list ) {
  Resize( granularity );
 }

 if ( num == size ) {
  int newsize;

  if ( granularity == 0 ) {
   granularity = 16;
  }
  newsize = size + granularity;
  Resize( newsize - newsize % granularity );
 }

 list[ num ] = obj;
 num++;

 return num - 1;
}
# 686 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::Insert( type const & obj, int index ) {
 if ( !list ) {
  Resize( granularity );
 }

 if ( num == size ) {
  int newsize;

  if ( granularity == 0 ) {
   granularity = 16;
  }
  newsize = size + granularity;
  Resize( newsize - newsize % granularity );
 }

 if ( index < 0 ) {
  index = 0;
 }
 else if ( index > num ) {
  index = num;
 }
 for ( int i = num; i > index; --i ) {
  list[i] = list[i-1];
 }
 num++;
 list[index] = obj;
 return index;
}
# 725 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::Append( const idList<type> &other ) {
 if ( !list ) {
  if ( granularity == 0 ) {
   granularity = 16;
  }
  Resize( granularity );
 }

 int n = other.Num();
 for (int i = 0; i < n; i++) {
  Append(other[i]);
 }

 return Num();
}
# 749 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::AddUnique( type const & obj ) {
 int index;

 index = FindIndex( obj );
 if ( index < 0 ) {
  index = Append( obj );
 }

 return index;
}
# 768 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::FindIndex( type const & obj ) const {
 int i;

 for( i = 0; i < num; i++ ) {
  if ( list[ i ] == obj ) {
   return i;
  }
 }


 return -1;
}
# 789 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline type *idList<type>::Find( type const & obj ) const {
 int i;

 i = FindIndex( obj );
 if ( i >= 0 ) {
  return &list[ i ];
 }

 return __null;
}
# 811 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::FindNull( void ) const {
 int i;

 for( i = 0; i < num; i++ ) {
  if ( list[ i ] == __null ) {
   return i;
  }
 }


 return -1;
}
# 835 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::IndexOf( type const *objptr ) const {
 int index;

 index = objptr - list;

 ((void)0);
 ((void)0);

 return index;
}
# 856 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline bool idList<type>::RemoveIndex( int index ) {
 int i;

 ((void)0);
 ((void)0);
 ((void)0);

 if ( ( index < 0 ) || ( index >= num ) ) {
  return false;
 }

 num--;
 for( i = index; i < num; i++ ) {
  list[ i ] = list[ i + 1 ];
 }

 return true;
}
# 885 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline bool idList<type>::Remove( type const & obj ) {
 int index;

 index = FindIndex( obj );
 if ( index >= 0 ) {
  return RemoveIndex( index );
 }

 return false;
}
# 905 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Sort( cmp_t *compare ) {
 if ( !list ) {
  return;
 }
 typedef int cmp_c(const void *, const void *);

 cmp_c *vCompare = (cmp_c *)compare;
 qsort( ( void * )list, ( size_t )num, sizeof( type ), vCompare );
}
# 923 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::SortSubSection( int startIndex, int endIndex, cmp_t *compare ) {
 if ( !list ) {
  return;
 }
 if ( startIndex < 0 ) {
  startIndex = 0;
 }
 if ( endIndex >= num ) {
  endIndex = num - 1;
 }
 if ( startIndex >= endIndex ) {
  return;
 }
 typedef int cmp_c(const void *, const void *);

 cmp_c *vCompare = (cmp_c *)compare;
 qsort( ( void * )( &list[startIndex] ), ( size_t )( endIndex - startIndex + 1 ), sizeof( type ), vCompare );
}
# 950 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Swap( idList<type> &other ) {
 idSwap( num, other.num );
 idSwap( size, other.size );
 idSwap( granularity, other.granularity );
 idSwap( list, other.list );
}
# 172 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Simd.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Simd.h"
class idSIMD {
public:
 static void Init( void );
 static void InitProcessor( const char *module, bool forceGeneric );
 static void Shutdown( void );
 static void Test_f( const class idCmdArgs &args );
};
# 66 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Simd.h"
class idVec2;
class idVec3;
class idVec4;
class idVec5;
class idVec6;
class idVecX;
class idMat2;
class idMat3;
class idMat4;
class idMat5;
class idMat6;
class idMatX;
class idPlane;
class idDrawVert;
class idJointQuat;
class idJointMat;
struct dominantTri_s;

const int MIXBUFFER_SAMPLES = 4096;

typedef enum {
 SPEAKER_LEFT = 0,
 SPEAKER_RIGHT,
 SPEAKER_CENTER,
 SPEAKER_LFE,
 SPEAKER_BACKLEFT,
 SPEAKER_BACKRIGHT
} speakerLabel;


class idSIMDProcessor {
public:
         idSIMDProcessor( void ) { cpuid = CPUID_NONE; }

 cpuid_t cpuid;

 virtual const char * GetName( void ) const = 0;

 virtual void Add( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void Add( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void Sub( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void Sub( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void Mul( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void Mul( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void Div( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void Div( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void MulAdd( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void MulAdd( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void MulSub( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void MulSub( float *dst, const float *src0, const float *src1, const int count ) = 0;

 virtual void Dot( float *dst, const idVec3 &constant, const idVec3 *src, const int count ) = 0;
 virtual void Dot( float *dst, const idVec3 &constant, const idPlane *src, const int count ) = 0;
 virtual void Dot( float *dst, const idVec3 &constant, const idDrawVert *src, const int count ) = 0;
 virtual void Dot( float *dst, const idPlane &constant,const idVec3 *src, const int count ) = 0;
 virtual void Dot( float *dst, const idPlane &constant,const idPlane *src, const int count ) = 0;
 virtual void Dot( float *dst, const idPlane &constant,const idDrawVert *src, const int count ) = 0;
 virtual void Dot( float *dst, const idVec3 *src0, const idVec3 *src1, const int count ) = 0;
 virtual void Dot( float &dot, const float *src1, const float *src2, const int count ) = 0;

 virtual void CmpGT( byte *dst, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpGT( byte *dst, const byte bitNum, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpGE( byte *dst, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpGE( byte *dst, const byte bitNum, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpLT( byte *dst, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpLT( byte *dst, const byte bitNum, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpLE( byte *dst, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpLE( byte *dst, const byte bitNum, const float *src0, const float constant, const int count ) = 0;

 virtual void MinMax( float &min, float &max, const float *src, const int count ) = 0;
 virtual void MinMax( idVec2 &min, idVec2 &max, const idVec2 *src, const int count ) = 0;
 virtual void MinMax( idVec3 &min, idVec3 &max, const idVec3 *src, const int count ) = 0;
 virtual void MinMax( idVec3 &min, idVec3 &max, const idDrawVert *src, const int count ) = 0;
 virtual void MinMax( idVec3 &min, idVec3 &max, const idDrawVert *src, const int *indexes, const int count ) = 0;

 virtual void Clamp( float *dst, const float *src, const float min, const float max, const int count ) = 0;
 virtual void ClampMin( float *dst, const float *src, const float min, const int count ) = 0;
 virtual void ClampMax( float *dst, const float *src, const float max, const int count ) = 0;

 virtual void Memcpy( void *dst, const void *src, const int count ) = 0;
 virtual void Memset( void *dst, const int val, const int count ) = 0;


 virtual void Zero16( float *dst, const int count ) = 0;
 virtual void Negate16( float *dst, const int count ) = 0;
 virtual void Copy16( float *dst, const float *src, const int count ) = 0;
 virtual void Add16( float *dst, const float *src1, const float *src2, const int count ) = 0;
 virtual void Sub16( float *dst, const float *src1, const float *src2, const int count ) = 0;
 virtual void Mul16( float *dst, const float *src1, const float constant, const int count ) = 0;
 virtual void AddAssign16( float *dst, const float *src, const int count ) = 0;
 virtual void SubAssign16( float *dst, const float *src, const int count ) = 0;
 virtual void MulAssign16( float *dst, const float constant, const int count ) = 0;


 virtual void MatX_MultiplyVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_MultiplyAddVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_MultiplySubVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_TransposeMultiplyVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_TransposeMultiplyAddVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_TransposeMultiplySubVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_MultiplyMatX( idMatX &dst, const idMatX &m1, const idMatX &m2 ) = 0;
 virtual void MatX_TransposeMultiplyMatX( idMatX &dst, const idMatX &m1, const idMatX &m2 ) = 0;
 virtual void MatX_LowerTriangularSolve( const idMatX &L, float *x, const float *b, const int n, int skip = 0 ) = 0;
 virtual void MatX_LowerTriangularSolveTranspose( const idMatX &L, float *x, const float *b, const int n ) = 0;
 virtual bool MatX_LDLTFactor( idMatX &mat, idVecX &invDiag, const int n ) = 0;


 virtual void BlendJoints( idJointQuat *joints, const idJointQuat *blendJoints, const float lerp, const int *index, const int numJoints ) = 0;
 virtual void ConvertJointQuatsToJointMats( idJointMat *jointMats, const idJointQuat *jointQuats, const int numJoints ) = 0;
 virtual void ConvertJointMatsToJointQuats( idJointQuat *jointQuats, const idJointMat *jointMats, const int numJoints ) = 0;
 virtual void TransformJoints( idJointMat *jointMats, const int *parents, const int firstJoint, const int lastJoint ) = 0;
 virtual void UntransformJoints( idJointMat *jointMats, const int *parents, const int firstJoint, const int lastJoint ) = 0;
 virtual void TransformVerts( idDrawVert *verts, const int numVerts, const idJointMat *joints, const idVec4 *weights, const int *index, const int numWeights ) = 0;
 virtual void TracePointCull( byte *cullBits, byte &totalOr, const float radius, const idPlane *planes, const idDrawVert *verts, const int numVerts ) = 0;
 virtual void DecalPointCull( byte *cullBits, const idPlane *planes, const idDrawVert *verts, const int numVerts ) = 0;
 virtual void OverlayPointCull( byte *cullBits, idVec2 *texCoords, const idPlane *planes, const idDrawVert *verts, const int numVerts ) = 0;
 virtual void DeriveTriPlanes( idPlane *planes, const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) = 0;
 virtual void DeriveTangents( idPlane *planes, idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) = 0;
 virtual void DeriveUnsmoothedTangents( idDrawVert *verts, const dominantTri_s *dominantTris, const int numVerts ) = 0;
 virtual void NormalizeTangents( idDrawVert *verts, const int numVerts ) = 0;
 virtual void CreateTextureSpaceLightVectors( idVec3 *lightVectors, const idVec3 &lightOrigin, const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) = 0;
 virtual void CreateSpecularTextureCoords( idVec4 *texCoords, const idVec3 &lightOrigin, const idVec3 &viewOrigin, const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) = 0;
 virtual int CreateShadowCache( idVec4 *vertexCache, int *vertRemap, const idVec3 &lightOrigin, const idDrawVert *verts, const int numVerts ) = 0;
 virtual int CreateVertexProgramShadowCache( idVec4 *vertexCache, const idDrawVert *verts, const int numVerts ) = 0;


 virtual void UpSamplePCMTo44kHz( float *dest, const short *pcm, const int numSamples, const int kHz, const int numChannels ) = 0;
 virtual void UpSampleOGGTo44kHz( float *dest, const float * const *ogg, const int numSamples, const int kHz, const int numChannels ) = 0;
 virtual void MixSoundTwoSpeakerMono( float *mixBuffer, const float *samples, const int numSamples, const float lastV[2], const float currentV[2] ) = 0;
 virtual void MixSoundTwoSpeakerStereo( float *mixBuffer, const float *samples, const int numSamples, const float lastV[2], const float currentV[2] ) = 0;
 virtual void MixSoundSixSpeakerMono( float *mixBuffer, const float *samples, const int numSamples, const float lastV[6], const float currentV[6] ) = 0;
 virtual void MixSoundSixSpeakerStereo( float *mixBuffer, const float *samples, const int numSamples, const float lastV[6], const float currentV[6] ) = 0;
 virtual void MixedSoundToSamples( short *samples, const float *mixBuffer, const int numSamples ) = 0;
};


extern idSIMDProcessor *SIMDProcessor;
# 175 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h" 1
# 95 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h"
template<class T> inline int MaxIndex( T x, T y ) { return ( x > y ) ? 0 : 1; }
template<class T> inline int MinIndex( T x, T y ) { return ( x < y ) ? 0 : 1; }

template<class T> inline T Max3( T x, T y, T z ) { return ( x > y ) ? ( ( x > z ) ? x : z ) : ( ( y > z ) ? y : z ); }
template<class T> inline T Min3( T x, T y, T z ) { return ( x < y ) ? ( ( x < z ) ? x : z ) : ( ( y < z ) ? y : z ); }
template<class T> inline int Max3Index( T x, T y, T z ) { return ( x > y ) ? ( ( x > z ) ? 0 : 2 ) : ( ( y > z ) ? 1 : 2 ); }
template<class T> inline int Min3Index( T x, T y, T z ) { return ( x < y ) ? ( ( x < z ) ? 0 : 2 ) : ( ( y < z ) ? 1 : 2 ); }

template<class T> inline T Sign( T f ) { return ( f > 0 ) ? 1 : ( ( f < 0 ) ? -1 : 0 ); }
template<class T> inline T Square( T x ) { return x * x; }
template<class T> inline T Cube( T x ) { return x * x * x; }


class idMath {
public:

 static void Init( void );

 static float RSqrt( float x );

 static float InvSqrt( float x );
 static float InvSqrt16( float x );
 static double InvSqrt64( float x );

 static float Sqrt( float x );
 static float Sqrt16( float x );
 static double Sqrt64( float x );

 static float Sin( float a );
 static float Sin16( float a );
 static double Sin64( float a );

 static float Cos( float a );
 static float Cos16( float a );
 static double Cos64( float a );

 static void SinCos( float a, float &s, float &c );
 static void SinCos16( float a, float &s, float &c );
 static void SinCos64( float a, double &s, double &c );

 static float Tan( float a );
 static float Tan16( float a );
 static double Tan64( float a );

 static float ASin( float a );
 static float ASin16( float a );
 static double ASin64( float a );

 static float ACos( float a );
 static float ACos16( float a );
 static double ACos64( float a );

 static float ATan( float a );
 static float ATan16( float a );
 static double ATan64( float a );

 static float ATan( float y, float x );
 static float ATan16( float y, float x );
 static double ATan64( float y, float x );

 static float Pow( float x, float y );
 static float Pow16( float x, float y );
 static double Pow64( float x, float y );

 static float Exp( float f );
 static float Exp16( float f );
 static double Exp64( float f );

 static float Log( float f );
 static float Log16( float f );
 static double Log64( float f );

 static int IPow( int x, int y );
 static int ILog2( float f );
 static int ILog2( int i );

 static int BitsForFloat( float f );
 static int BitsForInteger( int i );
 static int MaskForFloatSign( float f );
 static int MaskForIntegerSign( int i );
 static int FloorPowerOfTwo( int x );
 static int CeilPowerOfTwo( int x );
 static bool IsPowerOfTwo( int x );
 static int BitCount( int x );
 static int BitReverse( int x );

 static int Abs( int x );
 static float Fabs( float f );
 static float Floor( float f );
 static float Ceil( float f );
 static float Rint( float f );
 static int Ftoi( float f );
 static int FtoiFast( float f );
 static unsigned long Ftol( float f );
 static unsigned long FtolFast( float );

 static signed char ClampChar( int i );
 static signed short ClampShort( int i );
 static int ClampInt( int min, int max, int value );
 static float ClampFloat( float min, float max, float value );

 static float AngleNormalize360( float angle );
 static float AngleNormalize180( float angle );
 static float AngleDelta( float angle1, float angle2 );

 static int FloatToBits( float f, int exponentBits, int mantissaBits );
 static float BitsToFloat( int i, int exponentBits, int mantissaBits );

 static int FloatHash( const float *array, const int numFloats );

 static const float PI;
 static const float TWO_PI;
 static const float HALF_PI;
 static const float ONEFOURTH_PI;
 static const float E;
 static const float SQRT_TWO;
 static const float SQRT_THREE;
 static const float SQRT_1OVER2;
 static const float SQRT_1OVER3;
 static const float M_DEG2RAD;
 static const float M_RAD2DEG;
 static const float M_SEC2MS;
 static const float M_MS2SEC;
 static const float INFINITY;
 static const float FLT_EPSILON;

private:
 enum {
  LOOKUP_BITS = 8,
  EXP_POS = 23,
  EXP_BIAS = 127,
  LOOKUP_POS = (EXP_POS-LOOKUP_BITS),
  SEED_POS = (EXP_POS-8),
  SQRT_TABLE_SIZE = (2<<LOOKUP_BITS),
  LOOKUP_MASK = (SQRT_TABLE_SIZE-1)
 };

 union _flint {
  dword i;
  float f;
 };

 static dword iSqrt[SQRT_TABLE_SIZE];
 static bool initialized;
};

inline float idMath::RSqrt( float x ) {

 long i;
 float y, r;

 y = x * 0.5f;
 i = *reinterpret_cast<long *>( &x );
 i = 0x5f3759df - ( i >> 1 );
 r = *reinterpret_cast<float *>( &i );
 r = r * ( 1.5f - r * r * y );
 return r;
}

inline float idMath::InvSqrt16( float x ) {

 dword a = ((union _flint*)(&x))->i;
 union _flint seed;

 ((void)0);

 double y = x * 0.5f;
 seed.i = (( ( (3*EXP_BIAS-1) - ( (a >> EXP_POS) & 0xFF) ) >> 1)<<EXP_POS) | iSqrt[(a >> (EXP_POS-LOOKUP_BITS)) & LOOKUP_MASK];
 double r = seed.f;
 r = r * ( 1.5f - r * r * y );
 return (float) r;
}

inline float idMath::InvSqrt( float x ) {

 dword a = ((union _flint*)(&x))->i;
 union _flint seed;

 ((void)0);

 double y = x * 0.5f;
 seed.i = (( ( (3*EXP_BIAS-1) - ( (a >> EXP_POS) & 0xFF) ) >> 1)<<EXP_POS) | iSqrt[(a >> (EXP_POS-LOOKUP_BITS)) & LOOKUP_MASK];
 double r = seed.f;
 r = r * ( 1.5f - r * r * y );
 r = r * ( 1.5f - r * r * y );
 return (float) r;
}

inline double idMath::InvSqrt64( float x ) {
 dword a = ((union _flint*)(&x))->i;
 union _flint seed;

 ((void)0);

 double y = x * 0.5f;
 seed.i = (( ( (3*EXP_BIAS-1) - ( (a >> EXP_POS) & 0xFF) ) >> 1)<<EXP_POS) | iSqrt[(a >> (EXP_POS-LOOKUP_BITS)) & LOOKUP_MASK];
 double r = seed.f;
 r = r * ( 1.5f - r * r * y );
 r = r * ( 1.5f - r * r * y );
 r = r * ( 1.5f - r * r * y );
 return r;
}

inline float idMath::Sqrt16( float x ) {
 return x * InvSqrt16( x );
}

inline float idMath::Sqrt( float x ) {
 return x * InvSqrt( x );
}

inline double idMath::Sqrt64( float x ) {
 return x * InvSqrt64( x );
}

inline float idMath::Sin( float a ) {
 return sinf( a );
}

inline float idMath::Sin16( float a ) {
 float s;

 if ( ( a < 0.0f ) || ( a >= TWO_PI ) ) {
  a -= floorf( a / TWO_PI ) * TWO_PI;
 }

 if ( a < PI ) {
  if ( a > HALF_PI ) {
   a = PI - a;
  }
 } else {
  if ( a > PI + HALF_PI ) {
   a = a - TWO_PI;
  } else {
   a = PI - a;
  }
 }






 s = a * a;
 return a * ( ( ( ( ( -2.39e-08f * s + 2.7526e-06f ) * s - 1.98409e-04f ) * s + 8.3333315e-03f ) * s - 1.666666664e-01f ) * s + 1.0f );
}

inline double idMath::Sin64( float a ) {
 return sin( a );
}

inline float idMath::Cos( float a ) {
 return cosf( a );
}

inline float idMath::Cos16( float a ) {
 float s, d;

 if ( ( a < 0.0f ) || ( a >= TWO_PI ) ) {
  a -= floorf( a / TWO_PI ) * TWO_PI;
 }

 if ( a < PI ) {
  if ( a > HALF_PI ) {
   a = PI - a;
   d = -1.0f;
  } else {
   d = 1.0f;
  }
 } else {
  if ( a > PI + HALF_PI ) {
   a = a - TWO_PI;
   d = 1.0f;
  } else {
   a = PI - a;
   d = -1.0f;
  }
 }
# 382 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h"
 s = a * a;
 return d * ( ( ( ( ( -2.605e-07f * s + 2.47609e-05f ) * s - 1.3888397e-03f ) * s + 4.16666418e-02f ) * s - 4.999999963e-01f ) * s + 1.0f );
}

inline double idMath::Cos64( float a ) {
 return cos( a );
}

inline void idMath::SinCos( float a, float &s, float &c ) {
# 401 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h"
 s = sinf( a );
 c = cosf( a );

}

inline void idMath::SinCos16( float a, float &s, float &c ) {
 float t, d;

 if ( ( a < 0.0f ) || ( a >= idMath::TWO_PI ) ) {
  a -= floorf( a / idMath::TWO_PI ) * idMath::TWO_PI;
 }

 if ( a < PI ) {
  if ( a > HALF_PI ) {
   a = PI - a;
   d = -1.0f;
  } else {
   d = 1.0f;
  }
 } else {
  if ( a > PI + HALF_PI ) {
   a = a - TWO_PI;
   d = 1.0f;
  } else {
   a = PI - a;
   d = -1.0f;
  }
 }
# 438 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h"
 t = a * a;
 s = a * ( ( ( ( ( -2.39e-08f * t + 2.7526e-06f ) * t - 1.98409e-04f ) * t + 8.3333315e-03f ) * t - 1.666666664e-01f ) * t + 1.0f );
 c = d * ( ( ( ( ( -2.605e-07f * t + 2.47609e-05f ) * t - 1.3888397e-03f ) * t + 4.16666418e-02f ) * t - 4.999999963e-01f ) * t + 1.0f );
}

inline void idMath::SinCos64( float a, double &s, double &c ) {
# 454 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h"
 s = sin( a );
 c = cos( a );

}

inline float idMath::Tan( float a ) {
 return tanf( a );
}

inline float idMath::Tan16( float a ) {
 float s;
 bool reciprocal;

 if ( ( a < 0.0f ) || ( a >= PI ) ) {
  a -= floorf( a / PI ) * PI;
 }

 if ( a < HALF_PI ) {
  if ( a > ONEFOURTH_PI ) {
   a = HALF_PI - a;
   reciprocal = true;
  } else {
   reciprocal = false;
  }
 } else {
  if ( a > HALF_PI + ONEFOURTH_PI ) {
   a = a - PI;
   reciprocal = false;
  } else {
   a = HALF_PI - a;
   reciprocal = true;
  }
 }
# 496 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h"
 s = a * a;
 s = a * ( ( ( ( ( ( 9.5168091e-03f * s + 2.900525e-03f ) * s + 2.45650893e-02f ) * s + 5.33740603e-02f ) * s + 1.333923995e-01f ) * s + 3.333314036e-01f ) * s + 1.0f );
 if ( reciprocal ) {
  return 1.0f / s;
 } else {
  return s;
 }
}

inline double idMath::Tan64( float a ) {
 return tan( a );
}

inline float idMath::ASin( float a ) {
 if ( a <= -1.0f ) {
  return -HALF_PI;
 }
 if ( a >= 1.0f ) {
  return HALF_PI;
 }
 return asinf( a );
}

inline float idMath::ASin16( float a ) {
 if ( ((*(const unsigned long *)&(a)) >> 31) ) {
  if ( a <= -1.0f ) {
   return -HALF_PI;
  }
  a = fabs( a );
  return ( ( ( -0.0187293f * a + 0.0742610f ) * a - 0.2121144f ) * a + 1.5707288f ) * sqrt( 1.0f - a ) - HALF_PI;
 } else {
  if ( a >= 1.0f ) {
   return HALF_PI;
  }
  return HALF_PI - ( ( ( -0.0187293f * a + 0.0742610f ) * a - 0.2121144f ) * a + 1.5707288f ) * sqrt( 1.0f - a );
 }
}

inline double idMath::ASin64( float a ) {
 if ( a <= -1.0f ) {
  return -HALF_PI;
 }
 if ( a >= 1.0f ) {
  return HALF_PI;
 }
 return asin( a );
}

inline float idMath::ACos( float a ) {
 if ( a <= -1.0f ) {
  return PI;
 }
 if ( a >= 1.0f ) {
  return 0.0f;
 }
 return acosf( a );
}

inline float idMath::ACos16( float a ) {
 if ( ((*(const unsigned long *)&(a)) >> 31) ) {
  if ( a <= -1.0f ) {
   return PI;
  }
  a = fabs( a );
  return PI - ( ( ( -0.0187293f * a + 0.0742610f ) * a - 0.2121144f ) * a + 1.5707288f ) * sqrt( 1.0f - a );
 } else {
  if ( a >= 1.0f ) {
   return 0.0f;
  }
  return ( ( ( -0.0187293f * a + 0.0742610f ) * a - 0.2121144f ) * a + 1.5707288f ) * sqrt( 1.0f - a );
 }
}

inline double idMath::ACos64( float a ) {
 if ( a <= -1.0f ) {
  return PI;
 }
 if ( a >= 1.0f ) {
  return 0.0f;
 }
 return acos( a );
}

inline float idMath::ATan( float a ) {
 return atanf( a );
}

inline float idMath::ATan16( float a ) {
 float s;

 if ( fabs( a ) > 1.0f ) {
  a = 1.0f / a;
  s = a * a;
  s = - ( ( ( ( ( ( ( ( ( 0.0028662257f * s - 0.0161657367f ) * s + 0.0429096138f ) * s - 0.0752896400f )
    * s + 0.1065626393f ) * s - 0.1420889944f ) * s + 0.1999355085f ) * s - 0.3333314528f ) * s ) + 1.0f ) * a;
  if ( ((*(const unsigned long *)&(a)) >> 31) ) {
   return s - HALF_PI;
  } else {
   return s + HALF_PI;
  }
 } else {
  s = a * a;
  return ( ( ( ( ( ( ( ( ( 0.0028662257f * s - 0.0161657367f ) * s + 0.0429096138f ) * s - 0.0752896400f )
   * s + 0.1065626393f ) * s - 0.1420889944f ) * s + 0.1999355085f ) * s - 0.3333314528f ) * s ) + 1.0f ) * a;
 }
}

inline double idMath::ATan64( float a ) {
 return atan( a );
}

inline float idMath::ATan( float y, float x ) {
 return atan2f( y, x );
}

inline float idMath::ATan16( float y, float x ) {
 float a, s;

 if ( fabs( y ) > fabs( x ) ) {
  a = x / y;
  s = a * a;
  s = - ( ( ( ( ( ( ( ( ( 0.0028662257f * s - 0.0161657367f ) * s + 0.0429096138f ) * s - 0.0752896400f )
    * s + 0.1065626393f ) * s - 0.1420889944f ) * s + 0.1999355085f ) * s - 0.3333314528f ) * s ) + 1.0f ) * a;
  if ( ((*(const unsigned long *)&(a)) >> 31) ) {
   return s - HALF_PI;
  } else {
   return s + HALF_PI;
  }
 } else {
  a = y / x;
  s = a * a;
  return ( ( ( ( ( ( ( ( ( 0.0028662257f * s - 0.0161657367f ) * s + 0.0429096138f ) * s - 0.0752896400f )
   * s + 0.1065626393f ) * s - 0.1420889944f ) * s + 0.1999355085f ) * s - 0.3333314528f ) * s ) + 1.0f ) * a;
 }
}

inline double idMath::ATan64( float y, float x ) {
 return atan2( y, x );
}

inline float idMath::Pow( float x, float y ) {
 return powf( x, y );
}

inline float idMath::Pow16( float x, float y ) {
 return Exp16( y * Log16( x ) );
}

inline double idMath::Pow64( float x, float y ) {
 return pow( x, y );
}

inline float idMath::Exp( float f ) {
 return expf( f );
}

inline float idMath::Exp16( float f ) {
 int i, s, e, m, exponent;
 float x, x2, y, p, q;

 x = f * 1.44269504088896340f;

 i = *reinterpret_cast<int *>(&x);
 s = ( i >> 31 );
 e = ( ( i >> 23 ) & ( ( 1 << 8 ) - 1 ) ) - 127;
 m = ( i & ( ( 1 << 23 ) - 1 ) ) | ( 1 << 23 );
 i = ( ( m >> ( 23 - e ) ) & ~( e >> 31 ) ) ^ s;






 exponent = ( i + 127 ) << 23;
 y = *reinterpret_cast<float *>(&exponent);
 x -= (float) i;
 if ( x >= 0.5f ) {
  x -= 0.5f;
  y *= 1.4142135623730950488f;
 }
 x2 = x * x;
 p = x * ( 7.2152891511493f + x2 * 0.0576900723731f );
 q = 20.8189237930062f + x2;
 x = y * ( q + p ) / ( q - p );
 return x;
}

inline double idMath::Exp64( float f ) {
 return exp( f );
}

inline float idMath::Log( float f ) {
 return logf( f );
}

inline float idMath::Log16( float f ) {
 int i, exponent;
 float y, y2;

 i = *reinterpret_cast<int *>(&f);
 exponent = ( ( i >> 23 ) & ( ( 1 << 8 ) - 1 ) ) - 127;
 i -= ( exponent + 1 ) << 23;
 y = *reinterpret_cast<float *>(&i);
 y *= 1.4142135623730950488f;
 y = ( y - 1.0f ) / ( y + 1.0f );
 y2 = y * y;
 y = y * ( 2.000000000046727f + y2 * ( 0.666666635059382f + y2 * ( 0.4000059794795f + y2 * ( 0.28525381498f + y2 * 0.2376245609f ) ) ) );
 y += 0.693147180559945f * ( (float)exponent + 0.5f );
 return y;
}

inline double idMath::Log64( float f ) {
 return log( f );
}

inline int idMath::IPow( int x, int y ) {
 int r; for( r = x; y > 1; y-- ) { r *= x; } return r;
}

inline int idMath::ILog2( float f ) {
 return ( ( (*reinterpret_cast<int *>(&f)) >> 23 ) & ( ( 1 << 8 ) - 1 ) ) - 127;
}

inline int idMath::ILog2( int i ) {
 return ILog2( (float)i );
}

inline int idMath::BitsForFloat( float f ) {
 return ILog2( f ) + 1;
}

inline int idMath::BitsForInteger( int i ) {
 return ILog2( (float)i ) + 1;
}

inline int idMath::MaskForFloatSign( float f ) {
 return ( (*reinterpret_cast<int *>(&f)) >> 31 );
}

inline int idMath::MaskForIntegerSign( int i ) {
 return ( i >> 31 );
}

inline int idMath::FloorPowerOfTwo( int x ) {
 return CeilPowerOfTwo( x ) >> 1;
}

inline int idMath::CeilPowerOfTwo( int x ) {
 x--;
 x |= x >> 1;
 x |= x >> 2;
 x |= x >> 4;
 x |= x >> 8;
 x |= x >> 16;
 x++;
 return x;
}

inline bool idMath::IsPowerOfTwo( int x ) {
 return ( x & ( x - 1 ) ) == 0 && x > 0;
}

inline int idMath::BitCount( int x ) {
 x -= ( ( x >> 1 ) & 0x55555555 );
 x = ( ( ( x >> 2 ) & 0x33333333 ) + ( x & 0x33333333 ) );
 x = ( ( ( x >> 4 ) + x ) & 0x0f0f0f0f );
 x += ( x >> 8 );
 return ( ( x + ( x >> 16 ) ) & 0x0000003f );
}

inline int idMath::BitReverse( int x ) {
 x = ( ( ( x >> 1 ) & 0x55555555 ) | ( ( x & 0x55555555 ) << 1 ) );
 x = ( ( ( x >> 2 ) & 0x33333333 ) | ( ( x & 0x33333333 ) << 2 ) );
 x = ( ( ( x >> 4 ) & 0x0f0f0f0f ) | ( ( x & 0x0f0f0f0f ) << 4 ) );
 x = ( ( ( x >> 8 ) & 0x00ff00ff ) | ( ( x & 0x00ff00ff ) << 8 ) );
 return ( ( x >> 16 ) | ( x << 16 ) );
}

inline int idMath::Abs( int x ) {
   int y = x >> 31;
   return ( ( x ^ y ) - y );
}

inline float idMath::Fabs( float f ) {
 int tmp = *reinterpret_cast<int *>( &f );
 tmp &= 0x7FFFFFFF;
 return *reinterpret_cast<float *>( &tmp );
}

inline float idMath::Floor( float f ) {
 return floorf( f );
}

inline float idMath::Ceil( float f ) {
 return ceilf( f );
}

inline float idMath::Rint( float f ) {
 return floorf( f + 0.5f );
}

inline int idMath::Ftoi( float f ) {
 return (int) f;
}

inline int idMath::FtoiFast( float f ) {
# 825 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h"
 return (int) f;

}

inline unsigned long idMath::Ftol( float f ) {
 return (unsigned long) f;
}

inline unsigned long idMath::FtolFast( float f ) {
# 859 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Math.h"
 return (unsigned long) f;

}

inline signed char idMath::ClampChar( int i ) {
 if ( i < -128 ) {
  return -128;
 }
 if ( i > 127 ) {
  return 127;
 }
 return i;
}

inline signed short idMath::ClampShort( int i ) {
 if ( i < -32768 ) {
  return -32768;
 }
 if ( i > 32767 ) {
  return 32767;
 }
 return i;
}

inline int idMath::ClampInt( int min, int max, int value ) {
 if ( value < min ) {
  return min;
 }
 if ( value > max ) {
  return max;
 }
 return value;
}

inline float idMath::ClampFloat( float min, float max, float value ) {
 if ( value < min ) {
  return min;
 }
 if ( value > max ) {
  return max;
 }
 return value;
}

inline float idMath::AngleNormalize360( float angle ) {
 if ( ( angle >= 360.0f ) || ( angle < 0.0f ) ) {
  angle -= floor( angle / 360.0f ) * 360.0f;
 }
 return angle;
}

inline float idMath::AngleNormalize180( float angle ) {
 angle = AngleNormalize360( angle );
 if ( angle > 180.0f ) {
  angle -= 360.0f;
 }
 return angle;
}

inline float idMath::AngleDelta( float angle1, float angle2 ) {
 return AngleNormalize180( angle1 - angle2 );
}

inline int idMath::FloatHash( const float *array, const int numFloats ) {
 int i, hash = 0;
 const int *ptr;

 ptr = reinterpret_cast<const int *>( array );
 for ( i = 0; i < numFloats; i++ ) {
  hash ^= ptr[i];
 }
 return hash;
}
# 176 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Random.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Random.h"
class idRandom {
public:
      idRandom( int seed = 0 );

 void SetSeed( int seed );
 int GetSeed( void ) const;

 int RandomInt( void );
 int RandomInt( int max );
 float RandomFloat( void );
 float CRandomFloat( void );

 static const int MAX_RAND = 0x7fff;

private:
 int seed;
};

inline idRandom::idRandom( int seed ) {
 this->seed = seed;
}

inline void idRandom::SetSeed( int seed ) {
 this->seed = seed;
}

inline int idRandom::GetSeed( void ) const {
 return seed;
}

inline int idRandom::RandomInt( void ) {
 seed = 69069 * seed + 1;
 return ( seed & idRandom::MAX_RAND );
}

inline int idRandom::RandomInt( int max ) {
 if ( max == 0 ) {
  return 0;
 }
 return RandomInt() % max;
}

inline float idRandom::RandomFloat( void ) {
 return ( RandomInt() / ( float )( idRandom::MAX_RAND + 1 ) );
}

inline float idRandom::CRandomFloat( void ) {
 return ( 2.0f * ( RandomFloat() - 0.5f ) );
}
# 99 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Random.h"
class idRandom2 {
public:
       idRandom2( unsigned long seed = 0 );

 void SetSeed( unsigned long seed );
 unsigned long GetSeed( void ) const;

 int RandomInt( void );
 int RandomInt( int max );
 float RandomFloat( void );
 float CRandomFloat( void );

 static const int MAX_RAND = 0x7fff;

private:
 unsigned long seed;

 static const unsigned long IEEE_ONE = 0x3f800000;
 static const unsigned long IEEE_MASK = 0x007fffff;
};

inline idRandom2::idRandom2( unsigned long seed ) {
 this->seed = seed;
}

inline void idRandom2::SetSeed( unsigned long seed ) {
 this->seed = seed;
}

inline unsigned long idRandom2::GetSeed( void ) const {
 return seed;
}

inline int idRandom2::RandomInt( void ) {
 seed = 1664525L * seed + 1013904223L;
 return ( (int) seed & idRandom2::MAX_RAND );
}

inline int idRandom2::RandomInt( int max ) {
 if ( max == 0 ) {
  return 0;
 }
 return ( RandomInt() >> ( 16 - idMath::BitsForInteger( max ) ) ) % max;
}

inline float idRandom2::RandomFloat( void ) {
 unsigned long i;
 seed = 1664525L * seed + 1013904223L;
 i = idRandom2::IEEE_ONE | ( seed & idRandom2::IEEE_MASK );
 return ( ( *(float *)&i ) - 1.0f );
}

inline float idRandom2::CRandomFloat( void ) {
 unsigned long i;
 seed = 1664525L * seed + 1013904223L;
 i = idRandom2::IEEE_ONE | ( seed & idRandom2::IEEE_MASK );
 return ( 2.0f * ( *(float *)&i ) - 3.0f );
}
# 177 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Complex.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Complex.h"
class idComplex {
public:
 float r;
 float i;

      idComplex( void );
      idComplex( const float r, const float i );

 void Set( const float r, const float i );
 void Zero( void );

 float operator[]( int index ) const;
 float & operator[]( int index );

 idComplex operator-() const;
 idComplex & operator=( const idComplex &a );

 idComplex operator*( const idComplex &a ) const;
 idComplex operator/( const idComplex &a ) const;
 idComplex operator+( const idComplex &a ) const;
 idComplex operator-( const idComplex &a ) const;

 idComplex & operator*=( const idComplex &a );
 idComplex & operator/=( const idComplex &a );
 idComplex & operator+=( const idComplex &a );
 idComplex & operator-=( const idComplex &a );

 idComplex operator*( const float a ) const;
 idComplex operator/( const float a ) const;
 idComplex operator+( const float a ) const;
 idComplex operator-( const float a ) const;

 idComplex & operator*=( const float a );
 idComplex & operator/=( const float a );
 idComplex & operator+=( const float a );
 idComplex & operator-=( const float a );

 friend idComplex operator*( const float a, const idComplex &b );
 friend idComplex operator/( const float a, const idComplex &b );
 friend idComplex operator+( const float a, const idComplex &b );
 friend idComplex operator-( const float a, const idComplex &b );

 bool Compare( const idComplex &a ) const;
 bool Compare( const idComplex &a, const float epsilon ) const;
 bool operator==( const idComplex &a ) const;
 bool operator!=( const idComplex &a ) const;

 idComplex Reciprocal( void ) const;
 idComplex Sqrt( void ) const;
 float Abs( void ) const;

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;
};

extern idComplex complex_origin;


inline idComplex::idComplex( void ) {
}

inline idComplex::idComplex( const float r, const float i ) {
 this->r = r;
 this->i = i;
}

inline void idComplex::Set( const float r, const float i ) {
 this->r = r;
 this->i = i;
}

inline void idComplex::Zero( void ) {
 r = i = 0.0f;
}

inline float idComplex::operator[]( int index ) const {
 ((void)0);
 return ( &r )[ index ];
}

inline float& idComplex::operator[]( int index ) {
 ((void)0);
 return ( &r )[ index ];
}

inline idComplex idComplex::operator-() const {
 return idComplex( -r, -i );
}

inline idComplex &idComplex::operator=( const idComplex &a ) {
 r = a.r;
 i = a.i;
 return *this;
}

inline idComplex idComplex::operator*( const idComplex &a ) const {
 return idComplex( r * a.r - i * a.i, i * a.r + r * a.i );
}

inline idComplex idComplex::operator/( const idComplex &a ) const {
 float s, t;
 if ( idMath::Fabs( a.r ) >= idMath::Fabs( a.i ) ) {
  s = a.i / a.r;
  t = 1.0f / ( a.r + s * a.i );
  return idComplex( ( r + s * i ) * t, ( i - s * r ) * t );
 } else {
  s = a.r / a.i;
  t = 1.0f / ( s * a.r + a.i );
  return idComplex( ( r * s + i ) * t, ( i * s - r ) * t );
 }
}

inline idComplex idComplex::operator+( const idComplex &a ) const {
 return idComplex( r + a.r, i + a.i );
}

inline idComplex idComplex::operator-( const idComplex &a ) const {
 return idComplex( r - a.r, i - a.i );
}

inline idComplex &idComplex::operator*=( const idComplex &a ) {
 *this = idComplex( r * a.r - i * a.i, i * a.r + r * a.i );
 return *this;
}

inline idComplex &idComplex::operator/=( const idComplex &a ) {
 float s, t;
 if ( idMath::Fabs( a.r ) >= idMath::Fabs( a.i ) ) {
  s = a.i / a.r;
  t = 1.0f / ( a.r + s * a.i );
  *this = idComplex( ( r + s * i ) * t, ( i - s * r ) * t );
 } else {
  s = a.r / a.i;
  t = 1.0f / ( s * a.r + a.i );
  *this = idComplex( ( r * s + i ) * t, ( i * s - r ) * t );
 }
 return *this;
}

inline idComplex &idComplex::operator+=( const idComplex &a ) {
 r += a.r;
 i += a.i;
 return *this;
}

inline idComplex &idComplex::operator-=( const idComplex &a ) {
 r -= a.r;
 i -= a.i;
 return *this;
}

inline idComplex idComplex::operator*( const float a ) const {
 return idComplex( r * a, i * a );
}

inline idComplex idComplex::operator/( const float a ) const {
 float s = 1.0f / a;
 return idComplex( r * s, i * s );
}

inline idComplex idComplex::operator+( const float a ) const {
 return idComplex( r + a, i );
}

inline idComplex idComplex::operator-( const float a ) const {
 return idComplex( r - a, i );
}

inline idComplex &idComplex::operator*=( const float a ) {
 r *= a;
 i *= a;
 return *this;
}

inline idComplex &idComplex::operator/=( const float a ) {
 float s = 1.0f / a;
 r *= s;
 i *= s;
 return *this;
}

inline idComplex &idComplex::operator+=( const float a ) {
 r += a;
 return *this;
}

inline idComplex &idComplex::operator-=( const float a ) {
 r -= a;
 return *this;
}

inline idComplex operator*( const float a, const idComplex &b ) {
 return idComplex( a * b.r, a * b.i );
}

inline idComplex operator/( const float a, const idComplex &b ) {
 float s, t;
 if ( idMath::Fabs( b.r ) >= idMath::Fabs( b.i ) ) {
  s = b.i / b.r;
  t = a / ( b.r + s * b.i );
  return idComplex( t, - s * t );
 } else {
  s = b.r / b.i;
  t = a / ( s * b.r + b.i );
  return idComplex( s * t, - t );
 }
}

inline idComplex operator+( const float a, const idComplex &b ) {
 return idComplex( a + b.r, b.i );
}

inline idComplex operator-( const float a, const idComplex &b ) {
 return idComplex( a - b.r, -b.i );
}

inline idComplex idComplex::Reciprocal( void ) const {
 float s, t;
 if ( idMath::Fabs( r ) >= idMath::Fabs( i ) ) {
  s = i / r;
  t = 1.0f / ( r + s * i );
  return idComplex( t, - s * t );
 } else {
  s = r / i;
  t = 1.0f / ( s * r + i );
  return idComplex( s * t, - t );
 }
}

inline idComplex idComplex::Sqrt( void ) const {
 float x, y, w;

 if ( r == 0.0f && i == 0.0f ) {
  return idComplex( 0.0f, 0.0f );
 }
 x = idMath::Fabs( r );
 y = idMath::Fabs( i );
 if ( x >= y ) {
  w = y / x;
  w = idMath::Sqrt( x ) * idMath::Sqrt( 0.5f * ( 1.0f + idMath::Sqrt( 1.0f + w * w ) ) );
 } else {
  w = x / y;
  w = idMath::Sqrt( y ) * idMath::Sqrt( 0.5f * ( w + idMath::Sqrt( 1.0f + w * w ) ) );
 }
 if ( w == 0.0f ) {
  return idComplex( 0.0f, 0.0f );
 }
 if ( r >= 0.0f ) {
  return idComplex( w, 0.5f * i / w );
 } else {
  return idComplex( 0.5f * y / w, ( i >= 0.0f ) ? w : -w );
 }
}

inline float idComplex::Abs( void ) const {
 float x, y, t;
 x = idMath::Fabs( r );
 y = idMath::Fabs( i );
 if ( x == 0.0f ) {
  return y;
 } else if ( y == 0.0f ) {
  return x;
 } else if ( x > y ) {
  t = y / x;
  return x * idMath::Sqrt( 1.0f + t * t );
 } else {
  t = x / y;
  return y * idMath::Sqrt( 1.0f + t * t );
 }
}

inline bool idComplex::Compare( const idComplex &a ) const {
 return ( ( r == a.r ) && ( i == a.i ) );
}

inline bool idComplex::Compare( const idComplex &a, const float epsilon ) const {
 if ( idMath::Fabs( r - a.r ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( i - a.i ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idComplex::operator==( const idComplex &a ) const {
 return Compare( a );
}

inline bool idComplex::operator!=( const idComplex &a ) const {
 return !Compare( a );
}

inline int idComplex::GetDimension( void ) const {
 return 2;
}

inline const float *idComplex::ToFloatPtr( void ) const {
 return &r;
}

inline float *idComplex::ToFloatPtr( void ) {
 return &r;
}
# 178 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Vector.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Vector.h"
class idAngles;
class idPolar3;
class idMat3;







class idVec2 {
public:
 float x;
 float y;

     idVec2( void );
     explicit idVec2( const float x, const float y );

 void Set( const float x, const float y );
 void Zero( void );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idVec2 operator-() const;
 float operator*( const idVec2 &a ) const;
 idVec2 operator*( const float a ) const;
 idVec2 operator/( const float a ) const;
 idVec2 operator+( const idVec2 &a ) const;
 idVec2 operator-( const idVec2 &a ) const;
 idVec2 & operator+=( const idVec2 &a );
 idVec2 & operator-=( const idVec2 &a );
 idVec2 & operator/=( const idVec2 &a );
 idVec2 & operator/=( const float a );
 idVec2 & operator*=( const float a );

 friend idVec2 operator*( const float a, const idVec2 b );

 bool Compare( const idVec2 &a ) const;
 bool Compare( const idVec2 &a, const float epsilon ) const;
 bool operator==( const idVec2 &a ) const;
 bool operator!=( const idVec2 &a ) const;

 float Length( void ) const;
 float LengthFast( void ) const;
 float LengthSqr( void ) const;
 float Normalize( void );
 float NormalizeFast( void );
 idVec2 & Truncate( float length );
 void Clamp( const idVec2 &min, const idVec2 &max );
 void Snap( void );
 void SnapInt( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void Lerp( const idVec2 &v1, const idVec2 &v2, const float l );
};

extern idVec2 vec2_origin;


inline idVec2::idVec2( void ) {
}

inline idVec2::idVec2( const float x, const float y ) {
 this->x = x;
 this->y = y;
}

inline void idVec2::Set( const float x, const float y ) {
 this->x = x;
 this->y = y;
}

inline void idVec2::Zero( void ) {
 x = y = 0.0f;
}

inline bool idVec2::Compare( const idVec2 &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) );
}

inline bool idVec2::Compare( const idVec2 &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idVec2::operator==( const idVec2 &a ) const {
 return Compare( a );
}

inline bool idVec2::operator!=( const idVec2 &a ) const {
 return !Compare( a );
}

inline float idVec2::operator[]( int index ) const {
 return ( &x )[ index ];
}

inline float& idVec2::operator[]( int index ) {
 return ( &x )[ index ];
}

inline float idVec2::Length( void ) const {
 return ( float )idMath::Sqrt( x * x + y * y );
}

inline float idVec2::LengthFast( void ) const {
 float sqrLength;

 sqrLength = x * x + y * y;
 return sqrLength * idMath::RSqrt( sqrLength );
}

inline float idVec2::LengthSqr( void ) const {
 return ( x * x + y * y );
}

inline float idVec2::Normalize( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y;
 invLength = idMath::InvSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 return invLength * sqrLength;
}

inline float idVec2::NormalizeFast( void ) {
 float lengthSqr, invLength;

 lengthSqr = x * x + y * y;
 invLength = idMath::RSqrt( lengthSqr );
 x *= invLength;
 y *= invLength;
 return invLength * lengthSqr;
}

inline idVec2 &idVec2::Truncate( float length ) {
 float length2;
 float ilength;

 if ( !length ) {
  Zero();
 }
 else {
  length2 = LengthSqr();
  if ( length2 > length * length ) {
   ilength = length * idMath::InvSqrt( length2 );
   x *= ilength;
   y *= ilength;
  }
 }

 return *this;
}

inline void idVec2::Clamp( const idVec2 &min, const idVec2 &max ) {
 if ( x < min.x ) {
  x = min.x;
 } else if ( x > max.x ) {
  x = max.x;
 }
 if ( y < min.y ) {
  y = min.y;
 } else if ( y > max.y ) {
  y = max.y;
 }
}

inline void idVec2::Snap( void ) {
 x = floor( x + 0.5f );
 y = floor( y + 0.5f );
}

inline void idVec2::SnapInt( void ) {
 x = float( int( x ) );
 y = float( int( y ) );
}

inline idVec2 idVec2::operator-() const {
 return idVec2( -x, -y );
}

inline idVec2 idVec2::operator-( const idVec2 &a ) const {
 return idVec2( x - a.x, y - a.y );
}

inline float idVec2::operator*( const idVec2 &a ) const {
 return x * a.x + y * a.y;
}

inline idVec2 idVec2::operator*( const float a ) const {
 return idVec2( x * a, y * a );
}

inline idVec2 idVec2::operator/( const float a ) const {
 float inva = 1.0f / a;
 return idVec2( x * inva, y * inva );
}

inline idVec2 operator*( const float a, const idVec2 b ) {
 return idVec2( b.x * a, b.y * a );
}

inline idVec2 idVec2::operator+( const idVec2 &a ) const {
 return idVec2( x + a.x, y + a.y );
}

inline idVec2 &idVec2::operator+=( const idVec2 &a ) {
 x += a.x;
 y += a.y;

 return *this;
}

inline idVec2 &idVec2::operator/=( const idVec2 &a ) {
 x /= a.x;
 y /= a.y;

 return *this;
}

inline idVec2 &idVec2::operator/=( const float a ) {
 float inva = 1.0f / a;
 x *= inva;
 y *= inva;

 return *this;
}

inline idVec2 &idVec2::operator-=( const idVec2 &a ) {
 x -= a.x;
 y -= a.y;

 return *this;
}

inline idVec2 &idVec2::operator*=( const float a ) {
 x *= a;
 y *= a;

 return *this;
}

inline int idVec2::GetDimension( void ) const {
 return 2;
}

inline const float *idVec2::ToFloatPtr( void ) const {
 return &x;
}

inline float *idVec2::ToFloatPtr( void ) {
 return &x;
}
# 316 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Vector.h"
class idVec3 {
public:
 float x;
 float y;
 float z;

     idVec3( void );
     explicit idVec3( const float x, const float y, const float z );

 void Set( const float x, const float y, const float z );
 void Zero( void );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idVec3 operator-() const;
 idVec3 & operator=( const idVec3 &a );
 float operator*( const idVec3 &a ) const;
 idVec3 operator*( const float a ) const;
 idVec3 operator/( const float a ) const;
 idVec3 operator+( const idVec3 &a ) const;
 idVec3 operator-( const idVec3 &a ) const;
 idVec3 & operator+=( const idVec3 &a );
 idVec3 & operator-=( const idVec3 &a );
 idVec3 & operator/=( const idVec3 &a );
 idVec3 & operator/=( const float a );
 idVec3 & operator*=( const float a );

 friend idVec3 operator*( const float a, const idVec3 b );

 bool Compare( const idVec3 &a ) const;
 bool Compare( const idVec3 &a, const float epsilon ) const;
 bool operator==( const idVec3 &a ) const;
 bool operator!=( const idVec3 &a ) const;

 bool FixDegenerateNormal( void );
 bool FixDenormals( void );

 idVec3 Cross( const idVec3 &a ) const;
 idVec3 & Cross( const idVec3 &a, const idVec3 &b );
 float Length( void ) const;
 float LengthSqr( void ) const;
 float LengthFast( void ) const;
 float Normalize( void );
 float NormalizeFast( void );
 idVec3 & Truncate( float length );
 void Clamp( const idVec3 &min, const idVec3 &max );
 void Snap( void );
 void SnapInt( void );

 int GetDimension( void ) const;

 float ToYaw( void ) const;
 float ToPitch( void ) const;
 idAngles ToAngles( void ) const;
 idPolar3 ToPolar( void ) const;
 idMat3 ToMat3( void ) const;
 const idVec2 & ToVec2( void ) const;
 idVec2 & ToVec2( void );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void NormalVectors( idVec3 &left, idVec3 &down ) const;
 void OrthogonalBasis( idVec3 &left, idVec3 &up ) const;

 void ProjectOntoPlane( const idVec3 &normal, const float overBounce = 1.0f );
 bool ProjectAlongPlane( const idVec3 &normal, const float epsilon, const float overBounce = 1.0f );
 void ProjectSelfOntoSphere( const float radius );

 void Lerp( const idVec3 &v1, const idVec3 &v2, const float l );
 void SLerp( const idVec3 &v1, const idVec3 &v2, const float l );
};

extern idVec3 vec3_origin;


inline idVec3::idVec3( void ) {
}

inline idVec3::idVec3( const float x, const float y, const float z ) {
 this->x = x;
 this->y = y;
 this->z = z;
}

inline float idVec3::operator[]( const int index ) const {
 return ( &x )[ index ];
}

inline float &idVec3::operator[]( const int index ) {
 return ( &x )[ index ];
}

inline void idVec3::Set( const float x, const float y, const float z ) {
 this->x = x;
 this->y = y;
 this->z = z;
}

inline void idVec3::Zero( void ) {
 x = y = z = 0.0f;
}

inline idVec3 idVec3::operator-() const {
 return idVec3( -x, -y, -z );
}

inline idVec3 &idVec3::operator=( const idVec3 &a ) {
 x = a.x;
 y = a.y;
 z = a.z;
 return *this;
}

inline idVec3 idVec3::operator-( const idVec3 &a ) const {
 return idVec3( x - a.x, y - a.y, z - a.z );
}

inline float idVec3::operator*( const idVec3 &a ) const {
 return x * a.x + y * a.y + z * a.z;
}

inline idVec3 idVec3::operator*( const float a ) const {
 return idVec3( x * a, y * a, z * a );
}

inline idVec3 idVec3::operator/( const float a ) const {
 float inva = 1.0f / a;
 return idVec3( x * inva, y * inva, z * inva );
}

inline idVec3 operator*( const float a, const idVec3 b ) {
 return idVec3( b.x * a, b.y * a, b.z * a );
}

inline idVec3 idVec3::operator+( const idVec3 &a ) const {
 return idVec3( x + a.x, y + a.y, z + a.z );
}

inline idVec3 &idVec3::operator+=( const idVec3 &a ) {
 x += a.x;
 y += a.y;
 z += a.z;

 return *this;
}

inline idVec3 &idVec3::operator/=( const idVec3 &a ) {
 x /= a.x;
 y /= a.y;
 z /= a.z;

 return *this;
}

inline idVec3 &idVec3::operator/=( const float a ) {
 float inva = 1.0f / a;
 x *= inva;
 y *= inva;
 z *= inva;

 return *this;
}

inline idVec3 &idVec3::operator-=( const idVec3 &a ) {
 x -= a.x;
 y -= a.y;
 z -= a.z;

 return *this;
}

inline idVec3 &idVec3::operator*=( const float a ) {
 x *= a;
 y *= a;
 z *= a;

 return *this;
}

inline bool idVec3::Compare( const idVec3 &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) && ( z == a.z ) );
}

inline bool idVec3::Compare( const idVec3 &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( z - a.z ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idVec3::operator==( const idVec3 &a ) const {
 return Compare( a );
}

inline bool idVec3::operator!=( const idVec3 &a ) const {
 return !Compare( a );
}

inline float idVec3::NormalizeFast( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y + z * z;
 invLength = idMath::RSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 z *= invLength;
 return invLength * sqrLength;
}

inline bool idVec3::FixDegenerateNormal( void ) {
 if ( x == 0.0f ) {
  if ( y == 0.0f ) {
   if ( z > 0.0f ) {
    if ( z != 1.0f ) {
     z = 1.0f;
     return true;
    }
   } else {
    if ( z != -1.0f ) {
     z = -1.0f;
     return true;
    }
   }
   return false;
  } else if ( z == 0.0f ) {
   if ( y > 0.0f ) {
    if ( y != 1.0f ) {
     y = 1.0f;
     return true;
    }
   } else {
    if ( y != -1.0f ) {
     y = -1.0f;
     return true;
    }
   }
   return false;
  }
 } else if ( y == 0.0f ) {
  if ( z == 0.0f ) {
   if ( x > 0.0f ) {
    if ( x != 1.0f ) {
     x = 1.0f;
     return true;
    }
   } else {
    if ( x != -1.0f ) {
     x = -1.0f;
     return true;
    }
   }
   return false;
  }
 }
 if ( idMath::Fabs( x ) == 1.0f ) {
  if ( y != 0.0f || z != 0.0f ) {
   y = z = 0.0f;
   return true;
  }
  return false;
 } else if ( idMath::Fabs( y ) == 1.0f ) {
  if ( x != 0.0f || z != 0.0f ) {
   x = z = 0.0f;
   return true;
  }
  return false;
 } else if ( idMath::Fabs( z ) == 1.0f ) {
  if ( x != 0.0f || y != 0.0f ) {
   x = y = 0.0f;
   return true;
  }
  return false;
 }
 return false;
}

inline bool idVec3::FixDenormals( void ) {
 bool denormal = false;
 if ( fabs( x ) < 1e-30f ) {
  x = 0.0f;
  denormal = true;
 }
 if ( fabs( y ) < 1e-30f ) {
  y = 0.0f;
  denormal = true;
 }
 if ( fabs( z ) < 1e-30f ) {
  z = 0.0f;
  denormal = true;
 }
 return denormal;
}

inline idVec3 idVec3::Cross( const idVec3 &a ) const {
 return idVec3( y * a.z - z * a.y, z * a.x - x * a.z, x * a.y - y * a.x );
}

inline idVec3 &idVec3::Cross( const idVec3 &a, const idVec3 &b ) {
 x = a.y * b.z - a.z * b.y;
 y = a.z * b.x - a.x * b.z;
 z = a.x * b.y - a.y * b.x;

 return *this;
}

inline float idVec3::Length( void ) const {
 return ( float )idMath::Sqrt( x * x + y * y + z * z );
}

inline float idVec3::LengthSqr( void ) const {
 return ( x * x + y * y + z * z );
}

inline float idVec3::LengthFast( void ) const {
 float sqrLength;

 sqrLength = x * x + y * y + z * z;
 return sqrLength * idMath::RSqrt( sqrLength );
}

inline float idVec3::Normalize( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y + z * z;
 invLength = idMath::InvSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 z *= invLength;
 return invLength * sqrLength;
}

inline idVec3 &idVec3::Truncate( float length ) {
 float length2;
 float ilength;

 if ( !length ) {
  Zero();
 }
 else {
  length2 = LengthSqr();
  if ( length2 > length * length ) {
   ilength = length * idMath::InvSqrt( length2 );
   x *= ilength;
   y *= ilength;
   z *= ilength;
  }
 }

 return *this;
}

inline void idVec3::Clamp( const idVec3 &min, const idVec3 &max ) {
 if ( x < min.x ) {
  x = min.x;
 } else if ( x > max.x ) {
  x = max.x;
 }
 if ( y < min.y ) {
  y = min.y;
 } else if ( y > max.y ) {
  y = max.y;
 }
 if ( z < min.z ) {
  z = min.z;
 } else if ( z > max.z ) {
  z = max.z;
 }
}

inline void idVec3::Snap( void ) {
 x = floor( x + 0.5f );
 y = floor( y + 0.5f );
 z = floor( z + 0.5f );
}

inline void idVec3::SnapInt( void ) {
 x = float( int( x ) );
 y = float( int( y ) );
 z = float( int( z ) );
}

inline int idVec3::GetDimension( void ) const {
 return 3;
}

inline const idVec2 &idVec3::ToVec2( void ) const {
 return *reinterpret_cast<const idVec2 *>(this);
}

inline idVec2 &idVec3::ToVec2( void ) {
 return *reinterpret_cast<idVec2 *>(this);
}

inline const float *idVec3::ToFloatPtr( void ) const {
 return &x;
}

inline float *idVec3::ToFloatPtr( void ) {
 return &x;
}

inline void idVec3::NormalVectors( idVec3 &left, idVec3 &down ) const {
 float d;

 d = x * x + y * y;
 if ( !d ) {
  left[0] = 1;
  left[1] = 0;
  left[2] = 0;
 } else {
  d = idMath::InvSqrt( d );
  left[0] = -y * d;
  left[1] = x * d;
  left[2] = 0;
 }
 down = left.Cross( *this );
}

inline void idVec3::OrthogonalBasis( idVec3 &left, idVec3 &up ) const {
 float l, s;

 if ( idMath::Fabs( z ) > 0.7f ) {
  l = y * y + z * z;
  s = idMath::InvSqrt( l );
  up[0] = 0;
  up[1] = z * s;
  up[2] = -y * s;
  left[0] = l * s;
  left[1] = -x * up[2];
  left[2] = x * up[1];
 }
 else {
  l = x * x + y * y;
  s = idMath::InvSqrt( l );
  left[0] = -y * s;
  left[1] = x * s;
  left[2] = 0;
  up[0] = -z * left[1];
  up[1] = z * left[0];
  up[2] = l * s;
 }
}

inline void idVec3::ProjectOntoPlane( const idVec3 &normal, const float overBounce ) {
 float backoff;

 backoff = *this * normal;

 if ( overBounce != 1.0 ) {
  if ( backoff < 0 ) {
   backoff *= overBounce;
  } else {
   backoff /= overBounce;
  }
 }

 *this -= backoff * normal;
}

inline bool idVec3::ProjectAlongPlane( const idVec3 &normal, const float epsilon, const float overBounce ) {
 idVec3 cross;
 float len;

 cross = this->Cross( normal ).Cross( (*this) );

 cross.Normalize();
 len = normal * cross;
 if ( idMath::Fabs( len ) < epsilon ) {
  return false;
 }
 cross *= overBounce * ( normal * (*this) ) / len;
 (*this) -= cross;
 return true;
}
# 808 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Vector.h"
class idVec4 {
public:
 float x;
 float y;
 float z;
 float w;

     idVec4( void );
     explicit idVec4( const float x, const float y, const float z, const float w );

 void Set( const float x, const float y, const float z, const float w );
 void Zero( void );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idVec4 operator-() const;
 float operator*( const idVec4 &a ) const;
 idVec4 operator*( const float a ) const;
 idVec4 operator/( const float a ) const;
 idVec4 operator+( const idVec4 &a ) const;
 idVec4 operator-( const idVec4 &a ) const;
 idVec4 & operator+=( const idVec4 &a );
 idVec4 & operator-=( const idVec4 &a );
 idVec4 & operator/=( const idVec4 &a );
 idVec4 & operator/=( const float a );
 idVec4 & operator*=( const float a );

 friend idVec4 operator*( const float a, const idVec4 b );

 bool Compare( const idVec4 &a ) const;
 bool Compare( const idVec4 &a, const float epsilon ) const;
 bool operator==( const idVec4 &a ) const;
 bool operator!=( const idVec4 &a ) const;

 float Length( void ) const;
 float LengthSqr( void ) const;
 float Normalize( void );
 float NormalizeFast( void );

 int GetDimension( void ) const;

 const idVec2 & ToVec2( void ) const;
 idVec2 & ToVec2( void );
 const idVec3 & ToVec3( void ) const;
 idVec3 & ToVec3( void );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void Lerp( const idVec4 &v1, const idVec4 &v2, const float l );
};

extern idVec4 vec4_origin;


inline idVec4::idVec4( void ) {
}

inline idVec4::idVec4( const float x, const float y, const float z, const float w ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->w = w;
}

inline void idVec4::Set( const float x, const float y, const float z, const float w ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->w = w;
}

inline void idVec4::Zero( void ) {
 x = y = z = w = 0.0f;
}

inline float idVec4::operator[]( int index ) const {
 return ( &x )[ index ];
}

inline float& idVec4::operator[]( int index ) {
 return ( &x )[ index ];
}

inline idVec4 idVec4::operator-() const {
 return idVec4( -x, -y, -z, -w );
}

inline idVec4 idVec4::operator-( const idVec4 &a ) const {
 return idVec4( x - a.x, y - a.y, z - a.z, w - a.w );
}

inline float idVec4::operator*( const idVec4 &a ) const {
 return x * a.x + y * a.y + z * a.z + w * a.w;
}

inline idVec4 idVec4::operator*( const float a ) const {
 return idVec4( x * a, y * a, z * a, w * a );
}

inline idVec4 idVec4::operator/( const float a ) const {
 float inva = 1.0f / a;
 return idVec4( x * inva, y * inva, z * inva, w * inva );
}

inline idVec4 operator*( const float a, const idVec4 b ) {
 return idVec4( b.x * a, b.y * a, b.z * a, b.w * a );
}

inline idVec4 idVec4::operator+( const idVec4 &a ) const {
 return idVec4( x + a.x, y + a.y, z + a.z, w + a.w );
}

inline idVec4 &idVec4::operator+=( const idVec4 &a ) {
 x += a.x;
 y += a.y;
 z += a.z;
 w += a.w;

 return *this;
}

inline idVec4 &idVec4::operator/=( const idVec4 &a ) {
 x /= a.x;
 y /= a.y;
 z /= a.z;
 w /= a.w;

 return *this;
}

inline idVec4 &idVec4::operator/=( const float a ) {
 float inva = 1.0f / a;
 x *= inva;
 y *= inva;
 z *= inva;
 w *= inva;

 return *this;
}

inline idVec4 &idVec4::operator-=( const idVec4 &a ) {
 x -= a.x;
 y -= a.y;
 z -= a.z;
 w -= a.w;

 return *this;
}

inline idVec4 &idVec4::operator*=( const float a ) {
 x *= a;
 y *= a;
 z *= a;
 w *= a;

 return *this;
}

inline bool idVec4::Compare( const idVec4 &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) && ( z == a.z ) && w == a.w );
}

inline bool idVec4::Compare( const idVec4 &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( z - a.z ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( w - a.w ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idVec4::operator==( const idVec4 &a ) const {
 return Compare( a );
}

inline bool idVec4::operator!=( const idVec4 &a ) const {
 return !Compare( a );
}

inline float idVec4::Length( void ) const {
 return ( float )idMath::Sqrt( x * x + y * y + z * z + w * w );
}

inline float idVec4::LengthSqr( void ) const {
 return ( x * x + y * y + z * z + w * w );
}

inline float idVec4::Normalize( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y + z * z + w * w;
 invLength = idMath::InvSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 z *= invLength;
 w *= invLength;
 return invLength * sqrLength;
}

inline float idVec4::NormalizeFast( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y + z * z + w * w;
 invLength = idMath::RSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 z *= invLength;
 w *= invLength;
 return invLength * sqrLength;
}

inline int idVec4::GetDimension( void ) const {
 return 4;
}

inline const idVec2 &idVec4::ToVec2( void ) const {
 return *reinterpret_cast<const idVec2 *>(this);
}

inline idVec2 &idVec4::ToVec2( void ) {
 return *reinterpret_cast<idVec2 *>(this);
}

inline const idVec3 &idVec4::ToVec3( void ) const {
 return *reinterpret_cast<const idVec3 *>(this);
}

inline idVec3 &idVec4::ToVec3( void ) {
 return *reinterpret_cast<idVec3 *>(this);
}

inline const float *idVec4::ToFloatPtr( void ) const {
 return &x;
}

inline float *idVec4::ToFloatPtr( void ) {
 return &x;
}
# 1066 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Vector.h"
class idVec5 {
public:
 float x;
 float y;
 float z;
 float s;
 float t;

     idVec5( void );
     explicit idVec5( const idVec3 &xyz, const idVec2 &st );
     explicit idVec5( const float x, const float y, const float z, const float s, const float t );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idVec5 & operator=( const idVec3 &a );

 int GetDimension( void ) const;

 const idVec3 & ToVec3( void ) const;
 idVec3 & ToVec3( void );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void Lerp( const idVec5 &v1, const idVec5 &v2, const float l );
};

extern idVec5 vec5_origin;


inline idVec5::idVec5( void ) {
}

inline idVec5::idVec5( const idVec3 &xyz, const idVec2 &st ) {
 x = xyz.x;
 y = xyz.y;
 z = xyz.z;
 s = st[0];
 t = st[1];
}

inline idVec5::idVec5( const float x, const float y, const float z, const float s, const float t ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->s = s;
 this->t = t;
}

inline float idVec5::operator[]( int index ) const {
 return ( &x )[ index ];
}

inline float& idVec5::operator[]( int index ) {
 return ( &x )[ index ];
}

inline idVec5 &idVec5::operator=( const idVec3 &a ) {
 x = a.x;
 y = a.y;
 z = a.z;
 s = t = 0;
 return *this;
}

inline int idVec5::GetDimension( void ) const {
 return 5;
}

inline const idVec3 &idVec5::ToVec3( void ) const {
 return *reinterpret_cast<const idVec3 *>(this);
}

inline idVec3 &idVec5::ToVec3( void ) {
 return *reinterpret_cast<idVec3 *>(this);
}

inline const float *idVec5::ToFloatPtr( void ) const {
 return &x;
}

inline float *idVec5::ToFloatPtr( void ) {
 return &x;
}
# 1158 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Vector.h"
class idVec6 {
public:
     idVec6( void );
     explicit idVec6( const float *a );
     explicit idVec6( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 );

 void Set( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 );
 void Zero( void );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idVec6 operator-() const;
 idVec6 operator*( const float a ) const;
 idVec6 operator/( const float a ) const;
 float operator*( const idVec6 &a ) const;
 idVec6 operator-( const idVec6 &a ) const;
 idVec6 operator+( const idVec6 &a ) const;
 idVec6 & operator*=( const float a );
 idVec6 & operator/=( const float a );
 idVec6 & operator+=( const idVec6 &a );
 idVec6 & operator-=( const idVec6 &a );

 friend idVec6 operator*( const float a, const idVec6 b );

 bool Compare( const idVec6 &a ) const;
 bool Compare( const idVec6 &a, const float epsilon ) const;
 bool operator==( const idVec6 &a ) const;
 bool operator!=( const idVec6 &a ) const;

 float Length( void ) const;
 float LengthSqr( void ) const;
 float Normalize( void );
 float NormalizeFast( void );

 int GetDimension( void ) const;

 const idVec3 & SubVec3( int index ) const;
 idVec3 & SubVec3( int index );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 float p[6];
};

extern idVec6 vec6_origin;

extern idVec6 vec6_infinity;

inline idVec6::idVec6( void ) {
}

inline idVec6::idVec6( const float *a ) {
 memcpy( p, a, 6 * sizeof( float ) );
}

inline idVec6::idVec6( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 ) {
 p[0] = a1;
 p[1] = a2;
 p[2] = a3;
 p[3] = a4;
 p[4] = a5;
 p[5] = a6;
}

inline idVec6 idVec6::operator-() const {
 return idVec6( -p[0], -p[1], -p[2], -p[3], -p[4], -p[5] );
}

inline float idVec6::operator[]( const int index ) const {
 return p[index];
}

inline float &idVec6::operator[]( const int index ) {
 return p[index];
}

inline idVec6 idVec6::operator*( const float a ) const {
 return idVec6( p[0]*a, p[1]*a, p[2]*a, p[3]*a, p[4]*a, p[5]*a );
}

inline float idVec6::operator*( const idVec6 &a ) const {
 return p[0] * a[0] + p[1] * a[1] + p[2] * a[2] + p[3] * a[3] + p[4] * a[4] + p[5] * a[5];
}

inline idVec6 idVec6::operator/( const float a ) const {
 float inva;

 ((void)0);
 inva = 1.0f / a;
 return idVec6( p[0]*inva, p[1]*inva, p[2]*inva, p[3]*inva, p[4]*inva, p[5]*inva );
}

inline idVec6 idVec6::operator+( const idVec6 &a ) const {
 return idVec6( p[0] + a[0], p[1] + a[1], p[2] + a[2], p[3] + a[3], p[4] + a[4], p[5] + a[5] );
}

inline idVec6 idVec6::operator-( const idVec6 &a ) const {
 return idVec6( p[0] - a[0], p[1] - a[1], p[2] - a[2], p[3] - a[3], p[4] - a[4], p[5] - a[5] );
}

inline idVec6 &idVec6::operator*=( const float a ) {
 p[0] *= a;
 p[1] *= a;
 p[2] *= a;
 p[3] *= a;
 p[4] *= a;
 p[5] *= a;
 return *this;
}

inline idVec6 &idVec6::operator/=( const float a ) {
 float inva;

 ((void)0);
 inva = 1.0f / a;
 p[0] *= inva;
 p[1] *= inva;
 p[2] *= inva;
 p[3] *= inva;
 p[4] *= inva;
 p[5] *= inva;
 return *this;
}

inline idVec6 &idVec6::operator+=( const idVec6 &a ) {
 p[0] += a[0];
 p[1] += a[1];
 p[2] += a[2];
 p[3] += a[3];
 p[4] += a[4];
 p[5] += a[5];
 return *this;
}

inline idVec6 &idVec6::operator-=( const idVec6 &a ) {
 p[0] -= a[0];
 p[1] -= a[1];
 p[2] -= a[2];
 p[3] -= a[3];
 p[4] -= a[4];
 p[5] -= a[5];
 return *this;
}

inline idVec6 operator*( const float a, const idVec6 b ) {
 return b * a;
}

inline bool idVec6::Compare( const idVec6 &a ) const {
 return ( ( p[0] == a[0] ) && ( p[1] == a[1] ) && ( p[2] == a[2] ) &&
   ( p[3] == a[3] ) && ( p[4] == a[4] ) && ( p[5] == a[5] ) );
}

inline bool idVec6::Compare( const idVec6 &a, const float epsilon ) const {
 if ( idMath::Fabs( p[0] - a[0] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[1] - a[1] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[2] - a[2] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[3] - a[3] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[4] - a[4] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[5] - a[5] ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idVec6::operator==( const idVec6 &a ) const {
 return Compare( a );
}

inline bool idVec6::operator!=( const idVec6 &a ) const {
 return !Compare( a );
}

inline void idVec6::Set( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 ) {
 p[0] = a1;
 p[1] = a2;
 p[2] = a3;
 p[3] = a4;
 p[4] = a5;
 p[5] = a6;
}

inline void idVec6::Zero( void ) {
 p[0] = p[1] = p[2] = p[3] = p[4] = p[5] = 0.0f;
}

inline float idVec6::Length( void ) const {
 return ( float )idMath::Sqrt( p[0] * p[0] + p[1] * p[1] + p[2] * p[2] + p[3] * p[3] + p[4] * p[4] + p[5] * p[5] );
}

inline float idVec6::LengthSqr( void ) const {
 return ( p[0] * p[0] + p[1] * p[1] + p[2] * p[2] + p[3] * p[3] + p[4] * p[4] + p[5] * p[5] );
}

inline float idVec6::Normalize( void ) {
 float sqrLength, invLength;

 sqrLength = p[0] * p[0] + p[1] * p[1] + p[2] * p[2] + p[3] * p[3] + p[4] * p[4] + p[5] * p[5];
 invLength = idMath::InvSqrt( sqrLength );
 p[0] *= invLength;
 p[1] *= invLength;
 p[2] *= invLength;
 p[3] *= invLength;
 p[4] *= invLength;
 p[5] *= invLength;
 return invLength * sqrLength;
}

inline float idVec6::NormalizeFast( void ) {
 float sqrLength, invLength;

 sqrLength = p[0] * p[0] + p[1] * p[1] + p[2] * p[2] + p[3] * p[3] + p[4] * p[4] + p[5] * p[5];
 invLength = idMath::RSqrt( sqrLength );
 p[0] *= invLength;
 p[1] *= invLength;
 p[2] *= invLength;
 p[3] *= invLength;
 p[4] *= invLength;
 p[5] *= invLength;
 return invLength * sqrLength;
}

inline int idVec6::GetDimension( void ) const {
 return 6;
}

inline const idVec3 &idVec6::SubVec3( int index ) const {
 return *reinterpret_cast<const idVec3 *>(p + index * 3);
}

inline idVec3 &idVec6::SubVec3( int index ) {
 return *reinterpret_cast<idVec3 *>(p + index * 3);
}

inline const float *idVec6::ToFloatPtr( void ) const {
 return p;
}

inline float *idVec6::ToFloatPtr( void ) {
 return p;
}
# 1435 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Vector.h"
class idVecX {
 friend class idMatX;

public:
     idVecX( void );
     explicit idVecX( int length );
     explicit idVecX( int length, float *data );
     ~idVecX( void );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idVecX operator-() const;
 idVecX & operator=( const idVecX &a );
 idVecX operator*( const float a ) const;
 idVecX operator/( const float a ) const;
 float operator*( const idVecX &a ) const;
 idVecX operator-( const idVecX &a ) const;
 idVecX operator+( const idVecX &a ) const;
 idVecX & operator*=( const float a );
 idVecX & operator/=( const float a );
 idVecX & operator+=( const idVecX &a );
 idVecX & operator-=( const idVecX &a );

 friend idVecX operator*( const float a, const idVecX b );

 bool Compare( const idVecX &a ) const;
 bool Compare( const idVecX &a, const float epsilon ) const;
 bool operator==( const idVecX &a ) const;
 bool operator!=( const idVecX &a ) const;

 void SetSize( int size );
 void ChangeSize( int size, bool makeZero = false );
 int GetSize( void ) const { return size; }
 void SetData( int length, float *data );
 void Zero( void );
 void Zero( int length );
 void Random( int seed, float l = 0.0f, float u = 1.0f );
 void Random( int length, int seed, float l = 0.0f, float u = 1.0f );
 void Negate( void );
 void Clamp( float min, float max );
 idVecX & SwapElements( int e1, int e2 );

 float Length( void ) const;
 float LengthSqr( void ) const;
 idVecX Normalize( void ) const;
 float NormalizeSelf( void );

 int GetDimension( void ) const;

 const idVec3 & SubVec3( int index ) const;
 idVec3 & SubVec3( int index );
 const idVec6 & SubVec6( int index ) const;
 idVec6 & SubVec6( int index );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 int size;
 int alloced;
 float * p;

 static float temp[1024 +4];
 static float * tempPtr;
 static int tempIndex;

private:
 void SetTempSize( int size );
};


inline idVecX::idVecX( void ) {
 size = alloced = 0;
 p = __null;
}

inline idVecX::idVecX( int length ) {
 size = alloced = 0;
 p = __null;
 SetSize( length );
}

inline idVecX::idVecX( int length, float *data ) {
 size = alloced = 0;
 p = __null;
 SetData( length, data );
}

inline idVecX::~idVecX( void ) {

 if ( p && ( p < idVecX::tempPtr || p >= idVecX::tempPtr + 1024 ) && alloced != -1 ) {
  Mem_Free16( p );
 }
}

inline float idVecX::operator[]( const int index ) const {
 ((void)0);
 return p[index];
}

inline float &idVecX::operator[]( const int index ) {
 ((void)0);
 return p[index];
}

inline idVecX idVecX::operator-() const {
 int i;
 idVecX m;

 m.SetTempSize( size );
 for ( i = 0; i < size; i++ ) {
  m.p[i] = -p[i];
 }
 return m;
}

inline idVecX &idVecX::operator=( const idVecX &a ) {
 SetSize( a.size );

 SIMDProcessor->Copy16( p, a.p, a.size );



 idVecX::tempIndex = 0;
 return *this;
}

inline idVecX idVecX::operator+( const idVecX &a ) const {
 idVecX m;

 ((void)0);
 m.SetTempSize( size );

 SIMDProcessor->Add16( m.p, p, a.p, size );






 return m;
}

inline idVecX idVecX::operator-( const idVecX &a ) const {
 idVecX m;

 ((void)0);
 m.SetTempSize( size );

 SIMDProcessor->Sub16( m.p, p, a.p, size );






 return m;
}

inline idVecX &idVecX::operator+=( const idVecX &a ) {
 ((void)0);

 SIMDProcessor->AddAssign16( p, a.p, size );






 idVecX::tempIndex = 0;
 return *this;
}

inline idVecX &idVecX::operator-=( const idVecX &a ) {
 ((void)0);

 SIMDProcessor->SubAssign16( p, a.p, size );






 idVecX::tempIndex = 0;
 return *this;
}

inline idVecX idVecX::operator*( const float a ) const {
 idVecX m;

 m.SetTempSize( size );

 SIMDProcessor->Mul16( m.p, p, a, size );






 return m;
}

inline idVecX &idVecX::operator*=( const float a ) {

 SIMDProcessor->MulAssign16( p, a, size );






 return *this;
}

inline idVecX idVecX::operator/( const float a ) const {
 ((void)0);
 return (*this) * ( 1.0f / a );
}

inline idVecX &idVecX::operator/=( const float a ) {
 ((void)0);
 (*this) *= ( 1.0f / a );
 return *this;
}

inline idVecX operator*( const float a, const idVecX b ) {
 return b * a;
}

inline float idVecX::operator*( const idVecX &a ) const {
 int i;
 float sum = 0.0f;

 ((void)0);
 for ( i = 0; i < size; i++ ) {
  sum += p[i] * a.p[i];
 }
 return sum;
}

inline bool idVecX::Compare( const idVecX &a ) const {
 int i;

 ((void)0);
 for ( i = 0; i < size; i++ ) {
  if ( p[i] != a.p[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idVecX::Compare( const idVecX &a, const float epsilon ) const {
 int i;

 ((void)0);
 for ( i = 0; i < size; i++ ) {
  if ( idMath::Fabs( p[i] - a.p[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idVecX::operator==( const idVecX &a ) const {
 return Compare( a );
}

inline bool idVecX::operator!=( const idVecX &a ) const {
 return !Compare( a );
}

inline void idVecX::SetSize( int newSize ) {
 int alloc = ( newSize + 3 ) & ~3;
 if ( alloc > alloced && alloced != -1 ) {
  if ( p ) {
   Mem_Free16( p );
  }
  p = (float *) Mem_Alloc16( alloc * sizeof( float ) );
  alloced = alloc;
 }
 size = newSize;
 int s = size; while( s < ( ( s + 3) & ~3 ) ) { p[s++] = 0.0f; };
}

inline void idVecX::ChangeSize( int newSize, bool makeZero ) {
 int alloc = ( newSize + 3 ) & ~3;
 if ( alloc > alloced && alloced != -1 ) {
  float *oldVec = p;
  p = (float *) Mem_Alloc16( alloc * sizeof( float ) );
  alloced = alloc;
  if ( oldVec ) {
   for ( int i = 0; i < size; i++ ) {
    p[i] = oldVec[i];
   }
   Mem_Free16( oldVec );
  }
  if ( makeZero ) {

   for ( int i = size; i < newSize; i++ ) {
    p[i] = 0.0f;
   }
  }
 }
 size = newSize;
 int s = size; while( s < ( ( s + 3) & ~3 ) ) { p[s++] = 0.0f; };
}

inline void idVecX::SetTempSize( int newSize ) {

 size = newSize;
 alloced = ( newSize + 3 ) & ~3;
 ((void)0);
 if ( idVecX::tempIndex + alloced > 1024 ) {
  idVecX::tempIndex = 0;
 }
 p = idVecX::tempPtr + idVecX::tempIndex;
 idVecX::tempIndex += alloced;
 int s = size; while( s < ( ( s + 3) & ~3 ) ) { p[s++] = 0.0f; };
}

inline void idVecX::SetData( int length, float *data ) {
 if ( p && ( p < idVecX::tempPtr || p >= idVecX::tempPtr + 1024 ) && alloced != -1 ) {
  Mem_Free16( p );
 }
 ((void)0);
 p = data;
 size = length;
 alloced = -1;
 int s = size; while( s < ( ( s + 3) & ~3 ) ) { p[s++] = 0.0f; };
}

inline void idVecX::Zero( void ) {

 SIMDProcessor->Zero16( p, size );



}

inline void idVecX::Zero( int length ) {
 SetSize( length );

 SIMDProcessor->Zero16( p, length );



}

inline void idVecX::Random( int seed, float l, float u ) {
 int i;
 float c;
 idRandom rnd( seed );

 c = u - l;
 for ( i = 0; i < size; i++ ) {
  p[i] = l + rnd.RandomFloat() * c;
 }
}

inline void idVecX::Random( int length, int seed, float l, float u ) {
 int i;
 float c;
 idRandom rnd( seed );

 SetSize( length );
 c = u - l;
 for ( i = 0; i < size; i++ ) {
  p[i] = l + rnd.RandomFloat() * c;
 }
}

inline void idVecX::Negate( void ) {

 SIMDProcessor->Negate16( p, size );






}

inline void idVecX::Clamp( float min, float max ) {
 int i;
 for ( i = 0; i < size; i++ ) {
  if ( p[i] < min ) {
   p[i] = min;
  } else if ( p[i] > max ) {
   p[i] = max;
  }
 }
}

inline idVecX &idVecX::SwapElements( int e1, int e2 ) {
 float tmp;
 tmp = p[e1];
 p[e1] = p[e2];
 p[e2] = tmp;
 return *this;
}

inline float idVecX::Length( void ) const {
 int i;
 float sum = 0.0f;

 for ( i = 0; i < size; i++ ) {
  sum += p[i] * p[i];
 }
 return idMath::Sqrt( sum );
}

inline float idVecX::LengthSqr( void ) const {
 int i;
 float sum = 0.0f;

 for ( i = 0; i < size; i++ ) {
  sum += p[i] * p[i];
 }
 return sum;
}

inline idVecX idVecX::Normalize( void ) const {
 int i;
 idVecX m;
 float invSqrt, sum = 0.0f;

 m.SetTempSize( size );
 for ( i = 0; i < size; i++ ) {
  sum += p[i] * p[i];
 }
 invSqrt = idMath::InvSqrt( sum );
 for ( i = 0; i < size; i++ ) {
  m.p[i] = p[i] * invSqrt;
 }
 return m;
}

inline float idVecX::NormalizeSelf( void ) {
 float invSqrt, sum = 0.0f;
 int i;
 for ( i = 0; i < size; i++ ) {
  sum += p[i] * p[i];
 }
 invSqrt = idMath::InvSqrt( sum );
 for ( i = 0; i < size; i++ ) {
  p[i] *= invSqrt;
 }
 return invSqrt * sum;
}

inline int idVecX::GetDimension( void ) const {
 return size;
}

inline idVec3 &idVecX::SubVec3( int index ) {
 ((void)0);
 return *reinterpret_cast<idVec3 *>(p + index * 3);
}

inline const idVec3 &idVecX::SubVec3( int index ) const {
 ((void)0);
 return *reinterpret_cast<const idVec3 *>(p + index * 3);
}

inline idVec6 &idVecX::SubVec6( int index ) {
 ((void)0);
 return *reinterpret_cast<idVec6 *>(p + index * 6);
}

inline const idVec6 &idVecX::SubVec6( int index ) const {
 ((void)0);
 return *reinterpret_cast<const idVec6 *>(p + index * 6);
}

inline const float *idVecX::ToFloatPtr( void ) const {
 return p;
}

inline float *idVecX::ToFloatPtr( void ) {
 return p;
}
# 1925 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Vector.h"
class idPolar3 {
public:
 float radius, theta, phi;

     idPolar3( void );
     explicit idPolar3( const float radius, const float theta, const float phi );

 void Set( const float radius, const float theta, const float phi );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idPolar3 operator-() const;
 idPolar3 & operator=( const idPolar3 &a );

 idVec3 ToVec3( void ) const;
};

inline idPolar3::idPolar3( void ) {
}

inline idPolar3::idPolar3( const float radius, const float theta, const float phi ) {
 ((void)0);
 this->radius = radius;
 this->theta = theta;
 this->phi = phi;
}

inline void idPolar3::Set( const float radius, const float theta, const float phi ) {
 ((void)0);
 this->radius = radius;
 this->theta = theta;
 this->phi = phi;
}

inline float idPolar3::operator[]( const int index ) const {
 return ( &radius )[ index ];
}

inline float &idPolar3::operator[]( const int index ) {
 return ( &radius )[ index ];
}

inline idPolar3 idPolar3::operator-() const {
 return idPolar3( radius, -theta, -phi );
}

inline idPolar3 &idPolar3::operator=( const idPolar3 &a ) {
 radius = a.radius;
 theta = a.theta;
 phi = a.phi;
 return *this;
}

inline idVec3 idPolar3::ToVec3( void ) const {
 float sp, cp, st, ct;
 idMath::SinCos( phi, sp, cp );
 idMath::SinCos( theta, st, ct );
  return idVec3( cp * radius * ct, cp * radius * st, radius * sp );
}
# 179 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
class idAngles;
class idQuat;
class idCQuat;
class idRotation;
class idMat4;







class idMat2 {
public:
     idMat2( void );
     explicit idMat2( const idVec2 &x, const idVec2 &y );
     explicit idMat2( const float xx, const float xy, const float yx, const float yy );
     explicit idMat2( const float src[ 2 ][ 2 ] );

 const idVec2 & operator[]( int index ) const;
 idVec2 & operator[]( int index );
 idMat2 operator-() const;
 idMat2 operator*( const float a ) const;
 idVec2 operator*( const idVec2 &vec ) const;
 idMat2 operator*( const idMat2 &a ) const;
 idMat2 operator+( const idMat2 &a ) const;
 idMat2 operator-( const idMat2 &a ) const;
 idMat2 & operator*=( const float a );
 idMat2 & operator*=( const idMat2 &a );
 idMat2 & operator+=( const idMat2 &a );
 idMat2 & operator-=( const idMat2 &a );

 friend idMat2 operator*( const float a, const idMat2 &mat );
 friend idVec2 operator*( const idVec2 &vec, const idMat2 &mat );
 friend idVec2 & operator*=( idVec2 &vec, const idMat2 &mat );

 bool Compare( const idMat2 &a ) const;
 bool Compare( const idMat2 &a, const float epsilon ) const;
 bool operator==( const idMat2 &a ) const;
 bool operator!=( const idMat2 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;

 float Trace( void ) const;
 float Determinant( void ) const;
 idMat2 Transpose( void ) const;
 idMat2 & TransposeSelf( void );
 idMat2 Inverse( void ) const;
 bool InverseSelf( void );
 idMat2 InverseFast( void ) const;
 bool InverseFastSelf( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 idVec2 mat[ 2 ];
};

extern idMat2 mat2_zero;
extern idMat2 mat2_identity;


inline idMat2::idMat2( void ) {
}

inline idMat2::idMat2( const idVec2 &x, const idVec2 &y ) {
 mat[ 0 ].x = x.x; mat[ 0 ].y = x.y;
 mat[ 1 ].x = y.x; mat[ 1 ].y = y.y;
}

inline idMat2::idMat2( const float xx, const float xy, const float yx, const float yy ) {
 mat[ 0 ].x = xx; mat[ 0 ].y = xy;
 mat[ 1 ].x = yx; mat[ 1 ].y = yy;
}

inline idMat2::idMat2( const float src[ 2 ][ 2 ] ) {
 memcpy( mat, src, 2 * 2 * sizeof( float ) );
}

inline const idVec2 &idMat2::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec2 &idMat2::operator[]( int index ) {

 return mat[ index ];
}

inline idMat2 idMat2::operator-() const {
 return idMat2( -mat[0][0], -mat[0][1],
     -mat[1][0], -mat[1][1] );
}

inline idVec2 idMat2::operator*( const idVec2 &vec ) const {
 return idVec2(
  mat[ 0 ].x * vec.x + mat[ 0 ].y * vec.y,
  mat[ 1 ].x * vec.x + mat[ 1 ].y * vec.y );
}

inline idMat2 idMat2::operator*( const idMat2 &a ) const {
 return idMat2(
  mat[0].x * a[0].x + mat[0].y * a[1].x,
  mat[0].x * a[0].y + mat[0].y * a[1].y,
  mat[1].x * a[0].x + mat[1].y * a[1].x,
  mat[1].x * a[0].y + mat[1].y * a[1].y );
}

inline idMat2 idMat2::operator*( const float a ) const {
 return idMat2(
  mat[0].x * a, mat[0].y * a,
  mat[1].x * a, mat[1].y * a );
}

inline idMat2 idMat2::operator+( const idMat2 &a ) const {
 return idMat2(
  mat[0].x + a[0].x, mat[0].y + a[0].y,
  mat[1].x + a[1].x, mat[1].y + a[1].y );
}

inline idMat2 idMat2::operator-( const idMat2 &a ) const {
 return idMat2(
  mat[0].x - a[0].x, mat[0].y - a[0].y,
  mat[1].x - a[1].x, mat[1].y - a[1].y );
}

inline idMat2 &idMat2::operator*=( const float a ) {
 mat[0].x *= a; mat[0].y *= a;
 mat[1].x *= a; mat[1].y *= a;

    return *this;
}

inline idMat2 &idMat2::operator*=( const idMat2 &a ) {
 float x, y;
 x = mat[0].x; y = mat[0].y;
 mat[0].x = x * a[0].x + y * a[1].x;
 mat[0].y = x * a[0].y + y * a[1].y;
 x = mat[1].x; y = mat[1].y;
 mat[1].x = x * a[0].x + y * a[1].x;
 mat[1].y = x * a[0].y + y * a[1].y;
 return *this;
}

inline idMat2 &idMat2::operator+=( const idMat2 &a ) {
 mat[0].x += a[0].x; mat[0].y += a[0].y;
 mat[1].x += a[1].x; mat[1].y += a[1].y;

    return *this;
}

inline idMat2 &idMat2::operator-=( const idMat2 &a ) {
 mat[0].x -= a[0].x; mat[0].y -= a[0].y;
 mat[1].x -= a[1].x; mat[1].y -= a[1].y;

    return *this;
}

inline idVec2 operator*( const idVec2 &vec, const idMat2 &mat ) {
 return mat * vec;
}

inline idMat2 operator*( const float a, idMat2 const &mat ) {
 return mat * a;
}

inline idVec2 &operator*=( idVec2 &vec, const idMat2 &mat ) {
 vec = mat * vec;
 return vec;
}

inline bool idMat2::Compare( const idMat2 &a ) const {
 if ( mat[0].Compare( a[0] ) &&
  mat[1].Compare( a[1] ) ) {
  return true;
 }
 return false;
}

inline bool idMat2::Compare( const idMat2 &a, const float epsilon ) const {
 if ( mat[0].Compare( a[0], epsilon ) &&
  mat[1].Compare( a[1], epsilon ) ) {
  return true;
 }
 return false;
}

inline bool idMat2::operator==( const idMat2 &a ) const {
 return Compare( a );
}

inline bool idMat2::operator!=( const idMat2 &a ) const {
 return !Compare( a );
}

inline void idMat2::Zero( void ) {
 mat[0].Zero();
 mat[1].Zero();
}

inline void idMat2::Identity( void ) {
 *this = mat2_identity;
}

inline bool idMat2::IsIdentity( const float epsilon ) const {
 return Compare( mat2_identity, epsilon );
}

inline bool idMat2::IsSymmetric( const float epsilon ) const {
 return ( idMath::Fabs( mat[0][1] - mat[1][0] ) < epsilon );
}

inline bool idMat2::IsDiagonal( const float epsilon ) const {
 if ( idMath::Fabs( mat[0][1] ) > epsilon ||
  idMath::Fabs( mat[1][0] ) > epsilon ) {
  return false;
 }
 return true;
}

inline float idMat2::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] );
}

inline float idMat2::Determinant( void ) const {
 return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
}

inline idMat2 idMat2::Transpose( void ) const {
 return idMat2( mat[0][0], mat[1][0],
     mat[0][1], mat[1][1] );
}

inline idMat2 &idMat2::TransposeSelf( void ) {
 float tmp;

 tmp = mat[0][1];
 mat[0][1] = mat[1][0];
 mat[1][0] = tmp;

 return *this;
}

inline idMat2 idMat2::Inverse( void ) const {
 idMat2 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat2 idMat2::InverseFast( void ) const {
 idMat2 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline int idMat2::GetDimension( void ) const {
 return 4;
}

inline const float *idMat2::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat2::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 333 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
class idMat3 {
public:
     idMat3( void );
     explicit idMat3( const idVec3 &x, const idVec3 &y, const idVec3 &z );
     explicit idMat3( const float xx, const float xy, const float xz, const float yx, const float yy, const float yz, const float zx, const float zy, const float zz );
     explicit idMat3( const float src[ 3 ][ 3 ] );

 const idVec3 & operator[]( int index ) const;
 idVec3 & operator[]( int index );
 idMat3 operator-() const;
 idMat3 operator*( const float a ) const;
 idVec3 operator*( const idVec3 &vec ) const;
 idMat3 operator*( const idMat3 &a ) const;
 idMat3 operator+( const idMat3 &a ) const;
 idMat3 operator-( const idMat3 &a ) const;
 idMat3 & operator*=( const float a );
 idMat3 & operator*=( const idMat3 &a );
 idMat3 & operator+=( const idMat3 &a );
 idMat3 & operator-=( const idMat3 &a );

 friend idMat3 operator*( const float a, const idMat3 &mat );
 friend idVec3 operator*( const idVec3 &vec, const idMat3 &mat );
 friend idVec3 & operator*=( idVec3 &vec, const idMat3 &mat );

 bool Compare( const idMat3 &a ) const;
 bool Compare( const idMat3 &a, const float epsilon ) const;
 bool operator==( const idMat3 &a ) const;
 bool operator!=( const idMat3 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;
 bool IsRotated( void ) const;

 void ProjectVector( const idVec3 &src, idVec3 &dst ) const;
 void UnprojectVector( const idVec3 &src, idVec3 &dst ) const;

 bool FixDegeneracies( void );
 bool FixDenormals( void );

 float Trace( void ) const;
 float Determinant( void ) const;
 idMat3 OrthoNormalize( void ) const;
 idMat3 & OrthoNormalizeSelf( void );
 idMat3 Transpose( void ) const;
 idMat3 & TransposeSelf( void );
 idMat3 Inverse( void ) const;
 bool InverseSelf( void );
 idMat3 InverseFast( void ) const;
 bool InverseFastSelf( void );
 idMat3 TransposeMultiply( const idMat3 &b ) const;

 idMat3 InertiaTranslate( const float mass, const idVec3 &centerOfMass, const idVec3 &translation ) const;
 idMat3 & InertiaTranslateSelf( const float mass, const idVec3 &centerOfMass, const idVec3 &translation );
 idMat3 InertiaRotate( const idMat3 &rotation ) const;
 idMat3 & InertiaRotateSelf( const idMat3 &rotation );

 int GetDimension( void ) const;

 idAngles ToAngles( void ) const;
 idQuat ToQuat( void ) const;
 idCQuat ToCQuat( void ) const;
 idRotation ToRotation( void ) const;
 idMat4 ToMat4( void ) const;
 idVec3 ToAngularVelocity( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 friend void TransposeMultiply( const idMat3 &inv, const idMat3 &b, idMat3 &dst );
 friend idMat3 SkewSymmetric( idVec3 const &src );

private:
 idVec3 mat[ 3 ];
};

extern idMat3 mat3_zero;
extern idMat3 mat3_identity;


inline idMat3::idMat3( void ) {
}

inline idMat3::idMat3( const idVec3 &x, const idVec3 &y, const idVec3 &z ) {
 mat[ 0 ].x = x.x; mat[ 0 ].y = x.y; mat[ 0 ].z = x.z;
 mat[ 1 ].x = y.x; mat[ 1 ].y = y.y; mat[ 1 ].z = y.z;
 mat[ 2 ].x = z.x; mat[ 2 ].y = z.y; mat[ 2 ].z = z.z;
}

inline idMat3::idMat3( const float xx, const float xy, const float xz, const float yx, const float yy, const float yz, const float zx, const float zy, const float zz ) {
 mat[ 0 ].x = xx; mat[ 0 ].y = xy; mat[ 0 ].z = xz;
 mat[ 1 ].x = yx; mat[ 1 ].y = yy; mat[ 1 ].z = yz;
 mat[ 2 ].x = zx; mat[ 2 ].y = zy; mat[ 2 ].z = zz;
}

inline idMat3::idMat3( const float src[ 3 ][ 3 ] ) {
 memcpy( mat, src, 3 * 3 * sizeof( float ) );
}

inline const idVec3 &idMat3::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec3 &idMat3::operator[]( int index ) {

 return mat[ index ];
}

inline idMat3 idMat3::operator-() const {
 return idMat3( -mat[0][0], -mat[0][1], -mat[0][2],
     -mat[1][0], -mat[1][1], -mat[1][2],
     -mat[2][0], -mat[2][1], -mat[2][2] );
}

inline idVec3 idMat3::operator*( const idVec3 &vec ) const {
 return idVec3(
  mat[ 0 ].x * vec.x + mat[ 1 ].x * vec.y + mat[ 2 ].x * vec.z,
  mat[ 0 ].y * vec.x + mat[ 1 ].y * vec.y + mat[ 2 ].y * vec.z,
  mat[ 0 ].z * vec.x + mat[ 1 ].z * vec.y + mat[ 2 ].z * vec.z );
}

inline idMat3 idMat3::operator*( const idMat3 &a ) const {
 int i, j;
 const float *m1Ptr, *m2Ptr;
 float *dstPtr;
 idMat3 dst;

 m1Ptr = reinterpret_cast<const float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);
 dstPtr = reinterpret_cast<float *>(&dst);

 for ( i = 0; i < 3; i++ ) {
  for ( j = 0; j < 3; j++ ) {
   *dstPtr = m1Ptr[0] * m2Ptr[ 0 * 3 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 3 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 3 + j ];
   dstPtr++;
  }
  m1Ptr += 3;
 }
 return dst;
}

inline idMat3 idMat3::operator*( const float a ) const {
 return idMat3(
  mat[0].x * a, mat[0].y * a, mat[0].z * a,
  mat[1].x * a, mat[1].y * a, mat[1].z * a,
  mat[2].x * a, mat[2].y * a, mat[2].z * a );
}

inline idMat3 idMat3::operator+( const idMat3 &a ) const {
 return idMat3(
  mat[0].x + a[0].x, mat[0].y + a[0].y, mat[0].z + a[0].z,
  mat[1].x + a[1].x, mat[1].y + a[1].y, mat[1].z + a[1].z,
  mat[2].x + a[2].x, mat[2].y + a[2].y, mat[2].z + a[2].z );
}

inline idMat3 idMat3::operator-( const idMat3 &a ) const {
 return idMat3(
  mat[0].x - a[0].x, mat[0].y - a[0].y, mat[0].z - a[0].z,
  mat[1].x - a[1].x, mat[1].y - a[1].y, mat[1].z - a[1].z,
  mat[2].x - a[2].x, mat[2].y - a[2].y, mat[2].z - a[2].z );
}

inline idMat3 &idMat3::operator*=( const float a ) {
 mat[0].x *= a; mat[0].y *= a; mat[0].z *= a;
 mat[1].x *= a; mat[1].y *= a; mat[1].z *= a;
 mat[2].x *= a; mat[2].y *= a; mat[2].z *= a;

    return *this;
}

inline idMat3 &idMat3::operator*=( const idMat3 &a ) {
 int i, j;
 const float *m2Ptr;
 float *m1Ptr, dst[3];

 m1Ptr = reinterpret_cast<float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);

 for ( i = 0; i < 3; i++ ) {
  for ( j = 0; j < 3; j++ ) {
   dst[j] = m1Ptr[0] * m2Ptr[ 0 * 3 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 3 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 3 + j ];
  }
  m1Ptr[0] = dst[0]; m1Ptr[1] = dst[1]; m1Ptr[2] = dst[2];
  m1Ptr += 3;
 }
 return *this;
}

inline idMat3 &idMat3::operator+=( const idMat3 &a ) {
 mat[0].x += a[0].x; mat[0].y += a[0].y; mat[0].z += a[0].z;
 mat[1].x += a[1].x; mat[1].y += a[1].y; mat[1].z += a[1].z;
 mat[2].x += a[2].x; mat[2].y += a[2].y; mat[2].z += a[2].z;

    return *this;
}

inline idMat3 &idMat3::operator-=( const idMat3 &a ) {
 mat[0].x -= a[0].x; mat[0].y -= a[0].y; mat[0].z -= a[0].z;
 mat[1].x -= a[1].x; mat[1].y -= a[1].y; mat[1].z -= a[1].z;
 mat[2].x -= a[2].x; mat[2].y -= a[2].y; mat[2].z -= a[2].z;

    return *this;
}

inline idVec3 operator*( const idVec3 &vec, const idMat3 &mat ) {
 return mat * vec;
}

inline idMat3 operator*( const float a, const idMat3 &mat ) {
 return mat * a;
}

inline idVec3 &operator*=( idVec3 &vec, const idMat3 &mat ) {
 float x = mat[ 0 ].x * vec.x + mat[ 1 ].x * vec.y + mat[ 2 ].x * vec.z;
 float y = mat[ 0 ].y * vec.x + mat[ 1 ].y * vec.y + mat[ 2 ].y * vec.z;
 vec.z = mat[ 0 ].z * vec.x + mat[ 1 ].z * vec.y + mat[ 2 ].z * vec.z;
 vec.x = x;
 vec.y = y;
 return vec;
}

inline bool idMat3::Compare( const idMat3 &a ) const {
 if ( mat[0].Compare( a[0] ) &&
  mat[1].Compare( a[1] ) &&
  mat[2].Compare( a[2] ) ) {
  return true;
 }
 return false;
}

inline bool idMat3::Compare( const idMat3 &a, const float epsilon ) const {
 if ( mat[0].Compare( a[0], epsilon ) &&
  mat[1].Compare( a[1], epsilon ) &&
  mat[2].Compare( a[2], epsilon ) ) {
  return true;
 }
 return false;
}

inline bool idMat3::operator==( const idMat3 &a ) const {
 return Compare( a );
}

inline bool idMat3::operator!=( const idMat3 &a ) const {
 return !Compare( a );
}

inline void idMat3::Zero( void ) {
 memset( mat, 0, sizeof( idMat3 ) );
}

inline void idMat3::Identity( void ) {
 *this = mat3_identity;
}

inline bool idMat3::IsIdentity( const float epsilon ) const {
 return Compare( mat3_identity, epsilon );
}

inline bool idMat3::IsSymmetric( const float epsilon ) const {
 if ( idMath::Fabs( mat[0][1] - mat[1][0] ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( mat[0][2] - mat[2][0] ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( mat[1][2] - mat[2][1] ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idMat3::IsDiagonal( const float epsilon ) const {
 if ( idMath::Fabs( mat[0][1] ) > epsilon ||
  idMath::Fabs( mat[0][2] ) > epsilon ||
  idMath::Fabs( mat[1][0] ) > epsilon ||
  idMath::Fabs( mat[1][2] ) > epsilon ||
  idMath::Fabs( mat[2][0] ) > epsilon ||
  idMath::Fabs( mat[2][1] ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idMat3::IsRotated( void ) const {
 return !Compare( mat3_identity );
}

inline void idMat3::ProjectVector( const idVec3 &src, idVec3 &dst ) const {
 dst.x = src * mat[ 0 ];
 dst.y = src * mat[ 1 ];
 dst.z = src * mat[ 2 ];
}

inline void idMat3::UnprojectVector( const idVec3 &src, idVec3 &dst ) const {
 dst = mat[ 0 ] * src.x + mat[ 1 ] * src.y + mat[ 2 ] * src.z;
}

inline bool idMat3::FixDegeneracies( void ) {
 bool r = mat[0].FixDegenerateNormal();
 r |= mat[1].FixDegenerateNormal();
 r |= mat[2].FixDegenerateNormal();
 return r;
}

inline bool idMat3::FixDenormals( void ) {
 bool r = mat[0].FixDenormals();
 r |= mat[1].FixDenormals();
 r |= mat[2].FixDenormals();
 return r;
}

inline float idMat3::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] + mat[2][2] );
}

inline idMat3 idMat3::OrthoNormalize( void ) const {
 idMat3 ortho;

 ortho = *this;
 ortho[ 0 ].Normalize();
 ortho[ 2 ].Cross( mat[ 0 ], mat[ 1 ] );
 ortho[ 2 ].Normalize();
 ortho[ 1 ].Cross( mat[ 2 ], mat[ 0 ] );
 ortho[ 1 ].Normalize();
 return ortho;
}

inline idMat3 &idMat3::OrthoNormalizeSelf( void ) {
 mat[ 0 ].Normalize();
 mat[ 2 ].Cross( mat[ 0 ], mat[ 1 ] );
 mat[ 2 ].Normalize();
 mat[ 1 ].Cross( mat[ 2 ], mat[ 0 ] );
 mat[ 1 ].Normalize();
 return *this;
}

inline idMat3 idMat3::Transpose( void ) const {
 return idMat3( mat[0][0], mat[1][0], mat[2][0],
     mat[0][1], mat[1][1], mat[2][1],
     mat[0][2], mat[1][2], mat[2][2] );
}

inline idMat3 &idMat3::TransposeSelf( void ) {
 float tmp0, tmp1, tmp2;

 tmp0 = mat[0][1];
 mat[0][1] = mat[1][0];
 mat[1][0] = tmp0;
 tmp1 = mat[0][2];
 mat[0][2] = mat[2][0];
 mat[2][0] = tmp1;
 tmp2 = mat[1][2];
 mat[1][2] = mat[2][1];
 mat[2][1] = tmp2;

 return *this;
}

inline idMat3 idMat3::Inverse( void ) const {
 idMat3 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat3 idMat3::InverseFast( void ) const {
 idMat3 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline idMat3 idMat3::TransposeMultiply( const idMat3 &b ) const {
 return idMat3( mat[0].x * b[0].x + mat[1].x * b[1].x + mat[2].x * b[2].x,
     mat[0].x * b[0].y + mat[1].x * b[1].y + mat[2].x * b[2].y,
     mat[0].x * b[0].z + mat[1].x * b[1].z + mat[2].x * b[2].z,
     mat[0].y * b[0].x + mat[1].y * b[1].x + mat[2].y * b[2].x,
     mat[0].y * b[0].y + mat[1].y * b[1].y + mat[2].y * b[2].y,
     mat[0].y * b[0].z + mat[1].y * b[1].z + mat[2].y * b[2].z,
     mat[0].z * b[0].x + mat[1].z * b[1].x + mat[2].z * b[2].x,
     mat[0].z * b[0].y + mat[1].z * b[1].y + mat[2].z * b[2].y,
     mat[0].z * b[0].z + mat[1].z * b[1].z + mat[2].z * b[2].z );
}

inline void TransposeMultiply( const idMat3 &transpose, const idMat3 &b, idMat3 &dst ) {
 dst[0].x = transpose[0].x * b[0].x + transpose[1].x * b[1].x + transpose[2].x * b[2].x;
 dst[0].y = transpose[0].x * b[0].y + transpose[1].x * b[1].y + transpose[2].x * b[2].y;
 dst[0].z = transpose[0].x * b[0].z + transpose[1].x * b[1].z + transpose[2].x * b[2].z;
 dst[1].x = transpose[0].y * b[0].x + transpose[1].y * b[1].x + transpose[2].y * b[2].x;
 dst[1].y = transpose[0].y * b[0].y + transpose[1].y * b[1].y + transpose[2].y * b[2].y;
 dst[1].z = transpose[0].y * b[0].z + transpose[1].y * b[1].z + transpose[2].y * b[2].z;
 dst[2].x = transpose[0].z * b[0].x + transpose[1].z * b[1].x + transpose[2].z * b[2].x;
 dst[2].y = transpose[0].z * b[0].y + transpose[1].z * b[1].y + transpose[2].z * b[2].y;
 dst[2].z = transpose[0].z * b[0].z + transpose[1].z * b[1].z + transpose[2].z * b[2].z;
}

inline idMat3 SkewSymmetric( idVec3 const &src ) {
 return idMat3( 0.0f, -src.z, src.y, src.z, 0.0f, -src.x, -src.y, src.x, 0.0f );
}

inline int idMat3::GetDimension( void ) const {
 return 9;
}

inline const float *idMat3::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat3::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 764 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
class idMat4 {
public:
     idMat4( void );
     explicit idMat4( const idVec4 &x, const idVec4 &y, const idVec4 &z, const idVec4 &w );
     explicit idMat4(const float xx, const float xy, const float xz, const float xw,
         const float yx, const float yy, const float yz, const float yw,
         const float zx, const float zy, const float zz, const float zw,
         const float wx, const float wy, const float wz, const float ww );
     explicit idMat4( const idMat3 &rotation, const idVec3 &translation );
     explicit idMat4( const float src[ 4 ][ 4 ] );

 const idVec4 & operator[]( int index ) const;
 idVec4 & operator[]( int index );
 idMat4 operator*( const float a ) const;
 idVec4 operator*( const idVec4 &vec ) const;
 idVec3 operator*( const idVec3 &vec ) const;
 idMat4 operator*( const idMat4 &a ) const;
 idMat4 operator+( const idMat4 &a ) const;
 idMat4 operator-( const idMat4 &a ) const;
 idMat4 & operator*=( const float a );
 idMat4 & operator*=( const idMat4 &a );
 idMat4 & operator+=( const idMat4 &a );
 idMat4 & operator-=( const idMat4 &a );

 friend idMat4 operator*( const float a, const idMat4 &mat );
 friend idVec4 operator*( const idVec4 &vec, const idMat4 &mat );
 friend idVec3 operator*( const idVec3 &vec, const idMat4 &mat );
 friend idVec4 & operator*=( idVec4 &vec, const idMat4 &mat );
 friend idVec3 & operator*=( idVec3 &vec, const idMat4 &mat );

 bool Compare( const idMat4 &a ) const;
 bool Compare( const idMat4 &a, const float epsilon ) const;
 bool operator==( const idMat4 &a ) const;
 bool operator!=( const idMat4 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;
 bool IsRotated( void ) const;

 void ProjectVector( const idVec4 &src, idVec4 &dst ) const;
 void UnprojectVector( const idVec4 &src, idVec4 &dst ) const;

 float Trace( void ) const;
 float Determinant( void ) const;
 idMat4 Transpose( void ) const;
 idMat4 & TransposeSelf( void );
 idMat4 Inverse( void ) const;
 bool InverseSelf( void );
 idMat4 InverseFast( void ) const;
 bool InverseFastSelf( void );
 idMat4 TransposeMultiply( const idMat4 &b ) const;

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 idVec4 mat[ 4 ];
};

extern idMat4 mat4_zero;
extern idMat4 mat4_identity;


inline idMat4::idMat4( void ) {
}

inline idMat4::idMat4( const idVec4 &x, const idVec4 &y, const idVec4 &z, const idVec4 &w ) {
 mat[ 0 ] = x;
 mat[ 1 ] = y;
 mat[ 2 ] = z;
 mat[ 3 ] = w;
}

inline idMat4::idMat4( const float xx, const float xy, const float xz, const float xw,
       const float yx, const float yy, const float yz, const float yw,
       const float zx, const float zy, const float zz, const float zw,
       const float wx, const float wy, const float wz, const float ww ) {
 mat[0][0] = xx; mat[0][1] = xy; mat[0][2] = xz; mat[0][3] = xw;
 mat[1][0] = yx; mat[1][1] = yy; mat[1][2] = yz; mat[1][3] = yw;
 mat[2][0] = zx; mat[2][1] = zy; mat[2][2] = zz; mat[2][3] = zw;
 mat[3][0] = wx; mat[3][1] = wy; mat[3][2] = wz; mat[3][3] = ww;
}

inline idMat4::idMat4( const idMat3 &rotation, const idVec3 &translation ) {

 mat[ 0 ][ 0 ] = rotation[0][0];
 mat[ 0 ][ 1 ] = rotation[1][0];
 mat[ 0 ][ 2 ] = rotation[2][0];
 mat[ 0 ][ 3 ] = translation[0];
 mat[ 1 ][ 0 ] = rotation[0][1];
 mat[ 1 ][ 1 ] = rotation[1][1];
 mat[ 1 ][ 2 ] = rotation[2][1];
 mat[ 1 ][ 3 ] = translation[1];
 mat[ 2 ][ 0 ] = rotation[0][2];
 mat[ 2 ][ 1 ] = rotation[1][2];
 mat[ 2 ][ 2 ] = rotation[2][2];
 mat[ 2 ][ 3 ] = translation[2];
 mat[ 3 ][ 0 ] = 0.0f;
 mat[ 3 ][ 1 ] = 0.0f;
 mat[ 3 ][ 2 ] = 0.0f;
 mat[ 3 ][ 3 ] = 1.0f;
}

inline idMat4::idMat4( const float src[ 4 ][ 4 ] ) {
 memcpy( mat, src, 4 * 4 * sizeof( float ) );
}

inline const idVec4 &idMat4::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec4 &idMat4::operator[]( int index ) {

 return mat[ index ];
}

inline idMat4 idMat4::operator*( const float a ) const {
 return idMat4(
  mat[0].x * a, mat[0].y * a, mat[0].z * a, mat[0].w * a,
  mat[1].x * a, mat[1].y * a, mat[1].z * a, mat[1].w * a,
  mat[2].x * a, mat[2].y * a, mat[2].z * a, mat[2].w * a,
  mat[3].x * a, mat[3].y * a, mat[3].z * a, mat[3].w * a );
}

inline idVec4 idMat4::operator*( const idVec4 &vec ) const {
 return idVec4(
  mat[ 0 ].x * vec.x + mat[ 0 ].y * vec.y + mat[ 0 ].z * vec.z + mat[ 0 ].w * vec.w,
  mat[ 1 ].x * vec.x + mat[ 1 ].y * vec.y + mat[ 1 ].z * vec.z + mat[ 1 ].w * vec.w,
  mat[ 2 ].x * vec.x + mat[ 2 ].y * vec.y + mat[ 2 ].z * vec.z + mat[ 2 ].w * vec.w,
  mat[ 3 ].x * vec.x + mat[ 3 ].y * vec.y + mat[ 3 ].z * vec.z + mat[ 3 ].w * vec.w );
}

inline idVec3 idMat4::operator*( const idVec3 &vec ) const {
 float s = mat[ 3 ].x * vec.x + mat[ 3 ].y * vec.y + mat[ 3 ].z * vec.z + mat[ 3 ].w;
 if ( s == 0.0f ) {
  return idVec3( 0.0f, 0.0f, 0.0f );
 }
 if ( s == 1.0f ) {
  return idVec3(
   mat[ 0 ].x * vec.x + mat[ 0 ].y * vec.y + mat[ 0 ].z * vec.z + mat[ 0 ].w,
   mat[ 1 ].x * vec.x + mat[ 1 ].y * vec.y + mat[ 1 ].z * vec.z + mat[ 1 ].w,
   mat[ 2 ].x * vec.x + mat[ 2 ].y * vec.y + mat[ 2 ].z * vec.z + mat[ 2 ].w );
 }
 else {
  float invS = 1.0f / s;
  return idVec3(
   (mat[ 0 ].x * vec.x + mat[ 0 ].y * vec.y + mat[ 0 ].z * vec.z + mat[ 0 ].w) * invS,
   (mat[ 1 ].x * vec.x + mat[ 1 ].y * vec.y + mat[ 1 ].z * vec.z + mat[ 1 ].w) * invS,
   (mat[ 2 ].x * vec.x + mat[ 2 ].y * vec.y + mat[ 2 ].z * vec.z + mat[ 2 ].w) * invS );
 }
}

inline idMat4 idMat4::operator*( const idMat4 &a ) const {
 int i, j;
 const float *m1Ptr, *m2Ptr;
 float *dstPtr;
 idMat4 dst;

 m1Ptr = reinterpret_cast<const float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);
 dstPtr = reinterpret_cast<float *>(&dst);

 for ( i = 0; i < 4; i++ ) {
  for ( j = 0; j < 4; j++ ) {
   *dstPtr = m1Ptr[0] * m2Ptr[ 0 * 4 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 4 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 4 + j ]
     + m1Ptr[3] * m2Ptr[ 3 * 4 + j ];
   dstPtr++;
  }
  m1Ptr += 4;
 }
 return dst;
}

inline idMat4 idMat4::operator+( const idMat4 &a ) const {
 return idMat4(
  mat[0].x + a[0].x, mat[0].y + a[0].y, mat[0].z + a[0].z, mat[0].w + a[0].w,
  mat[1].x + a[1].x, mat[1].y + a[1].y, mat[1].z + a[1].z, mat[1].w + a[1].w,
  mat[2].x + a[2].x, mat[2].y + a[2].y, mat[2].z + a[2].z, mat[2].w + a[2].w,
  mat[3].x + a[3].x, mat[3].y + a[3].y, mat[3].z + a[3].z, mat[3].w + a[3].w );
}

inline idMat4 idMat4::operator-( const idMat4 &a ) const {
 return idMat4(
  mat[0].x - a[0].x, mat[0].y - a[0].y, mat[0].z - a[0].z, mat[0].w - a[0].w,
  mat[1].x - a[1].x, mat[1].y - a[1].y, mat[1].z - a[1].z, mat[1].w - a[1].w,
  mat[2].x - a[2].x, mat[2].y - a[2].y, mat[2].z - a[2].z, mat[2].w - a[2].w,
  mat[3].x - a[3].x, mat[3].y - a[3].y, mat[3].z - a[3].z, mat[3].w - a[3].w );
}

inline idMat4 &idMat4::operator*=( const float a ) {
 mat[0].x *= a; mat[0].y *= a; mat[0].z *= a; mat[0].w *= a;
 mat[1].x *= a; mat[1].y *= a; mat[1].z *= a; mat[1].w *= a;
 mat[2].x *= a; mat[2].y *= a; mat[2].z *= a; mat[2].w *= a;
 mat[3].x *= a; mat[3].y *= a; mat[3].z *= a; mat[3].w *= a;
    return *this;
}

inline idMat4 &idMat4::operator*=( const idMat4 &a ) {
 *this = (*this) * a;
 return *this;
}

inline idMat4 &idMat4::operator+=( const idMat4 &a ) {
 mat[0].x += a[0].x; mat[0].y += a[0].y; mat[0].z += a[0].z; mat[0].w += a[0].w;
 mat[1].x += a[1].x; mat[1].y += a[1].y; mat[1].z += a[1].z; mat[1].w += a[1].w;
 mat[2].x += a[2].x; mat[2].y += a[2].y; mat[2].z += a[2].z; mat[2].w += a[2].w;
 mat[3].x += a[3].x; mat[3].y += a[3].y; mat[3].z += a[3].z; mat[3].w += a[3].w;
    return *this;
}

inline idMat4 &idMat4::operator-=( const idMat4 &a ) {
 mat[0].x -= a[0].x; mat[0].y -= a[0].y; mat[0].z -= a[0].z; mat[0].w -= a[0].w;
 mat[1].x -= a[1].x; mat[1].y -= a[1].y; mat[1].z -= a[1].z; mat[1].w -= a[1].w;
 mat[2].x -= a[2].x; mat[2].y -= a[2].y; mat[2].z -= a[2].z; mat[2].w -= a[2].w;
 mat[3].x -= a[3].x; mat[3].y -= a[3].y; mat[3].z -= a[3].z; mat[3].w -= a[3].w;
    return *this;
}

inline idMat4 operator*( const float a, const idMat4 &mat ) {
 return mat * a;
}

inline idVec4 operator*( const idVec4 &vec, const idMat4 &mat ) {
 return mat * vec;
}

inline idVec3 operator*( const idVec3 &vec, const idMat4 &mat ) {
 return mat * vec;
}

inline idVec4 &operator*=( idVec4 &vec, const idMat4 &mat ) {
 vec = mat * vec;
 return vec;
}

inline idVec3 &operator*=( idVec3 &vec, const idMat4 &mat ) {
 vec = mat * vec;
 return vec;
}

inline bool idMat4::Compare( const idMat4 &a ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 4*4; i++ ) {
  if ( ptr1[i] != ptr2[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idMat4::Compare( const idMat4 &a, const float epsilon ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 4*4; i++ ) {
  if ( idMath::Fabs( ptr1[i] - ptr2[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idMat4::operator==( const idMat4 &a ) const {
 return Compare( a );
}

inline bool idMat4::operator!=( const idMat4 &a ) const {
 return !Compare( a );
}

inline void idMat4::Zero( void ) {
 memset( mat, 0, sizeof( idMat4 ) );
}

inline void idMat4::Identity( void ) {
 *this = mat4_identity;
}

inline bool idMat4::IsIdentity( const float epsilon ) const {
 return Compare( mat4_identity, epsilon );
}

inline bool idMat4::IsSymmetric( const float epsilon ) const {
 for ( int i = 1; i < 4; i++ ) {
  for ( int j = 0; j < i; j++ ) {
   if ( idMath::Fabs( mat[i][j] - mat[j][i] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMat4::IsDiagonal( const float epsilon ) const {
 for ( int i = 0; i < 4; i++ ) {
  for ( int j = 0; j < 4; j++ ) {
   if ( i != j && idMath::Fabs( mat[i][j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMat4::IsRotated( void ) const {
 if ( !mat[ 0 ][ 1 ] && !mat[ 0 ][ 2 ] &&
  !mat[ 1 ][ 0 ] && !mat[ 1 ][ 2 ] &&
  !mat[ 2 ][ 0 ] && !mat[ 2 ][ 1 ] ) {
  return false;
 }
 return true;
}

inline void idMat4::ProjectVector( const idVec4 &src, idVec4 &dst ) const {
 dst.x = src * mat[ 0 ];
 dst.y = src * mat[ 1 ];
 dst.z = src * mat[ 2 ];
 dst.w = src * mat[ 3 ];
}

inline void idMat4::UnprojectVector( const idVec4 &src, idVec4 &dst ) const {
 dst = mat[ 0 ] * src.x + mat[ 1 ] * src.y + mat[ 2 ] * src.z + mat[ 3 ] * src.w;
}

inline float idMat4::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3] );
}

inline idMat4 idMat4::Inverse( void ) const {
 idMat4 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat4 idMat4::InverseFast( void ) const {
 idMat4 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline idMat4 idMat3::ToMat4( void ) const {

 return idMat4( mat[0][0], mat[1][0], mat[2][0], 0.0f,
     mat[0][1], mat[1][1], mat[2][1], 0.0f,
     mat[0][2], mat[1][2], mat[2][2], 0.0f,
     0.0f, 0.0f, 0.0f, 1.0f );
}

inline int idMat4::GetDimension( void ) const {
 return 16;
}

inline const float *idMat4::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat4::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 1152 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
class idMat5 {
public:
     idMat5( void );
     explicit idMat5( const idVec5 &v0, const idVec5 &v1, const idVec5 &v2, const idVec5 &v3, const idVec5 &v4 );
     explicit idMat5( const float src[ 5 ][ 5 ] );

 const idVec5 & operator[]( int index ) const;
 idVec5 & operator[]( int index );
 idMat5 operator*( const float a ) const;
 idVec5 operator*( const idVec5 &vec ) const;
 idMat5 operator*( const idMat5 &a ) const;
 idMat5 operator+( const idMat5 &a ) const;
 idMat5 operator-( const idMat5 &a ) const;
 idMat5 & operator*=( const float a );
 idMat5 & operator*=( const idMat5 &a );
 idMat5 & operator+=( const idMat5 &a );
 idMat5 & operator-=( const idMat5 &a );

 friend idMat5 operator*( const float a, const idMat5 &mat );
 friend idVec5 operator*( const idVec5 &vec, const idMat5 &mat );
 friend idVec5 & operator*=( idVec5 &vec, const idMat5 &mat );

 bool Compare( const idMat5 &a ) const;
 bool Compare( const idMat5 &a, const float epsilon ) const;
 bool operator==( const idMat5 &a ) const;
 bool operator!=( const idMat5 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;

 float Trace( void ) const;
 float Determinant( void ) const;
 idMat5 Transpose( void ) const;
 idMat5 & TransposeSelf( void );
 idMat5 Inverse( void ) const;
 bool InverseSelf( void );
 idMat5 InverseFast( void ) const;
 bool InverseFastSelf( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 idVec5 mat[ 5 ];
};

extern idMat5 mat5_zero;
extern idMat5 mat5_identity;


inline idMat5::idMat5( void ) {
}

inline idMat5::idMat5( const float src[ 5 ][ 5 ] ) {
 memcpy( mat, src, 5 * 5 * sizeof( float ) );
}

inline idMat5::idMat5( const idVec5 &v0, const idVec5 &v1, const idVec5 &v2, const idVec5 &v3, const idVec5 &v4 ) {
 mat[0] = v0;
 mat[1] = v1;
 mat[2] = v2;
 mat[3] = v3;
 mat[4] = v4;
}

inline const idVec5 &idMat5::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec5 &idMat5::operator[]( int index ) {

 return mat[ index ];
}

inline idMat5 idMat5::operator*( const idMat5 &a ) const {
 int i, j;
 const float *m1Ptr, *m2Ptr;
 float *dstPtr;
 idMat5 dst;

 m1Ptr = reinterpret_cast<const float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);
 dstPtr = reinterpret_cast<float *>(&dst);

 for ( i = 0; i < 5; i++ ) {
  for ( j = 0; j < 5; j++ ) {
   *dstPtr = m1Ptr[0] * m2Ptr[ 0 * 5 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 5 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 5 + j ]
     + m1Ptr[3] * m2Ptr[ 3 * 5 + j ]
     + m1Ptr[4] * m2Ptr[ 4 * 5 + j ];
   dstPtr++;
  }
  m1Ptr += 5;
 }
 return dst;
}

inline idMat5 idMat5::operator*( const float a ) const {
 return idMat5(
  idVec5( mat[0][0] * a, mat[0][1] * a, mat[0][2] * a, mat[0][3] * a, mat[0][4] * a ),
  idVec5( mat[1][0] * a, mat[1][1] * a, mat[1][2] * a, mat[1][3] * a, mat[1][4] * a ),
  idVec5( mat[2][0] * a, mat[2][1] * a, mat[2][2] * a, mat[2][3] * a, mat[2][4] * a ),
  idVec5( mat[3][0] * a, mat[3][1] * a, mat[3][2] * a, mat[3][3] * a, mat[3][4] * a ),
  idVec5( mat[4][0] * a, mat[4][1] * a, mat[4][2] * a, mat[4][3] * a, mat[4][4] * a ) );
}

inline idVec5 idMat5::operator*( const idVec5 &vec ) const {
 return idVec5(
  mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2] + mat[0][3] * vec[3] + mat[0][4] * vec[4],
  mat[1][0] * vec[0] + mat[1][1] * vec[1] + mat[1][2] * vec[2] + mat[1][3] * vec[3] + mat[1][4] * vec[4],
  mat[2][0] * vec[0] + mat[2][1] * vec[1] + mat[2][2] * vec[2] + mat[2][3] * vec[3] + mat[2][4] * vec[4],
  mat[3][0] * vec[0] + mat[3][1] * vec[1] + mat[3][2] * vec[2] + mat[3][3] * vec[3] + mat[3][4] * vec[4],
  mat[4][0] * vec[0] + mat[4][1] * vec[1] + mat[4][2] * vec[2] + mat[4][3] * vec[3] + mat[4][4] * vec[4] );
}

inline idMat5 idMat5::operator+( const idMat5 &a ) const {
 return idMat5(
  idVec5( mat[0][0] + a[0][0], mat[0][1] + a[0][1], mat[0][2] + a[0][2], mat[0][3] + a[0][3], mat[0][4] + a[0][4] ),
  idVec5( mat[1][0] + a[1][0], mat[1][1] + a[1][1], mat[1][2] + a[1][2], mat[1][3] + a[1][3], mat[1][4] + a[1][4] ),
  idVec5( mat[2][0] + a[2][0], mat[2][1] + a[2][1], mat[2][2] + a[2][2], mat[2][3] + a[2][3], mat[2][4] + a[2][4] ),
  idVec5( mat[3][0] + a[3][0], mat[3][1] + a[3][1], mat[3][2] + a[3][2], mat[3][3] + a[3][3], mat[3][4] + a[3][4] ),
  idVec5( mat[4][0] + a[4][0], mat[4][1] + a[4][1], mat[4][2] + a[4][2], mat[4][3] + a[4][3], mat[4][4] + a[4][4] ) );
}

inline idMat5 idMat5::operator-( const idMat5 &a ) const {
 return idMat5(
  idVec5( mat[0][0] - a[0][0], mat[0][1] - a[0][1], mat[0][2] - a[0][2], mat[0][3] - a[0][3], mat[0][4] - a[0][4] ),
  idVec5( mat[1][0] - a[1][0], mat[1][1] - a[1][1], mat[1][2] - a[1][2], mat[1][3] - a[1][3], mat[1][4] - a[1][4] ),
  idVec5( mat[2][0] - a[2][0], mat[2][1] - a[2][1], mat[2][2] - a[2][2], mat[2][3] - a[2][3], mat[2][4] - a[2][4] ),
  idVec5( mat[3][0] - a[3][0], mat[3][1] - a[3][1], mat[3][2] - a[3][2], mat[3][3] - a[3][3], mat[3][4] - a[3][4] ),
  idVec5( mat[4][0] - a[4][0], mat[4][1] - a[4][1], mat[4][2] - a[4][2], mat[4][3] - a[4][3], mat[4][4] - a[4][4] ) );
}

inline idMat5 &idMat5::operator*=( const float a ) {
 mat[0][0] *= a; mat[0][1] *= a; mat[0][2] *= a; mat[0][3] *= a; mat[0][4] *= a;
 mat[1][0] *= a; mat[1][1] *= a; mat[1][2] *= a; mat[1][3] *= a; mat[1][4] *= a;
 mat[2][0] *= a; mat[2][1] *= a; mat[2][2] *= a; mat[2][3] *= a; mat[2][4] *= a;
 mat[3][0] *= a; mat[3][1] *= a; mat[3][2] *= a; mat[3][3] *= a; mat[3][4] *= a;
 mat[4][0] *= a; mat[4][1] *= a; mat[4][2] *= a; mat[4][3] *= a; mat[4][4] *= a;
 return *this;
}

inline idMat5 &idMat5::operator*=( const idMat5 &a ) {
 *this = *this * a;
 return *this;
}

inline idMat5 &idMat5::operator+=( const idMat5 &a ) {
 mat[0][0] += a[0][0]; mat[0][1] += a[0][1]; mat[0][2] += a[0][2]; mat[0][3] += a[0][3]; mat[0][4] += a[0][4];
 mat[1][0] += a[1][0]; mat[1][1] += a[1][1]; mat[1][2] += a[1][2]; mat[1][3] += a[1][3]; mat[1][4] += a[1][4];
 mat[2][0] += a[2][0]; mat[2][1] += a[2][1]; mat[2][2] += a[2][2]; mat[2][3] += a[2][3]; mat[2][4] += a[2][4];
 mat[3][0] += a[3][0]; mat[3][1] += a[3][1]; mat[3][2] += a[3][2]; mat[3][3] += a[3][3]; mat[3][4] += a[3][4];
 mat[4][0] += a[4][0]; mat[4][1] += a[4][1]; mat[4][2] += a[4][2]; mat[4][3] += a[4][3]; mat[4][4] += a[4][4];
 return *this;
}

inline idMat5 &idMat5::operator-=( const idMat5 &a ) {
 mat[0][0] -= a[0][0]; mat[0][1] -= a[0][1]; mat[0][2] -= a[0][2]; mat[0][3] -= a[0][3]; mat[0][4] -= a[0][4];
 mat[1][0] -= a[1][0]; mat[1][1] -= a[1][1]; mat[1][2] -= a[1][2]; mat[1][3] -= a[1][3]; mat[1][4] -= a[1][4];
 mat[2][0] -= a[2][0]; mat[2][1] -= a[2][1]; mat[2][2] -= a[2][2]; mat[2][3] -= a[2][3]; mat[2][4] -= a[2][4];
 mat[3][0] -= a[3][0]; mat[3][1] -= a[3][1]; mat[3][2] -= a[3][2]; mat[3][3] -= a[3][3]; mat[3][4] -= a[3][4];
 mat[4][0] -= a[4][0]; mat[4][1] -= a[4][1]; mat[4][2] -= a[4][2]; mat[4][3] -= a[4][3]; mat[4][4] -= a[4][4];
 return *this;
}

inline idVec5 operator*( const idVec5 &vec, const idMat5 &mat ) {
 return mat * vec;
}

inline idMat5 operator*( const float a, idMat5 const &mat ) {
 return mat * a;
}

inline idVec5 &operator*=( idVec5 &vec, const idMat5 &mat ) {
 vec = mat * vec;
 return vec;
}

inline bool idMat5::Compare( const idMat5 &a ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 5*5; i++ ) {
  if ( ptr1[i] != ptr2[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idMat5::Compare( const idMat5 &a, const float epsilon ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 5*5; i++ ) {
  if ( idMath::Fabs( ptr1[i] - ptr2[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idMat5::operator==( const idMat5 &a ) const {
 return Compare( a );
}

inline bool idMat5::operator!=( const idMat5 &a ) const {
 return !Compare( a );
}

inline void idMat5::Zero( void ) {
 memset( mat, 0, sizeof( idMat5 ) );
}

inline void idMat5::Identity( void ) {
 *this = mat5_identity;
}

inline bool idMat5::IsIdentity( const float epsilon ) const {
 return Compare( mat5_identity, epsilon );
}

inline bool idMat5::IsSymmetric( const float epsilon ) const {
 for ( int i = 1; i < 5; i++ ) {
  for ( int j = 0; j < i; j++ ) {
   if ( idMath::Fabs( mat[i][j] - mat[j][i] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMat5::IsDiagonal( const float epsilon ) const {
 for ( int i = 0; i < 5; i++ ) {
  for ( int j = 0; j < 5; j++ ) {
   if ( i != j && idMath::Fabs( mat[i][j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline float idMat5::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3] + mat[4][4] );
}

inline idMat5 idMat5::Inverse( void ) const {
 idMat5 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat5 idMat5::InverseFast( void ) const {
 idMat5 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline int idMat5::GetDimension( void ) const {
 return 25;
}

inline const float *idMat5::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat5::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 1449 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
class idMat6 {
public:
     idMat6( void );
     explicit idMat6( const idVec6 &v0, const idVec6 &v1, const idVec6 &v2, const idVec6 &v3, const idVec6 &v4, const idVec6 &v5 );
     explicit idMat6( const idMat3 &m0, const idMat3 &m1, const idMat3 &m2, const idMat3 &m3 );
     explicit idMat6( const float src[ 6 ][ 6 ] );

 const idVec6 & operator[]( int index ) const;
 idVec6 & operator[]( int index );
 idMat6 operator*( const float a ) const;
 idVec6 operator*( const idVec6 &vec ) const;
 idMat6 operator*( const idMat6 &a ) const;
 idMat6 operator+( const idMat6 &a ) const;
 idMat6 operator-( const idMat6 &a ) const;
 idMat6 & operator*=( const float a );
 idMat6 & operator*=( const idMat6 &a );
 idMat6 & operator+=( const idMat6 &a );
 idMat6 & operator-=( const idMat6 &a );

 friend idMat6 operator*( const float a, const idMat6 &mat );
 friend idVec6 operator*( const idVec6 &vec, const idMat6 &mat );
 friend idVec6 & operator*=( idVec6 &vec, const idMat6 &mat );

 bool Compare( const idMat6 &a ) const;
 bool Compare( const idMat6 &a, const float epsilon ) const;
 bool operator==( const idMat6 &a ) const;
 bool operator!=( const idMat6 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;

 idMat3 SubMat3( int n ) const;
 float Trace( void ) const;
 float Determinant( void ) const;
 idMat6 Transpose( void ) const;
 idMat6 & TransposeSelf( void );
 idMat6 Inverse( void ) const;
 bool InverseSelf( void );
 idMat6 InverseFast( void ) const;
 bool InverseFastSelf( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 idVec6 mat[ 6 ];
};

extern idMat6 mat6_zero;
extern idMat6 mat6_identity;


inline idMat6::idMat6( void ) {
}

inline idMat6::idMat6( const idMat3 &m0, const idMat3 &m1, const idMat3 &m2, const idMat3 &m3 ) {
 mat[0] = idVec6( m0[0][0], m0[0][1], m0[0][2], m1[0][0], m1[0][1], m1[0][2] );
 mat[1] = idVec6( m0[1][0], m0[1][1], m0[1][2], m1[1][0], m1[1][1], m1[1][2] );
 mat[2] = idVec6( m0[2][0], m0[2][1], m0[2][2], m1[2][0], m1[2][1], m1[2][2] );
 mat[3] = idVec6( m2[0][0], m2[0][1], m2[0][2], m3[0][0], m3[0][1], m3[0][2] );
 mat[4] = idVec6( m2[1][0], m2[1][1], m2[1][2], m3[1][0], m3[1][1], m3[1][2] );
 mat[5] = idVec6( m2[2][0], m2[2][1], m2[2][2], m3[2][0], m3[2][1], m3[2][2] );
}

inline idMat6::idMat6( const idVec6 &v0, const idVec6 &v1, const idVec6 &v2, const idVec6 &v3, const idVec6 &v4, const idVec6 &v5 ) {
 mat[0] = v0;
 mat[1] = v1;
 mat[2] = v2;
 mat[3] = v3;
 mat[4] = v4;
 mat[5] = v5;
}

inline idMat6::idMat6( const float src[ 6 ][ 6 ] ) {
 memcpy( mat, src, 6 * 6 * sizeof( float ) );
}

inline const idVec6 &idMat6::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec6 &idMat6::operator[]( int index ) {

 return mat[ index ];
}

inline idMat6 idMat6::operator*( const idMat6 &a ) const {
 int i, j;
 const float *m1Ptr, *m2Ptr;
 float *dstPtr;
 idMat6 dst;

 m1Ptr = reinterpret_cast<const float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);
 dstPtr = reinterpret_cast<float *>(&dst);

 for ( i = 0; i < 6; i++ ) {
  for ( j = 0; j < 6; j++ ) {
   *dstPtr = m1Ptr[0] * m2Ptr[ 0 * 6 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 6 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 6 + j ]
     + m1Ptr[3] * m2Ptr[ 3 * 6 + j ]
     + m1Ptr[4] * m2Ptr[ 4 * 6 + j ]
     + m1Ptr[5] * m2Ptr[ 5 * 6 + j ];
   dstPtr++;
  }
  m1Ptr += 6;
 }
 return dst;
}

inline idMat6 idMat6::operator*( const float a ) const {
 return idMat6(
  idVec6( mat[0][0] * a, mat[0][1] * a, mat[0][2] * a, mat[0][3] * a, mat[0][4] * a, mat[0][5] * a ),
  idVec6( mat[1][0] * a, mat[1][1] * a, mat[1][2] * a, mat[1][3] * a, mat[1][4] * a, mat[1][5] * a ),
  idVec6( mat[2][0] * a, mat[2][1] * a, mat[2][2] * a, mat[2][3] * a, mat[2][4] * a, mat[2][5] * a ),
  idVec6( mat[3][0] * a, mat[3][1] * a, mat[3][2] * a, mat[3][3] * a, mat[3][4] * a, mat[3][5] * a ),
  idVec6( mat[4][0] * a, mat[4][1] * a, mat[4][2] * a, mat[4][3] * a, mat[4][4] * a, mat[4][5] * a ),
  idVec6( mat[5][0] * a, mat[5][1] * a, mat[5][2] * a, mat[5][3] * a, mat[5][4] * a, mat[5][5] * a ) );
}

inline idVec6 idMat6::operator*( const idVec6 &vec ) const {
 return idVec6(
  mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2] + mat[0][3] * vec[3] + mat[0][4] * vec[4] + mat[0][5] * vec[5],
  mat[1][0] * vec[0] + mat[1][1] * vec[1] + mat[1][2] * vec[2] + mat[1][3] * vec[3] + mat[1][4] * vec[4] + mat[1][5] * vec[5],
  mat[2][0] * vec[0] + mat[2][1] * vec[1] + mat[2][2] * vec[2] + mat[2][3] * vec[3] + mat[2][4] * vec[4] + mat[2][5] * vec[5],
  mat[3][0] * vec[0] + mat[3][1] * vec[1] + mat[3][2] * vec[2] + mat[3][3] * vec[3] + mat[3][4] * vec[4] + mat[3][5] * vec[5],
  mat[4][0] * vec[0] + mat[4][1] * vec[1] + mat[4][2] * vec[2] + mat[4][3] * vec[3] + mat[4][4] * vec[4] + mat[4][5] * vec[5],
  mat[5][0] * vec[0] + mat[5][1] * vec[1] + mat[5][2] * vec[2] + mat[5][3] * vec[3] + mat[5][4] * vec[4] + mat[5][5] * vec[5] );
}

inline idMat6 idMat6::operator+( const idMat6 &a ) const {
 return idMat6(
  idVec6( mat[0][0] + a[0][0], mat[0][1] + a[0][1], mat[0][2] + a[0][2], mat[0][3] + a[0][3], mat[0][4] + a[0][4], mat[0][5] + a[0][5] ),
  idVec6( mat[1][0] + a[1][0], mat[1][1] + a[1][1], mat[1][2] + a[1][2], mat[1][3] + a[1][3], mat[1][4] + a[1][4], mat[1][5] + a[1][5] ),
  idVec6( mat[2][0] + a[2][0], mat[2][1] + a[2][1], mat[2][2] + a[2][2], mat[2][3] + a[2][3], mat[2][4] + a[2][4], mat[2][5] + a[2][5] ),
  idVec6( mat[3][0] + a[3][0], mat[3][1] + a[3][1], mat[3][2] + a[3][2], mat[3][3] + a[3][3], mat[3][4] + a[3][4], mat[3][5] + a[3][5] ),
  idVec6( mat[4][0] + a[4][0], mat[4][1] + a[4][1], mat[4][2] + a[4][2], mat[4][3] + a[4][3], mat[4][4] + a[4][4], mat[4][5] + a[4][5] ),
  idVec6( mat[5][0] + a[5][0], mat[5][1] + a[5][1], mat[5][2] + a[5][2], mat[5][3] + a[5][3], mat[5][4] + a[5][4], mat[5][5] + a[5][5] ) );
}

inline idMat6 idMat6::operator-( const idMat6 &a ) const {
 return idMat6(
  idVec6( mat[0][0] - a[0][0], mat[0][1] - a[0][1], mat[0][2] - a[0][2], mat[0][3] - a[0][3], mat[0][4] - a[0][4], mat[0][5] - a[0][5] ),
  idVec6( mat[1][0] - a[1][0], mat[1][1] - a[1][1], mat[1][2] - a[1][2], mat[1][3] - a[1][3], mat[1][4] - a[1][4], mat[1][5] - a[1][5] ),
  idVec6( mat[2][0] - a[2][0], mat[2][1] - a[2][1], mat[2][2] - a[2][2], mat[2][3] - a[2][3], mat[2][4] - a[2][4], mat[2][5] - a[2][5] ),
  idVec6( mat[3][0] - a[3][0], mat[3][1] - a[3][1], mat[3][2] - a[3][2], mat[3][3] - a[3][3], mat[3][4] - a[3][4], mat[3][5] - a[3][5] ),
  idVec6( mat[4][0] - a[4][0], mat[4][1] - a[4][1], mat[4][2] - a[4][2], mat[4][3] - a[4][3], mat[4][4] - a[4][4], mat[4][5] - a[4][5] ),
  idVec6( mat[5][0] - a[5][0], mat[5][1] - a[5][1], mat[5][2] - a[5][2], mat[5][3] - a[5][3], mat[5][4] - a[5][4], mat[5][5] - a[5][5] ) );
}

inline idMat6 &idMat6::operator*=( const float a ) {
 mat[0][0] *= a; mat[0][1] *= a; mat[0][2] *= a; mat[0][3] *= a; mat[0][4] *= a; mat[0][5] *= a;
 mat[1][0] *= a; mat[1][1] *= a; mat[1][2] *= a; mat[1][3] *= a; mat[1][4] *= a; mat[1][5] *= a;
 mat[2][0] *= a; mat[2][1] *= a; mat[2][2] *= a; mat[2][3] *= a; mat[2][4] *= a; mat[2][5] *= a;
 mat[3][0] *= a; mat[3][1] *= a; mat[3][2] *= a; mat[3][3] *= a; mat[3][4] *= a; mat[3][5] *= a;
 mat[4][0] *= a; mat[4][1] *= a; mat[4][2] *= a; mat[4][3] *= a; mat[4][4] *= a; mat[4][5] *= a;
 mat[5][0] *= a; mat[5][1] *= a; mat[5][2] *= a; mat[5][3] *= a; mat[5][4] *= a; mat[5][5] *= a;
 return *this;
}

inline idMat6 &idMat6::operator*=( const idMat6 &a ) {
 *this = *this * a;
 return *this;
}

inline idMat6 &idMat6::operator+=( const idMat6 &a ) {
 mat[0][0] += a[0][0]; mat[0][1] += a[0][1]; mat[0][2] += a[0][2]; mat[0][3] += a[0][3]; mat[0][4] += a[0][4]; mat[0][5] += a[0][5];
 mat[1][0] += a[1][0]; mat[1][1] += a[1][1]; mat[1][2] += a[1][2]; mat[1][3] += a[1][3]; mat[1][4] += a[1][4]; mat[1][5] += a[1][5];
 mat[2][0] += a[2][0]; mat[2][1] += a[2][1]; mat[2][2] += a[2][2]; mat[2][3] += a[2][3]; mat[2][4] += a[2][4]; mat[2][5] += a[2][5];
 mat[3][0] += a[3][0]; mat[3][1] += a[3][1]; mat[3][2] += a[3][2]; mat[3][3] += a[3][3]; mat[3][4] += a[3][4]; mat[3][5] += a[3][5];
 mat[4][0] += a[4][0]; mat[4][1] += a[4][1]; mat[4][2] += a[4][2]; mat[4][3] += a[4][3]; mat[4][4] += a[4][4]; mat[4][5] += a[4][5];
 mat[5][0] += a[5][0]; mat[5][1] += a[5][1]; mat[5][2] += a[5][2]; mat[5][3] += a[5][3]; mat[5][4] += a[5][4]; mat[5][5] += a[5][5];
 return *this;
}

inline idMat6 &idMat6::operator-=( const idMat6 &a ) {
 mat[0][0] -= a[0][0]; mat[0][1] -= a[0][1]; mat[0][2] -= a[0][2]; mat[0][3] -= a[0][3]; mat[0][4] -= a[0][4]; mat[0][5] -= a[0][5];
 mat[1][0] -= a[1][0]; mat[1][1] -= a[1][1]; mat[1][2] -= a[1][2]; mat[1][3] -= a[1][3]; mat[1][4] -= a[1][4]; mat[1][5] -= a[1][5];
 mat[2][0] -= a[2][0]; mat[2][1] -= a[2][1]; mat[2][2] -= a[2][2]; mat[2][3] -= a[2][3]; mat[2][4] -= a[2][4]; mat[2][5] -= a[2][5];
 mat[3][0] -= a[3][0]; mat[3][1] -= a[3][1]; mat[3][2] -= a[3][2]; mat[3][3] -= a[3][3]; mat[3][4] -= a[3][4]; mat[3][5] -= a[3][5];
 mat[4][0] -= a[4][0]; mat[4][1] -= a[4][1]; mat[4][2] -= a[4][2]; mat[4][3] -= a[4][3]; mat[4][4] -= a[4][4]; mat[4][5] -= a[4][5];
 mat[5][0] -= a[5][0]; mat[5][1] -= a[5][1]; mat[5][2] -= a[5][2]; mat[5][3] -= a[5][3]; mat[5][4] -= a[5][4]; mat[5][5] -= a[5][5];
 return *this;
}

inline idVec6 operator*( const idVec6 &vec, const idMat6 &mat ) {
 return mat * vec;
}

inline idMat6 operator*( const float a, idMat6 const &mat ) {
 return mat * a;
}

inline idVec6 &operator*=( idVec6 &vec, const idMat6 &mat ) {
 vec = mat * vec;
 return vec;
}

inline bool idMat6::Compare( const idMat6 &a ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 6*6; i++ ) {
  if ( ptr1[i] != ptr2[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idMat6::Compare( const idMat6 &a, const float epsilon ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 6*6; i++ ) {
  if ( idMath::Fabs( ptr1[i] - ptr2[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idMat6::operator==( const idMat6 &a ) const {
 return Compare( a );
}

inline bool idMat6::operator!=( const idMat6 &a ) const {
 return !Compare( a );
}

inline void idMat6::Zero( void ) {
 memset( mat, 0, sizeof( idMat6 ) );
}

inline void idMat6::Identity( void ) {
 *this = mat6_identity;
}

inline bool idMat6::IsIdentity( const float epsilon ) const {
 return Compare( mat6_identity, epsilon );
}

inline bool idMat6::IsSymmetric( const float epsilon ) const {
 for ( int i = 1; i < 6; i++ ) {
  for ( int j = 0; j < i; j++ ) {
   if ( idMath::Fabs( mat[i][j] - mat[j][i] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMat6::IsDiagonal( const float epsilon ) const {
 for ( int i = 0; i < 6; i++ ) {
  for ( int j = 0; j < 6; j++ ) {
   if ( i != j && idMath::Fabs( mat[i][j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline idMat3 idMat6::SubMat3( int n ) const {
 ((void)0);
 int b0 = ((n & 2) >> 1) * 3;
 int b1 = (n & 1) * 3;
 return idMat3(
  mat[b0 + 0][b1 + 0], mat[b0 + 0][b1 + 1], mat[b0 + 0][b1 + 2],
  mat[b0 + 1][b1 + 0], mat[b0 + 1][b1 + 1], mat[b0 + 1][b1 + 2],
  mat[b0 + 2][b1 + 0], mat[b0 + 2][b1 + 1], mat[b0 + 2][b1 + 2] );
}

inline float idMat6::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3] + mat[4][4] + mat[5][5] );
}

inline idMat6 idMat6::Inverse( void ) const {
 idMat6 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat6 idMat6::InverseFast( void ) const {
 idMat6 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline int idMat6::GetDimension( void ) const {
 return 36;
}

inline const float *idMat6::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat6::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 1786 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
class idMatX {
public:
     idMatX( void );
     explicit idMatX( int rows, int columns );
     explicit idMatX( int rows, int columns, float *src );
     ~idMatX( void );

 void Set( int rows, int columns, const float *src );
 void Set( const idMat3 &m1, const idMat3 &m2 );
 void Set( const idMat3 &m1, const idMat3 &m2, const idMat3 &m3, const idMat3 &m4 );

 const float * operator[]( int index ) const;
 float * operator[]( int index );
 idMatX & operator=( const idMatX &a );
 idMatX operator*( const float a ) const;
 idVecX operator*( const idVecX &vec ) const;
 idMatX operator*( const idMatX &a ) const;
 idMatX operator+( const idMatX &a ) const;
 idMatX operator-( const idMatX &a ) const;
 idMatX & operator*=( const float a );
 idMatX & operator*=( const idMatX &a );
 idMatX & operator+=( const idMatX &a );
 idMatX & operator-=( const idMatX &a );

 friend idMatX operator*( const float a, const idMatX &m );
 friend idVecX operator*( const idVecX &vec, const idMatX &m );
 friend idVecX & operator*=( idVecX &vec, const idMatX &m );

 bool Compare( const idMatX &a ) const;
 bool Compare( const idMatX &a, const float epsilon ) const;
 bool operator==( const idMatX &a ) const;
 bool operator!=( const idMatX &a ) const;

 void SetSize( int rows, int columns );
 void ChangeSize( int rows, int columns, bool makeZero = false );
 int GetNumRows( void ) const { return numRows; }
 int GetNumColumns( void ) const { return numColumns; }
 void SetData( int rows, int columns, float *data );
 void Zero( void );
 void Zero( int rows, int columns );
 void Identity( void );
 void Identity( int rows, int columns );
 void Diag( const idVecX &v );
 void Random( int seed, float l = 0.0f, float u = 1.0f );
 void Random( int rows, int columns, int seed, float l = 0.0f, float u = 1.0f );
 void Negate( void );
 void Clamp( float min, float max );
 idMatX & SwapRows( int r1, int r2 );
 idMatX & SwapColumns( int r1, int r2 );
 idMatX & SwapRowsColumns( int r1, int r2 );
 idMatX & RemoveRow( int r );
 idMatX & RemoveColumn( int r );
 idMatX & RemoveRowColumn( int r );
 void ClearUpperTriangle( void );
 void ClearLowerTriangle( void );
 void SquareSubMatrix( const idMatX &m, int size );
 float MaxDifference( const idMatX &m ) const;

 bool IsSquare( void ) const { return ( numRows == numColumns ); }
 bool IsZero( const float epsilon = 1e-6 ) const;
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;
 bool IsTriDiagonal( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsOrthogonal( const float epsilon = 1e-6 ) const;
 bool IsOrthonormal( const float epsilon = 1e-6 ) const;
 bool IsPMatrix( const float epsilon = 1e-6 ) const;
 bool IsZMatrix( const float epsilon = 1e-6 ) const;
 bool IsPositiveDefinite( const float epsilon = 1e-6 ) const;
 bool IsSymmetricPositiveDefinite( const float epsilon = 1e-6 ) const;
 bool IsPositiveSemiDefinite( const float epsilon = 1e-6 ) const;
 bool IsSymmetricPositiveSemiDefinite( const float epsilon = 1e-6 ) const;

 float Trace( void ) const;
 float Determinant( void ) const;
 idMatX Transpose( void ) const;
 idMatX & TransposeSelf( void );
 idMatX Inverse( void ) const;
 bool InverseSelf( void );
 idMatX InverseFast( void ) const;
 bool InverseFastSelf( void );

 bool LowerTriangularInverse( void );
 bool UpperTriangularInverse( void );

 idVecX Multiply( const idVecX &vec ) const;
 idVecX TransposeMultiply( const idVecX &vec ) const;

 idMatX Multiply( const idMatX &a ) const;
 idMatX TransposeMultiply( const idMatX &a ) const;

 void Multiply( idVecX &dst, const idVecX &vec ) const;
 void MultiplyAdd( idVecX &dst, const idVecX &vec ) const;
 void MultiplySub( idVecX &dst, const idVecX &vec ) const;
 void TransposeMultiply( idVecX &dst, const idVecX &vec ) const;
 void TransposeMultiplyAdd( idVecX &dst, const idVecX &vec ) const;
 void TransposeMultiplySub( idVecX &dst, const idVecX &vec ) const;

 void Multiply( idMatX &dst, const idMatX &a ) const;
 void TransposeMultiply( idMatX &dst, const idMatX &a ) const;

 int GetDimension( void ) const;

 const idVec6 & SubVec6( int row ) const;
 idVec6 & SubVec6( int row );
 const idVecX SubVecX( int row ) const;
 idVecX SubVecX( int row );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void Update_RankOne( const idVecX &v, const idVecX &w, float alpha );
 void Update_RankOneSymmetric( const idVecX &v, float alpha );
 void Update_RowColumn( const idVecX &v, const idVecX &w, int r );
 void Update_RowColumnSymmetric( const idVecX &v, int r );
 void Update_Increment( const idVecX &v, const idVecX &w );
 void Update_IncrementSymmetric( const idVecX &v );
 void Update_Decrement( int r );

 bool Inverse_GaussJordan( void );
 bool Inverse_UpdateRankOne( const idVecX &v, const idVecX &w, float alpha );
 bool Inverse_UpdateRowColumn( const idVecX &v, const idVecX &w, int r );
 bool Inverse_UpdateIncrement( const idVecX &v, const idVecX &w );
 bool Inverse_UpdateDecrement( const idVecX &v, const idVecX &w, int r );
 void Inverse_Solve( idVecX &x, const idVecX &b ) const;

 bool LU_Factor( int *index, float *det = __null );
 bool LU_UpdateRankOne( const idVecX &v, const idVecX &w, float alpha, int *index );
 bool LU_UpdateRowColumn( const idVecX &v, const idVecX &w, int r, int *index );
 bool LU_UpdateIncrement( const idVecX &v, const idVecX &w, int *index );
 bool LU_UpdateDecrement( const idVecX &v, const idVecX &w, const idVecX &u, int r, int *index );
 void LU_Solve( idVecX &x, const idVecX &b, const int *index ) const;
 void LU_Inverse( idMatX &inv, const int *index ) const;
 void LU_UnpackFactors( idMatX &L, idMatX &U ) const;
 void LU_MultiplyFactors( idMatX &m, const int *index ) const;

 bool QR_Factor( idVecX &c, idVecX &d );
 bool QR_UpdateRankOne( idMatX &R, const idVecX &v, const idVecX &w, float alpha );
 bool QR_UpdateRowColumn( idMatX &R, const idVecX &v, const idVecX &w, int r );
 bool QR_UpdateIncrement( idMatX &R, const idVecX &v, const idVecX &w );
 bool QR_UpdateDecrement( idMatX &R, const idVecX &v, const idVecX &w, int r );
 void QR_Solve( idVecX &x, const idVecX &b, const idVecX &c, const idVecX &d ) const;
 void QR_Solve( idVecX &x, const idVecX &b, const idMatX &R ) const;
 void QR_Inverse( idMatX &inv, const idVecX &c, const idVecX &d ) const;
 void QR_UnpackFactors( idMatX &Q, idMatX &R, const idVecX &c, const idVecX &d ) const;
 void QR_MultiplyFactors( idMatX &m, const idVecX &c, const idVecX &d ) const;

 bool SVD_Factor( idVecX &w, idMatX &V );
 void SVD_Solve( idVecX &x, const idVecX &b, const idVecX &w, const idMatX &V ) const;
 void SVD_Inverse( idMatX &inv, const idVecX &w, const idMatX &V ) const;
 void SVD_MultiplyFactors( idMatX &m, const idVecX &w, const idMatX &V ) const;

 bool Cholesky_Factor( void );
 bool Cholesky_UpdateRankOne( const idVecX &v, float alpha, int offset = 0 );
 bool Cholesky_UpdateRowColumn( const idVecX &v, int r );
 bool Cholesky_UpdateIncrement( const idVecX &v );
 bool Cholesky_UpdateDecrement( const idVecX &v, int r );
 void Cholesky_Solve( idVecX &x, const idVecX &b ) const;
 void Cholesky_Inverse( idMatX &inv ) const;
 void Cholesky_MultiplyFactors( idMatX &m ) const;

 bool LDLT_Factor( void );
 bool LDLT_UpdateRankOne( const idVecX &v, float alpha, int offset = 0 );
 bool LDLT_UpdateRowColumn( const idVecX &v, int r );
 bool LDLT_UpdateIncrement( const idVecX &v );
 bool LDLT_UpdateDecrement( const idVecX &v, int r );
 void LDLT_Solve( idVecX &x, const idVecX &b ) const;
 void LDLT_Inverse( idMatX &inv ) const;
 void LDLT_UnpackFactors( idMatX &L, idMatX &D ) const;
 void LDLT_MultiplyFactors( idMatX &m ) const;

 void TriDiagonal_ClearTriangles( void );
 bool TriDiagonal_Solve( idVecX &x, const idVecX &b ) const;
 void TriDiagonal_Inverse( idMatX &inv ) const;

 bool Eigen_SolveSymmetricTriDiagonal( idVecX &eigenValues );
 bool Eigen_SolveSymmetric( idVecX &eigenValues );
 bool Eigen_Solve( idVecX &realEigenValues, idVecX &imaginaryEigenValues );
 void Eigen_SortIncreasing( idVecX &eigenValues );
 void Eigen_SortDecreasing( idVecX &eigenValues );

 static void Test( void );

private:
 int numRows;
 int numColumns;
 int alloced;
 float * mat;

 static float temp[1024 +4];
 static float * tempPtr;
 static int tempIndex;

private:
 void SetTempSize( int rows, int columns );
 float DeterminantGeneric( void ) const;
 bool InverseSelfGeneric( void );
 void QR_Rotate( idMatX &R, int i, float a, float b );
 float Pythag( float a, float b ) const;
 void SVD_BiDiag( idVecX &w, idVecX &rv1, float &anorm );
 void SVD_InitialWV( idVecX &w, idMatX &V, idVecX &rv1 );
 void HouseholderReduction( idVecX &diag, idVecX &subd );
 bool QL( idVecX &diag, idVecX &subd );
 void HessenbergReduction( idMatX &H );
 void ComplexDivision( float xr, float xi, float yr, float yi, float &cdivr, float &cdivi );
 bool HessenbergToRealSchur( idMatX &H, idVecX &realEigenValues, idVecX &imaginaryEigenValues );
};

inline idMatX::idMatX( void ) {
 numRows = numColumns = alloced = 0;
 mat = __null;
}

inline idMatX::~idMatX( void ) {

 if ( mat != __null && ( mat < idMatX::tempPtr || mat > idMatX::tempPtr + 1024 ) && alloced != -1 ) {
  Mem_Free16( mat );
 }
}

inline idMatX::idMatX( int rows, int columns ) {
 numRows = numColumns = alloced = 0;
 mat = __null;
 SetSize( rows, columns );
}

inline idMatX::idMatX( int rows, int columns, float *src ) {
 numRows = numColumns = alloced = 0;
 mat = __null;
 SetData( rows, columns, src );
}

inline void idMatX::Set( int rows, int columns, const float *src ) {
 SetSize( rows, columns );
 memcpy( this->mat, src, rows * columns * sizeof( float ) );
}

inline void idMatX::Set( const idMat3 &m1, const idMat3 &m2 ) {
 int i, j;

 SetSize( 3, 6 );
 for ( i = 0; i < 3; i++ ) {
  for ( j = 0; j < 3; j++ ) {
   mat[(i+0) * numColumns + (j+0)] = m1[i][j];
   mat[(i+0) * numColumns + (j+3)] = m2[i][j];
  }
 }
}

inline void idMatX::Set( const idMat3 &m1, const idMat3 &m2, const idMat3 &m3, const idMat3 &m4 ) {
 int i, j;

 SetSize( 6, 6 );
 for ( i = 0; i < 3; i++ ) {
  for ( j = 0; j < 3; j++ ) {
   mat[(i+0) * numColumns + (j+0)] = m1[i][j];
   mat[(i+0) * numColumns + (j+3)] = m2[i][j];
   mat[(i+3) * numColumns + (j+0)] = m3[i][j];
   mat[(i+3) * numColumns + (j+3)] = m4[i][j];
  }
 }
}

inline const float *idMatX::operator[]( int index ) const {
 ((void)0);
 return mat + index * numColumns;
}

inline float *idMatX::operator[]( int index ) {
 ((void)0);
 return mat + index * numColumns;
}

inline idMatX &idMatX::operator=( const idMatX &a ) {
 SetSize( a.numRows, a.numColumns );

 SIMDProcessor->Copy16( mat, a.mat, a.numRows * a.numColumns );



 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX idMatX::operator*( const float a ) const {
 idMatX m;

 m.SetTempSize( numRows, numColumns );

 SIMDProcessor->Mul16( m.mat, mat, a, numRows * numColumns );







 return m;
}

inline idVecX idMatX::operator*( const idVecX &vec ) const {
 idVecX dst;

 ((void)0);

 dst.SetTempSize( numRows );

 SIMDProcessor->MatX_MultiplyVecX( dst, *this, vec );



 return dst;
}

inline idMatX idMatX::operator*( const idMatX &a ) const {
 idMatX dst;

 ((void)0);

 dst.SetTempSize( numRows, a.numColumns );

 SIMDProcessor->MatX_MultiplyMatX( dst, *this, a );



 return dst;
}

inline idMatX idMatX::operator+( const idMatX &a ) const {
 idMatX m;

 ((void)0);
 m.SetTempSize( numRows, numColumns );

 SIMDProcessor->Add16( m.mat, mat, a.mat, numRows * numColumns );







 return m;
}

inline idMatX idMatX::operator-( const idMatX &a ) const {
 idMatX m;

 ((void)0);
 m.SetTempSize( numRows, numColumns );

 SIMDProcessor->Sub16( m.mat, mat, a.mat, numRows * numColumns );







 return m;
}

inline idMatX &idMatX::operator*=( const float a ) {

 SIMDProcessor->MulAssign16( mat, a, numRows * numColumns );







 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX &idMatX::operator*=( const idMatX &a ) {
 *this = *this * a;
 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX &idMatX::operator+=( const idMatX &a ) {
 ((void)0);

 SIMDProcessor->AddAssign16( mat, a.mat, numRows * numColumns );







 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX &idMatX::operator-=( const idMatX &a ) {
 ((void)0);

 SIMDProcessor->SubAssign16( mat, a.mat, numRows * numColumns );







 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX operator*( const float a, idMatX const &m ) {
 return m * a;
}

inline idVecX operator*( const idVecX &vec, const idMatX &m ) {
 return m * vec;
}

inline idVecX &operator*=( idVecX &vec, const idMatX &m ) {
 vec = m * vec;
 return vec;
}

inline bool idMatX::Compare( const idMatX &a ) const {
 int i, s;

 ((void)0);

 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  if ( mat[i] != a.mat[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idMatX::Compare( const idMatX &a, const float epsilon ) const {
 int i, s;

 ((void)0);

 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  if ( idMath::Fabs( mat[i] - a.mat[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idMatX::operator==( const idMatX &a ) const {
 return Compare( a );
}

inline bool idMatX::operator!=( const idMatX &a ) const {
 return !Compare( a );
}

inline void idMatX::SetSize( int rows, int columns ) {
 ((void)0);
 int alloc = ( rows * columns + 3 ) & ~3;
 if ( alloc > alloced && alloced != -1 ) {
  if ( mat != __null ) {
   Mem_Free16( mat );
  }
  mat = (float *) Mem_Alloc16( alloc * sizeof( float ) );
  alloced = alloc;
 }
 numRows = rows;
 numColumns = columns;
 int s = numRows * numColumns; while( s < ( ( s + 3 ) & ~3 ) ) { mat[s++] = 0.0f; };
}

inline void idMatX::SetTempSize( int rows, int columns ) {
 int newSize;

 newSize = ( rows * columns + 3 ) & ~3;
 ((void)0);
 if ( idMatX::tempIndex + newSize > 1024 ) {
  idMatX::tempIndex = 0;
 }
 mat = idMatX::tempPtr + idMatX::tempIndex;
 idMatX::tempIndex += newSize;
 alloced = newSize;
 numRows = rows;
 numColumns = columns;
 int s = numRows * numColumns; while( s < ( ( s + 3 ) & ~3 ) ) { mat[s++] = 0.0f; };
}

inline void idMatX::SetData( int rows, int columns, float *data ) {
 ((void)0);
 if ( mat != __null && alloced != -1 ) {
  Mem_Free16( mat );
 }
 ((void)0);
 mat = data;
 alloced = -1;
 numRows = rows;
 numColumns = columns;
 int s = numRows * numColumns; while( s < ( ( s + 3 ) & ~3 ) ) { mat[s++] = 0.0f; };
}

inline void idMatX::Zero( void ) {

 SIMDProcessor->Zero16( mat, numRows * numColumns );



}

inline void idMatX::Zero( int rows, int columns ) {
 SetSize( rows, columns );

 SIMDProcessor->Zero16( mat, numRows * numColumns );



}

inline void idMatX::Identity( void ) {
 ((void)0);

 SIMDProcessor->Zero16( mat, numRows * numColumns );



 for ( int i = 0; i < numRows; i++ ) {
  mat[i * numColumns + i] = 1.0f;
 }
}

inline void idMatX::Identity( int rows, int columns ) {
 ((void)0);
 SetSize( rows, columns );
 idMatX::Identity();
}

inline void idMatX::Diag( const idVecX &v ) {
 Zero( v.GetSize(), v.GetSize() );
 for ( int i = 0; i < v.GetSize(); i++ ) {
  mat[i * numColumns + i] = v[i];
 }
}

inline void idMatX::Random( int seed, float l, float u ) {
 int i, s;
 float c;
 idRandom rnd(seed);

 c = u - l;
 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  mat[i] = l + rnd.RandomFloat() * c;
 }
}

inline void idMatX::Random( int rows, int columns, int seed, float l, float u ) {
 int i, s;
 float c;
 idRandom rnd(seed);

 SetSize( rows, columns );
 c = u - l;
 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  mat[i] = l + rnd.RandomFloat() * c;
 }
}

inline void idMatX::Negate( void ) {

 SIMDProcessor->Negate16( mat, numRows * numColumns );







}

inline void idMatX::Clamp( float min, float max ) {
 int i, s;
 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  if ( mat[i] < min ) {
   mat[i] = min;
  } else if ( mat[i] > max ) {
   mat[i] = max;
  }
 }
}

inline idMatX &idMatX::SwapRows( int r1, int r2 ) {
 float *ptr;

 ptr = (float *) ((void *)((((int)__builtin_alloca((numColumns * sizeof( float ))+15)) + 15) & ~15));
 memcpy( ptr, mat + r1 * numColumns, numColumns * sizeof( float ) );
 memcpy( mat + r1 * numColumns, mat + r2 * numColumns, numColumns * sizeof( float ) );
 memcpy( mat + r2 * numColumns, ptr, numColumns * sizeof( float ) );

 return *this;
}

inline idMatX &idMatX::SwapColumns( int r1, int r2 ) {
 int i;
 float tmp, *ptr;

 for ( i = 0; i < numRows; i++ ) {
  ptr = mat + i * numColumns;
  tmp = ptr[r1];
  ptr[r1] = ptr[r2];
  ptr[r2] = tmp;
 }

 return *this;
}

inline idMatX &idMatX::SwapRowsColumns( int r1, int r2 ) {

 SwapRows( r1, r2 );
 SwapColumns( r1, r2 );
 return *this;
}

inline void idMatX::ClearUpperTriangle( void ) {
 ((void)0);
 for ( int i = numRows-2; i >= 0; i-- ) {
  memset( mat + i * numColumns + i + 1, 0, (numColumns - 1 - i) * sizeof(float) );
 }
}

inline void idMatX::ClearLowerTriangle( void ) {
 ((void)0);
 for ( int i = 1; i < numRows; i++ ) {
  memset( mat + i * numColumns, 0, i * sizeof(float) );
 }
}

inline void idMatX::SquareSubMatrix( const idMatX &m, int size ) {
 int i;
 ((void)0);
 SetSize( size, size );
 for ( i = 0; i < size; i++ ) {
  memcpy( mat + i * numColumns, m.mat + i * m.numColumns, size * sizeof( float ) );
 }
}

inline float idMatX::MaxDifference( const idMatX &m ) const {
 int i, j;
 float diff, maxDiff;

 ((void)0);

 maxDiff = -1.0f;
 for ( i = 0; i < numRows; i++ ) {
  for ( j = 0; j < numColumns; j++ ) {
   diff = idMath::Fabs( mat[ i * numColumns + j ] - m[i][j] );
   if ( maxDiff < 0.0f || diff > maxDiff ) {
    maxDiff = diff;
   }
  }
 }
 return maxDiff;
}

inline bool idMatX::IsZero( const float epsilon ) const {

 for ( int i = 0; i < numRows; i++ ) {
  for ( int j = 0; j < numColumns; j++ ) {
   if ( idMath::Fabs( mat[i * numColumns + j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMatX::IsIdentity( const float epsilon ) const {

 ((void)0);
 for ( int i = 0; i < numRows; i++ ) {
  for ( int j = 0; j < numColumns; j++ ) {
   if ( idMath::Fabs( mat[i * numColumns + j] - (float)( i == j ) ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMatX::IsDiagonal( const float epsilon ) const {

 ((void)0);
 for ( int i = 0; i < numRows; i++ ) {
  for ( int j = 0; j < numColumns; j++ ) {
   if ( i != j && idMath::Fabs( mat[i * numColumns + j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMatX::IsTriDiagonal( const float epsilon ) const {


 if ( numRows != numColumns ) {
  return false;
 }
 for ( int i = 0; i < numRows-2; i++ ) {
  for ( int j = i+2; j < numColumns; j++ ) {
   if ( idMath::Fabs( (*this)[i][j] ) > epsilon ) {
    return false;
   }
   if ( idMath::Fabs( (*this)[j][i] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMatX::IsSymmetric( const float epsilon ) const {

 if ( numRows != numColumns ) {
  return false;
 }
 for ( int i = 0; i < numRows; i++ ) {
  for ( int j = 0; j < numColumns; j++ ) {
   if ( idMath::Fabs( mat[ i * numColumns + j ] - mat[ j * numColumns + i ] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline float idMatX::Trace( void ) const {
 float trace = 0.0f;

 ((void)0);


 for ( int i = 0; i < numRows; i++ ) {
  trace += mat[i * numRows + i];
 }
 return trace;
}

inline float idMatX::Determinant( void ) const {

 ((void)0);

 switch( numRows ) {
  case 1:
   return mat[0];
  case 2:
   return reinterpret_cast<const idMat2 *>(mat)->Determinant();
  case 3:
   return reinterpret_cast<const idMat3 *>(mat)->Determinant();
  case 4:
   return reinterpret_cast<const idMat4 *>(mat)->Determinant();
  case 5:
   return reinterpret_cast<const idMat5 *>(mat)->Determinant();
  case 6:
   return reinterpret_cast<const idMat6 *>(mat)->Determinant();
  default:
   return DeterminantGeneric();
 }
 return 0.0f;
}

inline idMatX idMatX::Transpose( void ) const {
 idMatX transpose;
 int i, j;

 transpose.SetTempSize( numColumns, numRows );

 for ( i = 0; i < numRows; i++ ) {
  for ( j = 0; j < numColumns; j++ ) {
   transpose.mat[j * transpose.numColumns + i] = mat[i * numColumns + j];
  }
 }

 return transpose;
}

inline idMatX &idMatX::TransposeSelf( void ) {
 *this = Transpose();
 return *this;
}

inline idMatX idMatX::Inverse( void ) const {
 idMatX invMat;

 invMat.SetTempSize( numRows, numColumns );
 memcpy( invMat.mat, mat, numRows * numColumns * sizeof( float ) );
 invMat.InverseSelf();

 return invMat;
}

inline bool idMatX::InverseSelf( void ) {

 ((void)0);

 switch( numRows ) {
  case 1:
   if ( idMath::Fabs( mat[0] ) < 1e-14 ) {
    return false;
   }
   mat[0] = 1.0f / mat[0];
   return true;
  case 2:
   return reinterpret_cast<idMat2 *>(mat)->InverseSelf();
  case 3:
   return reinterpret_cast<idMat3 *>(mat)->InverseSelf();
  case 4:
   return reinterpret_cast<idMat4 *>(mat)->InverseSelf();
  case 5:
   return reinterpret_cast<idMat5 *>(mat)->InverseSelf();
  case 6:
   return reinterpret_cast<idMat6 *>(mat)->InverseSelf();
  default:
   return InverseSelfGeneric();
 }
}

inline idMatX idMatX::InverseFast( void ) const {
 idMatX invMat;

 invMat.SetTempSize( numRows, numColumns );
 memcpy( invMat.mat, mat, numRows * numColumns * sizeof( float ) );
 invMat.InverseFastSelf();

 return invMat;
}

inline bool idMatX::InverseFastSelf( void ) {

 ((void)0);

 switch( numRows ) {
  case 1:
   if ( idMath::Fabs( mat[0] ) < 1e-14 ) {
    return false;
   }
   mat[0] = 1.0f / mat[0];
   return true;
  case 2:
   return reinterpret_cast<idMat2 *>(mat)->InverseFastSelf();
  case 3:
   return reinterpret_cast<idMat3 *>(mat)->InverseFastSelf();
  case 4:
   return reinterpret_cast<idMat4 *>(mat)->InverseFastSelf();
  case 5:
   return reinterpret_cast<idMat5 *>(mat)->InverseFastSelf();
  case 6:
   return reinterpret_cast<idMat6 *>(mat)->InverseFastSelf();
  default:
   return InverseSelfGeneric();
 }
 return false;
}

inline idVecX idMatX::Multiply( const idVecX &vec ) const {
 idVecX dst;

 ((void)0);

 dst.SetTempSize( numRows );

 SIMDProcessor->MatX_MultiplyVecX( dst, *this, vec );



 return dst;
}

inline idMatX idMatX::Multiply( const idMatX &a ) const {
 idMatX dst;

 ((void)0);

 dst.SetTempSize( numRows, a.numColumns );

 SIMDProcessor->MatX_MultiplyMatX( dst, *this, a );



 return dst;
}

inline idVecX idMatX::TransposeMultiply( const idVecX &vec ) const {
 idVecX dst;

 ((void)0);

 dst.SetTempSize( numColumns );

 SIMDProcessor->MatX_TransposeMultiplyVecX( dst, *this, vec );



 return dst;
}

inline idMatX idMatX::TransposeMultiply( const idMatX &a ) const {
 idMatX dst;

 ((void)0);

 dst.SetTempSize( numColumns, a.numColumns );

 SIMDProcessor->MatX_TransposeMultiplyMatX( dst, *this, a );



 return dst;
}

inline void idMatX::Multiply( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_MultiplyVecX( dst, *this, vec );
# 2731 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::MultiplyAdd( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_MultiplyAddVecX( dst, *this, vec );
# 2753 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::MultiplySub( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_MultiplySubVecX( dst, *this, vec );
# 2775 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::TransposeMultiply( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_TransposeMultiplyVecX( dst, *this, vec );
# 2797 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::TransposeMultiplyAdd( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_TransposeMultiplyAddVecX( dst, *this, vec );
# 2819 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::TransposeMultiplySub( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_TransposeMultiplySubVecX( dst, *this, vec );
# 2841 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::Multiply( idMatX &dst, const idMatX &a ) const {

 SIMDProcessor->MatX_MultiplyMatX( dst, *this, a );
# 2873 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::TransposeMultiply( idMatX &dst, const idMatX &a ) const {

 SIMDProcessor->MatX_TransposeMultiplyMatX( dst, *this, a );
# 2905 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Matrix.h"
}

inline int idMatX::GetDimension( void ) const {
 return numRows * numColumns;
}

inline const idVec6 &idMatX::SubVec6( int row ) const {
 ((void)0);
 return *reinterpret_cast<const idVec6 *>(mat + row * numColumns);
}

inline idVec6 &idMatX::SubVec6( int row ) {
 ((void)0);
 return *reinterpret_cast<idVec6 *>(mat + row * numColumns);
}

inline const idVecX idMatX::SubVecX( int row ) const {
 idVecX v;
 ((void)0);
 v.SetData( numColumns, mat + row * numColumns );
 return v;
}

inline idVecX idMatX::SubVecX( int row ) {
 idVecX v;
 ((void)0);
 v.SetData( numColumns, mat + row * numColumns );
 return v;
}

inline const float *idMatX::ToFloatPtr( void ) const {
 return mat;
}

inline float *idMatX::ToFloatPtr( void ) {
 return mat;
}
# 180 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Angles.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Angles.h"
class idVec3;
class idQuat;
class idRotation;
class idMat3;
class idMat4;

class idAngles {
public:
 float pitch;
 float yaw;
 float roll;

     idAngles( void );
     idAngles( float pitch, float yaw, float roll );
     explicit idAngles( const idVec3 &v );

 void Set( float pitch, float yaw, float roll );
 idAngles & Zero( void );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idAngles operator-() const;
 idAngles & operator=( const idAngles &a );
 idAngles operator+( const idAngles &a ) const;
 idAngles & operator+=( const idAngles &a );
 idAngles operator-( const idAngles &a ) const;
 idAngles & operator-=( const idAngles &a );
 idAngles operator*( const float a ) const;
 idAngles & operator*=( const float a );
 idAngles operator/( const float a ) const;
 idAngles & operator/=( const float a );

 friend idAngles operator*( const float a, const idAngles &b );

 bool Compare( const idAngles &a ) const;
 bool Compare( const idAngles &a, const float epsilon ) const;
 bool operator==( const idAngles &a ) const;
 bool operator!=( const idAngles &a ) const;

 idAngles & Normalize360( void );
 idAngles & Normalize180( void );

 void Clamp( const idAngles &min, const idAngles &max );

 int GetDimension( void ) const;

 void ToVectors( idVec3 *forward, idVec3 *right = __null, idVec3 *up = __null ) const;
 idVec3 ToForward( void ) const;
 idQuat ToQuat( void ) const;
 idRotation ToRotation( void ) const;
 idMat3 ToMat3( void ) const;
 idMat4 ToMat4( void ) const;
 idVec3 ToAngularVelocity( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;
};

extern idAngles ang_zero;

inline idAngles::idAngles( void ) {
}

inline idAngles::idAngles( float pitch, float yaw, float roll ) {
 this->pitch = pitch;
 this->yaw = yaw;
 this->roll = roll;
}

inline idAngles::idAngles( const idVec3 &v ) {
 this->pitch = v[0];
 this->yaw = v[1];
 this->roll = v[2];
}

inline void idAngles::Set( float pitch, float yaw, float roll ) {
 this->pitch = pitch;
 this->yaw = yaw;
 this->roll = roll;
}

inline idAngles &idAngles::Zero( void ) {
 pitch = yaw = roll = 0.0f;
 return *this;
}

inline float idAngles::operator[]( int index ) const {
 ((void)0);
 return ( &pitch )[ index ];
}

inline float &idAngles::operator[]( int index ) {
 ((void)0);
 return ( &pitch )[ index ];
}

inline idAngles idAngles::operator-() const {
 return idAngles( -pitch, -yaw, -roll );
}

inline idAngles &idAngles::operator=( const idAngles &a ) {
 pitch = a.pitch;
 yaw = a.yaw;
 roll = a.roll;
 return *this;
}

inline idAngles idAngles::operator+( const idAngles &a ) const {
 return idAngles( pitch + a.pitch, yaw + a.yaw, roll + a.roll );
}

inline idAngles& idAngles::operator+=( const idAngles &a ) {
 pitch += a.pitch;
 yaw += a.yaw;
 roll += a.roll;

 return *this;
}

inline idAngles idAngles::operator-( const idAngles &a ) const {
 return idAngles( pitch - a.pitch, yaw - a.yaw, roll - a.roll );
}

inline idAngles& idAngles::operator-=( const idAngles &a ) {
 pitch -= a.pitch;
 yaw -= a.yaw;
 roll -= a.roll;

 return *this;
}

inline idAngles idAngles::operator*( const float a ) const {
 return idAngles( pitch * a, yaw * a, roll * a );
}

inline idAngles& idAngles::operator*=( float a ) {
 pitch *= a;
 yaw *= a;
 roll *= a;
 return *this;
}

inline idAngles idAngles::operator/( const float a ) const {
 float inva = 1.0f / a;
 return idAngles( pitch * inva, yaw * inva, roll * inva );
}

inline idAngles& idAngles::operator/=( float a ) {
 float inva = 1.0f / a;
 pitch *= inva;
 yaw *= inva;
 roll *= inva;
 return *this;
}

inline idAngles operator*( const float a, const idAngles &b ) {
 return idAngles( a * b.pitch, a * b.yaw, a * b.roll );
}

inline bool idAngles::Compare( const idAngles &a ) const {
 return ( ( a.pitch == pitch ) && ( a.yaw == yaw ) && ( a.roll == roll ) );
}

inline bool idAngles::Compare( const idAngles &a, const float epsilon ) const {
 if ( idMath::Fabs( pitch - a.pitch ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( yaw - a.yaw ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( roll - a.roll ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idAngles::operator==( const idAngles &a ) const {
 return Compare( a );
}

inline bool idAngles::operator!=( const idAngles &a ) const {
 return !Compare( a );
}

inline void idAngles::Clamp( const idAngles &min, const idAngles &max ) {
 if ( pitch < min.pitch ) {
  pitch = min.pitch;
 } else if ( pitch > max.pitch ) {
  pitch = max.pitch;
 }
 if ( yaw < min.yaw ) {
  yaw = min.yaw;
 } else if ( yaw > max.yaw ) {
  yaw = max.yaw;
 }
 if ( roll < min.roll ) {
  roll = min.roll;
 } else if ( roll > max.roll ) {
  roll = max.roll;
 }
}

inline int idAngles::GetDimension( void ) const {
 return 3;
}

inline const float *idAngles::ToFloatPtr( void ) const {
 return &pitch;
}

inline float *idAngles::ToFloatPtr( void ) {
 return &pitch;
}
# 181 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Quat.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Quat.h"
class idVec3;
class idAngles;
class idRotation;
class idMat3;
class idMat4;
class idCQuat;

class idQuat {
public:
 float x;
 float y;
 float z;
 float w;

     idQuat( void );
     idQuat( float x, float y, float z, float w );

 void Set( float x, float y, float z, float w );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idQuat operator-() const;
 idQuat & operator=( const idQuat &a );
 idQuat operator+( const idQuat &a ) const;
 idQuat & operator+=( const idQuat &a );
 idQuat operator-( const idQuat &a ) const;
 idQuat & operator-=( const idQuat &a );
 idQuat operator*( const idQuat &a ) const;
 idVec3 operator*( const idVec3 &a ) const;
 idQuat operator*( float a ) const;
 idQuat & operator*=( const idQuat &a );
 idQuat & operator*=( float a );

 friend idQuat operator*( const float a, const idQuat &b );
 friend idVec3 operator*( const idVec3 &a, const idQuat &b );

 bool Compare( const idQuat &a ) const;
 bool Compare( const idQuat &a, const float epsilon ) const;
 bool operator==( const idQuat &a ) const;
 bool operator!=( const idQuat &a ) const;

 idQuat Inverse( void ) const;
 float Length( void ) const;
 idQuat & Normalize( void );

 float CalcW( void ) const;
 int GetDimension( void ) const;

 idAngles ToAngles( void ) const;
 idRotation ToRotation( void ) const;
 idMat3 ToMat3( void ) const;
 idMat4 ToMat4( void ) const;
 idCQuat ToCQuat( void ) const;
 idVec3 ToAngularVelocity( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 idQuat & Slerp( const idQuat &from, const idQuat &to, float t );
};

inline idQuat::idQuat( void ) {
}

inline idQuat::idQuat( float x, float y, float z, float w ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->w = w;
}

inline float idQuat::operator[]( int index ) const {
 ((void)0);
 return ( &x )[ index ];
}

inline float& idQuat::operator[]( int index ) {
 ((void)0);
 return ( &x )[ index ];
}

inline idQuat idQuat::operator-() const {
 return idQuat( -x, -y, -z, -w );
}

inline idQuat &idQuat::operator=( const idQuat &a ) {
 x = a.x;
 y = a.y;
 z = a.z;
 w = a.w;

 return *this;
}

inline idQuat idQuat::operator+( const idQuat &a ) const {
 return idQuat( x + a.x, y + a.y, z + a.z, w + a.w );
}

inline idQuat& idQuat::operator+=( const idQuat &a ) {
 x += a.x;
 y += a.y;
 z += a.z;
 w += a.w;

 return *this;
}

inline idQuat idQuat::operator-( const idQuat &a ) const {
 return idQuat( x - a.x, y - a.y, z - a.z, w - a.w );
}

inline idQuat& idQuat::operator-=( const idQuat &a ) {
 x -= a.x;
 y -= a.y;
 z -= a.z;
 w -= a.w;

 return *this;
}

inline idQuat idQuat::operator*( const idQuat &a ) const {
 return idQuat( w*a.x + x*a.w + y*a.z - z*a.y,
     w*a.y + y*a.w + z*a.x - x*a.z,
     w*a.z + z*a.w + x*a.y - y*a.x,
     w*a.w - x*a.x - y*a.y - z*a.z );
}

inline idVec3 idQuat::operator*( const idVec3 &a ) const {





 float xxzz = x*x - z*z;
 float wwyy = w*w - y*y;

 float xw2 = x*w*2.0f;
 float xy2 = x*y*2.0f;
 float xz2 = x*z*2.0f;
 float yw2 = y*w*2.0f;
 float yz2 = y*z*2.0f;
 float zw2 = z*w*2.0f;

 return idVec3(
  (xxzz + wwyy)*a.x + (xy2 + zw2)*a.y + (xz2 - yw2)*a.z,
  (xy2 - zw2)*a.x + (y*y+w*w-x*x-z*z)*a.y + (yz2 + xw2)*a.z,
  (xz2 + yw2)*a.x + (yz2 - xw2)*a.y + (wwyy - xxzz)*a.z
 );

}

inline idQuat idQuat::operator*( float a ) const {
 return idQuat( x * a, y * a, z * a, w * a );
}

inline idQuat operator*( const float a, const idQuat &b ) {
 return b * a;
}

inline idVec3 operator*( const idVec3 &a, const idQuat &b ) {
 return b * a;
}

inline idQuat& idQuat::operator*=( const idQuat &a ) {
 *this = *this * a;

 return *this;
}

inline idQuat& idQuat::operator*=( float a ) {
 x *= a;
 y *= a;
 z *= a;
 w *= a;

 return *this;
}

inline bool idQuat::Compare( const idQuat &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) && ( z == a.z ) && ( w == a.w ) );
}

inline bool idQuat::Compare( const idQuat &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( z - a.z ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( w - a.w ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idQuat::operator==( const idQuat &a ) const {
 return Compare( a );
}

inline bool idQuat::operator!=( const idQuat &a ) const {
 return !Compare( a );
}

inline void idQuat::Set( float x, float y, float z, float w ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->w = w;
}

inline idQuat idQuat::Inverse( void ) const {
 return idQuat( -x, -y, -z, w );
}

inline float idQuat::Length( void ) const {
 float len;

 len = x * x + y * y + z * z + w * w;
 return idMath::Sqrt( len );
}

inline idQuat& idQuat::Normalize( void ) {
 float len;
 float ilength;

 len = this->Length();
 if ( len ) {
  ilength = 1 / len;
  x *= ilength;
  y *= ilength;
  z *= ilength;
  w *= ilength;
 }
 return *this;
}

inline float idQuat::CalcW( void ) const {

 return sqrt( fabs( 1.0f - ( x * x + y * y + z * z ) ) );
}

inline int idQuat::GetDimension( void ) const {
 return 4;
}

inline const float *idQuat::ToFloatPtr( void ) const {
 return &x;
}

inline float *idQuat::ToFloatPtr( void ) {
 return &x;
}
# 306 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Quat.h"
class idCQuat {
public:
 float x;
 float y;
 float z;

     idCQuat( void );
     idCQuat( float x, float y, float z );

 void Set( float x, float y, float z );

 float operator[]( int index ) const;
 float & operator[]( int index );

 bool Compare( const idCQuat &a ) const;
 bool Compare( const idCQuat &a, const float epsilon ) const;
 bool operator==( const idCQuat &a ) const;
 bool operator!=( const idCQuat &a ) const;

 int GetDimension( void ) const;

 idAngles ToAngles( void ) const;
 idRotation ToRotation( void ) const;
 idMat3 ToMat3( void ) const;
 idMat4 ToMat4( void ) const;
 idQuat ToQuat( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;
};

inline idCQuat::idCQuat( void ) {
}

inline idCQuat::idCQuat( float x, float y, float z ) {
 this->x = x;
 this->y = y;
 this->z = z;
}

inline void idCQuat::Set( float x, float y, float z ) {
 this->x = x;
 this->y = y;
 this->z = z;
}

inline float idCQuat::operator[]( int index ) const {
 ((void)0);
 return ( &x )[ index ];
}

inline float& idCQuat::operator[]( int index ) {
 ((void)0);
 return ( &x )[ index ];
}

inline bool idCQuat::Compare( const idCQuat &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) && ( z == a.z ) );
}

inline bool idCQuat::Compare( const idCQuat &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( z - a.z ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idCQuat::operator==( const idCQuat &a ) const {
 return Compare( a );
}

inline bool idCQuat::operator!=( const idCQuat &a ) const {
 return !Compare( a );
}

inline int idCQuat::GetDimension( void ) const {
 return 3;
}

inline idQuat idCQuat::ToQuat( void ) const {

 return idQuat( x, y, z, sqrt( fabs( 1.0f - ( x * x + y * y + z * z ) ) ) );
}

inline const float *idCQuat::ToFloatPtr( void ) const {
 return &x;
}

inline float *idCQuat::ToFloatPtr( void ) {
 return &x;
}
# 182 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Rotation.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Rotation.h"
class idAngles;
class idQuat;
class idMat3;

class idRotation {

 friend class idAngles;
 friend class idQuat;
 friend class idMat3;

public:
      idRotation( void );
      idRotation( const idVec3 &rotationOrigin, const idVec3 &rotationVec, const float rotationAngle );

 void Set( const idVec3 &rotationOrigin, const idVec3 &rotationVec, const float rotationAngle );
 void SetOrigin( const idVec3 &rotationOrigin );
 void SetVec( const idVec3 &rotationVec );
 void SetVec( const float x, const float y, const float z );
 void SetAngle( const float rotationAngle );
 void Scale( const float s );
 void ReCalculateMatrix( void );
 const idVec3 & GetOrigin( void ) const;
 const idVec3 & GetVec( void ) const;
 float GetAngle( void ) const;

 idRotation operator-() const;
 idRotation operator*( const float s ) const;
 idRotation operator/( const float s ) const;
 idRotation & operator*=( const float s );
 idRotation & operator/=( const float s );
 idVec3 operator*( const idVec3 &v ) const;

 friend idRotation operator*( const float s, const idRotation &r );
 friend idVec3 operator*( const idVec3 &v, const idRotation &r );
 friend idVec3 & operator*=( idVec3 &v, const idRotation &r );

 idAngles ToAngles( void ) const;
 idQuat ToQuat( void ) const;
 const idMat3 & ToMat3( void ) const;
 idMat4 ToMat4( void ) const;
 idVec3 ToAngularVelocity( void ) const;

 void RotatePoint( idVec3 &point ) const;

 void Normalize180( void );
 void Normalize360( void );

private:
 idVec3 origin;
 idVec3 vec;
 float angle;
 mutable idMat3 axis;
 mutable bool axisValid;
};


inline idRotation::idRotation( void ) {
}

inline idRotation::idRotation( const idVec3 &rotationOrigin, const idVec3 &rotationVec, const float rotationAngle ) {
 origin = rotationOrigin;
 vec = rotationVec;
 angle = rotationAngle;
 axisValid = false;
}

inline void idRotation::Set( const idVec3 &rotationOrigin, const idVec3 &rotationVec, const float rotationAngle ) {
 origin = rotationOrigin;
 vec = rotationVec;
 angle = rotationAngle;
 axisValid = false;
}

inline void idRotation::SetOrigin( const idVec3 &rotationOrigin ) {
 origin = rotationOrigin;
}

inline void idRotation::SetVec( const idVec3 &rotationVec ) {
 vec = rotationVec;
 axisValid = false;
}

inline void idRotation::SetVec( float x, float y, float z ) {
 vec[0] = x;
 vec[1] = y;
 vec[2] = z;
 axisValid = false;
}

inline void idRotation::SetAngle( const float rotationAngle ) {
 angle = rotationAngle;
 axisValid = false;
}

inline void idRotation::Scale( const float s ) {
 angle *= s;
 axisValid = false;
}

inline void idRotation::ReCalculateMatrix( void ) {
 axisValid = false;
 ToMat3();
}

inline const idVec3 &idRotation::GetOrigin( void ) const {
 return origin;
}

inline const idVec3 &idRotation::GetVec( void ) const {
 return vec;
}

inline float idRotation::GetAngle( void ) const {
 return angle;
}

inline idRotation idRotation::operator-() const {
 return idRotation( origin, vec, -angle );
}

inline idRotation idRotation::operator*( const float s ) const {
 return idRotation( origin, vec, angle * s );
}

inline idRotation idRotation::operator/( const float s ) const {
 ((void)0);
 return idRotation( origin, vec, angle / s );
}

inline idRotation &idRotation::operator*=( const float s ) {
 angle *= s;
 axisValid = false;
 return *this;
}

inline idRotation &idRotation::operator/=( const float s ) {
 ((void)0);
 angle /= s;
 axisValid = false;
 return *this;
}

inline idVec3 idRotation::operator*( const idVec3 &v ) const {
 if ( !axisValid ) {
  ToMat3();
 }
 return ((v - origin) * axis + origin);
}

inline idRotation operator*( const float s, const idRotation &r ) {
 return r * s;
}

inline idVec3 operator*( const idVec3 &v, const idRotation &r ) {
 return r * v;
}

inline idVec3 &operator*=( idVec3 &v, const idRotation &r ) {
 v = r * v;
 return v;
}

inline void idRotation::RotatePoint( idVec3 &point ) const {
 if ( !axisValid ) {
  ToMat3();
 }
 point = ((point - origin) * axis + origin);
}
# 183 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Plane.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Plane.h"
class idVec3;
class idMat3;
# 71 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Plane.h"
class idPlane {
public:
     idPlane( void );
     idPlane( float a, float b, float c, float d );
     idPlane( const idVec3 &normal, const float dist );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idPlane operator-() const;
 idPlane & operator=( const idVec3 &v );
 idPlane operator+( const idPlane &p ) const;
 idPlane operator-( const idPlane &p ) const;
 idPlane & operator*=( const idMat3 &m );

 bool Compare( const idPlane &p ) const;
 bool Compare( const idPlane &p, const float epsilon ) const;
 bool Compare( const idPlane &p, const float normalEps, const float distEps ) const;
 bool operator==( const idPlane &p ) const;
 bool operator!=( const idPlane &p ) const;

 void Zero( void );
 void SetNormal( const idVec3 &normal );
 const idVec3 & Normal( void ) const;
 idVec3 & Normal( void );
 float Normalize( bool fixDegenerate = true );
 bool FixDegenerateNormal( void );
 bool FixDegeneracies( float distEpsilon );
 float Dist( void ) const;
 void SetDist( const float dist );
 int Type( void ) const;

 bool FromPoints( const idVec3 &p1, const idVec3 &p2, const idVec3 &p3, bool fixDegenerate = true );
 bool FromVecs( const idVec3 &dir1, const idVec3 &dir2, const idVec3 &p, bool fixDegenerate = true );
 void FitThroughPoint( const idVec3 &p );
 bool HeightFit( const idVec3 *points, const int numPoints );
 idPlane Translate( const idVec3 &translation ) const;
 idPlane & TranslateSelf( const idVec3 &translation );
 idPlane Rotate( const idVec3 &origin, const idMat3 &axis ) const;
 idPlane & RotateSelf( const idVec3 &origin, const idMat3 &axis );

 float Distance( const idVec3 &v ) const;
 int Side( const idVec3 &v, const float epsilon = 0.0f ) const;

 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale ) const;
 bool PlaneIntersection( const idPlane &plane, idVec3 &start, idVec3 &dir ) const;

 int GetDimension( void ) const;

 const idVec4 & ToVec4( void ) const;
 idVec4 & ToVec4( void );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 float a;
 float b;
 float c;
 float d;
};

extern idPlane plane_origin;


inline idPlane::idPlane( void ) {
}

inline idPlane::idPlane( float a, float b, float c, float d ) {
 this->a = a;
 this->b = b;
 this->c = c;
 this->d = d;
}

inline idPlane::idPlane( const idVec3 &normal, const float dist ) {
 this->a = normal.x;
 this->b = normal.y;
 this->c = normal.z;
 this->d = -dist;
}

inline float idPlane::operator[]( int index ) const {
 return ( &a )[ index ];
}

inline float& idPlane::operator[]( int index ) {
 return ( &a )[ index ];
}

inline idPlane idPlane::operator-() const {
 return idPlane( -a, -b, -c, -d );
}

inline idPlane &idPlane::operator=( const idVec3 &v ) {
 a = v.x;
 b = v.y;
 c = v.z;
 d = 0;
 return *this;
}

inline idPlane idPlane::operator+( const idPlane &p ) const {
 return idPlane( a + p.a, b + p.b, c + p.c, d + p.d );
}

inline idPlane idPlane::operator-( const idPlane &p ) const {
 return idPlane( a - p.a, b - p.b, c - p.c, d - p.d );
}

inline idPlane &idPlane::operator*=( const idMat3 &m ) {
 Normal() *= m;
 return *this;
}

inline bool idPlane::Compare( const idPlane &p ) const {
 return ( a == p.a && b == p.b && c == p.c && d == p.d );
}

inline bool idPlane::Compare( const idPlane &p, const float epsilon ) const {
 if ( idMath::Fabs( a - p.a ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( b - p.b ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( c - p.c ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( d - p.d ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idPlane::Compare( const idPlane &p, const float normalEps, const float distEps ) const {
 if ( idMath::Fabs( d - p.d ) > distEps ) {
  return false;
 }
 if ( !Normal().Compare( p.Normal(), normalEps ) ) {
  return false;
 }
 return true;
}

inline bool idPlane::operator==( const idPlane &p ) const {
 return Compare( p );
}

inline bool idPlane::operator!=( const idPlane &p ) const {
 return !Compare( p );
}

inline void idPlane::Zero( void ) {
 a = b = c = d = 0.0f;
}

inline void idPlane::SetNormal( const idVec3 &normal ) {
 a = normal.x;
 b = normal.y;
 c = normal.z;
}

inline const idVec3 &idPlane::Normal( void ) const {
 return *reinterpret_cast<const idVec3 *>(&a);
}

inline idVec3 &idPlane::Normal( void ) {
 return *reinterpret_cast<idVec3 *>(&a);
}

inline float idPlane::Normalize( bool fixDegenerate ) {
 float length = reinterpret_cast<idVec3 *>(&a)->Normalize();

 if ( fixDegenerate ) {
  FixDegenerateNormal();
 }
 return length;
}

inline bool idPlane::FixDegenerateNormal( void ) {
 return Normal().FixDegenerateNormal();
}

inline bool idPlane::FixDegeneracies( float distEpsilon ) {
 bool fixedNormal = FixDegenerateNormal();

 if ( fixedNormal ) {
  if ( idMath::Fabs( d - idMath::Rint( d ) ) < distEpsilon ) {
   d = idMath::Rint( d );
  }
 }
 return fixedNormal;
}

inline float idPlane::Dist( void ) const {
 return -d;
}

inline void idPlane::SetDist( const float dist ) {
 d = -dist;
}

inline bool idPlane::FromPoints( const idVec3 &p1, const idVec3 &p2, const idVec3 &p3, bool fixDegenerate ) {
 Normal() = (p1 - p2).Cross( p3 - p2 );
 if ( Normalize( fixDegenerate ) == 0.0f ) {
  return false;
 }
 d = -( Normal() * p2 );
 return true;
}

inline bool idPlane::FromVecs( const idVec3 &dir1, const idVec3 &dir2, const idVec3 &p, bool fixDegenerate ) {
 Normal() = dir1.Cross( dir2 );
 if ( Normalize( fixDegenerate ) == 0.0f ) {
  return false;
 }
 d = -( Normal() * p );
 return true;
}

inline void idPlane::FitThroughPoint( const idVec3 &p ) {
 d = -( Normal() * p );
}

inline idPlane idPlane::Translate( const idVec3 &translation ) const {
 return idPlane( a, b, c, d - translation * Normal() );
}

inline idPlane &idPlane::TranslateSelf( const idVec3 &translation ) {
 d -= translation * Normal();
 return *this;
}

inline idPlane idPlane::Rotate( const idVec3 &origin, const idMat3 &axis ) const {
 idPlane p;
 p.Normal() = Normal() * axis;
 p.d = d + origin * Normal() - origin * p.Normal();
 return p;
}

inline idPlane &idPlane::RotateSelf( const idVec3 &origin, const idMat3 &axis ) {
 d += origin * Normal();
 Normal() *= axis;
 d -= origin * Normal();
 return *this;
}

inline float idPlane::Distance( const idVec3 &v ) const {
 return a * v.x + b * v.y + c * v.z + d;
}

inline int idPlane::Side( const idVec3 &v, const float epsilon ) const {
 float dist = Distance( v );
 if ( dist > epsilon ) {
  return 0;
 }
 else if ( dist < -epsilon ) {
  return 1;
 }
 else {
  return 2;
 }
}

inline bool idPlane::LineIntersection( const idVec3 &start, const idVec3 &end ) const {
 float d1, d2, fraction;

 d1 = Normal() * start + d;
 d2 = Normal() * end + d;
 if ( d1 == d2 ) {
  return false;
 }
 if ( d1 > 0.0f && d2 > 0.0f ) {
  return false;
 }
 if ( d1 < 0.0f && d2 < 0.0f ) {
  return false;
 }
 fraction = ( d1 / ( d1 - d2 ) );
 return ( fraction >= 0.0f && fraction <= 1.0f );
}

inline bool idPlane::RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale ) const {
 float d1, d2;

 d1 = Normal() * start + d;
 d2 = Normal() * dir;
 if ( d2 == 0.0f ) {
  return false;
 }
 scale = -( d1 / d2 );
 return true;
}

inline int idPlane::GetDimension( void ) const {
 return 4;
}

inline const idVec4 &idPlane::ToVec4( void ) const {
 return *reinterpret_cast<const idVec4 *>(&a);
}

inline idVec4 &idPlane::ToVec4( void ) {
 return *reinterpret_cast<idVec4 *>(&a);
}

inline const float *idPlane::ToFloatPtr( void ) const {
 return reinterpret_cast<const float *>(&a);
}

inline float *idPlane::ToFloatPtr( void ) {
 return reinterpret_cast<float *>(&a);
}
# 184 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Pluecker.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Pluecker.h"
class idPluecker {
public:
     idPluecker( void );
     explicit idPluecker( const float *a );
     explicit idPluecker( const idVec3 &start, const idVec3 &end );
     explicit idPluecker( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idPluecker operator-() const;
 idPluecker operator*( const float a ) const;
 idPluecker operator/( const float a ) const;
 float operator*( const idPluecker &a ) const;
 idPluecker operator-( const idPluecker &a ) const;
 idPluecker operator+( const idPluecker &a ) const;
 idPluecker & operator*=( const float a );
 idPluecker & operator/=( const float a );
 idPluecker & operator+=( const idPluecker &a );
 idPluecker & operator-=( const idPluecker &a );

 bool Compare( const idPluecker &a ) const;
 bool Compare( const idPluecker &a, const float epsilon ) const;
 bool operator==( const idPluecker &a ) const;
 bool operator!=( const idPluecker &a ) const;

 void Set( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 );
 void Zero( void );

 void FromLine( const idVec3 &start, const idVec3 &end );
 void FromRay( const idVec3 &start, const idVec3 &dir );
 bool FromPlanes( const idPlane &p1, const idPlane &p2 );
 bool ToLine( idVec3 &start, idVec3 &end ) const;
 bool ToRay( idVec3 &start, idVec3 &dir ) const;
 void ToDir( idVec3 &dir ) const;
 float PermutedInnerProduct( const idPluecker &a ) const;
 float Distance3DSqr( const idPluecker &a ) const;

 float Length( void ) const;
 float LengthSqr( void ) const;
 idPluecker Normalize( void ) const;
 float NormalizeSelf( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 float p[6];
};

extern idPluecker pluecker_origin;


inline idPluecker::idPluecker( void ) {
}

inline idPluecker::idPluecker( const float *a ) {
 memcpy( p, a, 6 * sizeof( float ) );
}

inline idPluecker::idPluecker( const idVec3 &start, const idVec3 &end ) {
 FromLine( start, end );
}

inline idPluecker::idPluecker( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 ) {
 p[0] = a1;
 p[1] = a2;
 p[2] = a3;
 p[3] = a4;
 p[4] = a5;
 p[5] = a6;
}

inline idPluecker idPluecker::operator-() const {
 return idPluecker( -p[0], -p[1], -p[2], -p[3], -p[4], -p[5] );
}

inline float idPluecker::operator[]( const int index ) const {
 return p[index];
}

inline float &idPluecker::operator[]( const int index ) {
 return p[index];
}

inline idPluecker idPluecker::operator*( const float a ) const {
 return idPluecker( p[0]*a, p[1]*a, p[2]*a, p[3]*a, p[4]*a, p[5]*a );
}

inline float idPluecker::operator*( const idPluecker &a ) const {
 return p[0] * a.p[4] + p[1] * a.p[5] + p[2] * a.p[3] + p[4] * a.p[0] + p[5] * a.p[1] + p[3] * a.p[2];
}

inline idPluecker idPluecker::operator/( const float a ) const {
 float inva;

 ((void)0);
 inva = 1.0f / a;
 return idPluecker( p[0]*inva, p[1]*inva, p[2]*inva, p[3]*inva, p[4]*inva, p[5]*inva );
}

inline idPluecker idPluecker::operator+( const idPluecker &a ) const {
 return idPluecker( p[0] + a[0], p[1] + a[1], p[2] + a[2], p[3] + a[3], p[4] + a[4], p[5] + a[5] );
}

inline idPluecker idPluecker::operator-( const idPluecker &a ) const {
 return idPluecker( p[0] - a[0], p[1] - a[1], p[2] - a[2], p[3] - a[3], p[4] - a[4], p[5] - a[5] );
}

inline idPluecker &idPluecker::operator*=( const float a ) {
 p[0] *= a;
 p[1] *= a;
 p[2] *= a;
 p[3] *= a;
 p[4] *= a;
 p[5] *= a;
 return *this;
}

inline idPluecker &idPluecker::operator/=( const float a ) {
 float inva;

 ((void)0);
 inva = 1.0f / a;
 p[0] *= inva;
 p[1] *= inva;
 p[2] *= inva;
 p[3] *= inva;
 p[4] *= inva;
 p[5] *= inva;
 return *this;
}

inline idPluecker &idPluecker::operator+=( const idPluecker &a ) {
 p[0] += a[0];
 p[1] += a[1];
 p[2] += a[2];
 p[3] += a[3];
 p[4] += a[4];
 p[5] += a[5];
 return *this;
}

inline idPluecker &idPluecker::operator-=( const idPluecker &a ) {
 p[0] -= a[0];
 p[1] -= a[1];
 p[2] -= a[2];
 p[3] -= a[3];
 p[4] -= a[4];
 p[5] -= a[5];
 return *this;
}

inline bool idPluecker::Compare( const idPluecker &a ) const {
 return ( ( p[0] == a[0] ) && ( p[1] == a[1] ) && ( p[2] == a[2] ) &&
   ( p[3] == a[3] ) && ( p[4] == a[4] ) && ( p[5] == a[5] ) );
}

inline bool idPluecker::Compare( const idPluecker &a, const float epsilon ) const {
 if ( idMath::Fabs( p[0] - a[0] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[1] - a[1] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[2] - a[2] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[3] - a[3] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[4] - a[4] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[5] - a[5] ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idPluecker::operator==( const idPluecker &a ) const {
 return Compare( a );
}

inline bool idPluecker::operator!=( const idPluecker &a ) const {
 return !Compare( a );
}

inline void idPluecker::Set( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 ) {
 p[0] = a1;
 p[1] = a2;
 p[2] = a3;
 p[3] = a4;
 p[4] = a5;
 p[5] = a6;
}

inline void idPluecker::Zero( void ) {
 p[0] = p[1] = p[2] = p[3] = p[4] = p[5] = 0.0f;
}

inline void idPluecker::FromLine( const idVec3 &start, const idVec3 &end ) {
 p[0] = start[0] * end[1] - end[0] * start[1];
 p[1] = start[0] * end[2] - end[0] * start[2];
 p[2] = start[0] - end[0];
 p[3] = start[1] * end[2] - end[1] * start[2];
 p[4] = start[2] - end[2];
 p[5] = end[1] - start[1];
}

inline void idPluecker::FromRay( const idVec3 &start, const idVec3 &dir ) {
 p[0] = start[0] * dir[1] - dir[0] * start[1];
 p[1] = start[0] * dir[2] - dir[0] * start[2];
 p[2] = -dir[0];
 p[3] = start[1] * dir[2] - dir[1] * start[2];
 p[4] = -dir[2];
 p[5] = dir[1];
}

inline bool idPluecker::ToLine( idVec3 &start, idVec3 &end ) const {
 idVec3 dir1, dir2;
 float d;

 dir1[0] = p[3];
 dir1[1] = -p[1];
 dir1[2] = p[0];

 dir2[0] = -p[2];
 dir2[1] = p[5];
 dir2[2] = -p[4];

 d = dir2 * dir2;
 if ( d == 0.0f ) {
  return false;
 }

 start = dir2.Cross(dir1) * (1.0f / d);
 end = start + dir2;
 return true;
}

inline bool idPluecker::ToRay( idVec3 &start, idVec3 &dir ) const {
 idVec3 dir1;
 float d;

 dir1[0] = p[3];
 dir1[1] = -p[1];
 dir1[2] = p[0];

 dir[0] = -p[2];
 dir[1] = p[5];
 dir[2] = -p[4];

 d = dir * dir;
 if ( d == 0.0f ) {
  return false;
 }

 start = dir.Cross(dir1) * (1.0f / d);
 return true;
}

inline void idPluecker::ToDir( idVec3 &dir ) const {
 dir[0] = -p[2];
 dir[1] = p[5];
 dir[2] = -p[4];
}

inline float idPluecker::PermutedInnerProduct( const idPluecker &a ) const {
 return p[0] * a.p[4] + p[1] * a.p[5] + p[2] * a.p[3] + p[4] * a.p[0] + p[5] * a.p[1] + p[3] * a.p[2];
}

inline float idPluecker::Length( void ) const {
 return ( float )idMath::Sqrt( p[5] * p[5] + p[4] * p[4] + p[2] * p[2] );
}

inline float idPluecker::LengthSqr( void ) const {
 return ( p[5] * p[5] + p[4] * p[4] + p[2] * p[2] );
}

inline float idPluecker::NormalizeSelf( void ) {
 float l, d;

 l = LengthSqr();
 if ( l == 0.0f ) {
  return l;
 }
 d = idMath::InvSqrt( l );
 p[0] *= d;
 p[1] *= d;
 p[2] *= d;
 p[3] *= d;
 p[4] *= d;
 p[5] *= d;
 return d * l;
}

inline idPluecker idPluecker::Normalize( void ) const {
 float d;

 d = LengthSqr();
 if ( d == 0.0f ) {
  return *this;
 }
 d = idMath::InvSqrt( d );
 return idPluecker( p[0]*d, p[1]*d, p[2]*d, p[3]*d, p[4]*d, p[5]*d );
}

inline int idPluecker::GetDimension( void ) const {
 return 6;
}

inline const float *idPluecker::ToFloatPtr( void ) const {
 return p;
}

inline float *idPluecker::ToFloatPtr( void ) {
 return p;
}
# 185 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Polynomial.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Polynomial.h"
class idPolynomial {
public:
     idPolynomial( void );
     explicit idPolynomial( int d );
     explicit idPolynomial( float a, float b );
     explicit idPolynomial( float a, float b, float c );
     explicit idPolynomial( float a, float b, float c, float d );
     explicit idPolynomial( float a, float b, float c, float d, float e );

 float operator[]( int index ) const;
 float & operator[]( int index );

 idPolynomial operator-() const;
 idPolynomial & operator=( const idPolynomial &p );

 idPolynomial operator+( const idPolynomial &p ) const;
 idPolynomial operator-( const idPolynomial &p ) const;
 idPolynomial operator*( const float s ) const;
 idPolynomial operator/( const float s ) const;

 idPolynomial & operator+=( const idPolynomial &p );
 idPolynomial & operator-=( const idPolynomial &p );
 idPolynomial & operator*=( const float s );
 idPolynomial & operator/=( const float s );

 bool Compare( const idPolynomial &p ) const;
 bool Compare( const idPolynomial &p, const float epsilon ) const;
 bool operator==( const idPolynomial &p ) const;
 bool operator!=( const idPolynomial &p ) const;

 void Zero( void );
 void Zero( int d );

 int GetDimension( void ) const;
 int GetDegree( void ) const;
 float GetValue( const float x ) const;
 idComplex GetValue( const idComplex &x ) const;
 idPolynomial GetDerivative( void ) const;
 idPolynomial GetAntiDerivative( void ) const;

 int GetRoots( idComplex *roots ) const;
 int GetRoots( float *roots ) const;

 static int GetRoots1( float a, float b, float *roots );
 static int GetRoots2( float a, float b, float c, float *roots );
 static int GetRoots3( float a, float b, float c, float d, float *roots );
 static int GetRoots4( float a, float b, float c, float d, float e, float *roots );

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 static void Test( void );

private:
 int degree;
 int allocated;
 float * coefficient;

 void Resize( int d, bool keep );
 int Laguer( const idComplex *coef, const int degree, idComplex &r ) const;
};

inline idPolynomial::idPolynomial( void ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
}

inline idPolynomial::idPolynomial( int d ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( d, false );
}

inline idPolynomial::idPolynomial( float a, float b ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( 1, false );
 coefficient[0] = b;
 coefficient[1] = a;
}

inline idPolynomial::idPolynomial( float a, float b, float c ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( 2, false );
 coefficient[0] = c;
 coefficient[1] = b;
 coefficient[2] = a;
}

inline idPolynomial::idPolynomial( float a, float b, float c, float d ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( 3, false );
 coefficient[0] = d;
 coefficient[1] = c;
 coefficient[2] = b;
 coefficient[3] = a;
}

inline idPolynomial::idPolynomial( float a, float b, float c, float d, float e ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( 4, false );
 coefficient[0] = e;
 coefficient[1] = d;
 coefficient[2] = c;
 coefficient[3] = b;
 coefficient[4] = a;
}

inline float idPolynomial::operator[]( int index ) const {
 ((void)0);
 return coefficient[ index ];
}

inline float& idPolynomial::operator[]( int index ) {
 ((void)0);
 return coefficient[ index ];
}

inline idPolynomial idPolynomial::operator-() const {
 int i;
 idPolynomial n;

 n = *this;
 for ( i = 0; i <= degree; i++ ) {
  n[i] = -n[i];
 }
 return n;
}

inline idPolynomial &idPolynomial::operator=( const idPolynomial &p ) {
 Resize( p.degree, false );
 for ( int i = 0; i <= degree; i++ ) {
  coefficient[i] = p.coefficient[i];
 }
 return *this;
}

inline idPolynomial idPolynomial::operator+( const idPolynomial &p ) const {
 int i;
 idPolynomial n;

 if ( degree > p.degree ) {
  n.Resize( degree, false );
  for ( i = 0; i <= p.degree; i++ ) {
   n.coefficient[i] = coefficient[i] + p.coefficient[i];
  }
  for ( ; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i];
  }
  n.degree = degree;
 } else if ( p.degree > degree ) {
  n.Resize( p.degree, false );
  for ( i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] + p.coefficient[i];
  }
  for ( ; i <= p.degree; i++ ) {
   n.coefficient[i] = p.coefficient[i];
  }
  n.degree = p.degree;
 } else {
  n.Resize( degree, false );
  n.degree = 0;
  for ( i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] + p.coefficient[i];
   if ( n.coefficient[i] != 0.0f ) {
    n.degree = i;
   }
  }
 }
 return n;
}

inline idPolynomial idPolynomial::operator-( const idPolynomial &p ) const {
 int i;
 idPolynomial n;

 if ( degree > p.degree ) {
  n.Resize( degree, false );
  for ( i = 0; i <= p.degree; i++ ) {
   n.coefficient[i] = coefficient[i] - p.coefficient[i];
  }
  for ( ; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i];
  }
  n.degree = degree;
 } else if ( p.degree >= degree ) {
  n.Resize( p.degree, false );
  for ( i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] - p.coefficient[i];
  }
  for ( ; i <= p.degree; i++ ) {
   n.coefficient[i] = - p.coefficient[i];
  }
  n.degree = p.degree;
 } else {
  n.Resize( degree, false );
  n.degree = 0;
  for ( i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] - p.coefficient[i];
   if ( n.coefficient[i] != 0.0f ) {
    n.degree = i;
   }
  }
 }
 return n;
}

inline idPolynomial idPolynomial::operator*( const float s ) const {
 idPolynomial n;

 if ( s == 0.0f ) {
  n.degree = 0;
 } else {
  n.Resize( degree, false );
  for ( int i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] * s;
  }
 }
 return n;
}

inline idPolynomial idPolynomial::operator/( const float s ) const {
 float invs;
 idPolynomial n;

 ((void)0);
 n.Resize( degree, false );
 invs = 1.0f / s;
 for ( int i = 0; i <= degree; i++ ) {
  n.coefficient[i] = coefficient[i] * invs;
 }
 return n;
}

inline idPolynomial &idPolynomial::operator+=( const idPolynomial &p ) {
 int i;

 if ( degree > p.degree ) {
  for ( i = 0; i <= p.degree; i++ ) {
   coefficient[i] += p.coefficient[i];
  }
 } else if ( p.degree > degree ) {
  Resize( p.degree, true );
  for ( i = 0; i <= degree; i++ ) {
   coefficient[i] += p.coefficient[i];
  }
  for ( ; i <= p.degree; i++ ) {
   coefficient[i] = p.coefficient[i];
  }
 } else {
  for ( i = 0; i <= degree; i++ ) {
   coefficient[i] += p.coefficient[i];
   if ( coefficient[i] != 0.0f ) {
    degree = i;
   }
  }
 }
 return *this;
}

inline idPolynomial &idPolynomial::operator-=( const idPolynomial &p ) {
 int i;

 if ( degree > p.degree ) {
  for ( i = 0; i <= p.degree; i++ ) {
   coefficient[i] -= p.coefficient[i];
  }
 } else if ( p.degree > degree ) {
  Resize( p.degree, true );
  for ( i = 0; i <= degree; i++ ) {
   coefficient[i] -= p.coefficient[i];
  }
  for ( ; i <= p.degree; i++ ) {
   coefficient[i] = - p.coefficient[i];
  }
 } else {
  for ( i = 0; i <= degree; i++ ) {
   coefficient[i] -= p.coefficient[i];
   if ( coefficient[i] != 0.0f ) {
    degree = i;
   }
  }
 }
 return *this;
}

inline idPolynomial &idPolynomial::operator*=( const float s ) {
 if ( s == 0.0f ) {
  degree = 0;
 } else {
  for ( int i = 0; i <= degree; i++ ) {
   coefficient[i] *= s;
  }
 }
 return *this;
}

inline idPolynomial &idPolynomial::operator/=( const float s ) {
 float invs;

 ((void)0);
 invs = 1.0f / s;
 for ( int i = 0; i <= degree; i++ ) {
  coefficient[i] = invs;
 }
 return *this;;
}

inline bool idPolynomial::Compare( const idPolynomial &p ) const {
 if ( degree != p.degree ) {
  return false;
 }
 for ( int i = 0; i <= degree; i++ ) {
  if ( coefficient[i] != p.coefficient[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idPolynomial::Compare( const idPolynomial &p, const float epsilon ) const {
 if ( degree != p.degree ) {
  return false;
 }
 for ( int i = 0; i <= degree; i++ ) {
  if ( idMath::Fabs( coefficient[i] - p.coefficient[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idPolynomial::operator==( const idPolynomial &p ) const {
 return Compare( p );
}

inline bool idPolynomial::operator!=( const idPolynomial &p ) const {
 return !Compare( p );
}

inline void idPolynomial::Zero( void ) {
 degree = 0;
}

inline void idPolynomial::Zero( int d ) {
 Resize( d, false );
 for ( int i = 0; i <= degree; i++ ) {
  coefficient[i] = 0.0f;
 }
}

inline int idPolynomial::GetDimension( void ) const {
 return degree;
}

inline int idPolynomial::GetDegree( void ) const {
 return degree;
}

inline float idPolynomial::GetValue( const float x ) const {
 float y, z;
 y = coefficient[0];
 z = x;
 for ( int i = 1; i <= degree; i++ ) {
  y += coefficient[i] * z;
  z *= x;
 }
 return y;
}

inline idComplex idPolynomial::GetValue( const idComplex &x ) const {
 idComplex y, z;
 y.Set( coefficient[0], 0.0f );
 z = x;
 for ( int i = 1; i <= degree; i++ ) {
  y += coefficient[i] * z;
  z *= x;
 }
 return y;
}

inline idPolynomial idPolynomial::GetDerivative( void ) const {
 idPolynomial n;

 if ( degree == 0 ) {
  return n;
 }
 n.Resize( degree - 1, false );
 for ( int i = 1; i <= degree; i++ ) {
  n.coefficient[i-1] = i * coefficient[i];
 }
 return n;
}

inline idPolynomial idPolynomial::GetAntiDerivative( void ) const {
 idPolynomial n;

 if ( degree == 0 ) {
  return n;
 }
 n.Resize( degree + 1, false );
 n.coefficient[0] = 0.0f;
 for ( int i = 0; i <= degree; i++ ) {
  n.coefficient[i+1] = coefficient[i] / ( i + 1 );
 }
 return n;
}

inline int idPolynomial::GetRoots1( float a, float b, float *roots ) {
 ((void)0);
 roots[0] = - b / a;
 return 1;
}

inline int idPolynomial::GetRoots2( float a, float b, float c, float *roots ) {
 float inva, ds;

 if ( a != 1.0f ) {
  ((void)0);
  inva = 1.0f / a;
  c *= inva;
  b *= inva;
 }
 ds = b * b - 4.0f * c;
 if ( ds < 0.0f ) {
  return 0;
 } else if ( ds > 0.0f ) {
  ds = idMath::Sqrt( ds );
  roots[0] = 0.5f * ( -b - ds );
  roots[1] = 0.5f * ( -b + ds );
  return 2;
 } else {
  roots[0] = 0.5f * -b;
  return 1;
 }
}

inline int idPolynomial::GetRoots3( float a, float b, float c, float d, float *roots ) {
 float inva, f, g, halfg, ofs, ds, dist, angle, cs, ss, t;

 if ( a != 1.0f ) {
  ((void)0);
  inva = 1.0f / a;
  d *= inva;
  c *= inva;
  b *= inva;
 }

 f = ( 1.0f / 3.0f ) * ( 3.0f * c - b * b );
 g = ( 1.0f / 27.0f ) * ( 2.0f * b * b * b - 9.0f * c * b + 27.0f * d );
 halfg = 0.5f * g;
 ofs = ( 1.0f / 3.0f ) * b;
 ds = 0.25f * g * g + ( 1.0f / 27.0f ) * f * f * f;

 if ( ds < 0.0f ) {
  dist = idMath::Sqrt( ( -1.0f / 3.0f ) * f );
  angle = ( 1.0f / 3.0f ) * idMath::ATan( idMath::Sqrt( -ds ), -halfg );
  cs = idMath::Cos( angle );
  ss = idMath::Sin( angle );
  roots[0] = 2.0f * dist * cs - ofs;
  roots[1] = -dist * ( cs + idMath::SQRT_THREE * ss ) - ofs;
  roots[2] = -dist * ( cs - idMath::SQRT_THREE * ss ) - ofs;
  return 3;
 } else if ( ds > 0.0f ) {
  ds = idMath::Sqrt( ds );
  t = -halfg + ds;
  if ( t >= 0.0f ) {
   roots[0] = idMath::Pow( t, ( 1.0f / 3.0f ) );
  } else {
   roots[0] = -idMath::Pow( -t, ( 1.0f / 3.0f ) );
  }
  t = -halfg - ds;
  if ( t >= 0.0f ) {
   roots[0] += idMath::Pow( t, ( 1.0f / 3.0f ) );
  } else {
   roots[0] -= idMath::Pow( -t, ( 1.0f / 3.0f ) );
  }
  roots[0] -= ofs;
  return 1;
 } else {
  if ( halfg >= 0.0f ) {
   t = -idMath::Pow( halfg, ( 1.0f / 3.0f ) );
  } else {
   t = idMath::Pow( -halfg, ( 1.0f / 3.0f ) );
  }
  roots[0] = 2.0f * t - ofs;
  roots[1] = -t - ofs;
  roots[2] = roots[1];
  return 3;
 }
}

inline int idPolynomial::GetRoots4( float a, float b, float c, float d, float e, float *roots ) {
 int count;
 float inva, y, ds, r, s1, s2, t1, t2, tp, tm;
 float roots3[3];

 if ( a != 1.0f ) {
  ((void)0);
  inva = 1.0f / a;
  e *= inva;
  d *= inva;
  c *= inva;
  b *= inva;
 }

 count = 0;

 GetRoots3( 1.0f, -c, b * d - 4.0f * e, -b * b * e + 4.0f * c * e - d * d, roots3 );
 y = roots3[0];
 ds = 0.25f * b * b - c + y;

 if ( ds < 0.0f ) {
  return 0;
 } else if ( ds > 0.0f ) {
  r = idMath::Sqrt( ds );
  t1 = 0.75f * b * b - r * r - 2.0f * c;
  t2 = ( 4.0f * b * c - 8.0f * d - b * b * b ) / ( 4.0f * r );
  tp = t1 + t2;
  tm = t1 - t2;

  if ( tp >= 0.0f ) {
   s1 = idMath::Sqrt( tp );
   roots[count++] = -0.25f * b + 0.5f * ( r + s1 );
   roots[count++] = -0.25f * b + 0.5f * ( r - s1 );
  }
  if ( tm >= 0.0f ) {
   s2 = idMath::Sqrt( tm );
   roots[count++] = -0.25f * b + 0.5f * ( s2 - r );
   roots[count++] = -0.25f * b - 0.5f * ( s2 + r );
  }
  return count;
 } else {
  t2 = y * y - 4.0f * e;
  if ( t2 >= 0.0f ) {
   t2 = 2.0f * idMath::Sqrt( t2 );
   t1 = 0.75f * b * b - 2.0f * c;
   if ( t1 + t2 >= 0.0f ) {
    s1 = idMath::Sqrt( t1 + t2 );
    roots[count++] = -0.25f * b + 0.5f * s1;
    roots[count++] = -0.25f * b - 0.5f * s1;
   }
   if ( t1 - t2 >= 0.0f ) {
    s2 = idMath::Sqrt( t1 - t2 );
    roots[count++] = -0.25f * b + 0.5f * s2;
    roots[count++] = -0.25f * b - 0.5f * s2;
   }
  }
  return count;
 }
}

inline const float *idPolynomial::ToFloatPtr( void ) const {
 return coefficient;
}

inline float *idPolynomial::ToFloatPtr( void ) {
 return coefficient;
}

inline void idPolynomial::Resize( int d, bool keep ) {
 int alloc = ( d + 1 + 3 ) & ~3;
 if ( alloc > allocated ) {
  float *ptr = (float *) Mem_Alloc16( alloc * sizeof( float ) );
  if ( coefficient != __null ) {
   if ( keep ) {
    for ( int i = 0; i <= degree; i++ ) {
     ptr[i] = coefficient[i];
    }
   }
   Mem_Free16( coefficient );
  }
  allocated = alloc;
  coefficient = ptr;
 }
 degree = d;
}
# 186 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Extrapolate.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Extrapolate.h"
typedef enum {
 EXTRAPOLATION_NONE = 0x01,
 EXTRAPOLATION_LINEAR = 0x02,
 EXTRAPOLATION_ACCELLINEAR = 0x04,
 EXTRAPOLATION_DECELLINEAR = 0x08,
 EXTRAPOLATION_ACCELSINE = 0x10,
 EXTRAPOLATION_DECELSINE = 0x20,
 EXTRAPOLATION_NOSTOP = 0x40
} extrapolation_t;

template< class type >
class idExtrapolate {
public:
      idExtrapolate();

 void Init( const float startTime, const float duration, const type &startValue, const type &baseSpeed, const type &speed, const extrapolation_t extrapolationType );
 type GetCurrentValue( float time ) const;
 type GetCurrentSpeed( float time ) const;
 bool IsDone( float time ) const { return ( !( extrapolationType & EXTRAPOLATION_NOSTOP ) && time >= startTime + duration ); }
 void SetStartTime( float time ) { startTime = time; currentTime = -1; }
 float GetStartTime( void ) const { return startTime; }
 float GetEndTime( void ) const { return ( !( extrapolationType & EXTRAPOLATION_NOSTOP ) && duration > 0 ) ? startTime + duration : 0; }
 float GetDuration( void ) const { return duration; }
 void SetStartValue( const type &value ) { startValue = value; currentTime = -1; }
 const type & GetStartValue( void ) const { return startValue; }
 const type & GetBaseSpeed( void ) const { return baseSpeed; }
 const type & GetSpeed( void ) const { return speed; }
 extrapolation_t GetExtrapolationType( void ) const { return extrapolationType; }

private:
 extrapolation_t extrapolationType;
 float startTime;
 float duration;
 type startValue;
 type baseSpeed;
 type speed;
 mutable float currentTime;
 mutable type currentValue;
};






template< class type >
inline idExtrapolate<type>::idExtrapolate() {
 extrapolationType = EXTRAPOLATION_NONE;
 startTime = duration = 0.0f;
 memset( &startValue, 0, sizeof( startValue ) );
 memset( &baseSpeed, 0, sizeof( baseSpeed ) );
 memset( &speed, 0, sizeof( speed ) );
 currentTime = -1;
 currentValue = startValue;
}






template< class type >
inline void idExtrapolate<type>::Init( const float startTime, const float duration, const type &startValue, const type &baseSpeed, const type &speed, const extrapolation_t extrapolationType ) {
 this->extrapolationType = extrapolationType;
 this->startTime = startTime;
 this->duration = duration;
 this->startValue = startValue;
 this->baseSpeed = baseSpeed;
 this->speed = speed;
 currentTime = -1;
 currentValue = startValue;
}






template< class type >
inline type idExtrapolate<type>::GetCurrentValue( float time ) const {
 float deltaTime, s;

 if ( time == currentTime ) {
  return currentValue;
 }

 currentTime = time;

 if ( time < startTime ) {
  return startValue;
 }

 if ( !( extrapolationType & EXTRAPOLATION_NOSTOP ) && ( time > startTime + duration ) ) {
  time = startTime + duration;
 }

 switch( extrapolationType & ~EXTRAPOLATION_NOSTOP ) {
  case EXTRAPOLATION_NONE: {
   deltaTime = ( time - startTime ) * 0.001f;
   currentValue = startValue + deltaTime * baseSpeed;
   break;
  }
  case EXTRAPOLATION_LINEAR: {
   deltaTime = ( time - startTime ) * 0.001f;
   currentValue = startValue + deltaTime * ( baseSpeed + speed );
   break;
  }
  case EXTRAPOLATION_ACCELLINEAR: {
   if ( !duration ) {
    currentValue = startValue;
   } else {
    deltaTime = ( time - startTime ) / duration;
    s = ( 0.5f * deltaTime * deltaTime ) * ( duration * 0.001f );
    currentValue = startValue + deltaTime * baseSpeed + s * speed;
   }
   break;
  }
  case EXTRAPOLATION_DECELLINEAR: {
   if ( !duration ) {
    currentValue = startValue;
   } else {
    deltaTime = ( time - startTime ) / duration;
    s = ( deltaTime - ( 0.5f * deltaTime * deltaTime ) ) * ( duration * 0.001f );
    currentValue = startValue + deltaTime * baseSpeed + s * speed;
   }
   break;
  }
  case EXTRAPOLATION_ACCELSINE: {
   if ( !duration ) {
    currentValue = startValue;
   } else {
    deltaTime = ( time - startTime ) / duration;
    s = ( 1.0f - idMath::Cos( deltaTime * idMath::HALF_PI ) ) * duration * 0.001f * idMath::SQRT_1OVER2;
    currentValue = startValue + deltaTime * baseSpeed + s * speed;
   }
   break;
  }
  case EXTRAPOLATION_DECELSINE: {
   if ( !duration ) {
    currentValue = startValue;
   } else {
    deltaTime = ( time - startTime ) / duration;
    s = idMath::Sin( deltaTime * idMath::HALF_PI ) * duration * 0.001f * idMath::SQRT_1OVER2;
    currentValue = startValue + deltaTime * baseSpeed + s * speed;
   }
   break;
  }
 }
 return currentValue;
}






template< class type >
inline type idExtrapolate<type>::GetCurrentSpeed( float time ) const {
 float deltaTime, s;

 if ( time < startTime || !duration ) {
  return ( startValue - startValue );
 }

 if ( !( extrapolationType & EXTRAPOLATION_NOSTOP ) && ( time > startTime + duration ) ) {
  return ( startValue - startValue );
 }

 switch( extrapolationType & ~EXTRAPOLATION_NOSTOP ) {
  case EXTRAPOLATION_NONE: {
   return baseSpeed;
  }
  case EXTRAPOLATION_LINEAR: {
   return baseSpeed + speed;
  }
  case EXTRAPOLATION_ACCELLINEAR: {
   deltaTime = ( time - startTime ) / duration;
   s = deltaTime;
   return baseSpeed + s * speed;
  }
  case EXTRAPOLATION_DECELLINEAR: {
   deltaTime = ( time - startTime ) / duration;
   s = 1.0f - deltaTime;
   return baseSpeed + s * speed;
  }
  case EXTRAPOLATION_ACCELSINE: {
   deltaTime = ( time - startTime ) / duration;
   s = idMath::Sin( deltaTime * idMath::HALF_PI );
   return baseSpeed + s * speed;
  }
  case EXTRAPOLATION_DECELSINE: {
   deltaTime = ( time - startTime ) / duration;
   s = idMath::Cos( deltaTime * idMath::HALF_PI );
   return baseSpeed + s * speed;
  }
  default: {
   return baseSpeed;
  }
 }
}
# 187 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Interpolate.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Interpolate.h"
template< class type >
class idInterpolate {
public:
      idInterpolate();

 void Init( const float startTime, const float duration, const type &startValue, const type &endValue );
 void SetStartTime( float time ) { this->startTime = time; }
 void SetDuration( float duration ) { this->duration = duration; }
 void SetStartValue( const type &startValue ) { this->startValue = startValue; }
 void SetEndValue( const type &endValue ) { this->endValue = endValue; }

 type GetCurrentValue( float time ) const;
 bool IsDone( float time ) const { return ( time >= startTime + duration ); }

 float GetStartTime( void ) const { return startTime; }
 float GetEndTime( void ) const { return startTime + duration; }
 float GetDuration( void ) const { return duration; }
 const type & GetStartValue( void ) const { return startValue; }
 const type & GetEndValue( void ) const { return endValue; }

private:
 float startTime;
 float duration;
 type startValue;
 type endValue;
 mutable float currentTime;
 mutable type currentValue;
};






template< class type >
inline idInterpolate<type>::idInterpolate() {
 currentTime = startTime = duration = 0;
 memset( &currentValue, 0, sizeof( currentValue ) );
 startValue = endValue = currentValue;
}






template< class type >
inline void idInterpolate<type>::Init( const float startTime, const float duration, const type &startValue, const type &endValue ) {
 this->startTime = startTime;
 this->duration = duration;
 this->startValue = startValue;
 this->endValue = endValue;
 this->currentTime = startTime - 1;
 this->currentValue = startValue;
}






template< class type >
inline type idInterpolate<type>::GetCurrentValue( float time ) const {
 float deltaTime;

 deltaTime = time - startTime;
 if ( time != currentTime ) {
  currentTime = time;
  if ( deltaTime <= 0 ) {
   currentValue = startValue;
  } else if ( deltaTime >= duration ) {
   currentValue = endValue;
  } else {
   currentValue = startValue + ( endValue - startValue ) * ( (float) deltaTime / duration );
  }
 }
 return currentValue;
}
# 129 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Interpolate.h"
template< class type >
class idInterpolateAccelDecelLinear {
public:
      idInterpolateAccelDecelLinear();

 void Init( const float startTime, const float accelTime, const float decelTime, const float duration, const type &startValue, const type &endValue );
 void SetStartTime( float time ) { startTime = time; Invalidate(); }
 void SetStartValue( const type &startValue ) { this->startValue = startValue; Invalidate(); }
 void SetEndValue( const type &endValue ) { this->endValue = endValue; Invalidate(); }

 type GetCurrentValue( float time ) const;
 type GetCurrentSpeed( float time ) const;
 bool IsDone( float time ) const { return ( time >= startTime + accelTime + linearTime + decelTime ); }

 float GetStartTime( void ) const { return startTime; }
 float GetEndTime( void ) const { return startTime + accelTime + linearTime + decelTime; }
 float GetDuration( void ) const { return accelTime + linearTime + decelTime; }
 float GetAcceleration( void ) const { return accelTime; }
 float GetDeceleration( void ) const { return decelTime; }
 const type & GetStartValue( void ) const { return startValue; }
 const type & GetEndValue( void ) const { return endValue; }

private:
 float startTime;
 float accelTime;
 float linearTime;
 float decelTime;
 type startValue;
 type endValue;
 mutable idExtrapolate<type> extrapolate;

 void Invalidate( void );
 void SetPhase( float time ) const;
};






template< class type >
inline idInterpolateAccelDecelLinear<type>::idInterpolateAccelDecelLinear() {
 startTime = accelTime = linearTime = decelTime = 0;
 memset( &startValue, 0, sizeof( startValue ) );
 endValue = startValue;
}






template< class type >
inline void idInterpolateAccelDecelLinear<type>::Init( const float startTime, const float accelTime, const float decelTime, const float duration, const type &startValue, const type &endValue ) {
 type speed;

 this->startTime = startTime;
 this->accelTime = accelTime;
 this->decelTime = decelTime;
 this->startValue = startValue;
 this->endValue = endValue;

 if ( duration <= 0.0f ) {
  return;
 }

 if ( this->accelTime + this->decelTime > duration ) {
  this->accelTime = this->accelTime * duration / ( this->accelTime + this->decelTime );
  this->decelTime = duration - this->accelTime;
 }
 this->linearTime = duration - this->accelTime - this->decelTime;
 speed = ( endValue - startValue ) * ( 1000.0f / ( (float) this->linearTime + ( this->accelTime + this->decelTime ) * 0.5f ) );

 if ( this->accelTime ) {
  extrapolate.Init( startTime, this->accelTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_ACCELLINEAR );
 } else if ( this->linearTime ) {
  extrapolate.Init( startTime, this->linearTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_LINEAR );
 } else {
  extrapolate.Init( startTime, this->decelTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_DECELLINEAR );
 }
}






template< class type >
inline void idInterpolateAccelDecelLinear<type>::Invalidate( void ) {
 extrapolate.Init( 0, 0, extrapolate.GetStartValue(), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_NONE );
}






template< class type >
inline void idInterpolateAccelDecelLinear<type>::SetPhase( float time ) const {
 float deltaTime;

 deltaTime = time - startTime;
 if ( deltaTime < accelTime ) {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_ACCELLINEAR ) {
   extrapolate.Init( startTime, accelTime, startValue, extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_ACCELLINEAR );
  }
 } else if ( deltaTime < accelTime + linearTime ) {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_LINEAR ) {
   extrapolate.Init( startTime + accelTime, linearTime, startValue + extrapolate.GetSpeed() * ( accelTime * 0.001f * 0.5f ), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_LINEAR );
  }
 } else {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_DECELLINEAR ) {
   extrapolate.Init( startTime + accelTime + linearTime, decelTime, endValue - ( extrapolate.GetSpeed() * ( decelTime * 0.001f * 0.5f ) ), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_DECELLINEAR );
  }
 }
}






template< class type >
inline type idInterpolateAccelDecelLinear<type>::GetCurrentValue( float time ) const {
 SetPhase( time );
 return extrapolate.GetCurrentValue( time );
}






template< class type >
inline type idInterpolateAccelDecelLinear<type>::GetCurrentSpeed( float time ) const {
 SetPhase( time );
 return extrapolate.GetCurrentSpeed( time );
}
# 278 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Interpolate.h"
template< class type >
class idInterpolateAccelDecelSine {
public:
      idInterpolateAccelDecelSine();

 void Init( const float startTime, const float accelTime, const float decelTime, const float duration, const type &startValue, const type &endValue );
 void SetStartTime( float time ) { startTime = time; Invalidate(); }
 void SetStartValue( const type &startValue ) { this->startValue = startValue; Invalidate(); }
 void SetEndValue( const type &endValue ) { this->endValue = endValue; Invalidate(); }

 type GetCurrentValue( float time ) const;
 type GetCurrentSpeed( float time ) const;
 bool IsDone( float time ) const { return ( time >= startTime + accelTime + linearTime + decelTime ); }

 float GetStartTime( void ) const { return startTime; }
 float GetEndTime( void ) const { return startTime + accelTime + linearTime + decelTime; }
 float GetDuration( void ) const { return accelTime + linearTime + decelTime; }
 float GetAcceleration( void ) const { return accelTime; }
 float GetDeceleration( void ) const { return decelTime; }
 const type & GetStartValue( void ) const { return startValue; }
 const type & GetEndValue( void ) const { return endValue; }

private:
 float startTime;
 float accelTime;
 float linearTime;
 float decelTime;
 type startValue;
 type endValue;
 mutable idExtrapolate<type> extrapolate;

 void Invalidate( void );
 void SetPhase( float time ) const;
};






template< class type >
inline idInterpolateAccelDecelSine<type>::idInterpolateAccelDecelSine() {
 startTime = accelTime = linearTime = decelTime = 0;
 memset( &startValue, 0, sizeof( startValue ) );
 endValue = startValue;
}






template< class type >
inline void idInterpolateAccelDecelSine<type>::Init( const float startTime, const float accelTime, const float decelTime, const float duration, const type &startValue, const type &endValue ) {
 type speed;

 this->startTime = startTime;
 this->accelTime = accelTime;
 this->decelTime = decelTime;
 this->startValue = startValue;
 this->endValue = endValue;

 if ( duration <= 0.0f ) {
  return;
 }

 if ( this->accelTime + this->decelTime > duration ) {
  this->accelTime = this->accelTime * duration / ( this->accelTime + this->decelTime );
  this->decelTime = duration - this->accelTime;
 }
 this->linearTime = duration - this->accelTime - this->decelTime;
 speed = ( endValue - startValue ) * ( 1000.0f / ( (float) this->linearTime + ( this->accelTime + this->decelTime ) * idMath::SQRT_1OVER2 ) );

 if ( this->accelTime ) {
  extrapolate.Init( startTime, this->accelTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_ACCELSINE );
 } else if ( this->linearTime ) {
  extrapolate.Init( startTime, this->linearTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_LINEAR );
 } else {
  extrapolate.Init( startTime, this->decelTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_DECELSINE );
 }
}






template< class type >
inline void idInterpolateAccelDecelSine<type>::Invalidate( void ) {
 extrapolate.Init( 0, 0, extrapolate.GetStartValue(), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_NONE );
}






template< class type >
inline void idInterpolateAccelDecelSine<type>::SetPhase( float time ) const {
 float deltaTime;

 deltaTime = time - startTime;
 if ( deltaTime < accelTime ) {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_ACCELSINE ) {
   extrapolate.Init( startTime, accelTime, startValue, extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_ACCELSINE );
  }
 } else if ( deltaTime < accelTime + linearTime ) {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_LINEAR ) {
   extrapolate.Init( startTime + accelTime, linearTime, startValue + extrapolate.GetSpeed() * ( accelTime * 0.001f * idMath::SQRT_1OVER2 ), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_LINEAR );
  }
 } else {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_DECELSINE ) {
   extrapolate.Init( startTime + accelTime + linearTime, decelTime, endValue - ( extrapolate.GetSpeed() * ( decelTime * 0.001f * idMath::SQRT_1OVER2 ) ), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_DECELSINE );
  }
 }
}






template< class type >
inline type idInterpolateAccelDecelSine<type>::GetCurrentValue( float time ) const {
 SetPhase( time );
 return extrapolate.GetCurrentValue( time );
}






template< class type >
inline type idInterpolateAccelDecelSine<type>::GetCurrentSpeed( float time ) const {
 SetPhase( time );
 return extrapolate.GetCurrentSpeed( time );
}
# 188 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve {
public:
      idCurve( void );
 virtual ~idCurve( void );

 virtual int AddValue( const float time, const type &value );
 virtual void RemoveIndex( const int index ) { values.RemoveIndex(index); times.RemoveIndex(index); changed = true; }
 virtual void Clear( void ) { values.Clear(); times.Clear(); currentIndex = -1; changed = true; }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

 virtual bool IsDone( const float time ) const;

 int GetNumValues( void ) const { return values.Num(); }
 void SetValue( const int index, const type &value ) { values[index] = value; changed = true; }
 type GetValue( const int index ) const { return values[index]; }
 type * GetValueAddress( const int index ) { return &values[index]; }
 float GetTime( const int index ) const { return times[index]; }

 float GetLengthForTime( const float time ) const;
 float GetTimeForLength( const float length, const float epsilon = 0.1f ) const;
 float GetLengthBetweenKnots( const int i0, const int i1 ) const;

 void MakeUniform( const float totalTime );
 void SetConstantSpeed( const float totalTime );
 void ShiftTime( const float deltaTime );
 void Translate( const type &translation );

protected:

 idList<float> times;
 idList<type> values;

 mutable int currentIndex;
 mutable bool changed;

 int IndexForTime( const float time ) const;
 float TimeForIndex( const int index ) const;
 type ValueForIndex( const int index ) const;

 float GetSpeed( const float time ) const;
 float RombergIntegral( const float t0, const float t1, const int order ) const;
};






template< class type >
inline idCurve<type>::idCurve( void ) {
 currentIndex = -1;
 changed = false;
}






template< class type >
inline idCurve<type>::~idCurve( void ) {
}
# 115 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve<type>::AddValue( const float time, const type &value ) {
 int i;

 i = IndexForTime( time );
 times.Insert( time, i );
 values.Insert( value, i );
 changed = true;
 return i;
}
# 133 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve<type>::GetCurrentValue( const float time ) const {
 int i;

 i = IndexForTime( time );
 if ( i >= values.Num() ) {
  return values[values.Num() - 1];
 } else {
  return values[i];
 }
}
# 152 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve<type>::GetCurrentFirstDerivative( const float time ) const {
 return ( values[0] - values[0] );
}
# 164 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve<type>::GetCurrentSecondDerivative( const float time ) const {
 return ( values[0] - values[0] );
}






template< class type >
inline bool idCurve<type>::IsDone( const float time ) const {
 return ( time >= times[ times.Num() - 1 ] );
}






template< class type >
inline float idCurve<type>::GetSpeed( const float time ) const {
 int i;
 float speed;
 type value;

 value = GetCurrentFirstDerivative( time );
 for ( speed = 0.0f, i = 0; i < value.GetDimension(); i++ ) {
  speed += value[i] * value[i];
 }
 return idMath::Sqrt( speed );
}






template< class type >
inline float idCurve<type>::RombergIntegral( const float t0, const float t1, const int order ) const {
 int i, j, k, m, n;
 float sum, delta;
 float *temp[2];

 temp[0] = (float *) ((void *)((((int)__builtin_alloca((order * sizeof( float ))+15)) + 15) & ~15));
 temp[1] = (float *) ((void *)((((int)__builtin_alloca((order * sizeof( float ))+15)) + 15) & ~15));

 delta = t1 - t0;
 temp[0][0] = 0.5f * delta * ( GetSpeed( t0 ) + GetSpeed( t1 ) );

 for ( i = 2, m = 1; i <= order; i++, m *= 2, delta *= 0.5f ) {


  sum = 0.0f;
  for ( j = 1; j <= m; j++ ) {
   sum += GetSpeed( t0 + delta * ( j - 0.5f ) );
  }


  temp[1][0] = 0.5f * ( temp[0][0] + delta * sum );
  for ( k = 1, n = 4; k < i; k++, n *= 4 ) {
   temp[1][k] = ( n * temp[1][k-1] - temp[0][k-1] ) / ( n - 1 );
  }

  for ( j = 0; j < i; j++ ) {
   temp[0][j] = temp[1][j];
  }
 }
 return temp[0][order-1];
}






template< class type >
inline float idCurve<type>::GetLengthBetweenKnots( const int i0, const int i1 ) const {
 float length = 0.0f;
 for ( int i = i0; i < i1; i++ ) {
  length += RombergIntegral( times[i], times[i+1], 5 );
 }
 return length;
}






template< class type >
inline float idCurve<type>::GetLengthForTime( const float time ) const {
 float length = 0.0f;
 int index = IndexForTime( time );
 for ( int i = 0; i < index; i++ ) {
  length += RombergIntegral( times[i], times[i+1], 5 );
 }
 length += RombergIntegral( times[index], time, 5 );
 return length;
}






template< class type >
inline float idCurve<type>::GetTimeForLength( const float length, const float epsilon ) const {
 int i, index;
 float *accumLength, totalLength, len0, len1, t, diff;

 if ( length <= 0.0f ) {
  return times[0];
 }

 accumLength = (float *) ((void *)((((int)__builtin_alloca((values.Num() * sizeof( float ))+15)) + 15) & ~15));
 totalLength = 0.0f;
 for ( index = 0; index < values.Num() - 1; index++ ) {
  totalLength += GetLengthBetweenKnots( index, index + 1 );
  accumLength[index] = totalLength;
  if ( length < accumLength[index] ) {
   break;
  }
 }

 if ( index >= values.Num() - 1 ) {
  return times[times.Num() - 1];
 }

 if ( index == 0 ) {
  len0 = length;
  len1 = accumLength[0];
 } else {
  len0 = length - accumLength[index-1];
  len1 = accumLength[index] - accumLength[index-1];
 }


 t = ( times[index+1] - times[index] ) * len0 / len1;
 for ( i = 0; i < 32; i++ ) {
  diff = RombergIntegral( times[index], times[index] + t, 5 ) - len0;
  if ( idMath::Fabs( diff ) <= epsilon ) {
   return times[index] + t;
  }
  t -= diff / GetSpeed( times[index] + t );
 }
 return times[index] + t;
}






template< class type >
inline void idCurve<type>::MakeUniform( const float totalTime ) {
 int i, n;

 n = times.Num() - 1;
 for ( i = 0; i <= n; i++ ) {
  times[i] = i * totalTime / n;
 }
 changed = true;
}






template< class type >
inline void idCurve<type>::SetConstantSpeed( const float totalTime ) {
 int i;
 float *length, totalLength, scale, t;

 length = (float *) ((void *)((((int)__builtin_alloca((values.Num() * sizeof( float ))+15)) + 15) & ~15));
 totalLength = 0.0f;
 for ( i = 0; i < values.Num() - 1; i++ ) {
  length[i] = GetLengthBetweenKnots( i, i + 1 );
  totalLength += length[i];
 }
 scale = totalTime / totalLength;
 for ( t = 0.0f, i = 0; i < times.Num() - 1; i++ ) {
  times[i] = t;
  t += scale * length[i];
 }
 times[times.Num() - 1] = totalTime;
 changed = true;
}






template< class type >
inline void idCurve<type>::ShiftTime( const float deltaTime ) {
 for ( int i = 0; i < times.Num(); i++ ) {
  times[i] += deltaTime;
 }
 changed = true;
}






template< class type >
inline void idCurve<type>::Translate( const type &translation ) {
 for ( int i = 0; i < values.Num(); i++ ) {
  values[i] += translation;
 }
 changed = true;
}
# 387 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve<type>::IndexForTime( const float time ) const {
 int len, mid, offset, res;

 if ( currentIndex >= 0 && currentIndex <= times.Num() ) {

  if ( currentIndex == 0 ) {
   if ( time <= times[currentIndex] ) {
    return currentIndex;
   }
  } else if ( currentIndex == times.Num() ) {
   if ( time > times[currentIndex-1] ) {
    return currentIndex;
   }
  } else if ( time > times[currentIndex-1] && time <= times[currentIndex] ) {
   return currentIndex;
  } else if ( time > times[currentIndex] && ( currentIndex+1 == times.Num() || time <= times[currentIndex+1] ) ) {

   currentIndex++;
   return currentIndex;
  }
 }


 len = times.Num();
 mid = len;
 offset = 0;
 res = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( time == times[offset+mid] ) {
   return offset+mid;
  } else if ( time > times[offset+mid] ) {
   offset += mid;
   len -= mid;
   res = 1;
  } else {
   len -= mid;
   res = 0;
  }
 }
 currentIndex = offset+res;
 return currentIndex;
}
# 439 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve<type>::ValueForIndex( const int index ) const {
 int n = values.Num()-1;

 if ( index < 0 ) {
  return values[0] + index * ( values[1] - values[0] );
 } else if ( index > n ) {
  return values[n] + ( index - n ) * ( values[n] - values[n-1] );
 }
 return values[index];
}
# 458 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve<type>::TimeForIndex( const int index ) const {
 int n = times.Num()-1;

 if ( index < 0 ) {
  return times[0] + index * ( times[1] - times[0] );
 } else if ( index > n ) {
  return times[n] + ( index - n ) * ( times[n] - times[n-1] );
 }
 return times[index];
}
# 480 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_Bezier : public idCurve<type> {
public:
      idCurve_Bezier( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const int order, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int order, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int order, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_Bezier<type>::idCurve_Bezier( void ) {
}
# 511 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_Bezier<type>::GetCurrentValue( const float time ) const {
 int i;
 float *bvals;
 type v;

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));

 Basis( this->values.Num(), time, bvals );
 v = bvals[0] * this->values[0];
 for ( i = 1; i < this->values.Num(); i++ ) {
  v += bvals[i] * this->values[i];
 }
 return v;
}
# 534 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_Bezier<type>::GetCurrentFirstDerivative( const float time ) const {
 int i;
 float *bvals, d;
 type v;

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));

 BasisFirstDerivative( this->values.Num(), time, bvals );
 v = bvals[0] * this->values[0];
 for ( i = 1; i < this->values.Num(); i++ ) {
  v += bvals[i] * this->values[i];
 }
 d = ( this->times[this->times.Num()-1] - this->times[0] );
 return ( (float) (this->values.Num()-1) / d ) * v;
}
# 558 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_Bezier<type>::GetCurrentSecondDerivative( const float time ) const {
 int i;
 float *bvals, d;
 type v;

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));

 BasisSecondDerivative( this->values.Num(), time, bvals );
 v = bvals[0] * this->values[0];
 for ( i = 1; i < this->values.Num(); i++ ) {
  v += bvals[i] * this->values[i];
 }
 d = ( this->times[this->times.Num()-1] - this->times[0] );
 return ( (float) (this->values.Num()-2) * (this->values.Num()-1) / ( d * d ) ) * v;
}
# 582 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_Bezier<type>::Basis( const int order, const float t, float *bvals ) const {
 int i, j, d;
 float *c, c1, c2, s, o, ps, po;

 bvals[0] = 1.0f;
 d = order - 1;
 if ( d <= 0 ) {
  return;
 }

 c = (float *) ((void *)((((int)__builtin_alloca(((d+1) * sizeof( float ))+15)) + 15) & ~15));
 s = (float) ( t - this->times[0] ) / ( this->times[this->times.Num()-1] - this->times[0] );
    o = 1.0f - s;
 ps = s;
 po = o;

 for ( i = 1; i < d; i++ ) {
  c[i] = 1.0f;
 }
 for ( i = 1; i < d; i++ ) {
  c[i-1] = 0.0f;
  c1 = c[i];
  c[i] = 1.0f;
  for ( j = i+1; j <= d; j++ ) {
   c2 = c[j];
   c[j] = c1 + c[j-1];
   c1 = c2;
  }
  bvals[i] = c[d] * ps;
  ps *= s;
 }
 for ( i = d-1; i >= 0; i-- ) {
  bvals[i] *= po;
  po *= o;
 }
 bvals[d] = ps;
}
# 628 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_Bezier<type>::BasisFirstDerivative( const int order, const float t, float *bvals ) const {
 int i;

 Basis( order-1, t, bvals+1 );
 bvals[0] = 0.0f;
 for ( i = 0; i < order-1; i++ ) {
  bvals[i] -= bvals[i+1];
 }
}
# 646 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_Bezier<type>::BasisSecondDerivative( const int order, const float t, float *bvals ) const {
 int i;

 BasisFirstDerivative( order-1, t, bvals+1 );
 bvals[0] = 0.0f;
 for ( i = 0; i < order-1; i++ ) {
  bvals[i] -= bvals[i+1];
 }
}
# 667 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_QuadraticBezier : public idCurve<type> {

public:
      idCurve_QuadraticBezier( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const float t, float *bvals ) const;
 void BasisFirstDerivative( const float t, float *bvals ) const;
 void BasisSecondDerivative( const float t, float *bvals ) const;
};






template< class type >
inline idCurve_QuadraticBezier<type>::idCurve_QuadraticBezier( void ) {
}
# 700 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_QuadraticBezier<type>::GetCurrentValue( const float time ) const {
 float bvals[3];
 ((void)0);
 Basis( time, bvals );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] );
}
# 715 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_QuadraticBezier<type>::GetCurrentFirstDerivative( const float time ) const {
 float bvals[3], d;
 ((void)0);
 BasisFirstDerivative( time, bvals );
 d = ( this->times[2] - this->times[0] );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] ) / d;
}
# 731 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_QuadraticBezier<type>::GetCurrentSecondDerivative( const float time ) const {
 float bvals[3], d;
 ((void)0);
 BasisSecondDerivative( time, bvals );
 d = ( this->times[2] - this->times[0] );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] ) / ( d * d );
}
# 747 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_QuadraticBezier<type>::Basis( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[2] - this->times[0] );
 float s2 = s1 * s1;
 bvals[0] = s2 - 2.0f * s1 + 1.0f;
 bvals[1] = -2.0f * s2 + 2.0f * s1;
 bvals[2] = s2;
}
# 763 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_QuadraticBezier<type>::BasisFirstDerivative( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[2] - this->times[0] );
 bvals[0] = 2.0f * s1 - 2.0f;
 bvals[1] = -4.0f * s1 + 2.0f;
 bvals[2] = 2.0f * s1;
}
# 778 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_QuadraticBezier<type>::BasisSecondDerivative( const float t, float *bvals ) const {

 bvals[0] = 2.0f;
 bvals[1] = -4.0f;
 bvals[2] = 2.0f;
}
# 796 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_CubicBezier : public idCurve<type> {

public:
      idCurve_CubicBezier( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const float t, float *bvals ) const;
 void BasisFirstDerivative( const float t, float *bvals ) const;
 void BasisSecondDerivative( const float t, float *bvals ) const;
};






template< class type >
inline idCurve_CubicBezier<type>::idCurve_CubicBezier( void ) {
}
# 829 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CubicBezier<type>::GetCurrentValue( const float time ) const {
 float bvals[4];
 ((void)0);
 Basis( time, bvals );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] + bvals[3] * this->values[3] );
}
# 844 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CubicBezier<type>::GetCurrentFirstDerivative( const float time ) const {
 float bvals[4], d;
 ((void)0);
 BasisFirstDerivative( time, bvals );
 d = ( this->times[3] - this->times[0] );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] + bvals[3] * this->values[3] ) / d;
}
# 860 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CubicBezier<type>::GetCurrentSecondDerivative( const float time ) const {
 float bvals[4], d;
 ((void)0);
 BasisSecondDerivative( time, bvals );
 d = ( this->times[3] - this->times[0] );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] + bvals[3] * this->values[3] ) / ( d * d );
}
# 876 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CubicBezier<type>::Basis( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[3] - this->times[0] );
 float s2 = s1 * s1;
 float s3 = s2 * s1;
 bvals[0] = -s3 + 3.0f * s2 - 3.0f * s1 + 1.0f;
 bvals[1] = 3.0f * s3 - 6.0f * s2 + 3.0f * s1;
 bvals[2] = -3.0f * s3 + 3.0f * s2;
 bvals[3] = s3;
}
# 894 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CubicBezier<type>::BasisFirstDerivative( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[3] - this->times[0] );
 float s2 = s1 * s1;
 bvals[0] = -3.0f * s2 + 6.0f * s1 - 3.0f;
 bvals[1] = 9.0f * s2 - 12.0f * s1 + 3.0f;
 bvals[2] = -9.0f * s2 + 6.0f * s1;
 bvals[3] = 3.0f * s2;
}
# 911 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CubicBezier<type>::BasisSecondDerivative( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[3] - this->times[0] );
 bvals[0] = -6.0f * s1 + 6.0f;
 bvals[1] = 18.0f * s1 - 12.0f;
 bvals[2] = -18.0f * s1 + 6.0f;
 bvals[3] = 6.0f * s1;
}
# 929 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_Spline : public idCurve<type> {

public:
 enum boundary_t { BT_FREE, BT_CLAMPED, BT_CLOSED };

      idCurve_Spline( void );

 virtual bool IsDone( const float time ) const;

 virtual void SetBoundaryType( const boundary_t bt ) { boundaryType = bt; this->changed = true; }
 virtual boundary_t GetBoundaryType( void ) const { return boundaryType; }

 virtual void SetCloseTime( const float t ) { closeTime = t; this->changed = true; }
 virtual float GetCloseTime( void ) { return boundaryType == BT_CLOSED ? closeTime : 0.0f; }

protected:
 boundary_t boundaryType;
 float closeTime;

 type ValueForIndex( const int index ) const;
 float TimeForIndex( const int index ) const;
 float ClampedTime( const float t ) const;
};






template< class type >
inline idCurve_Spline<type>::idCurve_Spline( void ) {
 boundaryType = BT_FREE;
 closeTime = 0.0f;
}
# 972 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_Spline<type>::ValueForIndex( const int index ) const {
 int n = this->values.Num()-1;

 if ( index < 0 ) {
  if ( boundaryType == BT_CLOSED ) {
   return this->values[ this->values.Num() + index % this->values.Num() ];
  }
  else {
   return this->values[0] + index * ( this->values[1] - this->values[0] );
  }
 }
 else if ( index > n ) {
  if ( boundaryType == BT_CLOSED ) {
   return this->values[ index % this->values.Num() ];
  }
  else {
   return this->values[n] + ( index - n ) * ( this->values[n] - this->values[n-1] );
  }
 }
 return this->values[index];
}
# 1002 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_Spline<type>::TimeForIndex( const int index ) const {
 int n = this->times.Num()-1;

 if ( index < 0 ) {
  if ( boundaryType == BT_CLOSED ) {
   return ( index / this->times.Num() ) * ( this->times[n] + closeTime ) - ( this->times[n] + closeTime - this->times[this->times.Num() + index % this->times.Num()] );
  }
  else {
   return this->times[0] + index * ( this->times[1] - this->times[0] );
  }
 }
 else if ( index > n ) {
  if ( boundaryType == BT_CLOSED ) {
   return ( index / this->times.Num() ) * ( this->times[n] + closeTime ) + this->times[index % this->times.Num()];
  }
  else {
   return this->times[n] + ( index - n ) * ( this->times[n] - this->times[n-1] );
  }
 }
 return this->times[index];
}
# 1032 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_Spline<type>::ClampedTime( const float t ) const {
 if ( boundaryType == BT_CLAMPED ) {
  if ( t < this->times[0] ) {
   return this->times[0];
  }
  else if ( t >= this->times[this->times.Num()-1] ) {
   return this->times[this->times.Num()-1];
  }
 }
 return t;
}






template< class type >
inline bool idCurve_Spline<type>::IsDone( const float time ) const {
 return ( boundaryType != BT_CLOSED && time >= this->times[ this->times.Num() - 1 ] );
}
# 1065 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_NaturalCubicSpline : public idCurve_Spline<type> {
public:
      idCurve_NaturalCubicSpline( void );

 virtual void Clear( void ) { idCurve_Spline<type>::Clear(); this->values.Clear(); b.Clear(); c.Clear(); d.Clear(); }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 mutable idList<type>b;
 mutable idList<type>c;
 mutable idList<type>d;

 void Setup( void ) const;
 void SetupFree( void ) const;
 void SetupClamped( void ) const;
 void SetupClosed( void ) const;
};






template< class type >
inline idCurve_NaturalCubicSpline<type>::idCurve_NaturalCubicSpline( void ) {
}
# 1103 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NaturalCubicSpline<type>::GetCurrentValue( const float time ) const {
 float clampedTime = this->ClampedTime( time );
 int i = this->IndexForTime( clampedTime );
 float s = time - this->TimeForIndex( i );
 Setup();
 return ( this->values[i] + s * ( b[i] + s * ( c[i] + s * d[i] ) ) );
}
# 1119 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NaturalCubicSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 float clampedTime = this->ClampedTime( time );
 int i = this->IndexForTime( clampedTime );
 float s = time - this->TimeForIndex( i );
 Setup();
 return ( b[i] + s * ( 2.0f * c[i] + 3.0f * s * d[i] ) );
}
# 1135 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NaturalCubicSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 float clampedTime = this->ClampedTime( time );
 int i = this->IndexForTime( clampedTime );
 float s = time - this->TimeForIndex( i );
 Setup();
 return ( 2.0f * c[i] + 6.0f * s * d[i] );
}






template< class type >
inline void idCurve_NaturalCubicSpline<type>::Setup( void ) const {
 if ( this->changed ) {
  switch( this->boundaryType ) {
   case idCurve_Spline<type>::BT_FREE: SetupFree(); break;
   case idCurve_Spline<type>::BT_CLAMPED: SetupClamped(); break;
   case idCurve_Spline<type>::BT_CLOSED: SetupClosed(); break;
  }
  this->changed = false;
 }
}






template< class type >
inline void idCurve_NaturalCubicSpline<type>::SetupFree( void ) const {
 int i;
 float inv;
 float *d0, *d1, *beta, *gamma;
 type *alpha, *delta;

 d0 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 d1 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 alpha = (type *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( type ))+15)) + 15) & ~15));
 beta = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));
 gamma = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 delta = (type *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( type ))+15)) + 15) & ~15));

 for ( i = 0; i < this->values.Num() - 1; i++ ) {
  d0[i] = this->times[i+1] - this->times[i];
 }

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  d1[i] = this->times[i+1] - this->times[i-1];
 }

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  type sum = 3.0f * ( d0[i-1] * this->values[i+1] - d1[i] * this->values[i] + d0[i] * this->values[i-1] );
  inv = 1.0f / ( d0[i-1] * d0[i] );
  alpha[i] = inv * sum;
 }

 beta[0] = 1.0f;
 gamma[0] = 0.0f;
 delta[0] = this->values[0] - this->values[0];

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  beta[i] = 2.0f * d1[i] - d0[i-1] * gamma[i-1];
  inv = 1.0f / beta[i];
  gamma[i] = inv * d0[i];
  delta[i] = inv * ( alpha[i] - d0[i-1] * delta[i-1] );
 }
 beta[this->values.Num() - 1] = 1.0f;
 delta[this->values.Num() - 1] = this->values[0] - this->values[0];

 b.AssureSize( this->values.Num() );
 c.AssureSize( this->values.Num() );
 d.AssureSize( this->values.Num() );

 c[this->values.Num() - 1] = this->values[0] - this->values[0];

 for ( i = this->values.Num() - 2; i >= 0; i-- ) {
  c[i] = delta[i] - gamma[i] * c[i+1];
  inv = 1.0f / d0[i];
  b[i] = inv * ( this->values[i+1] - this->values[i] ) - ( 1.0f / 3.0f ) * d0[i] * ( c[i+1] + 2.0f * c[i] );
  d[i] = ( 1.0f / 3.0f ) * inv * ( c[i+1] - c[i] );
 }
}






template< class type >
inline void idCurve_NaturalCubicSpline<type>::SetupClamped( void ) const {
 int i;
 float inv;
 float *d0, *d1, *beta, *gamma;
 type *alpha, *delta;

 d0 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 d1 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 alpha = (type *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( type ))+15)) + 15) & ~15));
 beta = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));
 gamma = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 delta = (type *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( type ))+15)) + 15) & ~15));

 for ( i = 0; i < this->values.Num() - 1; i++ ) {
  d0[i] = this->times[i+1] - this->times[i];
 }

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  d1[i] = this->times[i+1] - this->times[i-1];
 }

 inv = 1.0f / d0[0];
 alpha[0] = 3.0f * ( inv - 1.0f ) * ( this->values[1] - this->values[0] );
 inv = 1.0f / d0[this->values.Num() - 2];
 alpha[this->values.Num() - 1] = 3.0f * ( 1.0f - inv ) * ( this->values[this->values.Num() - 1] - this->values[this->values.Num() - 2] );

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  type sum = 3.0f * ( d0[i-1] * this->values[i+1] - d1[i] * this->values[i] + d0[i] * this->values[i-1] );
  inv = 1.0f / ( d0[i-1] * d0[i] );
  alpha[i] = inv * sum;
 }

 beta[0] = 2.0f * d0[0];
 gamma[0] = 0.5f;
 inv = 1.0f / beta[0];
 delta[0] = inv * alpha[0];

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  beta[i] = 2.0f * d1[i] - d0[i-1] * gamma[i-1];
  inv = 1.0f / beta[i];
  gamma[i] = inv * d0[i];
  delta[i] = inv * ( alpha[i] - d0[i-1] * delta[i-1] );
 }

 beta[this->values.Num() - 1] = d0[this->values.Num() - 2] * ( 2.0f - gamma[this->values.Num() - 2] );
 inv = 1.0f / beta[this->values.Num() - 1];
 delta[this->values.Num() - 1] = inv * ( alpha[this->values.Num() - 1] - d0[this->values.Num() - 2] * delta[this->values.Num() - 2] );

 b.AssureSize( this->values.Num() );
 c.AssureSize( this->values.Num() );
 d.AssureSize( this->values.Num() );

 c[this->values.Num() - 1] = delta[this->values.Num() - 1];

 for ( i = this->values.Num() - 2; i >= 0; i-- ) {
  c[i] = delta[i] - gamma[i] * c[i+1];
  inv = 1.0f / d0[i];
  b[i] = inv * ( this->values[i+1] - this->values[i] ) - ( 1.0f / 3.0f ) * d0[i]* ( c[i+1] + 2.0f * c[i] );
  d[i] = ( 1.0f / 3.0f ) * inv * ( c[i+1] - c[i] );
 }
}






template< class type >
inline void idCurve_NaturalCubicSpline<type>::SetupClosed( void ) const {
 int i, j;
 float c0, c1;
 float *d0;
 idMatX mat;
 idVecX x;

 d0 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 x.SetData( this->values.Num(), ( (float *) ((void *)((((int)__builtin_alloca((( ( ( ( this->values.Num() ) + 3 ) & ~3 ) * sizeof( float ) ))+15)) + 15) & ~15)) ) );
 mat.SetData( this->values.Num(), this->values.Num(), ( (float *) ((void *)((((int)__builtin_alloca((( ( ( ( this->values.Num() * this->values.Num() ) + 3 ) & ~3 ) * sizeof( float ) ))+15)) + 15) & ~15)) ) );

 b.AssureSize( this->values.Num() );
 c.AssureSize( this->values.Num() );
 d.AssureSize( this->values.Num() );

 for ( i = 0; i < this->values.Num() - 1; i++ ) {
  d0[i] = this->times[i+1] - this->times[i];
 }


 mat[0][0] = 1.0f;
 mat[0][this->values.Num() - 1] = -1.0f;
 for ( i = 1; i <= this->values.Num() - 2; i++ ) {
  mat[i][i-1] = d0[i-1];
  mat[i][i ] = 2.0f * ( d0[i-1] + d0[i] );
  mat[i][i+1] = d0[i];
 }
 mat[this->values.Num() - 1][this->values.Num() - 2] = d0[this->values.Num() - 2];
 mat[this->values.Num() - 1][0] = 2.0f * ( d0[this->values.Num() - 2] + d0[0] );
 mat[this->values.Num() - 1][1] = d0[0];


 c[0].Zero();
 for ( i = 1; i <= this->values.Num() - 2; i++ ) {
  c0 = 1.0f / d0[i];
  c1 = 1.0f / d0[i-1];
  c[i] = 3.0f * ( c0 * ( this->values[i + 1] - this->values[i] ) - c1 * ( this->values[i] - this->values[i - 1] ) );
 }
 c0 = 1.0f / d0[0];
 c1 = 1.0f / d0[this->values.Num() - 2];
 c[this->values.Num() - 1] = 3.0f * ( c0 * ( this->values[1] - this->values[0] ) - c1 * ( this->values[0] - this->values[this->values.Num() - 2] ) );


 mat.LU_Factor( __null );
 for ( i = 0; i < this->values[0].GetDimension(); i++ ) {
  for ( j = 0; j < this->values.Num(); j++ ) {
   x[j] = c[j][i];
  }
  mat.LU_Solve( x, x, __null );
  for ( j = 0; j < this->values.Num(); j++ ) {
   c[j][i] = x[j];
  }
 }

 for ( i = 0; i < this->values.Num() - 1; i++ ) {
  c0 = 1.0f / d0[i];
  b[i] = c0 * ( this->values[i + 1] - this->values[i] ) - ( 1.0f / 3.0f ) * ( c[i+1] + 2.0f * c[i] ) * d0[i];
  d[i] = ( 1.0f / 3.0f ) * c0 * ( c[i + 1] - c[i] );
 }
}
# 1366 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_CatmullRomSpline : public idCurve_Spline<type> {

public:
      idCurve_CatmullRomSpline( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const int index, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int index, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int index, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_CatmullRomSpline<type>::idCurve_CatmullRomSpline( void ) {
}
# 1398 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CatmullRomSpline<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float bvals[4], clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 Basis( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 1426 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CatmullRomSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float bvals[4], d, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisFirstDerivative( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / d;
}
# 1455 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CatmullRomSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float bvals[4], d, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisSecondDerivative( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / ( d * d );
}
# 1484 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CatmullRomSpline<type>::Basis( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( ( -s + 2.0f ) * s - 1.0f ) * s * 0.5f;
 bvals[1] = ( ( ( 3.0f * s - 5.0f ) * s ) * s + 2.0f ) * 0.5f;
 bvals[2] = ( ( -3.0f * s + 4.0f ) * s + 1.0f ) * s * 0.5f;
 bvals[3] = ( ( s - 1.0f ) * s * s ) * 0.5f;
}
# 1500 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CatmullRomSpline<type>::BasisFirstDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( -1.5f * s + 2.0f ) * s - 0.5f;
 bvals[1] = ( 4.5f * s - 5.0f ) * s;
 bvals[2] = ( -4.5 * s + 4.0f ) * s + 0.5f;
 bvals[3] = 1.5f * s * s - s;
}
# 1516 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CatmullRomSpline<type>::BasisSecondDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = -3.0f * s + 2.0f;
 bvals[1] = 9.0f * s - 5.0f;
 bvals[2] = -9.0f * s + 4.0f;
 bvals[3] = 3.0f * s - 1.0f;
}
# 1537 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_KochanekBartelsSpline : public idCurve_Spline<type> {

public:
      idCurve_KochanekBartelsSpline( void );

 virtual int AddValue( const float time, const type &value );
 virtual int AddValue( const float time, const type &value, const float tension, const float continuity, const float bias );
 virtual void RemoveIndex( const int index ) { this->values.RemoveIndex(index); this->times.RemoveIndex(index); tension.RemoveIndex(index); continuity.RemoveIndex(index); bias.RemoveIndex(index); }
 virtual void Clear( void ) { this->values.Clear(); this->times.Clear(); tension.Clear(); continuity.Clear(); bias.Clear(); this->currentIndex = -1; }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 idList<float> tension;
 idList<float> continuity;
 idList<float> bias;

 void TangentsForIndex( const int index, type &t0, type &t1 ) const;

 void Basis( const int index, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int index, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int index, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_KochanekBartelsSpline<type>::idCurve_KochanekBartelsSpline( void ) {
}
# 1581 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve_KochanekBartelsSpline<type>::AddValue( const float time, const type &value ) {
 int i;

 i = this->IndexForTime( time );
 this->times.Insert( time, i );
 this->values.Insert( value, i );
 tension.Insert( 0.0f, i );
 continuity.Insert( 0.0f, i );
 bias.Insert( 0.0f, i );
 return i;
}
# 1602 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve_KochanekBartelsSpline<type>::AddValue( const float time, const type &value, const float tension, const float continuity, const float bias ) {
 int i;

 i = this->IndexForTime( time );
 this->times.Insert( time, i );
 this->values.Insert( value, i );
 this->tension.Insert( tension, i );
 this->continuity.Insert( continuity, i );
 this->bias.Insert( bias, i );
 return i;
}
# 1622 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_KochanekBartelsSpline<type>::GetCurrentValue( const float time ) const {
 int i;
 float bvals[4], clampedTime;
 type v, t0, t1;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 TangentsForIndex( i - 1, t0, t1 );
 Basis( i - 1, clampedTime, bvals );
 v = bvals[0] * this->ValueForIndex( i - 1 );
 v += bvals[1] * this->ValueForIndex( i );
 v += bvals[2] * t0;
 v += bvals[3] * t1;
 return v;
}
# 1650 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_KochanekBartelsSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i;
 float bvals[4], d, clampedTime;
 type v, t0, t1;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 TangentsForIndex( i - 1, t0, t1 );
 BasisFirstDerivative( i - 1, clampedTime, bvals );
 v = bvals[0] * this->ValueForIndex( i - 1 );
 v += bvals[1] * this->ValueForIndex( i );
 v += bvals[2] * t0;
 v += bvals[3] * t1;
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / d;
}
# 1679 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_KochanekBartelsSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i;
 float bvals[4], d, clampedTime;
 type v, t0, t1;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 TangentsForIndex( i - 1, t0, t1 );
 BasisSecondDerivative( i - 1, clampedTime, bvals );
 v = bvals[0] * this->ValueForIndex( i - 1 );
 v += bvals[1] * this->ValueForIndex( i );
 v += bvals[2] * t0;
 v += bvals[3] * t1;
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / ( d * d );
}






template< class type >
inline void idCurve_KochanekBartelsSpline<type>::TangentsForIndex( const int index, type &t0, type &t1 ) const {
 float dt, omt, omc, opc, omb, opb, adj, s0, s1;
 type delta;

 delta = this->ValueForIndex( index + 1 ) - this->ValueForIndex( index );
 dt = this->TimeForIndex( index + 1 ) - this->TimeForIndex( index );

 omt = 1.0f - tension[index];
 omc = 1.0f - continuity[index];
 opc = 1.0f + continuity[index];
 omb = 1.0f - bias[index];
 opb = 1.0f + bias[index];
 adj = 2.0f * dt / ( this->TimeForIndex( index + 1 ) - this->TimeForIndex( index - 1 ) );
 s0 = 0.5f * adj * omt * opc * opb;
 s1 = 0.5f * adj * omt * omc * omb;


 t0 = s1 * delta + s0 * ( this->ValueForIndex( index ) - this->ValueForIndex( index - 1 ) );

 omt = 1.0f - tension[index + 1];
 omc = 1.0f - continuity[index + 1];
 opc = 1.0f + continuity[index + 1];
 omb = 1.0f - bias[index + 1];
 opb = 1.0f + bias[index + 1];
 adj = 2.0f * dt / ( this->TimeForIndex( index + 2 ) - this->TimeForIndex( index ) );
 s0 = 0.5f * adj * omt * omc * opb;
 s1 = 0.5f * adj * omt * opc * omb;


 t1 = s1 * ( this->ValueForIndex( index + 2 ) - this->ValueForIndex( index + 1 ) ) + s0 * delta;
}
# 1746 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_KochanekBartelsSpline<type>::Basis( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( ( 2.0f * s - 3.0f ) * s ) * s + 1.0f;
 bvals[1] = ( ( -2.0f * s + 3.0f ) * s ) * s;
 bvals[2] = ( ( s - 2.0f ) * s ) * s + s;
 bvals[3] = ( ( s - 1.0f ) * s ) * s;
}
# 1762 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_KochanekBartelsSpline<type>::BasisFirstDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( 6.0f * s - 6.0f ) * s;
 bvals[1] = ( -6.0f * s + 6.0f ) * s;
 bvals[2] = ( 3.0f * s - 4.0f ) * s + 1.0f;
 bvals[3] = ( 3.0f * s - 2.0f ) * s;
}
# 1778 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_KochanekBartelsSpline<type>::BasisSecondDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = 12.0f * s - 6.0f;
 bvals[1] = -12.0f * s + 6.0f;
 bvals[2] = 6.0f * s - 4.0f;
 bvals[3] = 6.0f * s - 2.0f;
}
# 1797 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_BSpline : public idCurve_Spline<type> {

public:
      idCurve_BSpline( void );

 virtual int GetOrder( void ) const { return order; }
 virtual void SetOrder( const int i ) { ((void)0); order = i; }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 int order;

 float Basis( const int index, const int order, const float t ) const;
 float BasisFirstDerivative( const int index, const int order, const float t ) const;
 float BasisSecondDerivative( const int index, const int order, const float t ) const;
};






template< class type >
inline idCurve_BSpline<type>::idCurve_BSpline( void ) {
 order = 4;
}
# 1835 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_BSpline<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < order; j++ ) {
  k = i + j - ( order >> 1 );
  v += Basis( k-2, order, clampedTime ) * this->ValueForIndex( k );
 }
 return v;
}
# 1862 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_BSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < order; j++ ) {
  k = i + j - ( order >> 1 );
  v += BasisFirstDerivative( k-2, order, clampedTime ) * this->ValueForIndex( k );
 }
 return v;
}
# 1889 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_BSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < order; j++ ) {
  k = i + j - ( order >> 1 );
  v += BasisSecondDerivative( k-2, order, clampedTime ) * this->ValueForIndex( k );
 }
 return v;
}
# 1916 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_BSpline<type>::Basis( const int index, const int order, const float t ) const {
 if ( order <= 1 ) {
  if ( this->TimeForIndex( index ) < t && t <= this->TimeForIndex( index + 1 ) ) {
   return 1.0f;
  } else {
   return 0.0f;
  }
 } else {
  float sum = 0.0f;
  float d1 = this->TimeForIndex( index+order-1 ) - this->TimeForIndex( index );
  if ( d1 != 0.0f ) {
   sum += (float) ( t - this->TimeForIndex( index ) ) * Basis( index, order-1, t ) / d1;
  }

  float d2 = this->TimeForIndex( index+order ) - this->TimeForIndex( index+1 );
  if ( d2 != 0.0f ) {
   sum += (float) ( this->TimeForIndex( index+order ) - t ) * Basis( index+1, order-1, t ) / d2;
  }
  return sum;
 }
}
# 1946 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_BSpline<type>::BasisFirstDerivative( const int index, const int order, const float t ) const {
 return ( Basis( index, order-1, t ) - Basis( index+1, order-1, t ) ) *
   (float) ( order - 1 ) / ( this->TimeForIndex( index + ( order - 1 ) - 2 ) - this->TimeForIndex( index - 2 ) );
}
# 1959 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_BSpline<type>::BasisSecondDerivative( const int index, const int order, const float t ) const {
 return ( BasisFirstDerivative( index, order-1, t ) - BasisFirstDerivative( index+1, order-1, t ) ) *
   (float) ( order - 1 ) / ( this->TimeForIndex( index + ( order - 1 ) - 2 ) - this->TimeForIndex( index - 2 ) );
}
# 1974 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_UniformCubicBSpline : public idCurve_BSpline<type> {

public:
      idCurve_UniformCubicBSpline( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const int index, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int index, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int index, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_UniformCubicBSpline<type>::idCurve_UniformCubicBSpline( void ) {
 this->order = 4;
}
# 2007 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_UniformCubicBSpline<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float bvals[4], clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 Basis( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 2035 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_UniformCubicBSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float bvals[4], d, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisFirstDerivative( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / d;
}
# 2064 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_UniformCubicBSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float bvals[4], d, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisSecondDerivative( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / ( d * d );
}
# 2093 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_UniformCubicBSpline<type>::Basis( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( ( ( -s + 3.0f ) * s - 3.0f ) * s + 1.0f ) * ( 1.0f / 6.0f );
 bvals[1] = ( ( ( 3.0f * s - 6.0f ) * s ) * s + 4.0f ) * ( 1.0f / 6.0f );
 bvals[2] = ( ( ( -3.0f * s + 3.0f ) * s + 3.0f ) * s + 1.0f ) * ( 1.0f / 6.0f );
 bvals[3] = ( s * s * s ) * ( 1.0f / 6.0f );
}
# 2109 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_UniformCubicBSpline<type>::BasisFirstDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = -0.5f * s * s + s - 0.5f;
 bvals[1] = 1.5f * s * s - 2.0f * s;
 bvals[2] = -1.5f * s * s + s + 0.5f;
 bvals[3] = 0.5f * s * s;
}
# 2125 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_UniformCubicBSpline<type>::BasisSecondDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = -s + 1.0f;
 bvals[1] = 3.0f * s - 2.0f;
 bvals[2] = -3.0f * s + 1.0f;
 bvals[3] = s;
}
# 2143 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_NonUniformBSpline : public idCurve_BSpline<type> {

public:
      idCurve_NonUniformBSpline( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const int index, const int order, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int index, const int order, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int index, const int order, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_NonUniformBSpline<type>::idCurve_NonUniformBSpline( void ) {
}
# 2175 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NonUniformBSpline<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;
 float *bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 Basis( i-1, this->order, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 2204 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NonUniformBSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;
 float *bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisFirstDerivative( i-1, this->order, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 2233 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NonUniformBSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;
 float *bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisSecondDerivative( i-1, this->order, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 2262 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_NonUniformBSpline<type>::Basis( const int index, const int order, const float t, float *bvals ) const {
    int r, s, i;
    float omega;

    bvals[order-1] = 1.0f;
    for ( r = 2; r <= order; r++ ) {
  i = index - r + 1;
  bvals[order - r] = 0.0f;
  for ( s = order - r + 1; s < order; s++ ) {
   i++;
   omega = (float) ( t - this->TimeForIndex( i ) ) / ( this->TimeForIndex( i + r - 1 ) - this->TimeForIndex( i ) );
   bvals[s - 1] += ( 1.0f - omega ) * bvals[s];
   bvals[s] *= omega;
  }
    }
}
# 2287 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_NonUniformBSpline<type>::BasisFirstDerivative( const int index, const int order, const float t, float *bvals ) const {
 int i;

 Basis( index, order-1, t, bvals+1 );
 bvals[0] = 0.0f;
 for ( i = 0; i < order-1; i++ ) {
  bvals[i] -= bvals[i+1];
  bvals[i] *= (float) ( order - 1) / ( this->TimeForIndex( index + i + (order-1) - 2 ) - this->TimeForIndex( index + i - 2 ) );
 }
 bvals[i] *= (float) ( order - 1) / ( this->TimeForIndex( index + i + (order-1) - 2 ) - this->TimeForIndex( index + i - 2 ) );
}
# 2307 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_NonUniformBSpline<type>::BasisSecondDerivative( const int index, const int order, const float t, float *bvals ) const {
 int i;

 BasisFirstDerivative( index, order-1, t, bvals+1 );
 bvals[0] = 0.0f;
 for ( i = 0; i < order-1; i++ ) {
  bvals[i] -= bvals[i+1];
  bvals[i] *= (float) ( order - 1) / ( this->TimeForIndex( index + i + (order-1) - 2 ) - this->TimeForIndex( index + i - 2 ) );
 }
 bvals[i] *= (float) ( order - 1) / ( this->TimeForIndex( index + i + (order-1) - 2 ) - this->TimeForIndex( index + i - 2 ) );
}
# 2329 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_NURBS : public idCurve_NonUniformBSpline<type> {

public:
      idCurve_NURBS( void );

 virtual int AddValue( const float time, const type &value );
 virtual int AddValue( const float time, const type &value, const float weight );
 virtual void RemoveIndex( const int index ) { this->values.RemoveIndex(index); this->times.RemoveIndex(index); weights.RemoveIndex(index); }
 virtual void Clear( void ) { this->values.Clear(); this->times.Clear(); weights.Clear(); this->currentIndex = -1; }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 idList<float> weights;

 float WeightForIndex( const int index ) const;
};






template< class type >
inline idCurve_NURBS<type>::idCurve_NURBS( void ) {
}
# 2367 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve_NURBS<type>::AddValue( const float time, const type &value ) {
 int i;

 i = this->IndexForTime( time );
 this->times.Insert( time, i );
 this->values.Insert( value, i );
 weights.Insert( 1.0f, i );
 return i;
}
# 2386 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve_NURBS<type>::AddValue( const float time, const type &value, const float weight ) {
 int i;

 i = this->IndexForTime( time );
 this->times.Insert( time, i );
 this->values.Insert( value, i );
 weights.Insert( weight, i );
 return i;
}
# 2404 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NURBS<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float w, b, *bvals, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 this->Basis( i-1, this->order, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 w = 0.0f;
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  b = bvals[j] * WeightForIndex( k );
  w += b;
  v += b * this->ValueForIndex( k );
 }
 return v / w;
}
# 2437 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NURBS<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float w, wb, wd1, b, d1, *bvals, *d1vals, clampedTime;
 type v, vb, vd1;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));
 d1vals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 this->Basis( i-1, this->order, clampedTime, bvals );
 this->BasisFirstDerivative( i-1, this->order, clampedTime, d1vals );
 vb = vd1 = this->values[0] - this->values[0];
 wb = wd1 = 0.0f;
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  w = WeightForIndex( k );
  b = bvals[j] * w;
  d1 = d1vals[j] * w;
  wb += b;
  wd1 += d1;
  v = this->ValueForIndex( k );
  vb += b * v;
  vd1 += d1 * v;
 }
 return ( wb * vd1 - vb * wd1 ) / ( wb * wb );
}
# 2477 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NURBS<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float w, wb, wd1, wd2, b, d1, d2, *bvals, *d1vals, *d2vals, clampedTime;
 type v, vb, vd1, vd2;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));
 d1vals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));
 d2vals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 this->Basis( i-1, this->order, clampedTime, bvals );
 this->BasisFirstDerivative( i-1, this->order, clampedTime, d1vals );
 this->BasisSecondDerivative( i-1, this->order, clampedTime, d2vals );
 vb = vd1 = vd2 = this->values[0] - this->values[0];
 wb = wd1 = wd2 = 0.0f;
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  w = WeightForIndex( k );
  b = bvals[j] * w;
  d1 = d1vals[j] * w;
  d2 = d2vals[j] * w;
  wb += b;
  wd1 += d1;
  wd2 += d2;
  v = this->ValueForIndex( k );
  vb += b * v;
  vd1 += d1 * v;
  vd2 += d2 * v;
 }
 return ( ( wb * wb ) * ( wb * vd2 - vb * wd2 ) - ( wb * vd1 - vb * wd1 ) * 2.0f * wb * wd1 ) / ( wb * wb * wb * wb );
}
# 2522 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_NURBS<type>::WeightForIndex( const int index ) const {
 int n = weights.Num()-1;

 if ( index < 0 ) {
  if ( this->boundaryType == idCurve_Spline<type>::BT_CLOSED ) {
   return weights[ weights.Num() + index % weights.Num() ];
  } else {
   return weights[0] + index * ( weights[1] - weights[0] );
  }
 } else if ( index > n ) {
  if ( this->boundaryType == idCurve_Spline<type>::BT_CLOSED ) {
   return weights[ index % weights.Num() ];
  } else {
   return weights[n] + ( index - n ) * ( weights[n] - weights[n-1] );
  }
 }
 return weights[index];
}
# 189 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Ode.h" 1
# 47 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Ode.h"
typedef void (*deriveFunction_t)( const float t, const void *userData, const float *state, float *derivatives );

class idODE {

public:
 virtual ~idODE( void ) {}

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 ) = 0;

protected:
 int dimension;
 deriveFunction_t derive;
 const void * userData;
};







class idODE_Euler : public idODE {

public:
      idODE_Euler( const int dim, const deriveFunction_t dr, const void *ud );
 virtual ~idODE_Euler( void );

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 );

protected:
 float * derivatives;
};







class idODE_Midpoint : public idODE {

public:
      idODE_Midpoint( const int dim, const deriveFunction_t dr, const void *ud );
 virtual ~idODE_Midpoint( void );

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 );

protected:
 float * tmpState;
 float * derivatives;
};







class idODE_RK4 : public idODE {

public:
      idODE_RK4( const int dim, const deriveFunction_t dr, const void *ud );
 virtual ~idODE_RK4( void );

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 );

protected:
 float * tmpState;
 float * d1;
 float * d2;
 float * d3;
 float * d4;
};







class idODE_RK4Adaptive : public idODE {

public:
      idODE_RK4Adaptive( const int dim, const deriveFunction_t dr, const void *ud );
 virtual ~idODE_RK4Adaptive( void );

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 );
 void SetMaxError( const float err );

protected:
 float maxError;
 float * tmpState;
 float * d1;
 float * d1half;
 float * d2;
 float * d3;
 float * d4;
};
# 190 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Lcp.h" 1
# 62 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/math/Lcp.h"
class idLCP {
public:
 static idLCP * AllocSquare( void );
 static idLCP * AllocSymmetric( void );

 virtual ~idLCP( void );

 virtual bool Solve( const idMatX &A, idVecX &x, const idVecX &b, const idVecX &lo, const idVecX &hi, const int *boxIndex = __null ) = 0;
 virtual void SetMaxIterations( int max );
 virtual int GetMaxIterations( void );

protected:
 int maxIterations;
};
# 191 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/bv/Sphere.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/bv/Sphere.h"
class idSphere {
public:
     idSphere( void );
     explicit idSphere( const idVec3 &point );
     explicit idSphere( const idVec3 &point, const float r );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idSphere operator+( const idVec3 &t ) const;
 idSphere & operator+=( const idVec3 &t );
 idSphere operator+( const idSphere &s ) const;
 idSphere & operator+=( const idSphere &s );

 bool Compare( const idSphere &a ) const;
 bool Compare( const idSphere &a, const float epsilon ) const;
 bool operator==( const idSphere &a ) const;
 bool operator!=( const idSphere &a ) const;

 void Clear( void );
 void Zero( void );
 void SetOrigin( const idVec3 &o );
 void SetRadius( const float r );

 const idVec3 & GetOrigin( void ) const;
 float GetRadius( void ) const;
 bool IsCleared( void ) const;

 bool AddPoint( const idVec3 &p );
 bool AddSphere( const idSphere &s );
 idSphere Expand( const float d ) const;
 idSphere & ExpandSelf( const float d );
 idSphere Translate( const idVec3 &translation ) const;
 idSphere & TranslateSelf( const idVec3 &translation );

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;

 bool ContainsPoint( const idVec3 &p ) const;
 bool IntersectsSphere( const idSphere &s ) const;
 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;


 void FromPoints( const idVec3 *points, const int numPoints );

 void FromPointTranslation( const idVec3 &point, const idVec3 &translation );
 void FromSphereTranslation( const idSphere &sphere, const idVec3 &start, const idVec3 &translation );

 void FromPointRotation( const idVec3 &point, const idRotation &rotation );
 void FromSphereRotation( const idSphere &sphere, const idVec3 &start, const idRotation &rotation );

 void AxisProjection( const idVec3 &dir, float &min, float &max ) const;

private:
 idVec3 origin;
 float radius;
};

extern idSphere sphere_zero;

inline idSphere::idSphere( void ) {
}

inline idSphere::idSphere( const idVec3 &point ) {
 origin = point;
 radius = 0.0f;
}

inline idSphere::idSphere( const idVec3 &point, const float r ) {
 origin = point;
 radius = r;
}

inline float idSphere::operator[]( const int index ) const {
 return ((float *) &origin)[index];
}

inline float &idSphere::operator[]( const int index ) {
 return ((float *) &origin)[index];
}

inline idSphere idSphere::operator+( const idVec3 &t ) const {
 return idSphere( origin + t, radius );
}

inline idSphere &idSphere::operator+=( const idVec3 &t ) {
 origin += t;
 return *this;
}

inline bool idSphere::Compare( const idSphere &a ) const {
 return ( origin.Compare( a.origin ) && radius == a.radius );
}

inline bool idSphere::Compare( const idSphere &a, const float epsilon ) const {
 return ( origin.Compare( a.origin, epsilon ) && idMath::Fabs( radius - a.radius ) <= epsilon );
}

inline bool idSphere::operator==( const idSphere &a ) const {
 return Compare( a );
}

inline bool idSphere::operator!=( const idSphere &a ) const {
 return !Compare( a );
}

inline void idSphere::Clear( void ) {
 origin.Zero();
 radius = -1.0f;
}

inline void idSphere::Zero( void ) {
 origin.Zero();
 radius = 0.0f;
}

inline void idSphere::SetOrigin( const idVec3 &o ) {
 origin = o;
}

inline void idSphere::SetRadius( const float r ) {
 radius = r;
}

inline const idVec3 &idSphere::GetOrigin( void ) const {
 return origin;
}

inline float idSphere::GetRadius( void ) const {
 return radius;
}

inline bool idSphere::IsCleared( void ) const {
 return ( radius < 0.0f );
}

inline bool idSphere::AddPoint( const idVec3 &p ) {
 if ( radius < 0.0f ) {
  origin = p;
  radius = 0.0f;
  return true;
 }
 else {
  float r = ( p - origin ).LengthSqr();
  if ( r > radius * radius ) {
   r = idMath::Sqrt( r );
   origin += ( p - origin ) * 0.5f * (1.0f - radius / r );
   radius += 0.5f * ( r - radius );
   return true;
  }
  return false;
 }
}

inline bool idSphere::AddSphere( const idSphere &s ) {
 if ( radius < 0.0f ) {
  origin = s.origin;
  radius = s.radius;
  return true;
 }
 else {
  float r = ( s.origin - origin ).LengthSqr();
  if ( r > ( radius + s.radius ) * ( radius + s.radius ) ) {
   r = idMath::Sqrt( r );
   origin += ( s.origin - origin ) * 0.5f * (1.0f - radius / ( r + s.radius ) );
   radius += 0.5f * ( ( r + s.radius ) - radius );
   return true;
  }
  return false;
 }
}

inline idSphere idSphere::Expand( const float d ) const {
 return idSphere( origin, radius + d );
}

inline idSphere &idSphere::ExpandSelf( const float d ) {
 radius += d;
 return *this;
}

inline idSphere idSphere::Translate( const idVec3 &translation ) const {
 return idSphere( origin + translation, radius );
}

inline idSphere &idSphere::TranslateSelf( const idVec3 &translation ) {
 origin += translation;
 return *this;
}

inline bool idSphere::ContainsPoint( const idVec3 &p ) const {
 if ( ( p - origin ).LengthSqr() > radius * radius ) {
  return false;
 }
 return true;
}

inline bool idSphere::IntersectsSphere( const idSphere &s ) const {
 float r = s.radius + radius;
 if ( ( s.origin - origin ).LengthSqr() > r * r ) {
  return false;
 }
 return true;
}

inline void idSphere::FromPointTranslation( const idVec3 &point, const idVec3 &translation ) {
 origin = point + 0.5f * translation;
 radius = idMath::Sqrt( 0.5f * translation.LengthSqr() );
}

inline void idSphere::FromSphereTranslation( const idSphere &sphere, const idVec3 &start, const idVec3 &translation ) {
 origin = start + sphere.origin + 0.5f * translation;
 radius = idMath::Sqrt( 0.5f * translation.LengthSqr() ) + sphere.radius;
}

inline void idSphere::FromPointRotation( const idVec3 &point, const idRotation &rotation ) {
 idVec3 end = rotation * point;
 origin = ( point + end ) * 0.5f;
 radius = idMath::Sqrt( 0.5f * ( end - point ).LengthSqr() );
}

inline void idSphere::FromSphereRotation( const idSphere &sphere, const idVec3 &start, const idRotation &rotation ) {
 idVec3 end = rotation * sphere.origin;
 origin = start + ( sphere.origin + end ) * 0.5f;
 radius = idMath::Sqrt( 0.5f * ( end - sphere.origin ).LengthSqr() ) + sphere.radius;
}

inline void idSphere::AxisProjection( const idVec3 &dir, float &min, float &max ) const {
 float d;
 d = dir * origin;
 min = d - radius;
 max = d + radius;
}
# 194 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/bv/Bounds.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/bv/Bounds.h"
class idBounds {
public:
     idBounds( void );
     explicit idBounds( const idVec3 &mins, const idVec3 &maxs );
     explicit idBounds( const idVec3 &point );

 const idVec3 & operator[]( const int index ) const;
 idVec3 & operator[]( const int index );
 idBounds operator+( const idVec3 &t ) const;
 idBounds & operator+=( const idVec3 &t );
 idBounds operator*( const idMat3 &r ) const;
 idBounds & operator*=( const idMat3 &r );
 idBounds operator+( const idBounds &a ) const;
 idBounds & operator+=( const idBounds &a );
 idBounds operator-( const idBounds &a ) const;
 idBounds & operator-=( const idBounds &a );

 bool Compare( const idBounds &a ) const;
 bool Compare( const idBounds &a, const float epsilon ) const;
 bool operator==( const idBounds &a ) const;
 bool operator!=( const idBounds &a ) const;

 void Clear( void );
 void Zero( void );

 idVec3 GetCenter( void ) const;
 float GetRadius( void ) const;
 float GetRadius( const idVec3 &center ) const;
 float GetVolume( void ) const;
 bool IsCleared( void ) const;

 bool AddPoint( const idVec3 &v );
 bool AddBounds( const idBounds &a );
 idBounds Intersect( const idBounds &a ) const;
 idBounds & IntersectSelf( const idBounds &a );
 idBounds Expand( const float d ) const;
 idBounds & ExpandSelf( const float d );
 idBounds Translate( const idVec3 &translation ) const;
 idBounds & TranslateSelf( const idVec3 &translation );
 idBounds Rotate( const idMat3 &rotation ) const;
 idBounds & RotateSelf( const idMat3 &rotation );

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;

 bool ContainsPoint( const idVec3 &p ) const;
 bool IntersectsBounds( const idBounds &a ) const;
 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale ) const;


 void FromTransformedBounds( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis );

 void FromPoints( const idVec3 *points, const int numPoints );

 void FromPointTranslation( const idVec3 &point, const idVec3 &translation );
 void FromBoundsTranslation( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis, const idVec3 &translation );

 void FromPointRotation( const idVec3 &point, const idRotation &rotation );
 void FromBoundsRotation( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis, const idRotation &rotation );

 void ToPoints( idVec3 points[8] ) const;
 idSphere ToSphere( void ) const;

 void AxisProjection( const idVec3 &dir, float &min, float &max ) const;
 void AxisProjection( const idVec3 &origin, const idMat3 &axis, const idVec3 &dir, float &min, float &max ) const;

private:
 idVec3 b[2];
};

extern idBounds bounds_zero;

inline idBounds::idBounds( void ) {
}

inline idBounds::idBounds( const idVec3 &mins, const idVec3 &maxs ) {
 b[0] = mins;
 b[1] = maxs;
}

inline idBounds::idBounds( const idVec3 &point ) {
 b[0] = point;
 b[1] = point;
}

inline const idVec3 &idBounds::operator[]( const int index ) const {
 return b[index];
}

inline idVec3 &idBounds::operator[]( const int index ) {
 return b[index];
}

inline idBounds idBounds::operator+( const idVec3 &t ) const {
 return idBounds( b[0] + t, b[1] + t );
}

inline idBounds &idBounds::operator+=( const idVec3 &t ) {
 b[0] += t;
 b[1] += t;
 return *this;
}

inline idBounds idBounds::operator*( const idMat3 &r ) const {
 idBounds bounds;
 bounds.FromTransformedBounds( *this, vec3_origin, r );
 return bounds;
}

inline idBounds &idBounds::operator*=( const idMat3 &r ) {
 this->FromTransformedBounds( *this, vec3_origin, r );
 return *this;
}

inline idBounds idBounds::operator+( const idBounds &a ) const {
 idBounds newBounds;
 newBounds = *this;
 newBounds.AddBounds( a );
 return newBounds;
}

inline idBounds &idBounds::operator+=( const idBounds &a ) {
 idBounds::AddBounds( a );
 return *this;
}

inline idBounds idBounds::operator-( const idBounds &a ) const {
 ((void)0)

                                                ;
 return idBounds( idVec3( b[0][0] + a.b[1][0], b[0][1] + a.b[1][1], b[0][2] + a.b[1][2] ),
     idVec3( b[1][0] + a.b[0][0], b[1][1] + a.b[0][1], b[1][2] + a.b[0][2] ) );
}

inline idBounds &idBounds::operator-=( const idBounds &a ) {
 ((void)0)

                                                ;
 b[0] += a.b[1];
 b[1] += a.b[0];
 return *this;
}

inline bool idBounds::Compare( const idBounds &a ) const {
 return ( b[0].Compare( a.b[0] ) && b[1].Compare( a.b[1] ) );
}

inline bool idBounds::Compare( const idBounds &a, const float epsilon ) const {
 return ( b[0].Compare( a.b[0], epsilon ) && b[1].Compare( a.b[1], epsilon ) );
}

inline bool idBounds::operator==( const idBounds &a ) const {
 return Compare( a );
}

inline bool idBounds::operator!=( const idBounds &a ) const {
 return !Compare( a );
}

inline void idBounds::Clear( void ) {
 b[0][0] = b[0][1] = b[0][2] = idMath::INFINITY;
 b[1][0] = b[1][1] = b[1][2] = -idMath::INFINITY;
}

inline void idBounds::Zero( void ) {
 b[0][0] = b[0][1] = b[0][2] =
 b[1][0] = b[1][1] = b[1][2] = 0;
}

inline idVec3 idBounds::GetCenter( void ) const {
 return idVec3( ( b[1][0] + b[0][0] ) * 0.5f, ( b[1][1] + b[0][1] ) * 0.5f, ( b[1][2] + b[0][2] ) * 0.5f );
}

inline float idBounds::GetVolume( void ) const {
 if ( b[0][0] >= b[1][0] || b[0][1] >= b[1][1] || b[0][2] >= b[1][2] ) {
  return 0.0f;
 }
 return ( ( b[1][0] - b[0][0] ) * ( b[1][1] - b[0][1] ) * ( b[1][2] - b[0][2] ) );
}

inline bool idBounds::IsCleared( void ) const {
 return b[0][0] > b[1][0];
}

inline bool idBounds::AddPoint( const idVec3 &v ) {
 bool expanded = false;
 if ( v[0] < b[0][0]) {
  b[0][0] = v[0];
  expanded = true;
 }
 if ( v[0] > b[1][0]) {
  b[1][0] = v[0];
  expanded = true;
 }
 if ( v[1] < b[0][1] ) {
  b[0][1] = v[1];
  expanded = true;
 }
 if ( v[1] > b[1][1]) {
  b[1][1] = v[1];
  expanded = true;
 }
 if ( v[2] < b[0][2] ) {
  b[0][2] = v[2];
  expanded = true;
 }
 if ( v[2] > b[1][2]) {
  b[1][2] = v[2];
  expanded = true;
 }
 return expanded;
}

inline bool idBounds::AddBounds( const idBounds &a ) {
 bool expanded = false;
 if ( a.b[0][0] < b[0][0] ) {
  b[0][0] = a.b[0][0];
  expanded = true;
 }
 if ( a.b[0][1] < b[0][1] ) {
  b[0][1] = a.b[0][1];
  expanded = true;
 }
 if ( a.b[0][2] < b[0][2] ) {
  b[0][2] = a.b[0][2];
  expanded = true;
 }
 if ( a.b[1][0] > b[1][0] ) {
  b[1][0] = a.b[1][0];
  expanded = true;
 }
 if ( a.b[1][1] > b[1][1] ) {
  b[1][1] = a.b[1][1];
  expanded = true;
 }
 if ( a.b[1][2] > b[1][2] ) {
  b[1][2] = a.b[1][2];
  expanded = true;
 }
 return expanded;
}

inline idBounds idBounds::Intersect( const idBounds &a ) const {
 idBounds n;
 n.b[0][0] = ( a.b[0][0] > b[0][0] ) ? a.b[0][0] : b[0][0];
 n.b[0][1] = ( a.b[0][1] > b[0][1] ) ? a.b[0][1] : b[0][1];
 n.b[0][2] = ( a.b[0][2] > b[0][2] ) ? a.b[0][2] : b[0][2];
 n.b[1][0] = ( a.b[1][0] < b[1][0] ) ? a.b[1][0] : b[1][0];
 n.b[1][1] = ( a.b[1][1] < b[1][1] ) ? a.b[1][1] : b[1][1];
 n.b[1][2] = ( a.b[1][2] < b[1][2] ) ? a.b[1][2] : b[1][2];
 return n;
}

inline idBounds &idBounds::IntersectSelf( const idBounds &a ) {
 if ( a.b[0][0] > b[0][0] ) {
  b[0][0] = a.b[0][0];
 }
 if ( a.b[0][1] > b[0][1] ) {
  b[0][1] = a.b[0][1];
 }
 if ( a.b[0][2] > b[0][2] ) {
  b[0][2] = a.b[0][2];
 }
 if ( a.b[1][0] < b[1][0] ) {
  b[1][0] = a.b[1][0];
 }
 if ( a.b[1][1] < b[1][1] ) {
  b[1][1] = a.b[1][1];
 }
 if ( a.b[1][2] < b[1][2] ) {
  b[1][2] = a.b[1][2];
 }
 return *this;
}

inline idBounds idBounds::Expand( const float d ) const {
 return idBounds( idVec3( b[0][0] - d, b[0][1] - d, b[0][2] - d ),
      idVec3( b[1][0] + d, b[1][1] + d, b[1][2] + d ) );
}

inline idBounds &idBounds::ExpandSelf( const float d ) {
 b[0][0] -= d;
 b[0][1] -= d;
 b[0][2] -= d;
 b[1][0] += d;
 b[1][1] += d;
 b[1][2] += d;
 return *this;
}

inline idBounds idBounds::Translate( const idVec3 &translation ) const {
 return idBounds( b[0] + translation, b[1] + translation );
}

inline idBounds &idBounds::TranslateSelf( const idVec3 &translation ) {
 b[0] += translation;
 b[1] += translation;
 return *this;
}

inline idBounds idBounds::Rotate( const idMat3 &rotation ) const {
 idBounds bounds;
 bounds.FromTransformedBounds( *this, vec3_origin, rotation );
 return bounds;
}

inline idBounds &idBounds::RotateSelf( const idMat3 &rotation ) {
 FromTransformedBounds( *this, vec3_origin, rotation );
 return *this;
}

inline bool idBounds::ContainsPoint( const idVec3 &p ) const {
 if ( p[0] < b[0][0] || p[1] < b[0][1] || p[2] < b[0][2]
  || p[0] > b[1][0] || p[1] > b[1][1] || p[2] > b[1][2] ) {
  return false;
 }
 return true;
}

inline bool idBounds::IntersectsBounds( const idBounds &a ) const {
 if ( a.b[1][0] < b[0][0] || a.b[1][1] < b[0][1] || a.b[1][2] < b[0][2]
  || a.b[0][0] > b[1][0] || a.b[0][1] > b[1][1] || a.b[0][2] > b[1][2] ) {
  return false;
 }
 return true;
}

inline idSphere idBounds::ToSphere( void ) const {
 idSphere sphere;
 sphere.SetOrigin( ( b[0] + b[1] ) * 0.5f );
 sphere.SetRadius( ( b[1] - sphere.GetOrigin() ).Length() );
 return sphere;
}

inline void idBounds::AxisProjection( const idVec3 &dir, float &min, float &max ) const {
 float d1, d2;
 idVec3 center, extents;

 center = ( b[0] + b[1] ) * 0.5f;
 extents = b[1] - center;

 d1 = dir * center;
 d2 = idMath::Fabs( extents[0] * dir[0] ) +
   idMath::Fabs( extents[1] * dir[1] ) +
    idMath::Fabs( extents[2] * dir[2] );

 min = d1 - d2;
 max = d1 + d2;
}

inline void idBounds::AxisProjection( const idVec3 &origin, const idMat3 &axis, const idVec3 &dir, float &min, float &max ) const {
 float d1, d2;
 idVec3 center, extents;

 center = ( b[0] + b[1] ) * 0.5f;
 extents = b[1] - center;
 center = origin + center * axis;

 d1 = dir * center;
 d2 = idMath::Fabs( extents[0] * ( dir * axis[0] ) ) +
   idMath::Fabs( extents[1] * ( dir * axis[1] ) ) +
    idMath::Fabs( extents[2] * ( dir * axis[2] ) );

 min = d1 - d2;
 max = d1 + d2;
}
# 195 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/bv/Box.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/bv/Box.h"
class idBox {
public:
     idBox( void );
     explicit idBox( const idVec3 &center, const idVec3 &extents, const idMat3 &axis );
     explicit idBox( const idVec3 &point );
     explicit idBox( const idBounds &bounds );
     explicit idBox( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis );

 idBox operator+( const idVec3 &t ) const;
 idBox & operator+=( const idVec3 &t );
 idBox operator*( const idMat3 &r ) const;
 idBox & operator*=( const idMat3 &r );
 idBox operator+( const idBox &a ) const;
 idBox & operator+=( const idBox &a );
 idBox operator-( const idBox &a ) const;
 idBox & operator-=( const idBox &a );

 bool Compare( const idBox &a ) const;
 bool Compare( const idBox &a, const float epsilon ) const;
 bool operator==( const idBox &a ) const;
 bool operator!=( const idBox &a ) const;

 void Clear( void );
 void Zero( void );

 const idVec3 & GetCenter( void ) const;
 const idVec3 & GetExtents( void ) const;
 const idMat3 & GetAxis( void ) const;
 float GetVolume( void ) const;
 bool IsCleared( void ) const;

 bool AddPoint( const idVec3 &v );
 bool AddBox( const idBox &a );
 idBox Expand( const float d ) const;
 idBox & ExpandSelf( const float d );
 idBox Translate( const idVec3 &translation ) const;
 idBox & TranslateSelf( const idVec3 &translation );
 idBox Rotate( const idMat3 &rotation ) const;
 idBox & RotateSelf( const idMat3 &rotation );

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;

 bool ContainsPoint( const idVec3 &p ) const;
 bool IntersectsBox( const idBox &a ) const;
 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;


 void FromPoints( const idVec3 *points, const int numPoints );

 void FromPointTranslation( const idVec3 &point, const idVec3 &translation );
 void FromBoxTranslation( const idBox &box, const idVec3 &translation );

 void FromPointRotation( const idVec3 &point, const idRotation &rotation );
 void FromBoxRotation( const idBox &box, const idRotation &rotation );

 void ToPoints( idVec3 points[8] ) const;
 idSphere ToSphere( void ) const;


 void AxisProjection( const idVec3 &dir, float &min, float &max ) const;
 void AxisProjection( const idMat3 &ax, idBounds &bounds ) const;


 int GetProjectionSilhouetteVerts( const idVec3 &projectionOrigin, idVec3 silVerts[6] ) const;
 int GetParallelProjectionSilhouetteVerts( const idVec3 &projectionDir, idVec3 silVerts[6] ) const;

private:
 idVec3 center;
 idVec3 extents;
 idMat3 axis;
};

extern idBox box_zero;

inline idBox::idBox( void ) {
}

inline idBox::idBox( const idVec3 &center, const idVec3 &extents, const idMat3 &axis ) {
 this->center = center;
 this->extents = extents;
 this->axis = axis;
}

inline idBox::idBox( const idVec3 &point ) {
 this->center = point;
 this->extents.Zero();
 this->axis.Identity();
}

inline idBox::idBox( const idBounds &bounds ) {
 this->center = ( bounds[0] + bounds[1] ) * 0.5f;
 this->extents = bounds[1] - this->center;
 this->axis.Identity();
}

inline idBox::idBox( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis ) {
 this->center = ( bounds[0] + bounds[1] ) * 0.5f;
 this->extents = bounds[1] - this->center;
 this->center = origin + this->center * axis;
 this->axis = axis;
}

inline idBox idBox::operator+( const idVec3 &t ) const {
 return idBox( center + t, extents, axis );
}

inline idBox &idBox::operator+=( const idVec3 &t ) {
 center += t;
 return *this;
}

inline idBox idBox::operator*( const idMat3 &r ) const {
 return idBox( center * r, extents, axis * r );
}

inline idBox &idBox::operator*=( const idMat3 &r ) {
 center *= r;
 axis *= r;
 return *this;
}

inline idBox idBox::operator+( const idBox &a ) const {
 idBox newBox;
 newBox = *this;
 newBox.AddBox( a );
 return newBox;
}

inline idBox &idBox::operator+=( const idBox &a ) {
 idBox::AddBox( a );
 return *this;
}

inline idBox idBox::operator-( const idBox &a ) const {
 return idBox( center, extents - a.extents, axis );
}

inline idBox &idBox::operator-=( const idBox &a ) {
 extents -= a.extents;
 return *this;
}

inline bool idBox::Compare( const idBox &a ) const {
 return ( center.Compare( a.center ) && extents.Compare( a.extents ) && axis.Compare( a.axis ) );
}

inline bool idBox::Compare( const idBox &a, const float epsilon ) const {
 return ( center.Compare( a.center, epsilon ) && extents.Compare( a.extents, epsilon ) && axis.Compare( a.axis, epsilon ) );
}

inline bool idBox::operator==( const idBox &a ) const {
 return Compare( a );
}

inline bool idBox::operator!=( const idBox &a ) const {
 return !Compare( a );
}

inline void idBox::Clear( void ) {
 center.Zero();
 extents[0] = extents[1] = extents[2] = -idMath::INFINITY;
 axis.Identity();
}

inline void idBox::Zero( void ) {
 center.Zero();
 extents.Zero();
 axis.Identity();
}

inline const idVec3 &idBox::GetCenter( void ) const {
 return center;
}

inline const idVec3 &idBox::GetExtents( void ) const {
 return extents;
}

inline const idMat3 &idBox::GetAxis( void ) const {
 return axis;
}

inline float idBox::GetVolume( void ) const {
 return ( extents * 2.0f ).LengthSqr();
}

inline bool idBox::IsCleared( void ) const {
 return extents[0] < 0.0f;
}

inline idBox idBox::Expand( const float d ) const {
 return idBox( center, extents + idVec3( d, d, d ), axis );
}

inline idBox &idBox::ExpandSelf( const float d ) {
 extents[0] += d;
 extents[1] += d;
 extents[2] += d;
 return *this;
}

inline idBox idBox::Translate( const idVec3 &translation ) const {
 return idBox( center + translation, extents, axis );
}

inline idBox &idBox::TranslateSelf( const idVec3 &translation ) {
 center += translation;
 return *this;
}

inline idBox idBox::Rotate( const idMat3 &rotation ) const {
 return idBox( center * rotation, extents, axis * rotation );
}

inline idBox &idBox::RotateSelf( const idMat3 &rotation ) {
 center *= rotation;
 axis *= rotation;
 return *this;
}

inline bool idBox::ContainsPoint( const idVec3 &p ) const {
 idVec3 lp = p - center;
 if ( idMath::Fabs( lp * axis[0] ) > extents[0] ||
   idMath::Fabs( lp * axis[1] ) > extents[1] ||
    idMath::Fabs( lp * axis[2] ) > extents[2] ) {
  return false;
 }
 return true;
}

inline idSphere idBox::ToSphere( void ) const {
 return idSphere( center, extents.Length() );
}

inline void idBox::AxisProjection( const idVec3 &dir, float &min, float &max ) const {
 float d1 = dir * center;
 float d2 = idMath::Fabs( extents[0] * ( dir * axis[0] ) ) +
    idMath::Fabs( extents[1] * ( dir * axis[1] ) ) +
    idMath::Fabs( extents[2] * ( dir * axis[2] ) );
 min = d1 - d2;
 max = d1 + d2;
}

inline void idBox::AxisProjection( const idMat3 &ax, idBounds &bounds ) const {
 for ( int i = 0; i < 3; i++ ) {
  float d1 = ax[i] * center;
  float d2 = idMath::Fabs( extents[0] * ( ax[i] * axis[0] ) ) +
     idMath::Fabs( extents[1] * ( ax[i] * axis[1] ) ) +
     idMath::Fabs( extents[2] * ( ax[i] * axis[2] ) );
  bounds[0][i] = d1 - d2;
  bounds[1][i] = d1 + d2;
 }
}
# 196 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/bv/Frustum.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/bv/Frustum.h"
class idFrustum {
public:
     idFrustum( void );

 void SetOrigin( const idVec3 &origin );
 void SetAxis( const idMat3 &axis );
 void SetSize( float dNear, float dFar, float dLeft, float dUp );
 void SetPyramid( float dNear, float dFar );
 void MoveNearDistance( float dNear );
 void MoveFarDistance( float dFar );

 const idVec3 & GetOrigin( void ) const;
 const idMat3 & GetAxis( void ) const;
 idVec3 GetCenter( void ) const;

 bool IsValid( void ) const;
 float GetNearDistance( void ) const;
 float GetFarDistance( void ) const;
 float GetLeft( void ) const;
 float GetUp( void ) const;

 idFrustum Expand( const float d ) const;
 idFrustum & ExpandSelf( const float d );
 idFrustum Translate( const idVec3 &translation ) const;
 idFrustum & TranslateSelf( const idVec3 &translation );
 idFrustum Rotate( const idMat3 &rotation ) const;
 idFrustum & RotateSelf( const idMat3 &rotation );

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;


 bool CullPoint( const idVec3 &point ) const;
 bool CullBounds( const idBounds &bounds ) const;
 bool CullBox( const idBox &box ) const;
 bool CullSphere( const idSphere &sphere ) const;
 bool CullFrustum( const idFrustum &frustum ) const;
 bool CullWinding( const class idWinding &winding ) const;


 bool ContainsPoint( const idVec3 &point ) const;
 bool IntersectsBounds( const idBounds &bounds ) const;
 bool IntersectsBox( const idBox &box ) const;
 bool IntersectsSphere( const idSphere &sphere ) const;
 bool IntersectsFrustum( const idFrustum &frustum ) const;
 bool IntersectsWinding( const idWinding &winding ) const;
 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;
 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;


 bool FromProjection( const idBounds &bounds, const idVec3 &projectionOrigin, const float dFar );
 bool FromProjection( const idBox &box, const idVec3 &projectionOrigin, const float dFar );
 bool FromProjection( const idSphere &sphere, const idVec3 &projectionOrigin, const float dFar );


 bool ConstrainToBounds( const idBounds &bounds );
 bool ConstrainToBox( const idBox &box );
 bool ConstrainToSphere( const idSphere &sphere );
 bool ConstrainToFrustum( const idFrustum &frustum );

 void ToPlanes( idPlane planes[6] ) const;
 void ToPoints( idVec3 points[8] ) const;


 void AxisProjection( const idVec3 &dir, float &min, float &max ) const;
 void AxisProjection( const idMat3 &ax, idBounds &bounds ) const;


 bool ProjectionBounds( const idBounds &bounds, idBounds &projectionBounds ) const;
 bool ProjectionBounds( const idBox &box, idBounds &projectionBounds ) const;
 bool ProjectionBounds( const idSphere &sphere, idBounds &projectionBounds ) const;
 bool ProjectionBounds( const idFrustum &frustum, idBounds &projectionBounds ) const;
 bool ProjectionBounds( const idWinding &winding, idBounds &projectionBounds ) const;


 bool ClippedProjectionBounds( const idFrustum &frustum, const idBox &clipBox, idBounds &projectionBounds ) const;

private:
 idVec3 origin;
 idMat3 axis;
 float dNear;
 float dFar;
 float dLeft;
 float dUp;
 float invFar;

private:
 bool CullLocalBox( const idVec3 &localOrigin, const idVec3 &extents, const idMat3 &localAxis ) const;
 bool CullLocalFrustum( const idFrustum &localFrustum, const idVec3 indexPoints[8], const idVec3 cornerVecs[4] ) const;
 bool CullLocalWinding( const idVec3 *points, const int numPoints, int *pointCull ) const;
 bool BoundsCullLocalFrustum( const idBounds &bounds, const idFrustum &localFrustum, const idVec3 indexPoints[8], const idVec3 cornerVecs[4] ) const;
 bool LocalLineIntersection( const idVec3 &start, const idVec3 &end ) const;
 bool LocalRayIntersection( const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;
 bool LocalFrustumIntersectsFrustum( const idVec3 points[8], const bool testFirstSide ) const;
 bool LocalFrustumIntersectsBounds( const idVec3 points[8], const idBounds &bounds ) const;
 void ToClippedPoints( const float fractions[4], idVec3 points[8] ) const;
 void ToIndexPoints( idVec3 indexPoints[8] ) const;
 void ToIndexPointsAndCornerVecs( idVec3 indexPoints[8], idVec3 cornerVecs[4] ) const;
 void AxisProjection( const idVec3 indexPoints[8], const idVec3 cornerVecs[4], const idVec3 &dir, float &min, float &max ) const;
 void AddLocalLineToProjectionBoundsSetCull( const idVec3 &start, const idVec3 &end, int &startCull, int &endCull, idBounds &bounds ) const;
 void AddLocalLineToProjectionBoundsUseCull( const idVec3 &start, const idVec3 &end, int startCull, int endCull, idBounds &bounds ) const;
 bool AddLocalCapsToProjectionBounds( const idVec3 endPoints[4], const int endPointCull[4], const idVec3 &point, int pointCull, int pointClip, idBounds &projectionBounds ) const;
 bool BoundsRayIntersection( const idBounds &bounds, const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;
 void ClipFrustumToBox( const idBox &box, float clipFractions[4], int clipPlanes[4] ) const;
 bool ClipLine( const idVec3 localPoints[8], const idVec3 points[8], int startIndex, int endIndex, idVec3 &start, idVec3 &end, int &startClip, int &endClip ) const;
};


inline idFrustum::idFrustum( void ) {
 dNear = dFar = 0.0f;
}

inline void idFrustum::SetOrigin( const idVec3 &origin ) {
 this->origin = origin;
}

inline void idFrustum::SetAxis( const idMat3 &axis ) {
 this->axis = axis;
}

inline void idFrustum::SetSize( float dNear, float dFar, float dLeft, float dUp ) {
 ((void)0);
 this->dNear = dNear;
 this->dFar = dFar;
 this->dLeft = dLeft;
 this->dUp = dUp;
 this->invFar = 1.0f / dFar;
}

inline void idFrustum::SetPyramid( float dNear, float dFar ) {
 ((void)0);
 this->dNear = dNear;
 this->dFar = dFar;
 this->dLeft = dFar;
 this->dUp = dFar;
 this->invFar = 1.0f / dFar;
}

inline void idFrustum::MoveNearDistance( float dNear ) {
 ((void)0);
 this->dNear = dNear;
}

inline void idFrustum::MoveFarDistance( float dFar ) {
 ((void)0);
 float scale = dFar / this->dFar;
 this->dFar = dFar;
 this->dLeft *= scale;
 this->dUp *= scale;
 this->invFar = 1.0f / dFar;
}

inline const idVec3 &idFrustum::GetOrigin( void ) const {
 return origin;
}

inline const idMat3 &idFrustum::GetAxis( void ) const {
 return axis;
}

inline idVec3 idFrustum::GetCenter( void ) const {
 return ( origin + axis[0] * ( ( dFar - dNear ) * 0.5f ) );
}

inline bool idFrustum::IsValid( void ) const {
 return ( dFar > dNear );
}

inline float idFrustum::GetNearDistance( void ) const {
 return dNear;
}

inline float idFrustum::GetFarDistance( void ) const {
 return dFar;
}

inline float idFrustum::GetLeft( void ) const {
 return dLeft;
}

inline float idFrustum::GetUp( void ) const {
 return dUp;
}

inline idFrustum idFrustum::Expand( const float d ) const {
 idFrustum f = *this;
 f.origin -= d * f.axis[0];
 f.dFar += 2.0f * d;
 f.dLeft = f.dFar * dLeft * invFar;
 f.dUp = f.dFar * dUp * invFar;
 f.invFar = 1.0f / dFar;
 return f;
}

inline idFrustum &idFrustum::ExpandSelf( const float d ) {
 origin -= d * axis[0];
 dFar += 2.0f * d;
 dLeft = dFar * dLeft * invFar;
 dUp = dFar * dUp * invFar;
 invFar = 1.0f / dFar;
 return *this;
}

inline idFrustum idFrustum::Translate( const idVec3 &translation ) const {
 idFrustum f = *this;
 f.origin += translation;
 return f;
}

inline idFrustum &idFrustum::TranslateSelf( const idVec3 &translation ) {
 origin += translation;
 return *this;
}

inline idFrustum idFrustum::Rotate( const idMat3 &rotation ) const {
 idFrustum f = *this;
 f.axis *= rotation;
 return f;
}

inline idFrustum &idFrustum::RotateSelf( const idMat3 &rotation ) {
 axis *= rotation;
 return *this;
}
# 197 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/DrawVert.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/DrawVert.h"
class idDrawVert {
public:
 idVec3 xyz;
 idVec2 st;
 idVec3 normal;
 idVec3 tangents[2];
 byte color[4];



 float operator[]( const int index ) const;
 float & operator[]( const int index );

 void Clear( void );

 void Lerp( const idDrawVert &a, const idDrawVert &b, const float f );
 void LerpAll( const idDrawVert &a, const idDrawVert &b, const float f );

 void Normalize( void );

 void SetColor( dword color );
 dword GetColor( void ) const;
};

inline float idDrawVert::operator[]( const int index ) const {
 ((void)0);
 return ((float *)(&xyz))[index];
}
inline float &idDrawVert::operator[]( const int index ) {
 ((void)0);
 return ((float *)(&xyz))[index];
}

inline void idDrawVert::Clear( void ) {
 xyz.Zero();
 st.Zero();
 normal.Zero();
 tangents[0].Zero();
 tangents[1].Zero();
 color[0] = color[1] = color[2] = color[3] = 0;
}

inline void idDrawVert::Lerp( const idDrawVert &a, const idDrawVert &b, const float f ) {
 xyz = a.xyz + f * ( b.xyz - a.xyz );
 st = a.st + f * ( b.st - a.st );
}

inline void idDrawVert::LerpAll( const idDrawVert &a, const idDrawVert &b, const float f ) {
 xyz = a.xyz + f * ( b.xyz - a.xyz );
 st = a.st + f * ( b.st - a.st );
 normal = a.normal + f * ( b.normal - a.normal );
 tangents[0] = a.tangents[0] + f * ( b.tangents[0] - a.tangents[0] );
 tangents[1] = a.tangents[1] + f * ( b.tangents[1] - a.tangents[1] );
 color[0] = (byte)( a.color[0] + f * ( b.color[0] - a.color[0] ) );
 color[1] = (byte)( a.color[1] + f * ( b.color[1] - a.color[1] ) );
 color[2] = (byte)( a.color[2] + f * ( b.color[2] - a.color[2] ) );
 color[3] = (byte)( a.color[3] + f * ( b.color[3] - a.color[3] ) );
}

inline void idDrawVert::SetColor( dword color ) {
 *reinterpret_cast<dword *>(this->color) = color;
}

inline dword idDrawVert::GetColor( void ) const {
 return *reinterpret_cast<const dword *>(this->color);
}
# 200 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/JointTransform.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/JointTransform.h"
class idJointQuat {
public:

 idQuat q;
 idVec3 t;
};
# 63 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/JointTransform.h"
class idJointMat {
public:

 void SetRotation( const idMat3 &m );
 void SetTranslation( const idVec3 &t );

 idVec3 operator*( const idVec3 &v ) const;
 idVec3 operator*( const idVec4 &v ) const;

 idJointMat & operator*=( const idJointMat &a );
 idJointMat & operator/=( const idJointMat &a );

 bool Compare( const idJointMat &a ) const;
 bool Compare( const idJointMat &a, const float epsilon ) const;
 bool operator==( const idJointMat &a ) const;
 bool operator!=( const idJointMat &a ) const;

 idMat3 ToMat3( void ) const;
 idVec3 ToVec3( void ) const;
 idJointQuat ToJointQuat( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );

private:
 float mat[3*4];
};

inline void idJointMat::SetRotation( const idMat3 &m ) {

 mat[0 * 4 + 0] = m[0][0];
 mat[0 * 4 + 1] = m[1][0];
 mat[0 * 4 + 2] = m[2][0];
 mat[1 * 4 + 0] = m[0][1];
 mat[1 * 4 + 1] = m[1][1];
 mat[1 * 4 + 2] = m[2][1];
 mat[2 * 4 + 0] = m[0][2];
 mat[2 * 4 + 1] = m[1][2];
 mat[2 * 4 + 2] = m[2][2];
}

inline void idJointMat::SetTranslation( const idVec3 &t ) {
 mat[0 * 4 + 3] = t[0];
 mat[1 * 4 + 3] = t[1];
 mat[2 * 4 + 3] = t[2];
}

inline idVec3 idJointMat::operator*( const idVec3 &v ) const {
 return idVec3( mat[0 * 4 + 0] * v[0] + mat[0 * 4 + 1] * v[1] + mat[0 * 4 + 2] * v[2],
     mat[1 * 4 + 0] * v[0] + mat[1 * 4 + 1] * v[1] + mat[1 * 4 + 2] * v[2],
     mat[2 * 4 + 0] * v[0] + mat[2 * 4 + 1] * v[1] + mat[2 * 4 + 2] * v[2] );
}

inline idVec3 idJointMat::operator*( const idVec4 &v ) const {
 return idVec3( mat[0 * 4 + 0] * v[0] + mat[0 * 4 + 1] * v[1] + mat[0 * 4 + 2] * v[2] + mat[0 * 4 + 3] * v[3],
     mat[1 * 4 + 0] * v[0] + mat[1 * 4 + 1] * v[1] + mat[1 * 4 + 2] * v[2] + mat[1 * 4 + 3] * v[3],
     mat[2 * 4 + 0] * v[0] + mat[2 * 4 + 1] * v[1] + mat[2 * 4 + 2] * v[2] + mat[2 * 4 + 3] * v[3] );
}

inline idJointMat &idJointMat::operator*=( const idJointMat &a ) {
 float dst[3];

 dst[0] = mat[0 * 4 + 0] * a.mat[0 * 4 + 0] + mat[1 * 4 + 0] * a.mat[0 * 4 + 1] + mat[2 * 4 + 0] * a.mat[0 * 4 + 2];
 dst[1] = mat[0 * 4 + 0] * a.mat[1 * 4 + 0] + mat[1 * 4 + 0] * a.mat[1 * 4 + 1] + mat[2 * 4 + 0] * a.mat[1 * 4 + 2];
 dst[2] = mat[0 * 4 + 0] * a.mat[2 * 4 + 0] + mat[1 * 4 + 0] * a.mat[2 * 4 + 1] + mat[2 * 4 + 0] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 0] = dst[0];
 mat[1 * 4 + 0] = dst[1];
 mat[2 * 4 + 0] = dst[2];

 dst[0] = mat[0 * 4 + 1] * a.mat[0 * 4 + 0] + mat[1 * 4 + 1] * a.mat[0 * 4 + 1] + mat[2 * 4 + 1] * a.mat[0 * 4 + 2];
 dst[1] = mat[0 * 4 + 1] * a.mat[1 * 4 + 0] + mat[1 * 4 + 1] * a.mat[1 * 4 + 1] + mat[2 * 4 + 1] * a.mat[1 * 4 + 2];
 dst[2] = mat[0 * 4 + 1] * a.mat[2 * 4 + 0] + mat[1 * 4 + 1] * a.mat[2 * 4 + 1] + mat[2 * 4 + 1] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 1] = dst[0];
 mat[1 * 4 + 1] = dst[1];
 mat[2 * 4 + 1] = dst[2];

 dst[0] = mat[0 * 4 + 2] * a.mat[0 * 4 + 0] + mat[1 * 4 + 2] * a.mat[0 * 4 + 1] + mat[2 * 4 + 2] * a.mat[0 * 4 + 2];
 dst[1] = mat[0 * 4 + 2] * a.mat[1 * 4 + 0] + mat[1 * 4 + 2] * a.mat[1 * 4 + 1] + mat[2 * 4 + 2] * a.mat[1 * 4 + 2];
 dst[2] = mat[0 * 4 + 2] * a.mat[2 * 4 + 0] + mat[1 * 4 + 2] * a.mat[2 * 4 + 1] + mat[2 * 4 + 2] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 2] = dst[0];
 mat[1 * 4 + 2] = dst[1];
 mat[2 * 4 + 2] = dst[2];

 dst[0] = mat[0 * 4 + 3] * a.mat[0 * 4 + 0] + mat[1 * 4 + 3] * a.mat[0 * 4 + 1] + mat[2 * 4 + 3] * a.mat[0 * 4 + 2];
 dst[1] = mat[0 * 4 + 3] * a.mat[1 * 4 + 0] + mat[1 * 4 + 3] * a.mat[1 * 4 + 1] + mat[2 * 4 + 3] * a.mat[1 * 4 + 2];
 dst[2] = mat[0 * 4 + 3] * a.mat[2 * 4 + 0] + mat[1 * 4 + 3] * a.mat[2 * 4 + 1] + mat[2 * 4 + 3] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 3] = dst[0];
 mat[1 * 4 + 3] = dst[1];
 mat[2 * 4 + 3] = dst[2];

 mat[0 * 4 + 3] += a.mat[0 * 4 + 3];
 mat[1 * 4 + 3] += a.mat[1 * 4 + 3];
 mat[2 * 4 + 3] += a.mat[2 * 4 + 3];

 return *this;
}

inline idJointMat &idJointMat::operator/=( const idJointMat &a ) {
 float dst[3];

 mat[0 * 4 + 3] -= a.mat[0 * 4 + 3];
 mat[1 * 4 + 3] -= a.mat[1 * 4 + 3];
 mat[2 * 4 + 3] -= a.mat[2 * 4 + 3];

 dst[0] = mat[0 * 4 + 0] * a.mat[0 * 4 + 0] + mat[1 * 4 + 0] * a.mat[1 * 4 + 0] + mat[2 * 4 + 0] * a.mat[2 * 4 + 0];
 dst[1] = mat[0 * 4 + 0] * a.mat[0 * 4 + 1] + mat[1 * 4 + 0] * a.mat[1 * 4 + 1] + mat[2 * 4 + 0] * a.mat[2 * 4 + 1];
 dst[2] = mat[0 * 4 + 0] * a.mat[0 * 4 + 2] + mat[1 * 4 + 0] * a.mat[1 * 4 + 2] + mat[2 * 4 + 0] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 0] = dst[0];
 mat[1 * 4 + 0] = dst[1];
 mat[2 * 4 + 0] = dst[2];

 dst[0] = mat[0 * 4 + 1] * a.mat[0 * 4 + 0] + mat[1 * 4 + 1] * a.mat[1 * 4 + 0] + mat[2 * 4 + 1] * a.mat[2 * 4 + 0];
 dst[1] = mat[0 * 4 + 1] * a.mat[0 * 4 + 1] + mat[1 * 4 + 1] * a.mat[1 * 4 + 1] + mat[2 * 4 + 1] * a.mat[2 * 4 + 1];
 dst[2] = mat[0 * 4 + 1] * a.mat[0 * 4 + 2] + mat[1 * 4 + 1] * a.mat[1 * 4 + 2] + mat[2 * 4 + 1] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 1] = dst[0];
 mat[1 * 4 + 1] = dst[1];
 mat[2 * 4 + 1] = dst[2];

 dst[0] = mat[0 * 4 + 2] * a.mat[0 * 4 + 0] + mat[1 * 4 + 2] * a.mat[1 * 4 + 0] + mat[2 * 4 + 2] * a.mat[2 * 4 + 0];
 dst[1] = mat[0 * 4 + 2] * a.mat[0 * 4 + 1] + mat[1 * 4 + 2] * a.mat[1 * 4 + 1] + mat[2 * 4 + 2] * a.mat[2 * 4 + 1];
 dst[2] = mat[0 * 4 + 2] * a.mat[0 * 4 + 2] + mat[1 * 4 + 2] * a.mat[1 * 4 + 2] + mat[2 * 4 + 2] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 2] = dst[0];
 mat[1 * 4 + 2] = dst[1];
 mat[2 * 4 + 2] = dst[2];

 dst[0] = mat[0 * 4 + 3] * a.mat[0 * 4 + 0] + mat[1 * 4 + 3] * a.mat[1 * 4 + 0] + mat[2 * 4 + 3] * a.mat[2 * 4 + 0];
 dst[1] = mat[0 * 4 + 3] * a.mat[0 * 4 + 1] + mat[1 * 4 + 3] * a.mat[1 * 4 + 1] + mat[2 * 4 + 3] * a.mat[2 * 4 + 1];
 dst[2] = mat[0 * 4 + 3] * a.mat[0 * 4 + 2] + mat[1 * 4 + 3] * a.mat[1 * 4 + 2] + mat[2 * 4 + 3] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 3] = dst[0];
 mat[1 * 4 + 3] = dst[1];
 mat[2 * 4 + 3] = dst[2];

 return *this;
}

inline bool idJointMat::Compare( const idJointMat &a ) const {
 int i;

 for ( i = 0; i < 12; i++ ) {
  if ( mat[i] != a.mat[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idJointMat::Compare( const idJointMat &a, const float epsilon ) const {
 int i;

 for ( i = 0; i < 12; i++ ) {
  if ( idMath::Fabs( mat[i] - a.mat[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idJointMat::operator==( const idJointMat &a ) const {
 return Compare( a );
}

inline bool idJointMat::operator!=( const idJointMat &a ) const {
 return !Compare( a );
}

inline idMat3 idJointMat::ToMat3( void ) const {
 return idMat3( mat[0 * 4 + 0], mat[1 * 4 + 0], mat[2 * 4 + 0],
     mat[0 * 4 + 1], mat[1 * 4 + 1], mat[2 * 4 + 1],
     mat[0 * 4 + 2], mat[1 * 4 + 2], mat[2 * 4 + 2] );
}

inline idVec3 idJointMat::ToVec3( void ) const {
 return idVec3( mat[0 * 4 + 3], mat[1 * 4 + 3], mat[2 * 4 + 3] );
}

inline const float *idJointMat::ToFloatPtr( void ) const {
 return mat;
}

inline float *idJointMat::ToFloatPtr( void ) {
 return mat;
}
# 201 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Winding.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Winding.h"
class idWinding {

public:
     idWinding( void );
     explicit idWinding( const int n );
     explicit idWinding( const idVec3 *verts, const int n );
     explicit idWinding( const idVec3 &normal, const float dist );
     explicit idWinding( const idPlane &plane );
     explicit idWinding( const idWinding &winding );
 virtual ~idWinding( void );

 idWinding & operator=( const idWinding &winding );
 const idVec5 & operator[]( const int index ) const;
 idVec5 & operator[]( const int index );


 idWinding & operator+=( const idVec3 &v );
 idWinding & operator+=( const idVec5 &v );
 void AddPoint( const idVec3 &v );
 void AddPoint( const idVec5 &v );


 int GetNumPoints( void ) const;
 void SetNumPoints( int n );
 virtual void Clear( void );


 void BaseForPlane( const idVec3 &normal, const float dist );
 void BaseForPlane( const idPlane &plane );



 int Split( const idPlane &plane, const float epsilon, idWinding **front, idWinding **back ) const;


 idWinding * Clip( const idPlane &plane, const float epsilon = 0.1f, const bool keepOn = false );


 bool ClipInPlace( const idPlane &plane, const float epsilon = 0.1f, const bool keepOn = false );


 idWinding * Copy( void ) const;
 idWinding * Reverse( void ) const;
 void ReverseSelf( void );
 void RemoveEqualPoints( const float epsilon = 0.1f );
 void RemoveColinearPoints( const idVec3 &normal, const float epsilon = 0.1f );
 void RemovePoint( int point );
 void InsertPoint( const idVec3 &point, int spot );
 bool InsertPointIfOnEdge( const idVec3 &point, const idPlane &plane, const float epsilon = 0.1f );

 void AddToConvexHull( const idWinding *winding, const idVec3 &normal, const float epsilon = 0.1f );

 void AddToConvexHull( const idVec3 &point, const idVec3 &normal, const float epsilon = 0.1f );


 idWinding * TryMerge( const idWinding &w, const idVec3 &normal, int keep = false ) const;

 bool Check( bool print = true ) const;

 float GetArea( void ) const;
 idVec3 GetCenter( void ) const;
 float GetRadius( const idVec3 &center ) const;
 void GetPlane( idVec3 &normal, float &dist ) const;
 void GetPlane( idPlane &plane ) const;
 void GetBounds( idBounds &bounds ) const;

 bool IsTiny( void ) const;
 bool IsHuge( void ) const;
 void Print( void ) const;

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;

 bool PlanesConcave( const idWinding &w2, const idVec3 &normal1, const idVec3 &normal2, float dist1, float dist2 ) const;

 bool PointInside( const idVec3 &normal, const idVec3 &point, const float epsilon ) const;

 bool LineIntersection( const idPlane &windingPlane, const idVec3 &start, const idVec3 &end, bool backFaceCull = false ) const;

 bool RayIntersection( const idPlane &windingPlane, const idVec3 &start, const idVec3 &dir, float &scale, bool backFaceCull = false ) const;

 static float TriangleArea( const idVec3 &a, const idVec3 &b, const idVec3 &c );

protected:
 int numPoints;
 idVec5 * p;
 int allocedSize;

 bool EnsureAlloced( int n, bool keep = false );
 virtual bool ReAllocate( int n, bool keep = false );
};

inline idWinding::idWinding( void ) {
 numPoints = allocedSize = 0;
 p = __null;
}

inline idWinding::idWinding( int n ) {
 numPoints = allocedSize = 0;
 p = __null;
 EnsureAlloced( n );
}

inline idWinding::idWinding( const idVec3 *verts, const int n ) {
 int i;

 numPoints = allocedSize = 0;
 p = __null;
 if ( !EnsureAlloced( n ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < n; i++ ) {
  p[i].ToVec3() = verts[i];
  p[i].s = p[i].t = 0.0f;
 }
 numPoints = n;
}

inline idWinding::idWinding( const idVec3 &normal, const float dist ) {
 numPoints = allocedSize = 0;
 p = __null;
 BaseForPlane( normal, dist );
}

inline idWinding::idWinding( const idPlane &plane ) {
 numPoints = allocedSize = 0;
 p = __null;
 BaseForPlane( plane );
}

inline idWinding::idWinding( const idWinding &winding ) {
 int i;
 if ( !EnsureAlloced( winding.GetNumPoints() ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < winding.GetNumPoints(); i++ ) {
  p[i] = winding[i];
 }
 numPoints = winding.GetNumPoints();
}

inline idWinding::~idWinding( void ) {
 delete[] p;
 p = __null;
}

inline idWinding &idWinding::operator=( const idWinding &winding ) {
 int i;

 if ( !EnsureAlloced( winding.numPoints ) ) {
  numPoints = 0;
  return *this;
 }
 for ( i = 0; i < winding.numPoints; i++ ) {
  p[i] = winding.p[i];
 }
 numPoints = winding.numPoints;
 return *this;
}

inline const idVec5 &idWinding::operator[]( const int index ) const {

 return p[ index ];
}

inline idVec5 &idWinding::operator[]( const int index ) {

 return p[ index ];
}

inline idWinding &idWinding::operator+=( const idVec3 &v ) {
 AddPoint( v );
 return *this;
}

inline idWinding &idWinding::operator+=( const idVec5 &v ) {
 AddPoint( v );
 return *this;
}

inline void idWinding::AddPoint( const idVec3 &v ) {
 if ( !EnsureAlloced(numPoints+1, true) ) {
  return;
 }
 p[numPoints] = v;
 numPoints++;
}

inline void idWinding::AddPoint( const idVec5 &v ) {
 if ( !EnsureAlloced(numPoints+1, true) ) {
  return;
 }
 p[numPoints] = v;
 numPoints++;
}

inline int idWinding::GetNumPoints( void ) const {
 return numPoints;
}

inline void idWinding::SetNumPoints( int n ) {
 if ( !EnsureAlloced( n, true ) ) {
  return;
 }
 numPoints = n;
}

inline void idWinding::Clear( void ) {
 numPoints = 0;
 delete[] p;
 p = __null;
}

inline void idWinding::BaseForPlane( const idPlane &plane ) {
 BaseForPlane( plane.Normal(), plane.Dist() );
}

inline bool idWinding::EnsureAlloced( int n, bool keep ) {
 if ( n > allocedSize ) {
  return ReAllocate( n, keep );
 }
 return true;
}
# 281 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Winding.h"
class idFixedWinding : public idWinding {

public:
     idFixedWinding( void );
     explicit idFixedWinding( const int n );
     explicit idFixedWinding( const idVec3 *verts, const int n );
     explicit idFixedWinding( const idVec3 &normal, const float dist );
     explicit idFixedWinding( const idPlane &plane );
     explicit idFixedWinding( const idWinding &winding );
     explicit idFixedWinding( const idFixedWinding &winding );
 virtual ~idFixedWinding( void );

 idFixedWinding &operator=( const idWinding &winding );

 virtual void Clear( void );



 int Split( idFixedWinding *back, const idPlane &plane, const float epsilon = 0.1f );

protected:
 idVec5 data[64];

 virtual bool ReAllocate( int n, bool keep = false );
};

inline idFixedWinding::idFixedWinding( void ) {
 numPoints = 0;
 p = data;
 allocedSize = 64;
}

inline idFixedWinding::idFixedWinding( int n ) {
 numPoints = 0;
 p = data;
 allocedSize = 64;
}

inline idFixedWinding::idFixedWinding( const idVec3 *verts, const int n ) {
 int i;

 numPoints = 0;
 p = data;
 allocedSize = 64;
 if ( !EnsureAlloced( n ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < n; i++ ) {
  p[i].ToVec3() = verts[i];
  p[i].s = p[i].t = 0;
 }
 numPoints = n;
}

inline idFixedWinding::idFixedWinding( const idVec3 &normal, const float dist ) {
 numPoints = 0;
 p = data;
 allocedSize = 64;
 BaseForPlane( normal, dist );
}

inline idFixedWinding::idFixedWinding( const idPlane &plane ) {
 numPoints = 0;
 p = data;
 allocedSize = 64;
 BaseForPlane( plane );
}

inline idFixedWinding::idFixedWinding( const idWinding &winding ) {
 int i;

 p = data;
 allocedSize = 64;
 if ( !EnsureAlloced( winding.GetNumPoints() ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < winding.GetNumPoints(); i++ ) {
  p[i] = winding[i];
 }
 numPoints = winding.GetNumPoints();
}

inline idFixedWinding::idFixedWinding( const idFixedWinding &winding ) {
 int i;

 p = data;
 allocedSize = 64;
 if ( !EnsureAlloced( winding.GetNumPoints() ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < winding.GetNumPoints(); i++ ) {
  p[i] = winding[i];
 }
 numPoints = winding.GetNumPoints();
}

inline idFixedWinding::~idFixedWinding( void ) {
 p = __null;
}

inline idFixedWinding &idFixedWinding::operator=( const idWinding &winding ) {
 int i;

 if ( !EnsureAlloced( winding.GetNumPoints() ) ) {
  numPoints = 0;
  return *this;
 }
 for ( i = 0; i < winding.GetNumPoints(); i++ ) {
  p[i] = winding[i];
 }
 numPoints = winding.GetNumPoints();
 return *this;
}

inline void idFixedWinding::Clear( void ) {
 numPoints = 0;
}
# 202 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Winding2D.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Winding2D.h"
class idWinding2D {
public:
     idWinding2D( void );

 idWinding2D & operator=( const idWinding2D &winding );
 const idVec2 & operator[]( const int index ) const;
 idVec2 & operator[]( const int index );

 void Clear( void );
 void AddPoint( const idVec2 &point );
 int GetNumPoints( void ) const;

 void Expand( const float d );
 void ExpandForAxialBox( const idVec2 bounds[2] );



 int Split( const idVec3 &plane, const float epsilon, idWinding2D **front, idWinding2D **back ) const;


 bool ClipInPlace( const idVec3 &plane, const float epsilon = 0.1f, const bool keepOn = false );

 idWinding2D * Copy( void ) const;
 idWinding2D * Reverse( void ) const;

 float GetArea( void ) const;
 idVec2 GetCenter( void ) const;
 float GetRadius( const idVec2 &center ) const;
 void GetBounds( idVec2 bounds[2] ) const;

 bool IsTiny( void ) const;
 bool IsHuge( void ) const;
 void Print( void ) const;

 float PlaneDistance( const idVec3 &plane ) const;
 int PlaneSide( const idVec3 &plane, const float epsilon = 0.1f ) const;

 bool PointInside( const idVec2 &point, const float epsilon ) const;
 bool LineIntersection( const idVec2 &start, const idVec2 &end ) const;
 bool RayIntersection( const idVec2 &start, const idVec2 &dir, float &scale1, float &scale2, int *edgeNums = __null ) const;

 static idVec3 Plane2DFromPoints( const idVec2 &start, const idVec2 &end, const bool normalize = false );
 static idVec3 Plane2DFromVecs( const idVec2 &start, const idVec2 &dir, const bool normalize = false );
 static bool Plane2DIntersection( const idVec3 &plane1, const idVec3 &plane2, idVec2 &point );

private:
 int numPoints;
 idVec2 p[16];
};

inline idWinding2D::idWinding2D( void ) {
 numPoints = 0;
}

inline idWinding2D &idWinding2D::operator=( const idWinding2D &winding ) {
 int i;

 for ( i = 0; i < winding.numPoints; i++ ) {
  p[i] = winding.p[i];
 }
 numPoints = winding.numPoints;
 return *this;
}

inline const idVec2 &idWinding2D::operator[]( const int index ) const {
 return p[ index ];
}

inline idVec2 &idWinding2D::operator[]( const int index ) {
 return p[ index ];
}

inline void idWinding2D::Clear( void ) {
 numPoints = 0;
}

inline void idWinding2D::AddPoint( const idVec2 &point ) {
 p[numPoints++] = point;
}

inline int idWinding2D::GetNumPoints( void ) const {
 return numPoints;
}

inline idVec3 idWinding2D::Plane2DFromPoints( const idVec2 &start, const idVec2 &end, const bool normalize ) {
 idVec3 plane;
 plane.x = start.y - end.y;
 plane.y = end.x - start.x;
 if ( normalize ) {
  plane.ToVec2().Normalize();
 }
 plane.z = - ( start.x * plane.x + start.y * plane.y );
 return plane;
}

inline idVec3 idWinding2D::Plane2DFromVecs( const idVec2 &start, const idVec2 &dir, const bool normalize ) {
 idVec3 plane;
 plane.x = -dir.y;
 plane.y = dir.x;
 if ( normalize ) {
  plane.ToVec2().Normalize();
 }
 plane.z = - ( start.x * plane.x + start.y * plane.y );
 return plane;
}

inline bool idWinding2D::Plane2DIntersection( const idVec3 &plane1, const idVec3 &plane2, idVec2 &point ) {
 float n00, n01, n11, det, invDet, f0, f1;

 n00 = plane1.x * plane1.x + plane1.y * plane1.y;
 n01 = plane1.x * plane2.x + plane1.y * plane2.y;
 n11 = plane2.x * plane2.x + plane2.y * plane2.y;
 det = n00 * n11 - n01 * n01;

 if ( idMath::Fabs(det) < 1e-6f ) {
  return false;
 }

 invDet = 1.0f / det;
 f0 = ( n01 * plane2.z - n11 * plane1.z ) * invDet;
 f1 = ( n01 * plane1.z - n00 * plane2.z ) * invDet;
 point.x = f0 * plane1.x + f1 * plane2.x;
 point.y = f0 * plane1.y + f1 * plane2.y;
 return true;
}
# 203 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Surface.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Surface.h"
typedef struct surfaceEdge_s {
 int verts[2];
 int tris[2];
} surfaceEdge_t;


class idSurface {
public:
       idSurface( void );
       explicit idSurface( const idSurface &surf );
       explicit idSurface( const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes );
       ~idSurface( void );

 const idDrawVert & operator[]( const int index ) const;
 idDrawVert & operator[]( const int index );
 idSurface & operator+=( const idSurface &surf );

 int GetNumIndexes( void ) const { return indexes.Num(); }
 const int * GetIndexes( void ) const { return indexes.Ptr(); }
 int GetNumVertices( void ) const { return verts.Num(); }
 const idDrawVert * GetVertices( void ) const { return verts.Ptr(); }
 const int * GetEdgeIndexes( void ) const { return edgeIndexes.Ptr(); }
 const surfaceEdge_t * GetEdges( void ) const { return edges.Ptr(); }

 void Clear( void );
 void SwapTriangles( idSurface &surf );
 void TranslateSelf( const idVec3 &translation );
 void RotateSelf( const idMat3 &rotation );




 int Split( const idPlane &plane, const float epsilon, idSurface **front, idSurface **back, int *frontOnPlaneEdges = __null, int *backOnPlaneEdges = __null ) const;


 bool ClipInPlace( const idPlane &plane, const float epsilon = 0.1f, const bool keepOn = false );


 bool IsConnected( void ) const;

 bool IsClosed( void ) const;

 bool IsPolytope( const float epsilon = 0.1f ) const;

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;


 bool LineIntersection( const idVec3 &start, const idVec3 &end, bool backFaceCull = false ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale, bool backFaceCull = false ) const;

protected:
 idList<idDrawVert> verts;
 idList<int> indexes;
 idList<surfaceEdge_t> edges;
 idList<int> edgeIndexes;

protected:
 void GenerateEdgeIndexes( void );
 int FindEdge( int v1, int v2 ) const;
};






inline idSurface::idSurface( void ) {
}






inline idSurface::idSurface( const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) {
 ((void)0);
 this->verts.SetNum( numVerts );
 memcpy( this->verts.Ptr(), verts, numVerts * sizeof( verts[0] ) );
 this->indexes.SetNum( numIndexes );
 memcpy( this->indexes.Ptr(), indexes, numIndexes * sizeof( indexes[0] ) );
 GenerateEdgeIndexes();
}






inline idSurface::idSurface( const idSurface &surf ) {
 this->verts = surf.verts;
 this->indexes = surf.indexes;
 this->edges = surf.edges;
 this->edgeIndexes = surf.edgeIndexes;
}






inline idSurface::~idSurface( void ) {
}






inline const idDrawVert &idSurface::operator[]( const int index ) const {
 return verts[ index ];
};






inline idDrawVert &idSurface::operator[]( const int index ) {
 return verts[ index ];
};






inline idSurface &idSurface::operator+=( const idSurface &surf ) {
 int i, m, n;
 n = verts.Num();
 m = indexes.Num();
 verts.Append( surf.verts );
 indexes.Append( surf.indexes );
 for ( i = m; i < indexes.Num(); i++ ) {
  indexes[i] += n;
 }
 GenerateEdgeIndexes();
 return *this;
}






inline void idSurface::Clear( void ) {
 verts.Clear();
 indexes.Clear();
 edges.Clear();
 edgeIndexes.Clear();
}






inline void idSurface::SwapTriangles( idSurface &surf ) {
 verts.Swap( surf.verts );
 indexes.Swap( surf.indexes );
 edges.Swap( surf.edges );
 edgeIndexes.Swap( surf.edgeIndexes );
}






inline void idSurface::TranslateSelf( const idVec3 &translation ) {
 for ( int i = 0; i < verts.Num(); i++ ) {
  verts[i].xyz += translation;
 }
}






inline void idSurface::RotateSelf( const idMat3 &rotation ) {
 for ( int i = 0; i < verts.Num(); i++ ) {
  verts[i].xyz *= rotation;
  verts[i].normal *= rotation;
  verts[i].tangents[0] *= rotation;
  verts[i].tangents[1] *= rotation;
 }
}
# 204 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Surface_Patch.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Surface_Patch.h"
class idSurface_Patch : public idSurface {

public:
      idSurface_Patch( void );
      idSurface_Patch( int maxPatchWidth, int maxPatchHeight );
      idSurface_Patch( const idSurface_Patch &patch );
      ~idSurface_Patch( void );

 void SetSize( int patchWidth, int patchHeight );
 int GetWidth( void ) const;
 int GetHeight( void ) const;


 void Subdivide( float maxHorizontalError, float maxVerticalError, float maxLength, bool genNormals = false );

 void SubdivideExplicit( int horzSubdivisions, int vertSubdivisions, bool genNormals, bool removeLinear = false );

protected:
 int width;
 int height;
 int maxWidth;
 int maxHeight;
 bool expanded;

private:

 void PutOnCurve( void );

 void RemoveLinearColumnsRows( void );

 void ResizeExpanded( int height, int width );

 void Expand( void );

 void Collapse( void );

 void ProjectPointOntoVector( const idVec3 &point, const idVec3 &vStart, const idVec3 &vEnd, idVec3 &vProj );

 void GenerateNormals( void );

 void GenerateIndexes( void );

 void LerpVert( const idDrawVert &a, const idDrawVert &b, idDrawVert &out ) const;

 void SampleSinglePatchPoint( const idDrawVert ctrl[3][3], float u, float v, idDrawVert *out ) const;
 void SampleSinglePatch( const idDrawVert ctrl[3][3], int baseCol, int baseRow, int width, int horzSub, int vertSub, idDrawVert *outVerts ) const;
};






inline idSurface_Patch::idSurface_Patch( void ) {
 height = width = maxHeight = maxWidth = 0;
 expanded = false;
}






inline idSurface_Patch::idSurface_Patch( int maxPatchWidth, int maxPatchHeight ) {
 width = height = 0;
 maxWidth = maxPatchWidth;
 maxHeight = maxPatchHeight;
 verts.SetNum( maxWidth * maxHeight );
 expanded = false;
}






inline idSurface_Patch::idSurface_Patch( const idSurface_Patch &patch ) {
 (*this) = patch;
}






inline idSurface_Patch::~idSurface_Patch() {
}






inline int idSurface_Patch::GetWidth( void ) const {
 return width;
}






inline int idSurface_Patch::GetHeight( void ) const {
 return height;
}
# 205 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Surface_Polytope.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Surface_Polytope.h"
class idSurface_Polytope : public idSurface {
public:
      idSurface_Polytope( void );

 void FromPlanes( const idPlane *planes, const int numPlanes );

 void SetupTetrahedron( const idBounds &bounds );
 void SetupHexahedron( const idBounds &bounds );
 void SetupOctahedron( const idBounds &bounds );
 void SetupDodecahedron( const idBounds &bounds );
 void SetupIcosahedron( const idBounds &bounds );
 void SetupCylinder( const idBounds &bounds, const int numSides );
 void SetupCone( const idBounds &bounds, const int numSides );

 int SplitPolytope( const idPlane &plane, const float epsilon, idSurface_Polytope **front, idSurface_Polytope **back ) const;

protected:

};






inline idSurface_Polytope::idSurface_Polytope( void ) {
}
# 206 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Surface_SweptSpline.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/Surface_SweptSpline.h"
class idSurface_SweptSpline : public idSurface {
public:
       idSurface_SweptSpline( void );
       ~idSurface_SweptSpline( void );

 void SetSpline( idCurve_Spline<idVec4> *spline );
 void SetSweptSpline( idCurve_Spline<idVec4> *sweptSpline );
 void SetSweptCircle( const float radius );

 void Tessellate( const int splineSubdivisions, const int sweptSplineSubdivisions );

 void Clear( void );

protected:
 idCurve_Spline<idVec4> *spline;
 idCurve_Spline<idVec4> *sweptSpline;

 void GetFrame( const idMat3 &previousFrame, const idVec3 dir, idMat3 &newFrame );
};






inline idSurface_SweptSpline::idSurface_SweptSpline( void ) {
 spline = __null;
 sweptSpline = __null;
}






inline idSurface_SweptSpline::~idSurface_SweptSpline( void ) {
 delete spline;
 delete sweptSpline;
}






inline void idSurface_SweptSpline::Clear( void ) {
 idSurface::Clear();
 delete spline;
 spline = __null;
 delete sweptSpline;
 sweptSpline = __null;
}
# 207 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/TraceModel.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/geometry/TraceModel.h"
class idVec3;
class idMat3;
class idBounds;


typedef enum {
 TRM_INVALID,
 TRM_BOX,
 TRM_OCTAHEDRON,
 TRM_DODECAHEDRON,
 TRM_CYLINDER,
 TRM_CONE,
 TRM_BONE,
 TRM_POLYGON,
 TRM_POLYGONVOLUME,
 TRM_CUSTOM
} traceModel_t;







typedef idVec3 traceModelVert_t;

typedef struct {
 int v[2];
 idVec3 normal;
} traceModelEdge_t;

typedef struct {
 idVec3 normal;
 float dist;
 idBounds bounds;
 int numEdges;
 int edges[16];
} traceModelPoly_t;

class idTraceModel {

public:
 traceModel_t type;
 int numVerts;
 traceModelVert_t verts[32];
 int numEdges;
 traceModelEdge_t edges[32 +1];
 int numPolys;
 traceModelPoly_t polys[16];
 idVec3 offset;
 idBounds bounds;
 bool isConvex;

public:
      idTraceModel( void );

      idTraceModel( const idBounds &boxBounds );

      idTraceModel( const idBounds &cylBounds, const int numSides );

      idTraceModel( const float length, const float width );


 void SetupBox( const idBounds &boxBounds );
 void SetupBox( const float size );

 void SetupOctahedron( const idBounds &octBounds );
 void SetupOctahedron( const float size );

 void SetupDodecahedron( const idBounds &dodBounds );
 void SetupDodecahedron( const float size );

 void SetupCylinder( const idBounds &cylBounds, const int numSides );
 void SetupCylinder( const float height, const float width, const int numSides );

 void SetupCone( const idBounds &coneBounds, const int numSides );
 void SetupCone( const float height, const float width, const int numSides );

 void SetupBone( const float length, const float width );

 void SetupPolygon( const idVec3 *v, const int count );
 void SetupPolygon( const idWinding &w );

 int GenerateEdgeNormals( void );

 void Translate( const idVec3 &translation );

 void Rotate( const idMat3 &rotation );

 void Shrink( const float m );

 bool Compare( const idTraceModel &trm ) const;
 bool operator==( const idTraceModel &trm ) const;
 bool operator!=( const idTraceModel &trm ) const;

 float GetPolygonArea( int polyNum ) const;

 int GetProjectionSilhouetteEdges( const idVec3 &projectionOrigin, int silEdges[32] ) const;
 int GetParallelProjectionSilhouetteEdges( const idVec3 &projectionDir, int silEdges[32] ) const;

 void GetMassProperties( const float density, float &mass, idVec3 &centerOfMass, idMat3 &inertiaTensor ) const;

private:
 void InitBox( void );
 void InitOctahedron( void );
 void InitDodecahedron( void );
 void InitBone( void );

 void ProjectionIntegrals( int polyNum, int a, int b, struct projectionIntegrals_s &integrals ) const;
 void PolygonIntegrals( int polyNum, int a, int b, int c, struct polygonIntegrals_s &integrals ) const;
 void VolumeIntegrals( struct volumeIntegrals_s &integrals ) const;
 void VolumeFromPolygon( idTraceModel &trm, float thickness ) const;
 int GetOrderedSilhouetteEdges( const int edgeIsSilEdge[32 +1], int silEdges[32] ) const;
};


inline idTraceModel::idTraceModel( void ) {
 type = TRM_INVALID;
 numVerts = numEdges = numPolys = 0;
 bounds.Zero();
}

inline idTraceModel::idTraceModel( const idBounds &boxBounds ) {
 InitBox();
 SetupBox( boxBounds );
}

inline idTraceModel::idTraceModel( const idBounds &cylBounds, const int numSides ) {
 SetupCylinder( cylBounds, numSides );
}

inline idTraceModel::idTraceModel( const float length, const float width ) {
 InitBone();
 SetupBone( length, width );
}

inline bool idTraceModel::operator==( const idTraceModel &trm ) const {
 return Compare( trm );
}

inline bool idTraceModel::operator!=( const idTraceModel &trm ) const {
 return !Compare( trm );
}
# 208 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Str.h" 1
# 96 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Str.h"
class idVec4;






const int C_COLOR_ESCAPE = '^';
const int C_COLOR_DEFAULT = '0';
const int C_COLOR_RED = '1';
const int C_COLOR_GREEN = '2';
const int C_COLOR_YELLOW = '3';
const int C_COLOR_BLUE = '4';
const int C_COLOR_CYAN = '5';
const int C_COLOR_MAGENTA = '6';
const int C_COLOR_WHITE = '7';
const int C_COLOR_GRAY = '8';
const int C_COLOR_BLACK = '9';
# 129 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Str.h"
const int STR_ALLOC_BASE = 20;
const int STR_ALLOC_GRAN = 32;

typedef enum {
 MEASURE_SIZE = 0,
 MEASURE_BANDWIDTH
} Measure_t;

class idStr {

public:
      idStr( void );
      idStr( const idStr &text );
      idStr( const idStr &text, int start, int end );
      idStr( const char *text );
      idStr( const char *text, int start, int end );
      explicit idStr( const bool b );
      explicit idStr( const char c );
      explicit idStr( const int i );
      explicit idStr( const unsigned u );
      explicit idStr( const float f );
      ~idStr( void );

 size_t Size( void ) const;
 const char * c_str( void ) const;
 operator const char *( void ) const;
 operator const char *( void );

 char operator[]( int index ) const;
 char & operator[]( int index );

 void operator=( const idStr &text );
 void operator=( const char *text );

 friend idStr operator+( const idStr &a, const idStr &b );
 friend idStr operator+( const idStr &a, const char *b );
 friend idStr operator+( const char *a, const idStr &b );

 friend idStr operator+( const idStr &a, const float b );
 friend idStr operator+( const idStr &a, const int b );
 friend idStr operator+( const idStr &a, const unsigned b );
 friend idStr operator+( const idStr &a, const bool b );
 friend idStr operator+( const idStr &a, const char b );

 idStr & operator+=( const idStr &a );
 idStr & operator+=( const char *a );
 idStr & operator+=( const float a );
 idStr & operator+=( const char a );
 idStr & operator+=( const int a );
 idStr & operator+=( const unsigned a );
 idStr & operator+=( const bool a );


 friend bool operator==( const idStr &a, const idStr &b );
 friend bool operator==( const idStr &a, const char *b );
 friend bool operator==( const char *a, const idStr &b );


 friend bool operator!=( const idStr &a, const idStr &b );
 friend bool operator!=( const idStr &a, const char *b );
 friend bool operator!=( const char *a, const idStr &b );


 int Cmp( const char *text ) const;
 int Cmpn( const char *text, int n ) const;
 int CmpPrefix( const char *text ) const;


 int Icmp( const char *text ) const;
 int Icmpn( const char *text, int n ) const;
 int IcmpPrefix( const char *text ) const;


 int IcmpNoColor( const char *text ) const;


 int IcmpPath( const char *text ) const;
 int IcmpnPath( const char *text, int n ) const;
 int IcmpPrefixPath( const char *text ) const;

 int Length( void ) const;
 int Allocated( void ) const;
 void Empty( void );
 bool IsEmpty( void ) const;
 void Clear( void );
 void Append( const char a );
 void Append( const idStr &text );
 void Append( const char *text );
 void Append( const char *text, int len );
 void Insert( const char a, int index );
 void Insert( const char *text, int index );
 void ToLower( void );
 void ToUpper( void );
 bool IsNumeric( void ) const;
 bool IsColor( void ) const;
 bool HasLower( void ) const;
 bool HasUpper( void ) const;
 int LengthWithoutColors( void ) const;
 idStr & RemoveColors( void );
 void CapLength( int );
 void Fill( const char ch, int newlen );

 int Find( const char c, int start = 0, int end = -1 ) const;
 int Find( const char *text, bool casesensitive = true, int start = 0, int end = -1 ) const;
 bool Filter( const char *filter, bool casesensitive ) const;
 int Last( const char c ) const;
 const char * Left( int len, idStr &result ) const;
 const char * Right( int len, idStr &result ) const;
 const char * Mid( int start, int len, idStr &result ) const;
 idStr Left( int len ) const;
 idStr Right( int len ) const;
 idStr Mid( int start, int len ) const;
 void StripLeading( const char c );
 void StripLeading( const char *string );
 bool StripLeadingOnce( const char *string );
 void StripTrailing( const char c );
 void StripTrailing( const char *string );
 bool StripTrailingOnce( const char *string );
 void Strip( const char c );
 void Strip( const char *string );
 void StripTrailingWhitespace( void );
 idStr & StripQuotes( void );
 void Replace( const char *old, const char *nw );


 int FileNameHash( void ) const;
 idStr & BackSlashesToSlashes( void );
 idStr & SetFileExtension( const char *extension );
 idStr & StripFileExtension( void );
 idStr & StripAbsoluteFileExtension( void );
 idStr & DefaultFileExtension( const char *extension );
 idStr & DefaultPath( const char *basepath );
 void AppendPath( const char *text );
 idStr & StripFilename( void );
 idStr & StripPath( void );
 void ExtractFilePath( idStr &dest ) const;
 void ExtractFileName( idStr &dest ) const;
 void ExtractFileBase( idStr &dest ) const;
 void ExtractFileExtension( idStr &dest ) const;
 bool CheckExtension( const char *ext );


 static int Length( const char *s );
 static char * ToLower( char *s );
 static char * ToUpper( char *s );
 static bool IsNumeric( const char *s );
 static bool IsColor( const char *s );
 static bool HasLower( const char *s );
 static bool HasUpper( const char *s );
 static int LengthWithoutColors( const char *s );
 static char * RemoveColors( char *s );
 static int Cmp( const char *s1, const char *s2 );
 static int Cmpn( const char *s1, const char *s2, int n );
 static int Icmp( const char *s1, const char *s2 );
 static int Icmpn( const char *s1, const char *s2, int n );
 static int IcmpNoColor( const char *s1, const char *s2 );
 static int IcmpPath( const char *s1, const char *s2 );
 static int IcmpnPath( const char *s1, const char *s2, int n );
 static void Append( char *dest, int size, const char *src );
 static void Copynz( char *dest, const char *src, int destsize );
 static int snPrintf( char *dest, int size, const char *fmt, ... ) __attribute__((format(printf,3,4)));
 static int vsnPrintf( char *dest, int size, const char *fmt, va_list argptr );
 static int FindChar( const char *str, const char c, int start = 0, int end = -1 );
 static int FindText( const char *str, const char *text, bool casesensitive = true, int start = 0, int end = -1 );
 static bool Filter( const char *filter, const char *name, bool casesensitive );
 static void StripMediaName( const char *name, idStr &mediaName );
 static bool CheckExtension( const char *name, const char *ext );
 static const char * FloatArrayToString( const float *array, const int length, const int precision );


 static int Hash( const char *string );
 static int Hash( const char *string, int length );
 static int IHash( const char *string );
 static int IHash( const char *string, int length );


 static char ToLower( char c );
 static char ToUpper( char c );
 static bool CharIsPrintable( int c );
 static bool CharIsLower( int c );
 static bool CharIsUpper( int c );
 static bool CharIsAlpha( int c );
 static bool CharIsNumeric( int c );
 static bool CharIsNewLine( char c );
 static bool CharIsTab( char c );
 static int ColorIndex( int c );
 static idVec4 & ColorForIndex( int i );

 friend int sprintf( idStr &dest, const char *fmt, ... );
 friend int vsprintf( idStr &dest, const char *fmt, va_list ap );

 void ReAllocate( int amount, bool keepold );
 void FreeData( void );


 int BestUnit( const char *format, float value, Measure_t measure );

 void SetUnit( const char *format, float value, int unit, Measure_t measure );

 static void InitMemory( void );
 static void ShutdownMemory( void );
 static void PurgeMemory( void );
 static void ShowMemoryUsage_f( const idCmdArgs &args );

 int DynamicMemoryUsed() const;
 static idStr FormatNumber( int number );

protected:
 int len;
 char * data;
 int alloced;
 char baseBuffer[ STR_ALLOC_BASE ];

 void Init( void );
 void EnsureAlloced( int amount, bool keepold = true );
};

char * va( const char *fmt, ... ) __attribute__((format(printf,1,2)));


inline void idStr::EnsureAlloced( int amount, bool keepold ) {
 if ( amount > alloced ) {
  ReAllocate( amount, keepold );
 }
}

inline void idStr::Init( void ) {
 len = 0;
 alloced = STR_ALLOC_BASE;
 data = baseBuffer;
 data[ 0 ] = '\0';



}

inline idStr::idStr( void ) {
 Init();
}

inline idStr::idStr( const idStr &text ) {
 int l;

 Init();
 l = text.Length();
 EnsureAlloced( l + 1 );
 strcpy( data, text.data );
 len = l;
}

inline idStr::idStr( const idStr &text, int start, int end ) {
 int i;
 int l;

 Init();
 if ( end > text.Length() ) {
  end = text.Length();
 }
 if ( start > text.Length() ) {
  start = text.Length();
 } else if ( start < 0 ) {
  start = 0;
 }

 l = end - start;
 if ( l < 0 ) {
  l = 0;
 }

 EnsureAlloced( l + 1 );

 for ( i = 0; i < l; i++ ) {
  data[ i ] = text[ start + i ];
 }

 data[ l ] = '\0';
 len = l;
}

inline idStr::idStr( const char *text ) {
 int l;

 Init();
 if ( text ) {
  l = strlen( text );
  EnsureAlloced( l + 1 );
  strcpy( data, text );
  len = l;
 }
}

inline idStr::idStr( const char *text, int start, int end ) {
 int i;
 int l = strlen( text );

 Init();
 if ( end > l ) {
  end = l;
 }
 if ( start > l ) {
  start = l;
 } else if ( start < 0 ) {
  start = 0;
 }

 l = end - start;
 if ( l < 0 ) {
  l = 0;
 }

 EnsureAlloced( l + 1 );

 for ( i = 0; i < l; i++ ) {
  data[ i ] = text[ start + i ];
 }

 data[ l ] = '\0';
 len = l;
}

inline idStr::idStr( const bool b ) {
 Init();
 EnsureAlloced( 2 );
 data[ 0 ] = b ? '1' : '0';
 data[ 1 ] = '\0';
 len = 1;
}

inline idStr::idStr( const char c ) {
 Init();
 EnsureAlloced( 2 );
 data[ 0 ] = c;
 data[ 1 ] = '\0';
 len = 1;
}

inline idStr::idStr( const int i ) {
 char text[ 64 ];
 int l;

 Init();
 l = sprintf( text, "%d", i );
 EnsureAlloced( l + 1 );
 strcpy( data, text );
 len = l;
}

inline idStr::idStr( const unsigned u ) {
 char text[ 64 ];
 int l;

 Init();
 l = sprintf( text, "%u", u );
 EnsureAlloced( l + 1 );
 strcpy( data, text );
 len = l;
}

inline idStr::idStr( const float f ) {
 char text[ 64 ];
 int l;

 Init();
 l = idStr::snPrintf( text, sizeof( text ), "%f", f );
 while( l > 0 && text[l-1] == '0' ) text[--l] = '\0';
 while( l > 0 && text[l-1] == '.' ) text[--l] = '\0';
 EnsureAlloced( l + 1 );
 strcpy( data, text );
 len = l;
}

inline idStr::~idStr( void ) {
 FreeData();
}

inline size_t idStr::Size( void ) const {
 return sizeof( *this ) + Allocated();
}

inline const char *idStr::c_str( void ) const {
 return data;
}

inline idStr::operator const char *( void ) {
 return c_str();
}

inline idStr::operator const char *( void ) const {
 return c_str();
}

inline char idStr::operator[]( int index ) const {
 ((void)0);
 return data[ index ];
}

inline char &idStr::operator[]( int index ) {
 ((void)0);
 return data[ index ];
}

inline void idStr::operator=( const idStr &text ) {
 int l;

 l = text.Length();
 EnsureAlloced( l + 1, false );
 memcpy( data, text.data, l );
 data[l] = '\0';
 len = l;
}

inline idStr operator+( const idStr &a, const idStr &b ) {
 idStr result( a );
 result.Append( b );
 return result;
}

inline idStr operator+( const idStr &a, const char *b ) {
 idStr result( a );
 result.Append( b );
 return result;
}

inline idStr operator+( const char *a, const idStr &b ) {
 idStr result( a );
 result.Append( b );
 return result;
}

inline idStr operator+( const idStr &a, const bool b ) {
 idStr result( a );
 result.Append( b ? "true" : "false" );
 return result;
}

inline idStr operator+( const idStr &a, const char b ) {
 idStr result( a );
 result.Append( b );
 return result;
}

inline idStr operator+( const idStr &a, const float b ) {
 char text[ 64 ];
 idStr result( a );

 sprintf( text, "%f", b );
 result.Append( text );

 return result;
}

inline idStr operator+( const idStr &a, const int b ) {
 char text[ 64 ];
 idStr result( a );

 sprintf( text, "%d", b );
 result.Append( text );

 return result;
}

inline idStr operator+( const idStr &a, const unsigned b ) {
 char text[ 64 ];
 idStr result( a );

 sprintf( text, "%u", b );
 result.Append( text );

 return result;
}

inline idStr &idStr::operator+=( const float a ) {
 char text[ 64 ];

 sprintf( text, "%f", a );
 Append( text );

 return *this;
}

inline idStr &idStr::operator+=( const int a ) {
 char text[ 64 ];

 sprintf( text, "%d", a );
 Append( text );

 return *this;
}

inline idStr &idStr::operator+=( const unsigned a ) {
 char text[ 64 ];

 sprintf( text, "%u", a );
 Append( text );

 return *this;
}

inline idStr &idStr::operator+=( const idStr &a ) {
 Append( a );
 return *this;
}

inline idStr &idStr::operator+=( const char *a ) {
 Append( a );
 return *this;
}

inline idStr &idStr::operator+=( const char a ) {
 Append( a );
 return *this;
}

inline idStr &idStr::operator+=( const bool a ) {
 Append( a ? "true" : "false" );
 return *this;
}

inline bool operator==( const idStr &a, const idStr &b ) {
 return ( !idStr::Cmp( a.data, b.data ) );
}

inline bool operator==( const idStr &a, const char *b ) {
 ((void)0);
 return ( !idStr::Cmp( a.data, b ) );
}

inline bool operator==( const char *a, const idStr &b ) {
 ((void)0);
 return ( !idStr::Cmp( a, b.data ) );
}

inline bool operator!=( const idStr &a, const idStr &b ) {
 return !( a == b );
}

inline bool operator!=( const idStr &a, const char *b ) {
 return !( a == b );
}

inline bool operator!=( const char *a, const idStr &b ) {
 return !( a == b );
}

inline int idStr::Cmp( const char *text ) const {
 ((void)0);
 return idStr::Cmp( data, text );
}

inline int idStr::Cmpn( const char *text, int n ) const {
 ((void)0);
 return idStr::Cmpn( data, text, n );
}

inline int idStr::CmpPrefix( const char *text ) const {
 ((void)0);
 return idStr::Cmpn( data, text, strlen( text ) );
}

inline int idStr::Icmp( const char *text ) const {
 ((void)0);
 return idStr::Icmp( data, text );
}

inline int idStr::Icmpn( const char *text, int n ) const {
 ((void)0);
 return idStr::Icmpn( data, text, n );
}

inline int idStr::IcmpPrefix( const char *text ) const {
 ((void)0);
 return idStr::Icmpn( data, text, strlen( text ) );
}

inline int idStr::IcmpNoColor( const char *text ) const {
 ((void)0);
 return idStr::IcmpNoColor( data, text );
}

inline int idStr::IcmpPath( const char *text ) const {
 ((void)0);
 return idStr::IcmpPath( data, text );
}

inline int idStr::IcmpnPath( const char *text, int n ) const {
 ((void)0);
 return idStr::IcmpnPath( data, text, n );
}

inline int idStr::IcmpPrefixPath( const char *text ) const {
 ((void)0);
 return idStr::IcmpnPath( data, text, strlen( text ) );
}

inline int idStr::Length( void ) const {
 return len;
}

inline int idStr::Allocated( void ) const {
 if ( data != baseBuffer ) {
  return alloced;
 } else {
  return 0;
 }
}

inline void idStr::Empty( void ) {
 EnsureAlloced( 1 );
 data[ 0 ] = '\0';
 len = 0;
}

inline bool idStr::IsEmpty( void ) const {
 return ( idStr::Cmp( data, "" ) == 0 );
}

inline void idStr::Clear( void ) {
 FreeData();
 Init();
}

inline void idStr::Append( const char a ) {
 EnsureAlloced( len + 2 );
 data[ len ] = a;
 len++;
 data[ len ] = '\0';
}

inline void idStr::Append( const idStr &text ) {
 int newLen;
 int i;

 newLen = len + text.Length();
 EnsureAlloced( newLen + 1 );
 for ( i = 0; i < text.len; i++ ) {
  data[ len + i ] = text[ i ];
 }
 len = newLen;
 data[ len ] = '\0';
}

inline void idStr::Append( const char *text ) {
 int newLen;
 int i;

 if ( text ) {
  newLen = len + strlen( text );
  EnsureAlloced( newLen + 1 );
  for ( i = 0; text[ i ]; i++ ) {
   data[ len + i ] = text[ i ];
  }
  len = newLen;
  data[ len ] = '\0';
 }
}

inline void idStr::Append( const char *text, int l ) {
 int newLen;
 int i;

 if ( text && l ) {
  newLen = len + l;
  EnsureAlloced( newLen + 1 );
  for ( i = 0; text[ i ] && i < l; i++ ) {
   data[ len + i ] = text[ i ];
  }
  len = newLen;
  data[ len ] = '\0';
 }
}

inline void idStr::Insert( const char a, int index ) {
 int i, l;

 if ( index < 0 ) {
  index = 0;
 } else if ( index > len ) {
  index = len;
 }

 l = 1;
 EnsureAlloced( len + l + 1 );
 for ( i = len; i >= index; i-- ) {
  data[i+l] = data[i];
 }
 data[index] = a;
 len++;
}

inline void idStr::Insert( const char *text, int index ) {
 int i, l;

 if ( index < 0 ) {
  index = 0;
 } else if ( index > len ) {
  index = len;
 }

 l = strlen( text );
 EnsureAlloced( len + l + 1 );
 for ( i = len; i >= index; i-- ) {
  data[i+l] = data[i];
 }
 for ( i = 0; i < l; i++ ) {
  data[index+i] = text[i];
 }
 len += l;
}

inline void idStr::ToLower( void ) {
 for (int i = 0; data[i]; i++ ) {
  if ( CharIsUpper( data[i] ) ) {
   data[i] += ( 'a' - 'A' );
  }
 }
}

inline void idStr::ToUpper( void ) {
 for (int i = 0; data[i]; i++ ) {
  if ( CharIsLower( data[i] ) ) {
   data[i] -= ( 'a' - 'A' );
  }
 }
}

inline bool idStr::IsNumeric( void ) const {
 return idStr::IsNumeric( data );
}

inline bool idStr::IsColor( void ) const {
 return idStr::IsColor( data );
}

inline bool idStr::HasLower( void ) const {
 return idStr::HasLower( data );
}

inline bool idStr::HasUpper( void ) const {
 return idStr::HasUpper( data );
}

inline idStr &idStr::RemoveColors( void ) {
 idStr::RemoveColors( data );
 len = Length( data );
 return *this;
}

inline int idStr::LengthWithoutColors( void ) const {
 return idStr::LengthWithoutColors( data );
}

inline void idStr::CapLength( int newlen ) {
 if ( len <= newlen ) {
  return;
 }
 data[ newlen ] = 0;
 len = newlen;
}

inline void idStr::Fill( const char ch, int newlen ) {
 EnsureAlloced( newlen + 1 );
 len = newlen;
 memset( data, ch, len );
 data[ len ] = 0;
}

inline int idStr::Find( const char c, int start, int end ) const {
 if ( end == -1 ) {
  end = len;
 }
 return idStr::FindChar( data, c, start, end );
}

inline int idStr::Find( const char *text, bool casesensitive, int start, int end ) const {
 if ( end == -1 ) {
  end = len;
 }
 return idStr::FindText( data, text, casesensitive, start, end );
}

inline bool idStr::Filter( const char *filter, bool casesensitive ) const {
 return idStr::Filter( filter, data, casesensitive );
}

inline const char *idStr::Left( int len, idStr &result ) const {
 return Mid( 0, len, result );
}

inline const char *idStr::Right( int len, idStr &result ) const {
 if ( len >= Length() ) {
  result = *this;
  return result;
 }
 return Mid( Length() - len, len, result );
}

inline idStr idStr::Left( int len ) const {
 return Mid( 0, len );
}

inline idStr idStr::Right( int len ) const {
 if ( len >= Length() ) {
  return *this;
 }
 return Mid( Length() - len, len );
}

inline void idStr::Strip( const char c ) {
 StripLeading( c );
 StripTrailing( c );
}

inline void idStr::Strip( const char *string ) {
 StripLeading( string );
 StripTrailing( string );
}

inline bool idStr::CheckExtension( const char *ext ) {
 return idStr::CheckExtension( data, ext );
}

inline int idStr::Length( const char *s ) {
 int i;
 for ( i = 0; s[i]; i++ ) {}
 return i;
}

inline char *idStr::ToLower( char *s ) {
 for ( int i = 0; s[i]; i++ ) {
  if ( CharIsUpper( s[i] ) ) {
   s[i] += ( 'a' - 'A' );
  }
 }
 return s;
}

inline char *idStr::ToUpper( char *s ) {
 for ( int i = 0; s[i]; i++ ) {
  if ( CharIsLower( s[i] ) ) {
   s[i] -= ( 'a' - 'A' );
  }
 }
 return s;
}

inline int idStr::Hash( const char *string ) {
 int i, hash = 0;
 for ( i = 0; *string != '\0'; i++ ) {
  hash += ( *string++ ) * ( i + 119 );
 }
 return hash;
}

inline int idStr::Hash( const char *string, int length ) {
 int i, hash = 0;
 for ( i = 0; i < length; i++ ) {
  hash += ( *string++ ) * ( i + 119 );
 }
 return hash;
}

inline int idStr::IHash( const char *string ) {
 int i, hash = 0;
 for( i = 0; *string != '\0'; i++ ) {
  hash += ToLower( *string++ ) * ( i + 119 );
 }
 return hash;
}

inline int idStr::IHash( const char *string, int length ) {
 int i, hash = 0;
 for ( i = 0; i < length; i++ ) {
  hash += ToLower( *string++ ) * ( i + 119 );
 }
 return hash;
}

inline bool idStr::IsColor( const char *s ) {
 return ( s[0] == C_COLOR_ESCAPE && s[1] != '\0' && s[1] != ' ' );
}

inline char idStr::ToLower( char c ) {
 if ( c <= 'Z' && c >= 'A' ) {
  return ( c + ( 'a' - 'A' ) );
 }
 return c;
}

inline char idStr::ToUpper( char c ) {
 if ( c >= 'a' && c <= 'z' ) {
  return ( c - ( 'a' - 'A' ) );
 }
 return c;
}

inline bool idStr::CharIsPrintable( int c ) {

 return ( c >= 0x20 && c <= 0x7E ) || ( c >= 0xA1 && c <= 0xFF );
}

inline bool idStr::CharIsLower( int c ) {

 return ( c >= 'a' && c <= 'z' ) || ( c >= 0xE0 && c <= 0xFF );
}

inline bool idStr::CharIsUpper( int c ) {

 return ( c <= 'Z' && c >= 'A' ) || ( c >= 0xC0 && c <= 0xDF );
}

inline bool idStr::CharIsAlpha( int c ) {

 return ( ( c >= 'a' && c <= 'z' ) || ( c >= 'A' && c <= 'Z' ) ||
    ( c >= 0xC0 && c <= 0xFF ) );
}

inline bool idStr::CharIsNumeric( int c ) {
 return ( c <= '9' && c >= '0' );
}

inline bool idStr::CharIsNewLine( char c ) {
 return ( c == '\n' || c == '\r' || c == '\v' );
}

inline bool idStr::CharIsTab( char c ) {
 return ( c == '\t' );
}

inline int idStr::ColorIndex( int c ) {
 return ( c & 15 );
}

inline int idStr::DynamicMemoryUsed() const {
 return ( data == baseBuffer ) ? 0 : alloced;
}
# 211 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Token.h" 1
# 71 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Token.h"
class idToken : public idStr {

 friend class idParser;
 friend class idLexer;

public:
 int type;
 int subtype;
 int line;
 int linesCrossed;
 int flags;

public:
     idToken( void );
     idToken( const idToken *token );
     ~idToken( void );

 void operator=( const idStr& text );
 void operator=( const char *text );

 double GetDoubleValue( void );
 float GetFloatValue( void );
 unsigned long GetUnsignedLongValue( void );
 int GetIntValue( void );
 int WhiteSpaceBeforeToken( void ) const;
 void ClearTokenWhiteSpace( void );

 void NumberValue( void );

private:
 unsigned long intvalue;
 double floatvalue;


 int whiteSpaceStart_p;
 int whiteSpaceEnd_p;
 idToken * next;

 void AppendDirty( const char a );
};

inline idToken::idToken( void ) {
}

inline idToken::idToken( const idToken *token ) {
 *this = *token;
}

inline idToken::~idToken( void ) {
}

inline void idToken::operator=( const char *text) {
 *static_cast<idStr *>(this) = text;
}

inline void idToken::operator=( const idStr& text ) {
 *static_cast<idStr *>(this) = text;
}

inline double idToken::GetDoubleValue( void ) {
 if ( type != 3 ) {
  return 0.0;
 }
 if ( !(subtype & 0x10000) ) {
  NumberValue();
 }
 return floatvalue;
}

inline float idToken::GetFloatValue( void ) {
 return (float) GetDoubleValue();
}

inline unsigned long idToken::GetUnsignedLongValue( void ) {
 if ( type != 3 ) {
  return 0;
 }
 if ( !(subtype & 0x10000) ) {
  NumberValue();
 }
 return intvalue;
}

inline int idToken::GetIntValue( void ) {
 return (int) GetUnsignedLongValue();
}

inline int idToken::WhiteSpaceBeforeToken( void ) const {
 return ( whiteSpaceEnd_p > whiteSpaceStart_p );
}

inline void idToken::AppendDirty( const char a ) {
 EnsureAlloced( len + 2, true );
 data[len++] = a;
}
# 212 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lexer.h" 1
# 49 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lexer.h"
typedef enum {
 LEXFL_NOERRORS = ( 1 << ( 0 ) ),
 LEXFL_NOWARNINGS = ( 1 << ( 1 ) ),
 LEXFL_NOFATALERRORS = ( 1 << ( 2 ) ),
 LEXFL_NOSTRINGCONCAT = ( 1 << ( 3 ) ),
 LEXFL_NOSTRINGESCAPECHARS = ( 1 << ( 4 ) ),
 LEXFL_NODOLLARPRECOMPILE = ( 1 << ( 5 ) ),
 LEXFL_NOBASEINCLUDES = ( 1 << ( 6 ) ),
 LEXFL_ALLOWPATHNAMES = ( 1 << ( 7 ) ),
 LEXFL_ALLOWNUMBERNAMES = ( 1 << ( 8 ) ),
 LEXFL_ALLOWIPADDRESSES = ( 1 << ( 9 ) ),
 LEXFL_ALLOWFLOATEXCEPTIONS = ( 1 << ( 10 ) ),
 LEXFL_ALLOWMULTICHARLITERALS = ( 1 << ( 11 ) ),
 LEXFL_ALLOWBACKSLASHSTRINGCONCAT = ( 1 << ( 12 ) ),
 LEXFL_ONLYSTRINGS = ( 1 << ( 13 ) )
} lexerFlags_t;
# 130 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lexer.h"
typedef struct punctuation_s
{
 const char *p;
 int n;
} punctuation_t;



class fileDataPtr {
public:
 fileDataPtr();
 ~fileDataPtr();

 fileDataPtr(const fileDataPtr &other);
 fileDataPtr(fileDataPtr &other);

 void setFile(const char *filename);
 void setBuffer(char *buffer, int length);

 operator const int ( void ) const;
 operator const int ( void );

 char operator*(void);
 char operator[](int & index);
 fileDataPtr & operator++();
 fileDataPtr operator++(int);
 fileDataPtr & operator--();
 fileDataPtr operator--(int);
 fileDataPtr & operator+=(const int & plus);
 fileDataPtr & operator-=(const int & minus);
 fileDataPtr operator+(const int & plus);
 fileDataPtr operator-(const int & minus);
 fileDataPtr & operator=(const int & ptr);
 bool operator==(const int & ptr) const;
 bool operator!=(const int & ptr) const;
 bool operator<(const int & ptr) const;
 bool operator>(const int & ptr) const;
 bool operator<=(const int & ptr) const;
 bool operator>=(const int & ptr) const;


 int ptr;
 char * buf;
 idFile * file;

private:

 char readBuf(int position);

 int posStart;
 int posEnd;
 int size;
 bool allocated;
 bool master;

};



class idLexer {

 friend class idParser;

public:

     idLexer();
     idLexer( int flags );
     idLexer( const char *filename, int flags = 0, bool OSPath = false );
     idLexer( const char *ptr, int length, const char *name, int flags = 0 );

     ~idLexer();

 int LoadFile( const char *filename, bool OSPath = false );



 int LoadMemory( const char *ptr, int length, const char *name, int startLine = 1 );

 void FreeSource( void );

 int IsLoaded( void ) { return idLexer::loaded; };

 int ReadToken( idToken *token );

 int ExpectTokenString( const char *string );

 int ExpectTokenType( int type, int subtype, idToken *token );

 int ExpectAnyToken( idToken *token );

 int CheckTokenString( const char *string );

 int CheckTokenType( int type, int subtype, idToken *token );

 int PeekTokenString( const char *string );

 int PeekTokenType( int type, int subtype, idToken *token );

 int SkipUntilString( const char *string );

 int SkipRestOfLine( void );

 int SkipBracedSection( bool parseFirstBrace = true );

 void UnreadToken( const idToken *token );

 int ReadTokenOnLine( idToken *token );


 const char* ReadRestOfLine(idStr& out);


 int ParseInt( void );

 bool ParseBool( void );


 float ParseFloat( bool *errorFlag = __null );

 int Parse1DMatrix( int x, float *m );
 int Parse2DMatrix( int y, int x, float *m );
 int Parse3DMatrix( int z, int y, int x, float *m );

 const char * ParseBracedSection( idStr &out );

 const char * ParseBracedSectionExact ( idStr &out, int tabs = -1 );

 const char * ParseRestOfLine( idStr &out );

 int GetLastWhiteSpace( idStr &whiteSpace ) const;

 int GetLastWhiteSpaceStart( void ) const;

 int GetLastWhiteSpaceEnd( void ) const;

 void SetPunctuations( const punctuation_t *p );

 const char * GetPunctuationFromId( int id );

 int GetPunctuationId( const char *p );

 void SetFlags( int flags );

 int GetFlags( void );

 void Reset( void );

 int EndOfFile( void );

 const char * GetFileName( void );

 const int GetFileOffset( void );
 void SetFileOffset( int offset );

 const time_t GetFileTime( void );

 const int GetLineNum( void );

 void Error( const char *str, ... ) __attribute__((format(printf,2,3)));

 void Warning( const char *str, ... ) __attribute__((format(printf,2,3)));

 bool HadError( void ) const;


 static void SetBaseFolder( const char *path );

private:
 int loaded;
 idStr filename;
 int allocated;

 fileDataPtr script_p;
 int end_p;
 int lastScript_p;
 int whiteSpaceStart_p;
 int whiteSpaceEnd_p;
# 315 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lexer.h"
 time_t fileTime;
 int length;
 int line;
 int lastline;
 int tokenavailable;
 int flags;
 const punctuation_t *punctuations;
 int * punctuationtable;
 int * nextpunctuation;
 idToken token;
 idLexer * next;
 bool hadError;

 static char baseFolder[ 256 ];

private:
 void CreatePunctuationTable( const punctuation_t *punctuations );
 int ReadWhiteSpace( void );
 int ReadEscapeCharacter( char *ch );
 int ReadString( idToken *token, int quote );
 int ReadName( idToken *token );
 int ReadNumber( idToken *token );
 int ReadPunctuation( idToken *token );
 int ReadPrimitive( idToken *token );
 int CheckString( const char *str );
 int NumLinesCrossed( void );
};

inline const char *idLexer::GetFileName( void ) {
 return idLexer::filename;
}

inline const int idLexer::GetFileOffset( void ) {

 return idLexer::script_p;
}

inline void idLexer::SetFileOffset( int offset ) {
 idLexer::script_p = offset;
}



inline const time_t idLexer::GetFileTime( void ) {
 return idLexer::fileTime;
}

inline const int idLexer::GetLineNum( void ) {
 return idLexer::line;
}

inline void idLexer::SetFlags( int flags ) {
 idLexer::flags = flags;
}

inline int idLexer::GetFlags( void ) {
 return idLexer::flags;
}
# 213 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Parser.h" 1
# 55 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Parser.h"
typedef struct define_s {
 char * name;
 int flags;
 int builtin;
 int numparms;
 idToken * parms;
 idToken * tokens;
 struct define_s *next;
 struct define_s *hashnext;
} define_t;



typedef struct indent_s {
 int type;
 int skip;
 idLexer * script;
 struct indent_s *next;
} indent_t;


class idParser {

public:

     idParser();
     idParser( int flags );
     idParser( const char *filename, int flags = 0, bool OSPath = false );
     idParser( const char *ptr, int length, const char *name, int flags = 0 );

     ~idParser();

 int LoadFile( const char *filename, bool OSPath = false );


 int LoadMemory( const char *ptr, int length, const char *name );

 void FreeSource( bool keepDefines = false );

 int IsLoaded( void ) const { return idParser::loaded; }

 int ReadToken( idToken *token );

 int ExpectTokenString( const char *string );

 int ExpectTokenType( int type, int subtype, idToken *token );

 int ExpectAnyToken( idToken *token );

 int CheckTokenString( const char *string );

 int CheckTokenType( int type, int subtype, idToken *token );

 int PeekTokenString( const char *string );

 int PeekTokenType( int type, int subtype, idToken *token );

 int SkipUntilString( const char *string );

 int SkipRestOfLine( void );

 int SkipBracedSection( bool parseFirstBrace = true );

 const char * ParseBracedSection( idStr &out, int tabs = -1 );

 const char * ParseBracedSectionExact( idStr &out, int tabs = -1 );

 const char * ParseRestOfLine( idStr &out );

 void UnreadToken( idToken *token );

 int ReadTokenOnLine( idToken *token );

 int ParseInt( void );

 bool ParseBool( void );

 float ParseFloat( void );

 int Parse1DMatrix( int x, float *m );
 int Parse2DMatrix( int y, int x, float *m );
 int Parse3DMatrix( int z, int y, int x, float *m );

 int GetLastWhiteSpace( idStr &whiteSpace ) const;

 void SetMarker( void );

 void GetStringFromMarker( idStr& out, bool clean = false );

 int AddDefine( const char *string );

 void AddBuiltinDefines( void );

 void SetIncludePath( const char *path );

 void SetPunctuations( const punctuation_t *p );

 const char * GetPunctuationFromId( int id );

 int GetPunctuationId( const char *p );

 void SetFlags( int flags );

 int GetFlags( void ) const;

 const char * GetFileName( void ) const;

 const int GetFileOffset( void ) const;

 const time_t GetFileTime( void ) const;

 const int GetLineNum( void ) const;

 void Error( const char *str, ... ) const __attribute__((format(printf,2,3)));

 void Warning( const char *str, ... ) const __attribute__((format(printf,2,3)));


 static int AddGlobalDefine( const char *string );

 static int RemoveGlobalDefine( const char *name );

 static void RemoveAllGlobalDefines( void );

 static void SetBaseFolder( const char *path );

private:
 int loaded;
 idStr filename;
 idStr includepath;
 bool OSPath;
 const punctuation_t *punctuations;
 int flags;
 idLexer * scriptstack;
 idToken * tokens;
 define_t * defines;
 define_t ** definehash;
 indent_t * indentstack;
 int skip;

 int marker_p;

 static define_t *globaldefines;

private:
 void PushIndent( int type, int skip );
 void PopIndent( int *type, int *skip );
 void PushScript( idLexer *script );
 int ReadSourceToken( idToken *token );
 int ReadLine( idToken *token );
 int UnreadSourceToken( idToken *token );
 int ReadDefineParms( define_t *define, idToken **parms, int maxparms );
 int StringizeTokens( idToken *tokens, idToken *token );
 int MergeTokens( idToken *t1, idToken *t2 );
 int ExpandBuiltinDefine( idToken *deftoken, define_t *define, idToken **firsttoken, idToken **lasttoken );
 int ExpandDefine( idToken *deftoken, define_t *define, idToken **firsttoken, idToken **lasttoken );
 int ExpandDefineIntoSource( idToken *deftoken, define_t *define );
 void AddGlobalDefinesToSource( void );
 define_t * CopyDefine( define_t *define );
 define_t * FindHashedDefine(define_t **definehash, const char *name);
 int FindDefineParm( define_t *define, const char *name );
 void AddDefineToHash(define_t *define, define_t **definehash);
 static void PrintDefine( define_t *define );
 static void FreeDefine( define_t *define );
 static define_t *FindDefine( define_t *defines, const char *name );
 static define_t *DefineFromString( const char *string);
 define_t * CopyFirstDefine( void );
 int Directive_include( void );
 int Directive_undef( void );
 int Directive_if_def( int type );
 int Directive_ifdef( void );
 int Directive_ifndef( void );
 int Directive_else( void );
 int Directive_endif( void );
 int EvaluateTokens( idToken *tokens, signed long int *intvalue, double *floatvalue, int integer );
 int Evaluate( signed long int *intvalue, double *floatvalue, int integer );
 int DollarEvaluate( signed long int *intvalue, double *floatvalue, int integer);
 int Directive_define( void );
 int Directive_elif( void );
 int Directive_if( void );
 int Directive_line( void );
 int Directive_error( void );
 int Directive_warning( void );
 int Directive_pragma( void );
 void UnreadSignToken( void );
 int Directive_eval( void );
 int Directive_evalfloat( void );
 int ReadDirective( void );
 int DollarDirective_evalint( void );
 int DollarDirective_evalfloat( void );
 int ReadDollarDirective( void );
};

inline const char *idParser::GetFileName( void ) const {
 if ( idParser::scriptstack ) {
  return idParser::scriptstack->GetFileName();
 }
 else {
  return "";
 }
}

inline const int idParser::GetFileOffset( void ) const {
 if ( idParser::scriptstack ) {
  return idParser::scriptstack->GetFileOffset();
 }
 else {
  return 0;
 }
}

inline const time_t idParser::GetFileTime( void ) const {
 if ( idParser::scriptstack ) {
  return idParser::scriptstack->GetFileTime();
 }
 else {
  return 0;
 }
}

inline const int idParser::GetLineNum( void ) const {
 if ( idParser::scriptstack ) {
  return idParser::scriptstack->GetLineNum();
 }
 else {
  return 0;
 }
}
# 214 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Base64.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Base64.h"
class idBase64 {
public:
    idBase64( void );
    idBase64( const idStr &s );
    ~idBase64( void );

 void Encode( const byte *from, int size );
 void Encode( const idStr &src );
 int DecodeLength( void ) const;
 int Decode( byte *to ) const;
 void Decode( idStr &dest ) const;
 void Decode( idFile *dest ) const;

 const char *c_str() const;

 void operator=( const idStr &s );

private:
 byte * data;
 int len;
 int alloced;

 void Init( void );
 void Release( void );
 void EnsureAlloced( int size );
};

inline idBase64::idBase64( void ) {
 Init();
}

inline idBase64::idBase64( const idStr &s ) {
 Init();
 *this = s;
}

inline idBase64::~idBase64( void ) {
 Release();
}

inline const char *idBase64::c_str( void ) const {
 return (const char *)data;
}

inline void idBase64::Init( void ) {
 len = 0;
 alloced = 0;
 data = __null;
}

inline void idBase64::Release( void ) {
 if ( data ) {
  delete[] data;
 }
 Init();
}

inline void idBase64::EnsureAlloced( int size ) {
 if ( size > alloced ) {
  Release();
 }
 data = new byte[size];
 alloced = size;
}

inline void idBase64::operator=( const idStr &s ) {
 EnsureAlloced( s.Length()+1 );
 strcpy( (char *)data, s.c_str() );
 len = s.Length();
}
# 215 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/CmdArgs.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/CmdArgs.h"
class idCmdArgs {
public:
       idCmdArgs( void ) { argc = 0; }
       idCmdArgs( const char *text, bool keepAsStrings ) { TokenizeString( text, keepAsStrings ); }

 void operator=( const idCmdArgs &args );


 int Argc( void ) const { return argc; }

 const char * Argv( int arg ) const { return ( arg >= 0 && arg < argc ) ? argv[arg] : ""; }


 const char * Args( int start = 1, int end = -1, bool escapeArgs = false ) const;




 void TokenizeString( const char *text, bool keepAsStrings );

 void AppendArg( const char *text );
 void Clear( void ) { argc = 0; }
 const char ** GetArgs( int *argc );

private:
 static const int MAX_COMMAND_ARGS = 64;
 static const int MAX_COMMAND_STRING = 2 * 1024;

 int argc;
 char * argv[MAX_COMMAND_ARGS];
 char tokenized[MAX_COMMAND_STRING];
};
# 216 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2



# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/BinSearch.h" 1
# 49 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/BinSearch.h"
template< class type >
inline int idBinSearch_Less( const type *array, const int arraySize, const type &value ) {
 int len = arraySize;
 int mid = len;
 int offset = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( array[offset+mid] < value ) {
   offset += mid;
  }
  len -= mid;
 }
 return offset;
}
# 71 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/BinSearch.h"
template< class type >
inline int idBinSearch_LessEqual( const type *array, const int arraySize, const type &value ) {
 int len = arraySize;
 int mid = len;
 int offset = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( array[offset+mid] <= value ) {
   offset += mid;
  }
  len -= mid;
 }
 return offset;
}
# 93 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/BinSearch.h"
template< class type >
inline int idBinSearch_Greater( const type *array, const int arraySize, const type &value ) {
 int len = arraySize;
 int mid = len;
 int offset = 0;
 int res = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( array[offset+mid] > value ) {
   res = 0;
  } else {
   offset += mid;
   res = 1;
  }
  len -= mid;
 }
 return offset+res;
}
# 119 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/BinSearch.h"
template< class type >
inline int idBinSearch_GreaterEqual( const type *array, const int arraySize, const type &value ) {
 int len = arraySize;
 int mid = len;
 int offset = 0;
 int res = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( array[offset+mid] >= value ) {
   res = 0;
  } else {
   offset += mid;
   res = 1;
  }
  len -= mid;
 }
 return offset+res;
}
# 220 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/HashIndex.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/HashIndex.h"
class idHashIndex {
public:
     idHashIndex( void );
     idHashIndex( const int initialHashSize, const int initialIndexSize );
     ~idHashIndex( void );


 size_t Allocated( void ) const;

 size_t Size( void ) const;

 idHashIndex & operator=( const idHashIndex &other );

 void Add( const int key, const int index );

 void Remove( const int key, const int index );

 int First( const int key ) const;

 int Next( const int index ) const;

 void InsertIndex( const int key, const int index );

 void RemoveIndex( const int key, const int index );

 void Clear( void );

 void Clear( const int newHashSize, const int newIndexSize );

 void Free( void );

 int GetHashSize( void ) const;

 int GetIndexSize( void ) const;

 void SetGranularity( const int newGranularity );

 void ResizeIndex( const int newIndexSize );

 int GetSpread( void ) const;

 int GenerateKey( const char *string, bool caseSensitive = true ) const;

 int GenerateKey( const idVec3 &v ) const;

 int GenerateKey( const int n1, const int n2 ) const;

private:
 int hashSize;
 int * hash;
 int indexSize;
 int * indexChain;
 int granularity;
 int hashMask;
 int lookupMask;

 static int INVALID_INDEX[1];

 void Init( const int initialHashSize, const int initialIndexSize );
 void Allocate( const int newHashSize, const int newIndexSize );
};






inline idHashIndex::idHashIndex( void ) {
 Init( 1024, 1024 );
}






inline idHashIndex::idHashIndex( const int initialHashSize, const int initialIndexSize ) {
 Init( initialHashSize, initialIndexSize );
}






inline idHashIndex::~idHashIndex( void ) {
 Free();
}






inline size_t idHashIndex::Allocated( void ) const {
 return hashSize * sizeof( int ) + indexSize * sizeof( int );
}






inline size_t idHashIndex::Size( void ) const {
 return sizeof( *this ) + Allocated();
}






inline idHashIndex &idHashIndex::operator=( const idHashIndex &other ) {
 granularity = other.granularity;
 hashMask = other.hashMask;
 lookupMask = other.lookupMask;

 if ( other.lookupMask == 0 ) {
  hashSize = other.hashSize;
  indexSize = other.indexSize;
  Free();
 }
 else {
  if ( other.hashSize != hashSize || hash == INVALID_INDEX ) {
   if ( hash != INVALID_INDEX ) {
    delete[] hash;
   }
   hashSize = other.hashSize;
   hash = new int[hashSize];
  }
  if ( other.indexSize != indexSize || indexChain == INVALID_INDEX ) {
   if ( indexChain != INVALID_INDEX ) {
    delete[] indexChain;
   }
   indexSize = other.indexSize;
   indexChain = new int[indexSize];
  }
  memcpy( hash, other.hash, hashSize * sizeof( hash[0] ) );
  memcpy( indexChain, other.indexChain, indexSize * sizeof( indexChain[0] ) );
 }

 return *this;
}






inline void idHashIndex::Add( const int key, const int index ) {
 int h;

 ((void)0);
 if ( hash == INVALID_INDEX ) {
  Allocate( hashSize, index >= indexSize ? index + 1 : indexSize );
 }
 else if ( index >= indexSize ) {
  ResizeIndex( index + 1 );
 }
 h = key & hashMask;
 indexChain[index] = hash[h];
 hash[h] = index;
}






inline void idHashIndex::Remove( const int key, const int index ) {
 int k = key & hashMask;

 if ( hash == INVALID_INDEX ) {
  return;
 }
 if ( hash[k] == index ) {
  hash[k] = indexChain[index];
 }
 else {
  for ( int i = hash[k]; i != -1; i = indexChain[i] ) {
   if ( indexChain[i] == index ) {
    indexChain[i] = indexChain[index];
    break;
   }
  }
 }
 indexChain[index] = -1;
}






inline int idHashIndex::First( const int key ) const {
 return hash[key & hashMask & lookupMask];
}






inline int idHashIndex::Next( const int index ) const {
 ((void)0);
 return indexChain[index & lookupMask];
}






inline void idHashIndex::InsertIndex( const int key, const int index ) {
 int i, max;

 if ( hash != INVALID_INDEX ) {
  max = index;
  for ( i = 0; i < hashSize; i++ ) {
   if ( hash[i] >= index ) {
    hash[i]++;
    if ( hash[i] > max ) {
     max = hash[i];
    }
   }
  }
  for ( i = 0; i < indexSize; i++ ) {
   if ( indexChain[i] >= index ) {
    indexChain[i]++;
    if ( indexChain[i] > max ) {
     max = indexChain[i];
    }
   }
  }
  if ( max >= indexSize ) {
   ResizeIndex( max + 1 );
  }
  for ( i = max; i > index; i-- ) {
   indexChain[i] = indexChain[i-1];
  }
  indexChain[index] = -1;
 }
 Add( key, index );
}






inline void idHashIndex::RemoveIndex( const int key, const int index ) {
 int i, max;

 Remove( key, index );
 if ( hash != INVALID_INDEX ) {
  max = index;
  for ( i = 0; i < hashSize; i++ ) {
   if ( hash[i] >= index ) {
    if ( hash[i] > max ) {
     max = hash[i];
    }
    hash[i]--;
   }
  }
  for ( i = 0; i < indexSize; i++ ) {
   if ( indexChain[i] >= index ) {
    if ( indexChain[i] > max ) {
     max = indexChain[i];
    }
    indexChain[i]--;
   }
  }
  for ( i = index; i < max; i++ ) {
   indexChain[i] = indexChain[i+1];
  }
  indexChain[max] = -1;
 }
}






inline void idHashIndex::Clear( void ) {

 if ( hash != INVALID_INDEX ) {
  memset( hash, 0xff, hashSize * sizeof( hash[0] ) );
 }
}






inline void idHashIndex::Clear( const int newHashSize, const int newIndexSize ) {
 Free();
 hashSize = newHashSize;
 indexSize = newIndexSize;
}






inline int idHashIndex::GetHashSize( void ) const {
 return hashSize;
}






inline int idHashIndex::GetIndexSize( void ) const {
 return indexSize;
}






inline void idHashIndex::SetGranularity( const int newGranularity ) {
 ((void)0);
 granularity = newGranularity;
}






inline int idHashIndex::GenerateKey( const char *string, bool caseSensitive ) const {
 if ( caseSensitive ) {
  return ( idStr::Hash( string ) & hashMask );
 } else {
  return ( idStr::IHash( string ) & hashMask );
 }
}






inline int idHashIndex::GenerateKey( const idVec3 &v ) const {
 return ( (((int) v[0]) + ((int) v[1]) + ((int) v[2])) & hashMask );
}






inline int idHashIndex::GenerateKey( const int n1, const int n2 ) const {
 return ( ( n1 + n2 ) & hashMask );
}
# 221 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/HashTable.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/HashTable.h"
template< class Type >
class idHashTable {
public:
     idHashTable( int newtablesize = 256 );
     idHashTable( const idHashTable<Type> &map );
     ~idHashTable( void );


 size_t Allocated( void ) const;

 size_t Size( void ) const;

 void Set( const char *key, Type &value );
 bool Get( const char *key, Type **value = __null ) const;
 bool Remove( const char *key );

 void Clear( void );
 void DeleteContents( void );



 int Num( void ) const;
 Type * GetIndex( int index ) const;

 int GetSpread( void ) const;

private:
 struct hashnode_s {
  idStr key;
  Type value;
  hashnode_s *next;

  hashnode_s( const idStr &k, Type v, hashnode_s *n ) : key( k ), value( v ), next( n ) {};
  hashnode_s( const char *k, Type v, hashnode_s *n ) : key( k ), value( v ), next( n ) {};
 };

 hashnode_s ** heads;

 int tablesize;
 int numentries;
 int tablesizemask;

 int GetHash( const char *key ) const;
};






template< class Type >
inline idHashTable<Type>::idHashTable( int newtablesize ) {

 ((void)0);

 tablesize = newtablesize;
 ((void)0);

 heads = new hashnode_s *[ tablesize ];
 memset( heads, 0, sizeof( *heads ) * tablesize );

 numentries = 0;

 tablesizemask = tablesize - 1;
}






template< class Type >
inline idHashTable<Type>::idHashTable( const idHashTable<Type> &map ) {
 int i;
 hashnode_s *node;
 hashnode_s **prev;

 ((void)0);

 tablesize = map.tablesize;
 heads = new hashnode_s *[ tablesize ];
 numentries = map.numentries;
 tablesizemask = map.tablesizemask;

 for( i = 0; i < tablesize; i++ ) {
  if ( !map.heads[ i ] ) {
   heads[ i ] = __null;
   continue;
  }

  prev = &heads[ i ];
  for( node = map.heads[ i ]; node != __null; node = node->next ) {
   *prev = new hashnode_s( node->key, node->value, __null );
   prev = &( *prev )->next;
  }
 }
}






template< class Type >
inline idHashTable<Type>::~idHashTable( void ) {
 Clear();
 delete[] heads;
}






template< class Type >
inline size_t idHashTable<Type>::Allocated( void ) const {
 return sizeof( heads ) * tablesize + sizeof( *heads ) * numentries;
}






template< class Type >
inline size_t idHashTable<Type>::Size( void ) const {
 return sizeof( idHashTable<Type> ) + sizeof( heads ) * tablesize + sizeof( *heads ) * numentries;
}






template< class Type >
inline int idHashTable<Type>::GetHash( const char *key ) const {
 return ( idStr::Hash( key ) & tablesizemask );
}






template< class Type >
inline void idHashTable<Type>::Set( const char *key, Type &value ) {
 hashnode_s *node, **nextPtr;
 int hash, s;

 hash = GetHash( key );
 for( nextPtr = &(heads[hash]), node = *nextPtr; node != __null; nextPtr = &(node->next), node = *nextPtr ) {
  s = node->key.Cmp( key );
  if ( s == 0 ) {
   node->value = value;
   return;
  }
  if ( s > 0 ) {
   break;
  }
 }

 numentries++;

 *nextPtr = new hashnode_s( key, value, heads[ hash ] );
 (*nextPtr)->next = node;
}






template< class Type >
inline bool idHashTable<Type>::Get( const char *key, Type **value ) const {
 hashnode_s *node;
 int hash, s;

 hash = GetHash( key );
 for( node = heads[ hash ]; node != __null; node = node->next ) {
  s = node->key.Cmp( key );
  if ( s == 0 ) {
   if ( value ) {
    *value = &node->value;
   }
   return true;
  }
  if ( s > 0 ) {
   break;
  }
 }

 if ( value ) {
  *value = __null;
 }

 return false;
}
# 247 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/HashTable.h"
template< class Type >
inline Type *idHashTable<Type>::GetIndex( int index ) const {
 hashnode_s *node;
 int count;
 int i;

 if ( ( index < 0 ) || ( index > numentries ) ) {
  ((void)0);
  return __null;
 }

 count = 0;
 for( i = 0; i < tablesize; i++ ) {
  for( node = heads[ i ]; node != __null; node = node->next ) {
   if ( count == index ) {
    return &node->value;
   }
   count++;
  }
 }

 return __null;
}






template< class Type >
inline bool idHashTable<Type>::Remove( const char *key ) {
 hashnode_s **head;
 hashnode_s *node;
 hashnode_s *prev;
 int hash;

 hash = GetHash( key );
 head = &heads[ hash ];
 if ( *head ) {
  for( prev = __null, node = *head; node != __null; prev = node, node = node->next ) {
   if ( node->key == key ) {
    if ( prev ) {
     prev->next = node->next;
    } else {
     *head = node->next;
    }

    delete node;
    numentries--;
    return true;
   }
  }
 }

 return false;
}






template< class Type >
inline void idHashTable<Type>::Clear( void ) {
 int i;
 hashnode_s *node;
 hashnode_s *next;

 for( i = 0; i < tablesize; i++ ) {
  next = heads[ i ];
  while( next != __null ) {
   node = next;
   next = next->next;
   delete node;
  }

  heads[ i ] = __null;
 }

 numentries = 0;
}






template< class Type >
inline void idHashTable<Type>::DeleteContents( void ) {
 int i;
 hashnode_s *node;
 hashnode_s *next;

 for( i = 0; i < tablesize; i++ ) {
  next = heads[ i ];
  while( next != __null ) {
   node = next;
   next = next->next;
   delete node->value;
   delete node;
  }

  heads[ i ] = __null;
 }

 numentries = 0;
}






template< class Type >
inline int idHashTable<Type>::Num( void ) const {
 return numentries;
}
# 222 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
class idStaticList {
public:

      idStaticList();
      idStaticList( const idStaticList<type,size> &other );
      ~idStaticList<type,size>( void );

 void Clear( void );
 int Num( void ) const;
 int Max( void ) const;
 void SetNum( int newnum );

 size_t Allocated( void ) const;
 size_t Size( void ) const;
 size_t MemoryUsed( void ) const;

 const type & operator[]( int index ) const;
 type & operator[]( int index );

 type * Ptr( void );
 const type * Ptr( void ) const;
 type * Alloc( void );
 int Append( const type & obj );
 int Append( const idStaticList<type,size> &other );
 int AddUnique( const type & obj );
 int Insert( const type & obj, int index );
 int FindIndex( const type & obj ) const;
 type * Find( type const & obj ) const;
 int FindNull( void ) const;
 int IndexOf( const type *obj ) const;
 bool RemoveIndex( int index );
 bool Remove( const type & obj );
 void Swap( idStaticList<type,size> &other );
 void DeleteContents( bool clear );

private:
 int num;
 type list[ size ];
};






template<class type,int size>
inline idStaticList<type,size>::idStaticList() {
 num = 0;
}






template<class type,int size>
inline idStaticList<type,size>::idStaticList( const idStaticList<type,size> &other ) {
 *this = other;
}






template<class type,int size>
inline idStaticList<type,size>::~idStaticList( void ) {
}
# 118 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline void idStaticList<type,size>::Clear( void ) {
 num = 0;
}
# 135 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline void idStaticList<type,size>::DeleteContents( bool clear ) {
 int i;

 for( i = 0; i < size; i++ ) {
  delete list[ i ];
  list[ i ] = __null;
 }

 if ( clear ) {
  Clear();
 } else {
  memset( list, 0, sizeof( list ) );
 }
}
# 158 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Num( void ) const {
 return num;
}
# 170 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Max( void ) const {
 return size;
}






template<class type,int size>
inline size_t idStaticList<type,size>::Allocated( void ) const {
 return size * sizeof( type );
}






template<class type,int size>
inline size_t idStaticList<type,size>::Size( void ) const {
 return sizeof( idStaticList<type,size> ) + Allocated();
}






template<class type,int size>
inline size_t idStaticList<type,size>::MemoryUsed( void ) const {
 return num * sizeof( list[ 0 ] );
}
# 212 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline void idStaticList<type,size>::SetNum( int newnum ) {
 ((void)0);
 ((void)0);
 num = newnum;
}
# 227 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline const type &idStaticList<type,size>::operator[]( int index ) const {
 ((void)0);
 ((void)0);

 return list[ index ];
}
# 243 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline type &idStaticList<type,size>::operator[]( int index ) {
 ((void)0);
 ((void)0);

 return list[ index ];
}
# 262 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline type *idStaticList<type,size>::Ptr( void ) {
 return &list[ 0 ];
}
# 278 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline const type *idStaticList<type,size>::Ptr( void ) const {
 return &list[ 0 ];
}
# 290 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline type *idStaticList<type,size>::Alloc( void ) {
 if ( num >= size ) {
  return __null;
 }

 return &list[ num++ ];
}
# 308 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Append( type const & obj ) {
 ((void)0);
 if ( num < size ) {
  list[ num ] = obj;
  num++;
  return num - 1;
 }

 return -1;
}
# 331 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Insert( type const & obj, int index ) {
 int i;

 ((void)0);
 if ( num >= size ) {
  return -1;
 }

 ((void)0);
 if ( index < 0 ) {
  index = 0;
 } else if ( index > num ) {
  index = num;
 }

 for( i = num; i > index; --i ) {
  list[i] = list[i-1];
 }

 num++;
 list[index] = obj;
 return index;
}
# 365 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Append( const idStaticList<type,size> &other ) {
 int i;
 int n = other.Num();

 if ( num + n > size ) {
  n = size - num;
 }
 for( i = 0; i < n; i++ ) {
  list[i + num] = other.list[i];
 }
 num += n;
 return Num();
}
# 387 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::AddUnique( type const & obj ) {
 int index;

 index = FindIndex( obj );
 if ( index < 0 ) {
  index = Append( obj );
 }

 return index;
}
# 406 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::FindIndex( type const & obj ) const {
 int i;

 for( i = 0; i < num; i++ ) {
  if ( list[ i ] == obj ) {
   return i;
  }
 }


 return -1;
}
# 427 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline type *idStaticList<type,size>::Find( type const & obj ) const {
 int i;

 i = FindIndex( obj );
 if ( i >= 0 ) {
  return &list[ i ];
 }

 return __null;
}
# 449 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::FindNull( void ) const {
 int i;

 for( i = 0; i < num; i++ ) {
  if ( list[ i ] == __null ) {
   return i;
  }
 }


 return -1;
}
# 473 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::IndexOf( type const *objptr ) const {
 int index;

 index = objptr - list;

 ((void)0);
 ((void)0);

 return index;
}
# 494 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline bool idStaticList<type,size>::RemoveIndex( int index ) {
 int i;

 ((void)0);
 ((void)0);

 if ( ( index < 0 ) || ( index >= num ) ) {
  return false;
 }

 num--;
 for( i = index; i < num; i++ ) {
  list[ i ] = list[ i + 1 ];
 }

 return true;
}
# 522 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline bool idStaticList<type,size>::Remove( type const & obj ) {
 int index;

 index = FindIndex( obj );
 if ( index >= 0 ) {
  return RemoveIndex( index );
 }

 return false;
}
# 541 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline void idStaticList<type,size>::Swap( idStaticList<type,size> &other ) {
 idStaticList<type,size> temp = *this;
 *this = other;
 other = temp;
}
# 223 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
class idLinkList {
public:
      idLinkList();
      ~idLinkList();

 bool IsListEmpty( void ) const;
 bool InList( void ) const;
 int Num( void ) const;
 void Clear( void );

 void InsertBefore( idLinkList &node );
 void InsertAfter( idLinkList &node );
 void AddToEnd( idLinkList &node );
 void AddToFront( idLinkList &node );

 void Remove( void );

 type * Next( void ) const;
 type * Prev( void ) const;

 type * Owner( void ) const;
 void SetOwner( type *object );

 idLinkList * ListHead( void ) const;
 idLinkList * NextNode( void ) const;
 idLinkList * PrevNode( void ) const;

private:
 idLinkList * head;
 idLinkList * next;
 idLinkList * prev;
 type * owner;
};
# 84 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type>::idLinkList() {
 owner = __null;
 head = this;
 next = this;
 prev = this;
}
# 100 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type>::~idLinkList() {
 Clear();
}
# 112 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
bool idLinkList<type>::IsListEmpty( void ) const {
 return head->next == head;
}
# 124 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
bool idLinkList<type>::InList( void ) const {
 return head != this;
}
# 136 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
int idLinkList<type>::Num( void ) const {
 idLinkList<type> *node;
 int num;

 num = 0;
 for( node = head->next; node != head; node = node->next ) {
  num++;
 }

 return num;
}
# 156 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::Clear( void ) {
 if ( head == this ) {
  while( next != this ) {
   next->Remove();
  }
 } else {
  Remove();
 }
}
# 174 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::Remove( void ) {
 prev->next = next;
 next->prev = prev;

 next = this;
 prev = this;
 head = this;
}
# 192 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::InsertBefore( idLinkList &node ) {
 Remove();

 next = &node;
 prev = node.prev;
 node.prev = this;
 prev->next = this;
 head = node.head;
}
# 211 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::InsertAfter( idLinkList &node ) {
 Remove();

 prev = &node;
 next = node.next;
 node.next = this;
 next->prev = this;
 head = node.head;
}
# 229 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::AddToEnd( idLinkList &node ) {
 InsertBefore( *node.head );
}
# 241 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::AddToFront( idLinkList &node ) {
 InsertAfter( *node.head );
}
# 254 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type> *idLinkList<type>::ListHead( void ) const {
 return head;
}
# 266 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
type *idLinkList<type>::Next( void ) const {
 if ( !next || ( next == head ) ) {
  return __null;
 }
 return next->owner;
}
# 281 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
type *idLinkList<type>::Prev( void ) const {
 if ( !prev || ( prev == head ) ) {
  return __null;
 }
 return prev->owner;
}
# 296 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type> *idLinkList<type>::NextNode( void ) const {
 if ( next == head ) {
  return __null;
 }
 return next;
}
# 311 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type> *idLinkList<type>::PrevNode( void ) const {
 if ( prev == head ) {
  return __null;
 }
 return prev;
}
# 326 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
type *idLinkList<type>::Owner( void ) const {
 return owner;
}
# 338 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::SetOwner( type *object ) {
 owner = object;
}
# 224 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
class idHierarchy {
public:

      idHierarchy();
      ~idHierarchy();

 void SetOwner( type *object );
 type * Owner( void ) const;
 void ParentTo( idHierarchy &node );
 void MakeSiblingAfter( idHierarchy &node );
 bool ParentedBy( const idHierarchy &node ) const;
 void RemoveFromParent( void );
 void RemoveFromHierarchy( void );

 type * GetParent( void ) const;
 type * GetChild( void ) const;
 type * GetSibling( void ) const;
 type * GetPriorSibling( void ) const;
 type * GetNext( void ) const;
 type * GetNextLeaf( void ) const;

private:
 idHierarchy * parent;
 idHierarchy * sibling;
 idHierarchy * child;
 type * owner;

 idHierarchy<type> *GetPriorSiblingNode( void ) const;
};






template< class type >
idHierarchy<type>::idHierarchy() {
 owner = __null;
 parent = __null;
 sibling = __null;
 child = __null;
}






template< class type >
idHierarchy<type>::~idHierarchy() {
 RemoveFromHierarchy();
}
# 101 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
type *idHierarchy<type>::Owner( void ) const {
 return owner;
}
# 113 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
void idHierarchy<type>::SetOwner( type *object ) {
 owner = object;
}






template< class type >
bool idHierarchy<type>::ParentedBy( const idHierarchy &node ) const {
 if ( parent == &node ) {
  return true;
 } else if ( parent ) {
  return parent->ParentedBy( node );
 }
 return false;
}
# 140 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
void idHierarchy<type>::ParentTo( idHierarchy &node ) {
 RemoveFromParent();

 parent = &node;
 sibling = node.child;
 node.child = this;
}
# 156 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
void idHierarchy<type>::MakeSiblingAfter( idHierarchy &node ) {
 RemoveFromParent();
 parent = node.parent;
 sibling = node.sibling;
 node.sibling = this;
}






template< class type >
void idHierarchy<type>::RemoveFromParent( void ) {
 idHierarchy<type> *prev;

 if ( parent ) {
  prev = GetPriorSiblingNode();
  if ( prev ) {
   prev->sibling = sibling;
  } else {
   parent->child = sibling;
  }
 }

 parent = __null;
 sibling = __null;
}
# 193 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
void idHierarchy<type>::RemoveFromHierarchy( void ) {
 idHierarchy<type> *parentNode;
 idHierarchy<type> *node;

 parentNode = parent;
 RemoveFromParent();

 if ( parentNode ) {
  while( child ) {
   node = child;
   node->RemoveFromParent();
   node->ParentTo( *parentNode );
  }
 } else {
  while( child ) {
   child->RemoveFromParent();
  }
 }
}






template< class type >
type *idHierarchy<type>::GetParent( void ) const {
 if ( parent ) {
  return parent->owner;
 }
 return __null;
}






template< class type >
type *idHierarchy<type>::GetChild( void ) const {
 if ( child ) {
  return child->owner;
 }
 return __null;
}






template< class type >
type *idHierarchy<type>::GetSibling( void ) const {
 if ( sibling ) {
  return sibling->owner;
 }
 return __null;
}
# 260 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
idHierarchy<type> *idHierarchy<type>::GetPriorSiblingNode( void ) const {
 if ( !parent || ( parent->child == this ) ) {
  return __null;
 }

 idHierarchy<type> *prev;
 idHierarchy<type> *node;

 node = parent->child;
 prev = __null;
 while( ( node != this ) && ( node != __null ) ) {
  prev = node;
  node = node->sibling;
 }

 if ( node != this ) {
  idLib::Error( "idHierarchy::GetPriorSibling: could not find node in parent's list of children" );
 }

 return prev;
}
# 290 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
type *idHierarchy<type>::GetPriorSibling( void ) const {
 idHierarchy<type> *prior;

 prior = GetPriorSiblingNode();
 if ( prior ) {
  return prior->owner;
 }

 return __null;
}
# 309 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
type *idHierarchy<type>::GetNext( void ) const {
 const idHierarchy<type> *node;

 if ( child ) {
  return child->owner;
 } else {
  node = this;
  while( node && node->sibling == __null ) {
   node = node->parent;
  }
  if ( node ) {
   return node->sibling->owner;
  } else {
   return __null;
  }
 }
}
# 335 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Hierarchy.h"
template< class type >
type *idHierarchy<type>::GetNextLeaf( void ) const {
 const idHierarchy<type> *node;

 if ( child ) {
  node = child;
  while ( node->child ) {
   node = node->child;
  }
  return node->owner;
 } else {
  node = this;
  while( node && node->sibling == __null ) {
   node = node->parent;
  }
  if ( node ) {
   node = node->sibling;
   while ( node->child ) {
    node = node->child;
   }
   return node->owner;
  } else {
   return __null;
  }
 }
}
# 225 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Queue.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Queue.h"
template< class type, int nextOffset >
class idQueueTemplate {
public:
       idQueueTemplate( void );

 void Add( type *element );
 type * Get( void );

private:
 type * first;
 type * last;
};



template< class type, int nextOffset >
idQueueTemplate<type,nextOffset>::idQueueTemplate( void ) {
 first = last = __null;
}

template< class type, int nextOffset >
void idQueueTemplate<type,nextOffset>::Add( type *element ) {
 (*((type**)(((byte*)element)+nextOffset))) = __null;
 if ( last ) {
  (*((type**)(((byte*)last)+nextOffset))) = element;
 } else {
  first = element;
 }
 last = element;
}

template< class type, int nextOffset >
type *idQueueTemplate<type,nextOffset>::Get( void ) {
 type *element;

 element = first;
 if ( element ) {
  first = (*((type**)(((byte*)first)+nextOffset)));
  if ( last == element ) {
   last = __null;
  }
  (*((type**)(((byte*)element)+nextOffset))) = __null;
 }
 return element;
}
# 226 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Stack.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/Stack.h"
template< class type, int nextOffset >
class idStackTemplate {
public:
       idStackTemplate( void );

 void Add( type *element );
 type * Get( void );

private:
 type * top;
 type * bottom;
};



template< class type, int nextOffset >
idStackTemplate<type,nextOffset>::idStackTemplate( void ) {
 top = bottom = __null;
}

template< class type, int nextOffset >
void idStackTemplate<type,nextOffset>::Add( type *element ) {
 (*(type**)(((byte*)element)+nextOffset)) = top;
 top = element;
 if ( !bottom ) {
  bottom = element;
 }
}

template< class type, int nextOffset >
type *idStackTemplate<type,nextOffset>::Get( void ) {
 type *element;

 element = top;
 if ( element ) {
  top = (*(type**)(((byte*)top)+nextOffset));
  if ( bottom == element ) {
   bottom = __null;
  }
  (*(type**)(((byte*)element)+nextOffset)) = __null;
 }
 return element;
}
# 227 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrList.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrList.h"
typedef idList<idStr> idStrList;
typedef idList<idStr*> idStrPtrList;
typedef idStr *idStrPtr;
# 51 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrList.h"
template<>
inline int idListSortCompare<idStrPtr>( const idStrPtr *a, const idStrPtr *b ) {
 return ( *a )->Icmp( **b );
}
# 64 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrList.h"
template<>
inline void idStrList::Sort( cmp_t *compare ) {
 int i;

 if ( !num ) {
  return;
 }

 idList<idStr> other;
 idList<idStrPtr> pointerList;

 pointerList.SetNum( num );
 for( i = 0; i < num; i++ ) {
  pointerList[ i ] = &( *this )[ i ];
 }

 pointerList.Sort();

 other.SetNum( num );
 other.SetGranularity( granularity );
 for( i = 0; i < other.Num(); i++ ) {
  other[ i ] = *pointerList[ i ];
 }

 this->Swap( other );
}
# 98 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrList.h"
template<>
inline void idStrList::SortSubSection( int startIndex, int endIndex, cmp_t *compare ) {
 int i, s;

 if ( !num ) {
  return;
 }
 if ( startIndex < 0 ) {
  startIndex = 0;
 }
 if ( endIndex >= num ) {
  endIndex = num - 1;
 }
 if ( startIndex >= endIndex ) {
  return;
 }

 idList<idStr> other;
 idList<idStrPtr> pointerList;

 s = endIndex - startIndex + 1;
 other.SetNum( s );
 pointerList.SetNum( s );
 for( i = 0; i < s; i++ ) {
  other[ i ] = ( *this )[ startIndex + i ];
  pointerList[ i ] = &other[ i ];
 }

 pointerList.Sort();

 for( i = 0; i < s; i++ ) {
  (*this)[ startIndex + i ] = *pointerList[ i ];
 }
}






template<>
inline size_t idStrList::Size( void ) const {
 size_t s;
 int i;

 s = sizeof( *this );
 for( i = 0; i < Num(); i++ ) {
  s += ( *this )[ i ].Size();
 }

 return s;
}
# 166 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrList.h"
template<class idStrPtr>
inline int idListSortComparePaths( const idStrPtr *a, const idStrPtr *b ) {
 return ( *a )->IcmpPath( **b );
}
# 178 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrList.h"
inline void idStrListSortPaths( idStrList &list ) {
 int i;

 if ( !list.Num() ) {
  return;
 }

 idList<idStr> other;
 idList<idStrPtr> pointerList;

 pointerList.SetNum( list.Num() );
 for( i = 0; i < list.Num(); i++ ) {
  pointerList[ i ] = &list[ i ];
 }

 pointerList.Sort( idListSortComparePaths<idStrPtr> );

 other.SetNum( list.Num() );
 other.SetGranularity( list.GetGranularity() );
 for( i = 0; i < other.Num(); i++ ) {
  other[ i ] = *pointerList[ i ];
 }

 list.Swap( other );
}
# 228 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrPool.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/StrPool.h"
class idStrPool;

class idPoolStr : public idStr {
 friend class idStrPool;

public:
      idPoolStr() { numUsers = 0; }
      ~idPoolStr() { ((void)0); }


 size_t Allocated( void ) const { return idStr::Allocated(); }

 size_t Size( void ) const { return sizeof( *this ) + Allocated(); }

 const idStrPool * GetPool( void ) const { return pool; }

private:
 idStrPool * pool;
 mutable int numUsers;
};

class idStrPool {
public:
      idStrPool() { caseSensitive = true; }

 void SetCaseSensitive( bool caseSensitive );

 int Num( void ) const { return pool.Num(); }
 size_t Allocated( void ) const;
 size_t Size( void ) const;

 const idPoolStr * operator[]( int index ) const { return pool[index]; }

 const idPoolStr * AllocString( const char *string );
 void FreeString( const idPoolStr *poolStr );
 const idPoolStr * CopyString( const idPoolStr *poolStr );
 void Clear( void );

private:
 bool caseSensitive;
 idList<idPoolStr *> pool;
 idHashIndex poolHash;
};






inline void idStrPool::SetCaseSensitive( bool caseSensitive ) {
 this->caseSensitive = caseSensitive;
}






inline const idPoolStr *idStrPool::AllocString( const char *string ) {
 int i, hash;
 idPoolStr *poolStr;

 hash = poolHash.GenerateKey( string, caseSensitive );
 if ( caseSensitive ) {
  for ( i = poolHash.First( hash ); i != -1; i = poolHash.Next( i ) ) {
   if ( pool[i]->Cmp( string ) == 0 ) {
    pool[i]->numUsers++;
    return pool[i];
   }
  }
 } else {
  for ( i = poolHash.First( hash ); i != -1; i = poolHash.Next( i ) ) {
   if ( pool[i]->Icmp( string ) == 0 ) {
    pool[i]->numUsers++;
    return pool[i];
   }
  }
 }

 poolStr = new idPoolStr;
 *static_cast<idStr *>(poolStr) = string;
 poolStr->pool = this;
 poolStr->numUsers = 1;
 poolHash.Add( hash, pool.Append( poolStr ) );
 return poolStr;
}






inline void idStrPool::FreeString( const idPoolStr *poolStr ) {
 int i, hash;

 ((void)0);
 ((void)0);

 poolStr->numUsers--;
 if ( poolStr->numUsers <= 0 ) {
  hash = poolHash.GenerateKey( poolStr->c_str(), caseSensitive );
  if ( caseSensitive ) {
   for ( i = poolHash.First( hash ); i != -1; i = poolHash.Next( i ) ) {
    if ( pool[i]->Cmp( poolStr->c_str() ) == 0 ) {
     break;
    }
   }
  } else {
   for ( i = poolHash.First( hash ); i != -1; i = poolHash.Next( i ) ) {
    if ( pool[i]->Icmp( poolStr->c_str() ) == 0 ) {
     break;
    }
   }
  }
  ((void)0);
  ((void)0);
  delete pool[i];
  pool.RemoveIndex( i );
  poolHash.RemoveIndex( hash, i );
 }
}






inline const idPoolStr *idStrPool::CopyString( const idPoolStr *poolStr ) {

 ((void)0);

 if ( poolStr->pool == this ) {

  poolStr->numUsers++;
  return poolStr;
 } else {

  return AllocString( poolStr->c_str() );
 }
}






inline void idStrPool::Clear( void ) {
 int i;

 for ( i = 0; i < pool.Num(); i++ ) {
  pool[i]->numUsers = 0;
 }
 pool.DeleteContents( true );
 poolHash.Free();
}






inline size_t idStrPool::Allocated( void ) const {
 int i;
 size_t size;

 size = pool.Allocated() + poolHash.Allocated();
 for ( i = 0; i < pool.Num(); i++ ) {
  size += pool[i]->Allocated();
 }
 return size;
}






inline size_t idStrPool::Size( void ) const {
 int i;
 size_t size;

 size = pool.Size() + poolHash.Size();
 for ( i = 0; i < pool.Num(); i++ ) {
  size += pool[i]->Size();
 }
 return size;
}
# 229 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/VectorSet.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/VectorSet.h"
template< class type, int dimension >
class idVectorSet : public idList<type> {
public:
       idVectorSet( void );
       idVectorSet( const type &mins, const type &maxs, const int boxHashSize, const int initialSize );


 size_t Allocated( void ) const { return idList<type>::Allocated() + hash.Allocated(); }

 size_t Size( void ) const { return sizeof( *this ) + Allocated(); }

 void Init( const type &mins, const type &maxs, const int boxHashSize, const int initialSize );
 void ResizeIndex( const int newSize );
 void Clear( void );

 int FindVector( const type &v, const float epsilon );

private:
 idHashIndex hash;
 type mins;
 type maxs;
 int boxHashSize;
 float boxInvSize[dimension];
 float boxHalfSize[dimension];
};

template< class type, int dimension >
inline idVectorSet<type,dimension>::idVectorSet( void ) {
 hash.Clear( idMath::IPow( boxHashSize, dimension ), 128 );
 boxHashSize = 16;
 memset( boxInvSize, 0, dimension * sizeof( boxInvSize[0] ) );
 memset( boxHalfSize, 0, dimension * sizeof( boxHalfSize[0] ) );
}

template< class type, int dimension >
inline idVectorSet<type,dimension>::idVectorSet( const type &mins, const type &maxs, const int boxHashSize, const int initialSize ) {
 Init( mins, maxs, boxHashSize, initialSize );
}

template< class type, int dimension >
inline void idVectorSet<type,dimension>::Init( const type &mins, const type &maxs, const int boxHashSize, const int initialSize ) {
 int i;
 float boxSize;

 idList<type>::AssureSize( initialSize );
 idList<type>::SetNum( 0, false );

 hash.Clear( idMath::IPow( boxHashSize, dimension ), initialSize );

 this->mins = mins;
 this->maxs = maxs;
 this->boxHashSize = boxHashSize;

 for ( i = 0; i < dimension; i++ ) {
  boxSize = ( maxs[i] - mins[i] ) / (float) boxHashSize;
  boxInvSize[i] = 1.0f / boxSize;
  boxHalfSize[i] = boxSize * 0.5f;
 }
}

template< class type, int dimension >
inline void idVectorSet<type,dimension>::ResizeIndex( const int newSize ) {
 idList<type>::Resize( newSize );
 hash.ResizeIndex( newSize );
}

template< class type, int dimension >
inline void idVectorSet<type,dimension>::Clear( void ) {
 idList<type>::Clear();
 hash.Clear();
}

template< class type, int dimension >
inline int idVectorSet<type,dimension>::FindVector( const type &v, const float epsilon ) {
 int i, j, k, hashKey, partialHashKey[dimension];

 for ( i = 0; i < dimension; i++ ) {
  ((void)0);
  partialHashKey[i] = (int) ( ( v[i] - mins[i] - boxHalfSize[i] ) * boxInvSize[i] );
 }

 for ( i = 0; i < ( 1 << dimension ); i++ ) {

  hashKey = 0;
  for ( j = 0; j < dimension; j++ ) {
   hashKey *= boxHashSize;
   hashKey += partialHashKey[j] + ( ( i >> j ) & 1 );
  }

  for ( j = hash.First( hashKey ); j >= 0; j = hash.Next( j ) ) {
   const type &lv = (*this)[j];
   for ( k = 0; k < dimension; k++ ) {
    if ( idMath::Fabs( lv[k] - v[k] ) > epsilon ) {
     break;
    }
   }
   if ( k >= dimension ) {
    return j;
   }
  }
 }

 hashKey = 0;
 for ( i = 0; i < dimension; i++ ) {
  hashKey *= boxHashSize;
  hashKey += (int) ( ( v[i] - mins[i] ) * boxInvSize[i] );
 }

 hash.Add( hashKey, idList<type>::Num() );
 this->Append( v );
 return idList<type>::Num()-1;
}
# 166 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/VectorSet.h"
template< class type, int dimension >
class idVectorSubset {
public:
       idVectorSubset( void );
       idVectorSubset( const type &mins, const type &maxs, const int boxHashSize, const int initialSize );


 size_t Allocated( void ) const { return idList<type>::Allocated() + hash.Allocated(); }

 size_t Size( void ) const { return sizeof( *this ) + Allocated(); }

 void Init( const type &mins, const type &maxs, const int boxHashSize, const int initialSize );
 void Clear( void );


 int FindVector( const type *vectorList, const int vectorNum, const float epsilon );

private:
 idHashIndex hash;
 type mins;
 type maxs;
 int boxHashSize;
 float boxInvSize[dimension];
 float boxHalfSize[dimension];
};

template< class type, int dimension >
inline idVectorSubset<type,dimension>::idVectorSubset( void ) {
 hash.Clear( idMath::IPow( boxHashSize, dimension ), 128 );
 boxHashSize = 16;
 memset( boxInvSize, 0, dimension * sizeof( boxInvSize[0] ) );
 memset( boxHalfSize, 0, dimension * sizeof( boxHalfSize[0] ) );
}

template< class type, int dimension >
inline idVectorSubset<type,dimension>::idVectorSubset( const type &mins, const type &maxs, const int boxHashSize, const int initialSize ) {
 Init( mins, maxs, boxHashSize, initialSize );
}

template< class type, int dimension >
inline void idVectorSubset<type,dimension>::Init( const type &mins, const type &maxs, const int boxHashSize, const int initialSize ) {
 int i;
 float boxSize;

 hash.Clear( idMath::IPow( boxHashSize, dimension ), initialSize );

 this->mins = mins;
 this->maxs = maxs;
 this->boxHashSize = boxHashSize;

 for ( i = 0; i < dimension; i++ ) {
  boxSize = ( maxs[i] - mins[i] ) / (float) boxHashSize;
  boxInvSize[i] = 1.0f / boxSize;
  boxHalfSize[i] = boxSize * 0.5f;
 }
}

template< class type, int dimension >
inline void idVectorSubset<type,dimension>::Clear( void ) {
 idList<type>::Clear();
 hash.Clear();
}

template< class type, int dimension >
inline int idVectorSubset<type,dimension>::FindVector( const type *vectorList, const int vectorNum, const float epsilon ) {
 int i, j, k, hashKey, partialHashKey[dimension];
 const type &v = vectorList[vectorNum];

 for ( i = 0; i < dimension; i++ ) {
  ((void)0);
  partialHashKey[i] = (int) ( ( v[i] - mins[i] - boxHalfSize[i] ) * boxInvSize[i] );
 }

 for ( i = 0; i < ( 1 << dimension ); i++ ) {

  hashKey = 0;
  for ( j = 0; j < dimension; j++ ) {
   hashKey *= boxHashSize;
   hashKey += partialHashKey[j] + ( ( i >> j ) & 1 );
  }

  for ( j = hash.First( hashKey ); j >= 0; j = hash.Next( j ) ) {
   const type &lv = vectorList[j];
   for ( k = 0; k < dimension; k++ ) {
    if ( idMath::Fabs( lv[k] - v[k] ) > epsilon ) {
     break;
    }
   }
   if ( k >= dimension ) {
    return j;
   }
  }
 }

 hashKey = 0;
 for ( i = 0; i < dimension; i++ ) {
  hashKey *= boxHashSize;
  hashKey += (int) ( ( v[i] - mins[i] ) * boxInvSize[i] );
 }

 hash.Add( hashKey, vectorNum );
 return vectorNum;
}
# 230 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/PlaneSet.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/containers/PlaneSet.h"
class idPlaneSet : public idList<idPlane> {
public:

 void Clear( void ) { idList<idPlane>::Clear(); hash.Free(); }

 int FindPlane( const idPlane &plane, const float normalEps, const float distEps );

private:
 idHashIndex hash;
};

inline int idPlaneSet::FindPlane( const idPlane &plane, const float normalEps, const float distEps ) {
 int i, border, hashKey;

 ((void)0);

 hashKey = (int)( idMath::Fabs( plane.Dist() ) * 0.125f );
 for ( border = -1; border <= 1; border++ ) {
  for ( i = hash.First( hashKey + border ); i >= 0; i = hash.Next( i ) ) {
   if ( (*this)[i].Compare( plane, normalEps, distEps ) ) {
    return i;
   }
  }
 }

 if ( plane.Type() >= 3 && plane.Type() < 6 ) {
  Append( -plane );
  hash.Add( hashKey, Num()-1 );
  Append( plane );
  hash.Add( hashKey, Num()-1 );
  return ( Num() - 1 );
 }
 else {
  Append( plane );
  hash.Add( hashKey, Num()-1 );
  Append( -plane );
  hash.Add( hashKey, Num()-1 );
  return ( Num() - 2 );
 }
}
# 231 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/hashing/CRC32.h" 1
# 13 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/hashing/CRC32.h"
void CRC32_InitChecksum( unsigned long &crcvalue );
void CRC32_UpdateChecksum( unsigned long &crcvalue, const void *data, int length );
void CRC32_FinishChecksum( unsigned long &crcvalue );
unsigned long CRC32_BlockChecksum( const void *data, int length );
# 234 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/hashing/MD4.h" 1
# 13 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/hashing/MD4.h"
unsigned long MD4_BlockChecksum( const void *data, int length );
# 235 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/hashing/MD5.h" 1
# 13 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/hashing/MD5.h"
unsigned long MD5_BlockChecksum( const void *data, int length );
# 236 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Dict.h" 1
# 48 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Dict.h"
class idKeyValue {
 friend class idDict;

public:
 const idStr & GetKey( void ) const { return *key; }
 const idStr & GetValue( void ) const { return *value; }

 size_t Allocated( void ) const { return key->Allocated() + value->Allocated(); }
 size_t Size( void ) const { return sizeof( *this ) + key->Size() + value->Size(); }

 bool operator==( const idKeyValue &kv ) const { return ( key == kv.key && value == kv.value ); }

private:
 const idPoolStr * key;
 const idPoolStr * value;
};

class idDict {
public:
      idDict( void );
      idDict( const idDict &other );
      ~idDict( void );


 void SetGranularity( int granularity );

 void SetHashSize( int hashSize );

 idDict & operator=( const idDict &other );

 void Copy( const idDict &other );

 void TransferKeyValues( idDict &other );

 bool Parse( idParser &parser );

 void SetDefaults( const idDict *dict );

 void Clear( void );

 void Print() const;

 size_t Allocated( void ) const;
 size_t Size( void ) const { return sizeof( *this ) + Allocated(); }

 void Set( const char *key, const char *value );
 void SetFloat( const char *key, float val );
 void SetInt( const char *key, int val );
 void SetBool( const char *key, bool val );
 void SetVector( const char *key, const idVec3 &val );
 void SetVec2( const char *key, const idVec2 &val );
 void SetVec4( const char *key, const idVec4 &val );
 void SetAngles( const char *key, const idAngles &val );
 void SetMatrix( const char *key, const idMat3 &val );


 const char * GetString( const char *key, const char *defaultString = "" ) const;
 float GetFloat( const char *key, const char *defaultString = "0" ) const;
 int GetInt( const char *key, const char *defaultString = "0" ) const;
 bool GetBool( const char *key, const char *defaultString = "0" ) const;
 idVec3 GetVector( const char *key, const char *defaultString = __null ) const;
 idVec2 GetVec2( const char *key, const char *defaultString = __null ) const;
 idVec4 GetVec4( const char *key, const char *defaultString = __null ) const;
 idAngles GetAngles( const char *key, const char *defaultString = __null ) const;
 idMat3 GetMatrix( const char *key, const char *defaultString = __null ) const;

 bool GetString( const char *key, const char *defaultString, const char **out ) const;
 bool GetString( const char *key, const char *defaultString, idStr &out ) const;
 bool GetFloat( const char *key, const char *defaultString, float &out ) const;
 bool GetInt( const char *key, const char *defaultString, int &out ) const;
 bool GetBool( const char *key, const char *defaultString, bool &out ) const;
 bool GetVector( const char *key, const char *defaultString, idVec3 &out ) const;
 bool GetVec2( const char *key, const char *defaultString, idVec2 &out ) const;
 bool GetVec4( const char *key, const char *defaultString, idVec4 &out ) const;
 bool GetAngles( const char *key, const char *defaultString, idAngles &out ) const;
 bool GetMatrix( const char *key, const char *defaultString, idMat3 &out ) const;

 int GetNumKeyVals( void ) const;
 const idKeyValue * GetKeyVal( int index ) const;


 const idKeyValue * FindKey( const char *key ) const;


 int FindKeyIndex( const char *key ) const;

 void Delete( const char *key );


 const idKeyValue * MatchPrefix( const char *prefix, const idKeyValue *lastMatch = __null ) const;

 const char * RandomPrefix( const char *prefix, idRandom &random ) const;

 void WriteToFileHandle( idFile *f ) const;
 void ReadFromFileHandle( idFile *f );


 int Checksum( void ) const;

 static void Init( void );
 static void Shutdown( void );

 static void ShowMemoryUsage_f( const idCmdArgs &args );
 static void ListKeys_f( const idCmdArgs &args );
 static void ListValues_f( const idCmdArgs &args );

private:
 idList<idKeyValue> args;
 idHashIndex argHash;

 static idStrPool globalKeys;
 static idStrPool globalValues;
};


inline idDict::idDict( void ) {
 args.SetGranularity( 16 );
 argHash.SetGranularity( 16 );
 argHash.Clear( 128, 16 );
}

inline idDict::idDict( const idDict &other ) {
 *this = other;
}

inline idDict::~idDict( void ) {
 Clear();
}

inline void idDict::SetGranularity( int granularity ) {
 args.SetGranularity( granularity );
 argHash.SetGranularity( granularity );
}

inline void idDict::SetHashSize( int hashSize ) {
 if ( args.Num() == 0 ) {
  argHash.Clear( hashSize, 16 );
 }
}

inline void idDict::SetFloat( const char *key, float val ) {
 Set( key, va( "%f", val ) );
}

inline void idDict::SetInt( const char *key, int val ) {
 Set( key, va( "%i", val ) );
}

inline void idDict::SetBool( const char *key, bool val ) {
 Set( key, va( "%i", val ) );
}

inline void idDict::SetVector( const char *key, const idVec3 &val ) {
 Set( key, val.ToString() );
}

inline void idDict::SetVec4( const char *key, const idVec4 &val ) {
 Set( key, val.ToString() );
}

inline void idDict::SetVec2( const char *key, const idVec2 &val ) {
 Set( key, val.ToString() );
}

inline void idDict::SetAngles( const char *key, const idAngles &val ) {
 Set( key, val.ToString() );
}

inline void idDict::SetMatrix( const char *key, const idMat3 &val ) {
 Set( key, val.ToString() );
}

inline bool idDict::GetString( const char *key, const char *defaultString, const char **out ) const {
 const idKeyValue *kv = FindKey( key );
 if ( kv ) {
  *out = kv->GetValue();
  return true;
 }
 *out = defaultString;
 return false;
}

inline bool idDict::GetString( const char *key, const char *defaultString, idStr &out ) const {
 const idKeyValue *kv = FindKey( key );
 if ( kv ) {
  out = kv->GetValue();
  return true;
 }
 out = defaultString;
 return false;
}

inline const char *idDict::GetString( const char *key, const char *defaultString ) const {
 const idKeyValue *kv = FindKey( key );
 if ( kv ) {
  return kv->GetValue();
 }
 return defaultString;
}

inline float idDict::GetFloat( const char *key, const char *defaultString ) const {
 return atof( GetString( key, defaultString ) );
}

inline int idDict::GetInt( const char *key, const char *defaultString ) const {
 return atoi( GetString( key, defaultString ) );
}

inline bool idDict::GetBool( const char *key, const char *defaultString ) const {
 return ( atoi( GetString( key, defaultString ) ) != 0 );
}

inline idVec3 idDict::GetVector( const char *key, const char *defaultString ) const {
 idVec3 out;
 GetVector( key, defaultString, out );
 return out;
}

inline idVec2 idDict::GetVec2( const char *key, const char *defaultString ) const {
 idVec2 out;
 GetVec2( key, defaultString, out );
 return out;
}

inline idVec4 idDict::GetVec4( const char *key, const char *defaultString ) const {
 idVec4 out;
 GetVec4( key, defaultString, out );
 return out;
}

inline idAngles idDict::GetAngles( const char *key, const char *defaultString ) const {
 idAngles out;
 GetAngles( key, defaultString, out );
 return out;
}

inline idMat3 idDict::GetMatrix( const char *key, const char *defaultString ) const {
 idMat3 out;
 GetMatrix( key, defaultString, out );
 return out;
}

inline int idDict::GetNumKeyVals( void ) const {
 return args.Num();
}

inline const idKeyValue *idDict::GetKeyVal( int index ) const {
 if ( index >= 0 && index < args.Num() ) {
  return &args[ index ];
 }
 return __null;
}
# 239 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/LangDict.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/LangDict.h"
class idLangKeyValue {
public:
 idStr key;
 idStr value;
};

class idLangDict {
public:
       idLangDict( void );
       ~idLangDict( void );

 void Clear( void );
 bool Load( const char *fileName, bool clear = true );
 void Save( const char *fileName );

 const char * AddString( const char *str );
 const char * GetString( const char *str ) const;


 void AddKeyVal( const char *key, const char *val );

 int GetNumKeyVals( void ) const;
 const idLangKeyValue * GetKeyVal( int i ) const;

 void SetBaseID(int id) { baseID = id; };

private:
 idList<idLangKeyValue> args;
 idHashIndex hash;

 bool ExcludeString( const char *str ) const;
 int GetNextId( void ) const;
 int GetHashKey( const char *str ) const;

 int baseID;
};
# 240 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/BitMsg.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/BitMsg.h"
class idBitMsg {
public:
     idBitMsg();
     ~idBitMsg() {}

 void Init( byte *data, int length );
 void Init( const byte *data, int length );
 byte * GetData( void );
 const byte * GetData( void ) const;
 int GetMaxSize( void ) const;
 void SetAllowOverflow( bool set );
 bool IsOverflowed( void ) const;

 int GetSize( void ) const;
 void SetSize( int size );
 int GetWriteBit( void ) const;
 void SetWriteBit( int bit );
 int GetNumBitsWritten( void ) const;
 int GetRemainingWriteBits( void ) const;
 void SaveWriteState( int &s, int &b ) const;
 void RestoreWriteState( int s, int b );

 int GetReadCount( void ) const;
 void SetReadCount( int bytes );
 int GetReadBit( void ) const;
 void SetReadBit( int bit );
 int GetNumBitsRead( void ) const;
 int GetRemainingReadBits( void ) const;
 void SaveReadState( int &c, int &b ) const;
 void RestoreReadState( int c, int b );

 void BeginWriting( void );
 int GetRemainingSpace( void ) const;
 void WriteByteAlign( void );
 void WriteBits( int value, int numBits );
 void WriteChar( int c );
 void WriteByte( int c );
 void WriteShort( int c );
 void WriteUShort( int c );
 void WriteLong( int c );
 void WriteFloat( float f );
 void WriteFloat( float f, int exponentBits, int mantissaBits );
 void WriteAngle8( float f );
 void WriteAngle16( float f );
 void WriteDir( const idVec3 &dir, int numBits );
 void WriteString( const char *s, int maxLength = -1, bool make7Bit = true );
 void WriteData( const void *data, int length );
 void WriteNetadr( const netadr_t adr );

 void WriteDeltaChar( int oldValue, int newValue );
 void WriteDeltaByte( int oldValue, int newValue );
 void WriteDeltaShort( int oldValue, int newValue );
 void WriteDeltaLong( int oldValue, int newValue );
 void WriteDeltaFloat( float oldValue, float newValue );
 void WriteDeltaFloat( float oldValue, float newValue, int exponentBits, int mantissaBits );
 void WriteDeltaByteCounter( int oldValue, int newValue );
 void WriteDeltaShortCounter( int oldValue, int newValue );
 void WriteDeltaLongCounter( int oldValue, int newValue );
 bool WriteDeltaDict( const idDict &dict, const idDict *base );

 void BeginReading( void ) const;
 int GetRemaingData( void ) const;
 void ReadByteAlign( void ) const;
 int ReadBits( int numBits ) const;
 int ReadChar( void ) const;
 int ReadByte( void ) const;
 int ReadShort( void ) const;
 int ReadUShort( void ) const;
 int ReadLong( void ) const;
 float ReadFloat( void ) const;
 float ReadFloat( int exponentBits, int mantissaBits ) const;
 float ReadAngle8( void ) const;
 float ReadAngle16( void ) const;
 idVec3 ReadDir( int numBits ) const;
 int ReadString( char *buffer, int bufferSize ) const;
 int ReadData( void *data, int length ) const;
 void ReadNetadr( netadr_t *adr ) const;

 int ReadDeltaChar( int oldValue ) const;
 int ReadDeltaByte( int oldValue ) const;
 int ReadDeltaShort( int oldValue ) const;
 int ReadDeltaLong( int oldValue ) const;
 float ReadDeltaFloat( float oldValue ) const;
 float ReadDeltaFloat( float oldValue, int exponentBits, int mantissaBits ) const;
 int ReadDeltaByteCounter( int oldValue ) const;
 int ReadDeltaShortCounter( int oldValue ) const;
 int ReadDeltaLongCounter( int oldValue ) const;
 bool ReadDeltaDict( idDict &dict, const idDict *base ) const;

 static int DirToBits( const idVec3 &dir, int numBits );
 static idVec3 BitsToDir( int bits, int numBits );

private:
 byte * writeData;
 const byte * readData;
 int maxSize;
 int curSize;
 int writeBit;
 mutable int readCount;
 mutable int readBit;
 bool allowOverflow;
 bool overflowed;

private:
 bool CheckOverflow( int numBits );
 byte * GetByteSpace( int length );
 void WriteDelta( int oldValue, int newValue, int numBits );
 int ReadDelta( int oldValue, int numBits ) const;
};


inline void idBitMsg::Init( byte *data, int length ) {
 writeData = data;
 readData = data;
 maxSize = length;
}

inline void idBitMsg::Init( const byte *data, int length ) {
 writeData = __null;
 readData = data;
 maxSize = length;
}

inline byte *idBitMsg::GetData( void ) {
 return writeData;
}

inline const byte *idBitMsg::GetData( void ) const {
 return readData;
}

inline int idBitMsg::GetMaxSize( void ) const {
 return maxSize;
}

inline void idBitMsg::SetAllowOverflow( bool set ) {
 allowOverflow = set;
}

inline bool idBitMsg::IsOverflowed( void ) const {
 return overflowed;
}

inline int idBitMsg::GetSize( void ) const {
 return curSize;
}

inline void idBitMsg::SetSize( int size ) {
 if ( size > maxSize ) {
  curSize = maxSize;
 } else {
  curSize = size;
 }
}

inline int idBitMsg::GetWriteBit( void ) const {
 return writeBit;
}

inline void idBitMsg::SetWriteBit( int bit ) {
 writeBit = bit & 7;
 if ( writeBit ) {
  writeData[curSize - 1] &= ( 1 << writeBit ) - 1;
 }
}

inline int idBitMsg::GetNumBitsWritten( void ) const {
 return ( ( curSize << 3 ) - ( ( 8 - writeBit ) & 7 ) );
}

inline int idBitMsg::GetRemainingWriteBits( void ) const {
 return ( maxSize << 3 ) - GetNumBitsWritten();
}

inline void idBitMsg::SaveWriteState( int &s, int &b ) const {
 s = curSize;
 b = writeBit;
}

inline void idBitMsg::RestoreWriteState( int s, int b ) {
 curSize = s;
 writeBit = b & 7;
 if ( writeBit ) {
  writeData[curSize - 1] &= ( 1 << writeBit ) - 1;
 }
}

inline int idBitMsg::GetReadCount( void ) const {
 return readCount;
}

inline void idBitMsg::SetReadCount( int bytes ) {
 readCount = bytes;
}

inline int idBitMsg::GetReadBit( void ) const {
 return readBit;
}

inline void idBitMsg::SetReadBit( int bit ) {
 readBit = bit & 7;
}

inline int idBitMsg::GetNumBitsRead( void ) const {
 return ( ( readCount << 3 ) - ( ( 8 - readBit ) & 7 ) );
}

inline int idBitMsg::GetRemainingReadBits( void ) const {
 return ( curSize << 3 ) - GetNumBitsRead();
}

inline void idBitMsg::SaveReadState( int &c, int &b ) const {
 c = readCount;
 b = readBit;
}

inline void idBitMsg::RestoreReadState( int c, int b ) {
 readCount = c;
 readBit = b & 7;
}

inline void idBitMsg::BeginWriting( void ) {
 curSize = 0;
 overflowed = false;
 writeBit = 0;
}

inline int idBitMsg::GetRemainingSpace( void ) const {
 return maxSize - curSize;
}

inline void idBitMsg::WriteByteAlign( void ) {
 writeBit = 0;
}

inline void idBitMsg::WriteChar( int c ) {
 WriteBits( c, -8 );
}

inline void idBitMsg::WriteByte( int c ) {
 WriteBits( c, 8 );
}

inline void idBitMsg::WriteShort( int c ) {
 WriteBits( c, -16 );
}

inline void idBitMsg::WriteUShort( int c ) {
 WriteBits( c, 16 );
}

inline void idBitMsg::WriteLong( int c ) {
 WriteBits( c, 32 );
}

inline void idBitMsg::WriteFloat( float f ) {
 WriteBits( *reinterpret_cast<int *>(&f), 32 );
}

inline void idBitMsg::WriteFloat( float f, int exponentBits, int mantissaBits ) {
 int bits = idMath::FloatToBits( f, exponentBits, mantissaBits );
 WriteBits( bits, 1 + exponentBits + mantissaBits );
}

inline void idBitMsg::WriteAngle8( float f ) {
 WriteByte( ( idMath::FtoiFast( (f) * 256.0f / 360.0f ) & 255 ) );
}

inline void idBitMsg::WriteAngle16( float f ) {
 WriteShort( ( idMath::FtoiFast( (f) * 65536.0f / 360.0f ) & 65535 ) );
}

inline void idBitMsg::WriteDir( const idVec3 &dir, int numBits ) {
 WriteBits( DirToBits( dir, numBits ), numBits );
}

inline void idBitMsg::WriteDeltaChar( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, -8 );
}

inline void idBitMsg::WriteDeltaByte( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, 8 );
}

inline void idBitMsg::WriteDeltaShort( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, -16 );
}

inline void idBitMsg::WriteDeltaLong( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, 32 );
}

inline void idBitMsg::WriteDeltaFloat( float oldValue, float newValue ) {
 WriteDelta( *reinterpret_cast<int *>(&oldValue), *reinterpret_cast<int *>(&newValue), 32 );
}

inline void idBitMsg::WriteDeltaFloat( float oldValue, float newValue, int exponentBits, int mantissaBits ) {
 int oldBits = idMath::FloatToBits( oldValue, exponentBits, mantissaBits );
 int newBits = idMath::FloatToBits( newValue, exponentBits, mantissaBits );
 WriteDelta( oldBits, newBits, 1 + exponentBits + mantissaBits );
}

inline void idBitMsg::BeginReading( void ) const {
 readCount = 0;
 readBit = 0;
}

inline int idBitMsg::GetRemaingData( void ) const {
 return curSize - readCount;
}

inline void idBitMsg::ReadByteAlign( void ) const {
 readBit = 0;
}

inline int idBitMsg::ReadChar( void ) const {
 return (signed char)ReadBits( -8 );
}

inline int idBitMsg::ReadByte( void ) const {
 return (unsigned char)ReadBits( 8 );
}

inline int idBitMsg::ReadShort( void ) const {
 return (short)ReadBits( -16 );
}

inline int idBitMsg::ReadUShort( void ) const {
 return (unsigned short)ReadBits( 16 );
}

inline int idBitMsg::ReadLong( void ) const {
 return ReadBits( 32 );
}

inline float idBitMsg::ReadFloat( void ) const {
 float value;
 *reinterpret_cast<int *>(&value) = ReadBits( 32 );
 return value;
}

inline float idBitMsg::ReadFloat( int exponentBits, int mantissaBits ) const {
 int bits = ReadBits( 1 + exponentBits + mantissaBits );
 return idMath::BitsToFloat( bits, exponentBits, mantissaBits );
}

inline float idBitMsg::ReadAngle8( void ) const {
 return ( (ReadByte()) * ( 360.0f / 256.0f ) );
}

inline float idBitMsg::ReadAngle16( void ) const {
 return ( (ReadShort()) * ( 360.0f / 65536.0f ) );
}

inline idVec3 idBitMsg::ReadDir( int numBits ) const {
 return BitsToDir( ReadBits( numBits ), numBits );
}

inline int idBitMsg::ReadDeltaChar( int oldValue ) const {
 return (signed char)ReadDelta( oldValue, -8 );
}

inline int idBitMsg::ReadDeltaByte( int oldValue ) const {
 return (unsigned char)ReadDelta( oldValue, 8 );
}

inline int idBitMsg::ReadDeltaShort( int oldValue ) const {
 return (short)ReadDelta( oldValue, -16 );
}

inline int idBitMsg::ReadDeltaLong( int oldValue ) const {
 return ReadDelta( oldValue, 32 );
}

inline float idBitMsg::ReadDeltaFloat( float oldValue ) const {
 float value;
 *reinterpret_cast<int *>(&value) = ReadDelta( *reinterpret_cast<int *>(&oldValue), 32 );
 return value;
}

inline float idBitMsg::ReadDeltaFloat( float oldValue, int exponentBits, int mantissaBits ) const {
 int oldBits = idMath::FloatToBits( oldValue, exponentBits, mantissaBits );
 int newBits = ReadDelta( oldBits, 1 + exponentBits + mantissaBits );
 return idMath::BitsToFloat( newBits, exponentBits, mantissaBits );
}
# 439 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/BitMsg.h"
class idBitMsgDelta {
public:
     idBitMsgDelta();
     ~idBitMsgDelta() {}

 void Init( const idBitMsg *base, idBitMsg *newBase, idBitMsg *delta );
 void Init( const idBitMsg *base, idBitMsg *newBase, const idBitMsg *delta );
 bool HasChanged( void ) const;

 void WriteBits( int value, int numBits );
 void WriteChar( int c );
 void WriteByte( int c );
 void WriteShort( int c );
 void WriteUShort( int c );
 void WriteLong( int c );
 void WriteFloat( float f );
 void WriteFloat( float f, int exponentBits, int mantissaBits );
 void WriteAngle8( float f );
 void WriteAngle16( float f );
 void WriteDir( const idVec3 &dir, int numBits );
 void WriteString( const char *s, int maxLength = -1 );
 void WriteData( const void *data, int length );
 void WriteDict( const idDict &dict );

 void WriteDeltaChar( int oldValue, int newValue );
 void WriteDeltaByte( int oldValue, int newValue );
 void WriteDeltaShort( int oldValue, int newValue );
 void WriteDeltaLong( int oldValue, int newValue );
 void WriteDeltaFloat( float oldValue, float newValue );
 void WriteDeltaFloat( float oldValue, float newValue, int exponentBits, int mantissaBits );
 void WriteDeltaByteCounter( int oldValue, int newValue );
 void WriteDeltaShortCounter( int oldValue, int newValue );
 void WriteDeltaLongCounter( int oldValue, int newValue );

 int ReadBits( int numBits ) const;
 int ReadChar( void ) const;
 int ReadByte( void ) const;
 int ReadShort( void ) const;
 int ReadUShort( void ) const;
 int ReadLong( void ) const;
 float ReadFloat( void ) const;
 float ReadFloat( int exponentBits, int mantissaBits ) const;
 float ReadAngle8( void ) const;
 float ReadAngle16( void ) const;
 idVec3 ReadDir( int numBits ) const;
 void ReadString( char *buffer, int bufferSize ) const;
 void ReadData( void *data, int length ) const;
 void ReadDict( idDict &dict );

 int ReadDeltaChar( int oldValue ) const;
 int ReadDeltaByte( int oldValue ) const;
 int ReadDeltaShort( int oldValue ) const;
 int ReadDeltaLong( int oldValue ) const;
 float ReadDeltaFloat( float oldValue ) const;
 float ReadDeltaFloat( float oldValue, int exponentBits, int mantissaBits ) const;
 int ReadDeltaByteCounter( int oldValue ) const;
 int ReadDeltaShortCounter( int oldValue ) const;
 int ReadDeltaLongCounter( int oldValue ) const;

private:
 const idBitMsg *base;
 idBitMsg * newBase;
 idBitMsg * writeDelta;
 const idBitMsg *readDelta;
 mutable bool changed;

private:
 void WriteDelta( int oldValue, int newValue, int numBits );
 int ReadDelta( int oldValue, int numBits ) const;
};

inline idBitMsgDelta::idBitMsgDelta() {
 base = __null;
 newBase = __null;
 writeDelta = __null;
 readDelta = __null;
 changed = false;
}

inline void idBitMsgDelta::Init( const idBitMsg *base, idBitMsg *newBase, idBitMsg *delta ) {
 this->base = base;
 this->newBase = newBase;
 this->writeDelta = delta;
 this->readDelta = delta;
 this->changed = false;
}

inline void idBitMsgDelta::Init( const idBitMsg *base, idBitMsg *newBase, const idBitMsg *delta ) {
 this->base = base;
 this->newBase = newBase;
 this->writeDelta = __null;
 this->readDelta = delta;
 this->changed = false;
}

inline bool idBitMsgDelta::HasChanged( void ) const {
 return changed;
}

inline void idBitMsgDelta::WriteChar( int c ) {
 WriteBits( c, -8 );
}

inline void idBitMsgDelta::WriteByte( int c ) {
 WriteBits( c, 8 );
}

inline void idBitMsgDelta::WriteShort( int c ) {
 WriteBits( c, -16 );
}

inline void idBitMsgDelta::WriteUShort( int c ) {
 WriteBits( c, 16 );
}

inline void idBitMsgDelta::WriteLong( int c ) {
 WriteBits( c, 32 );
}

inline void idBitMsgDelta::WriteFloat( float f ) {
 WriteBits( *reinterpret_cast<int *>(&f), 32 );
}

inline void idBitMsgDelta::WriteFloat( float f, int exponentBits, int mantissaBits ) {
 int bits = idMath::FloatToBits( f, exponentBits, mantissaBits );
 WriteBits( bits, 1 + exponentBits + mantissaBits );
}

inline void idBitMsgDelta::WriteAngle8( float f ) {
 WriteBits( ( idMath::FtoiFast( (f) * 256.0f / 360.0f ) & 255 ), 8 );
}

inline void idBitMsgDelta::WriteAngle16( float f ) {
 WriteBits( ( idMath::FtoiFast( (f) * 65536.0f / 360.0f ) & 65535 ), 16 );
}

inline void idBitMsgDelta::WriteDir( const idVec3 &dir, int numBits ) {
 WriteBits( idBitMsg::DirToBits( dir, numBits ), numBits );
}

inline void idBitMsgDelta::WriteDeltaChar( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, -8 );
}

inline void idBitMsgDelta::WriteDeltaByte( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, 8 );
}

inline void idBitMsgDelta::WriteDeltaShort( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, -16 );
}

inline void idBitMsgDelta::WriteDeltaLong( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, 32 );
}

inline void idBitMsgDelta::WriteDeltaFloat( float oldValue, float newValue ) {
 WriteDelta( *reinterpret_cast<int *>(&oldValue), *reinterpret_cast<int *>(&newValue), 32 );
}

inline void idBitMsgDelta::WriteDeltaFloat( float oldValue, float newValue, int exponentBits, int mantissaBits ) {
 int oldBits = idMath::FloatToBits( oldValue, exponentBits, mantissaBits );
 int newBits = idMath::FloatToBits( newValue, exponentBits, mantissaBits );
 WriteDelta( oldBits, newBits, 1 + exponentBits + mantissaBits );
}

inline int idBitMsgDelta::ReadChar( void ) const {
 return (signed char)ReadBits( -8 );
}

inline int idBitMsgDelta::ReadByte( void ) const {
 return (unsigned char)ReadBits( 8 );
}

inline int idBitMsgDelta::ReadShort( void ) const {
 return (short)ReadBits( -16 );
}

inline int idBitMsgDelta::ReadUShort( void ) const {
 return (unsigned short)ReadBits( 16 );
}

inline int idBitMsgDelta::ReadLong( void ) const {
 return ReadBits( 32 );
}

inline float idBitMsgDelta::ReadFloat( void ) const {
 float value;
 *reinterpret_cast<int *>(&value) = ReadBits( 32 );
 return value;
}

inline float idBitMsgDelta::ReadFloat( int exponentBits, int mantissaBits ) const {
 int bits = ReadBits( 1 + exponentBits + mantissaBits );
 return idMath::BitsToFloat( bits, exponentBits, mantissaBits );
}

inline float idBitMsgDelta::ReadAngle8( void ) const {
 return ( (ReadByte()) * ( 360.0f / 256.0f ) );
}

inline float idBitMsgDelta::ReadAngle16( void ) const {
 return ( (ReadShort()) * ( 360.0f / 65536.0f ) );
}

inline idVec3 idBitMsgDelta::ReadDir( int numBits ) const {
 return idBitMsg::BitsToDir( ReadBits( numBits ), numBits );
}

inline int idBitMsgDelta::ReadDeltaChar( int oldValue ) const {
 return (signed char)ReadDelta( oldValue, -8 );
}

inline int idBitMsgDelta::ReadDeltaByte( int oldValue ) const {
 return (unsigned char)ReadDelta( oldValue, 8 );
}

inline int idBitMsgDelta::ReadDeltaShort( int oldValue ) const {
 return (short)ReadDelta( oldValue, -16 );
}

inline int idBitMsgDelta::ReadDeltaLong( int oldValue ) const {
 return ReadDelta( oldValue, 32 );
}

inline float idBitMsgDelta::ReadDeltaFloat( float oldValue ) const {
 float value;
 *reinterpret_cast<int *>(&value) = ReadDelta( *reinterpret_cast<int *>(&oldValue), 32 );
 return value;
}

inline float idBitMsgDelta::ReadDeltaFloat( float oldValue, int exponentBits, int mantissaBits ) const {
 int oldBits = idMath::FloatToBits( oldValue, exponentBits, mantissaBits );
 int newBits = ReadDelta( oldBits, 1 + exponentBits + mantissaBits );
 return idMath::BitsToFloat( newBits, exponentBits, mantissaBits );
}
# 241 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/MapFile.h" 1
# 46 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/MapFile.h"
const int OLD_MAP_VERSION = 1;
const int CURRENT_MAP_VERSION = 2;
const int DEFAULT_CURVE_SUBDIVISION = 4;
const float DEFAULT_CURVE_MAX_ERROR = 4.0f;
const float DEFAULT_CURVE_MAX_ERROR_CD = 24.0f;
const float DEFAULT_CURVE_MAX_LENGTH = -1.0f;
const float DEFAULT_CURVE_MAX_LENGTH_CD = -1.0f;


class idMapPrimitive {
public:
 enum { TYPE_INVALID = -1, TYPE_BRUSH, TYPE_PATCH };

 idDict epairs;

       idMapPrimitive( void ) { type = TYPE_INVALID; }
 virtual ~idMapPrimitive( void ) { }
 int GetType( void ) const { return type; }

protected:
 int type;
};


class idMapBrushSide {
 friend class idMapBrush;

public:
       idMapBrushSide( void );
       ~idMapBrushSide( void ) { }
 const char * GetMaterial( void ) const { return material; }
 void SetMaterial( const char *p ) { material = p; }
 const idPlane & GetPlane( void ) const { return plane; }
 void SetPlane( const idPlane &p ) { plane = p; }
 void SetTextureMatrix( const idVec3 mat[2] ) { texMat[0] = mat[0]; texMat[1] = mat[1]; }
 void GetTextureMatrix( idVec3 &mat1, idVec3 &mat2 ) { mat1 = texMat[0]; mat2 = texMat[1]; }
 void GetTextureVectors( idVec4 v[2] ) const;

protected:
 idStr material;
 idPlane plane;
 idVec3 texMat[2];
 idVec3 origin;
};

inline idMapBrushSide::idMapBrushSide( void ) {
 plane.Zero();
 texMat[0].Zero();
 texMat[1].Zero();
 origin.Zero();
}


class idMapBrush : public idMapPrimitive {
public:
       idMapBrush( void ) { type = TYPE_BRUSH; sides.Resize( 8, 4 ); }
       ~idMapBrush( void ) { sides.DeleteContents( true ); }
 static idMapBrush * Parse( idLexer &src, const idVec3 &origin, bool newFormat = true, float version = CURRENT_MAP_VERSION );
 static idMapBrush * ParseQ3( idLexer &src, const idVec3 &origin );
 bool Write( idFile *fp, int primitiveNum, const idVec3 &origin ) const;
 int GetNumSides( void ) const { return sides.Num(); }
 int AddSide( idMapBrushSide *side ) { return sides.Append( side ); }
 idMapBrushSide * GetSide( int i ) const { return sides[i]; }
 unsigned int GetGeometryCRC( void ) const;

protected:
 int numSides;
 idList<idMapBrushSide*> sides;
};


class idMapPatch : public idMapPrimitive, public idSurface_Patch {
public:
       idMapPatch( void );
       idMapPatch( int maxPatchWidth, int maxPatchHeight );
       ~idMapPatch( void ) { }
 static idMapPatch * Parse( idLexer &src, const idVec3 &origin, bool patchDef3 = true, float version = CURRENT_MAP_VERSION );
 bool Write( idFile *fp, int primitiveNum, const idVec3 &origin ) const;
 const char * GetMaterial( void ) const { return material; }
 void SetMaterial( const char *p ) { material = p; }
 int GetHorzSubdivisions( void ) const { return horzSubdivisions; }
 int GetVertSubdivisions( void ) const { return vertSubdivisions; }
 bool GetExplicitlySubdivided( void ) const { return explicitSubdivisions; }
 void SetHorzSubdivisions( int n ) { horzSubdivisions = n; }
 void SetVertSubdivisions( int n ) { vertSubdivisions = n; }
 void SetExplicitlySubdivided( bool b ) { explicitSubdivisions = b; }
 unsigned int GetGeometryCRC( void ) const;

protected:
 idStr material;
 int horzSubdivisions;
 int vertSubdivisions;
 bool explicitSubdivisions;
};

inline idMapPatch::idMapPatch( void ) {
 type = TYPE_PATCH;
 horzSubdivisions = vertSubdivisions = 0;
 explicitSubdivisions = false;
 width = height = 0;
 maxWidth = maxHeight = 0;
 expanded = false;
}

inline idMapPatch::idMapPatch( int maxPatchWidth, int maxPatchHeight ) {
 type = TYPE_PATCH;
 horzSubdivisions = vertSubdivisions = 0;
 explicitSubdivisions = false;
 width = height = 0;
 maxWidth = maxPatchWidth;
 maxHeight = maxPatchHeight;
 verts.SetNum( maxWidth * maxHeight );
 expanded = false;
}


class idMapEntity {
 friend class idMapFile;

public:
 idDict epairs;

public:
       idMapEntity( void ) { epairs.SetHashSize( 64 ); }
       ~idMapEntity( void ) { primitives.DeleteContents( true ); }
 static idMapEntity * Parse( idLexer &src, bool worldSpawn = false, float version = CURRENT_MAP_VERSION );
 bool Write( idFile *fp, int entityNum ) const;
 int GetNumPrimitives( void ) const { return primitives.Num(); }
 idMapPrimitive * GetPrimitive( int i ) const { return primitives[i]; }
 void AddPrimitive( idMapPrimitive *p ) { primitives.Append( p ); }
 unsigned int GetGeometryCRC( void ) const;
 void RemovePrimitiveData();

protected:
 idList<idMapPrimitive*> primitives;
};


class idMapFile {
public:
       idMapFile( void );
       ~idMapFile( void ) { entities.DeleteContents( true ); }





 bool Parse( const char *filename, bool ignoreRegion = false, bool osPath = false );
 bool Write( const char *fileName, const char *ext, bool fromBasePath = true );

 int GetNumEntities( void ) const { return entities.Num(); }

 idMapEntity * GetEntity( int i ) const { return entities[i]; }

 const char * GetName( void ) const { return name; }

 time_t GetFileTime( void ) const { return fileTime; }


 unsigned int GetGeometryCRC( void ) const { return geometryCRC; }

 bool NeedsReload();

 int AddEntity( idMapEntity *mapentity );
 idMapEntity * FindEntity( const char *name );
 void RemoveEntity( idMapEntity *mapEnt );
 void RemoveEntities( const char *classname );
 void RemoveAllEntities();
 void RemovePrimitiveData();
 bool HasPrimitiveData() { return hasPrimitiveData; }

protected:
 float version;
 time_t fileTime;
 unsigned int geometryCRC;
 idList<idMapEntity *> entities;
 idStr name;
 bool hasPrimitiveData;

private:
 void SetGeometryCRC( void );
};

inline idMapFile::idMapFile( void ) {
 version = CURRENT_MAP_VERSION;
 fileTime = 0;
 geometryCRC = 0;
 entities.Resize( 1024, 256 );
 hasPrimitiveData = false;
}
# 242 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Timer.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Timer.h"
class idTimer {
public:
     idTimer( void );
     idTimer( double clockTicks );
     ~idTimer( void );

 idTimer operator+( const idTimer &t ) const;
 idTimer operator-( const idTimer &t ) const;
 idTimer & operator+=( const idTimer &t );
 idTimer & operator-=( const idTimer &t );

 void Start( void );
 void Stop( void );
 void Clear( void );
 double ClockTicks( void ) const;
 double Milliseconds( void ) const;

private:
 static double base;
 enum {
      TS_STARTED,
      TS_STOPPED
     } state;
 double start;
 double clockTicks;

 void InitBaseClockTicks( void ) const;
};






inline idTimer::idTimer( void ) {
 state = TS_STOPPED;
 clockTicks = 0.0;
}






inline idTimer::idTimer( double _clockTicks ) {
 state = TS_STOPPED;
 clockTicks = _clockTicks;
}






inline idTimer::~idTimer( void ) {
}






inline idTimer idTimer::operator+( const idTimer &t ) const {
 ((void)0);
 return idTimer( clockTicks + t.clockTicks );
}






inline idTimer idTimer::operator-( const idTimer &t ) const {
 ((void)0);
 return idTimer( clockTicks - t.clockTicks );
}






inline idTimer &idTimer::operator+=( const idTimer &t ) {
 ((void)0);
 clockTicks += t.clockTicks;
 return *this;
}






inline idTimer &idTimer::operator-=( const idTimer &t ) {
 ((void)0);
 clockTicks -= t.clockTicks;
 return *this;
}






inline void idTimer::Start( void ) {
 ((void)0);
 state = TS_STARTED;
 start = idLib::sys->GetClockTicks();
}






inline void idTimer::Stop( void ) {
 ((void)0);
 clockTicks += idLib::sys->GetClockTicks() - start;
 if ( base < 0.0 ) {
  InitBaseClockTicks();
 }
 if ( clockTicks > base ) {
  clockTicks -= base;
 }
 state = TS_STOPPED;
}






inline void idTimer::Clear( void ) {
 clockTicks = 0.0;
}






inline double idTimer::ClockTicks( void ) const {
 ((void)0);
 return clockTicks;
}






inline double idTimer::Milliseconds( void ) const {
 ((void)0);
 return clockTicks / ( idLib::sys->ClockTicksPerSecond() * 0.001 );
}
# 205 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Timer.h"
class idTimerReport {
public:
     idTimerReport( void );
     ~idTimerReport( void );

 void SetReportName( const char *name );
 int AddReport( const char *name );
 void Clear( void );
 void Reset( void );
 void PrintReport( void );
 void AddTime( const char *name, idTimer *time );

private:
 idList<idTimer*>timers;
 idStrList names;
 idStr reportName;
};
# 243 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../idlib/Lib.h" 2
# 114 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/BuildVersion.h" 1
# 28 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/BuildVersion.h"
const int BUILD_NUMBER = 1304;
# 117 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/BuildDefines.h" 1
# 118 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Licensee.h" 1
# 119 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/CmdSystem.h" 1
# 48 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/CmdSystem.h"
typedef enum {
 CMD_FL_ALL = -1,
 CMD_FL_CHEAT = ( 1 << ( 0 ) ),
 CMD_FL_SYSTEM = ( 1 << ( 1 ) ),
 CMD_FL_RENDERER = ( 1 << ( 2 ) ),
 CMD_FL_SOUND = ( 1 << ( 3 ) ),
 CMD_FL_GAME = ( 1 << ( 4 ) ),
 CMD_FL_TOOL = ( 1 << ( 5 ) )
} cmdFlags_t;


typedef enum {
 CMD_EXEC_NOW,
 CMD_EXEC_INSERT,
 CMD_EXEC_APPEND
} cmdExecution_t;


typedef void (*cmdFunction_t)( const idCmdArgs &args );


typedef void (*argCompletion_t)( const idCmdArgs &args, void(*callback)( const char *s ) );


class idCmdSystem {
public:
 virtual ~idCmdSystem( void ) {}

 virtual void Init( void ) = 0;
 virtual void Shutdown( void ) = 0;


 virtual void AddCommand( const char *cmdName, cmdFunction_t function, int flags, const char *description, argCompletion_t argCompletion = __null ) = 0;

 virtual void RemoveCommand( const char *cmdName ) = 0;

 virtual void RemoveFlaggedCommands( int flags ) = 0;


 virtual void CommandCompletion( void(*callback)( const char *s ) ) = 0;
 virtual void ArgCompletion( const char *cmdString, void(*callback)( const char *s ) ) = 0;


 virtual void BufferCommandText( cmdExecution_t exec, const char *text ) = 0;



 virtual void ExecuteCommandBuffer( void ) = 0;


 virtual void ArgCompletion_FolderExtension( const idCmdArgs &args, void(*callback)( const char *s ), const char *folder, bool stripFolder, ... ) = 0;

 virtual void ArgCompletion_DeclName( const idCmdArgs &args, void(*callback)( const char *s ), int type ) = 0;


 virtual void BufferCommandArgs( cmdExecution_t exec, const idCmdArgs &args ) = 0;


 virtual void SetupReloadEngine( const idCmdArgs &args ) = 0;
 virtual bool PostReloadEngine( void ) = 0;


 static void ArgCompletion_Boolean( const idCmdArgs &args, void(*callback)( const char *s ) );
 template<int min,int max>
 static void ArgCompletion_Integer( const idCmdArgs &args, void(*callback)( const char *s ) );
 template<const char **strings>
 static void ArgCompletion_String( const idCmdArgs &args, void(*callback)( const char *s ) );
 template<int type>
 static void ArgCompletion_Decl( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_FileName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_MapName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_ModelName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_SoundName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_ImageName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_VideoName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_ConfigName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_SaveGame( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_DemoName( const idCmdArgs &args, void(*callback)( const char *s ) );
};

extern idCmdSystem * cmdSystem;


inline void idCmdSystem::ArgCompletion_Boolean( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 callback( va( "%s 0", args.Argv( 0 ) ) );
 callback( va( "%s 1", args.Argv( 0 ) ) );
}

template<int min,int max> inline void idCmdSystem::ArgCompletion_Integer( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 for ( int i = min; i <= max; i++ ) {
  callback( va( "%s %d", args.Argv( 0 ), i ) );
 }
}

template<const char **strings> inline void idCmdSystem::ArgCompletion_String( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 for ( int i = 0; strings[i]; i++ ) {
  callback( va( "%s %s", args.Argv( 0 ), strings[i] ) );
 }
}

template<int type> inline void idCmdSystem::ArgCompletion_Decl( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_DeclName( args, callback, type );
}

inline void idCmdSystem::ArgCompletion_FileName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "/", true, "", __null );
}

inline void idCmdSystem::ArgCompletion_MapName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "maps/", true, ".map", __null );
}

inline void idCmdSystem::ArgCompletion_ModelName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "models/", false, ".lwo", ".ase", ".md5mesh", ".ma", __null );
}

inline void idCmdSystem::ArgCompletion_SoundName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "sound/", false, ".wav", ".ogg", __null );
}

inline void idCmdSystem::ArgCompletion_ImageName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "/", false, ".tga", ".dds", ".jpg", ".pcx", __null );
}

inline void idCmdSystem::ArgCompletion_VideoName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "video/", false, ".roq", __null );
}

inline void idCmdSystem::ArgCompletion_ConfigName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "/", true, ".cfg", __null );
}

inline void idCmdSystem::ArgCompletion_SaveGame( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "SaveGames/", true, ".save", __null );
}

inline void idCmdSystem::ArgCompletion_DemoName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "demos/", true, ".demo", __null );
}
# 120 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/CVarSystem.h" 1
# 82 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/CVarSystem.h"
typedef enum {
 CVAR_ALL = -1,
 CVAR_BOOL = ( 1 << ( 0 ) ),
 CVAR_INTEGER = ( 1 << ( 1 ) ),
 CVAR_FLOAT = ( 1 << ( 2 ) ),
 CVAR_SYSTEM = ( 1 << ( 3 ) ),
 CVAR_RENDERER = ( 1 << ( 4 ) ),
 CVAR_SOUND = ( 1 << ( 5 ) ),
 CVAR_GUI = ( 1 << ( 6 ) ),
 CVAR_GAME = ( 1 << ( 7 ) ),
 CVAR_TOOL = ( 1 << ( 8 ) ),
 CVAR_USERINFO = ( 1 << ( 9 ) ),
 CVAR_SERVERINFO = ( 1 << ( 10 ) ),
 CVAR_NETWORKSYNC = ( 1 << ( 11 ) ),
 CVAR_STATIC = ( 1 << ( 12 ) ),
 CVAR_CHEAT = ( 1 << ( 13 ) ),
 CVAR_NOCHEAT = ( 1 << ( 14 ) ),
 CVAR_INIT = ( 1 << ( 15 ) ),
 CVAR_ROM = ( 1 << ( 16 ) ),
 CVAR_ARCHIVE = ( 1 << ( 17 ) ),
 CVAR_MODIFIED = ( 1 << ( 18 ) )
} cvarFlags_t;
# 114 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/CVarSystem.h"
class idCVar {
public:

       idCVar( void ) { ((void)0); }


       idCVar( const char *name, const char *value, int flags, const char *description,
         argCompletion_t valueCompletion = __null );
       idCVar( const char *name, const char *value, int flags, const char *description,
         float valueMin, float valueMax, argCompletion_t valueCompletion = __null );
       idCVar( const char *name, const char *value, int flags, const char *description,
         const char **valueStrings, argCompletion_t valueCompletion = __null );

 virtual ~idCVar( void ) {}

 const char * GetName( void ) const { return internalVar->name; }
 int GetFlags( void ) const { return internalVar->flags; }
 const char * GetDescription( void ) const { return internalVar->description; }
 float GetMinValue( void ) const { return internalVar->valueMin; }
 float GetMaxValue( void ) const { return internalVar->valueMax; }
 const char ** GetValueStrings( void ) const { return valueStrings; }
 argCompletion_t GetValueCompletion( void ) const { return valueCompletion; }

 bool IsModified( void ) const { return ( internalVar->flags & CVAR_MODIFIED ) != 0; }
 void SetModified( void ) { internalVar->flags |= CVAR_MODIFIED; }
 void ClearModified( void ) { internalVar->flags &= ~CVAR_MODIFIED; }

 const char * GetString( void ) const { return internalVar->value; }
 bool GetBool( void ) const { return ( internalVar->integerValue != 0 ); }
 int GetInteger( void ) const { return internalVar->integerValue; }
 float GetFloat( void ) const { return internalVar->floatValue; }

 void SetString( const char *value ) { internalVar->InternalSetString( value ); }
 void SetBool( const bool value ) { internalVar->InternalSetBool( value ); }
 void SetInteger( const int value ) { internalVar->InternalSetInteger( value ); }
 void SetFloat( const float value ) { internalVar->InternalSetFloat( value ); }

 void SetInternalVar( idCVar *cvar ) { internalVar = cvar; }

 static void RegisterStaticVars( void );

protected:
 const char * name;
 const char * value;
 const char * description;
 int flags;
 float valueMin;
 float valueMax;
 const char ** valueStrings;
 argCompletion_t valueCompletion;
 int integerValue;
 float floatValue;
 idCVar * internalVar;
 idCVar * next;

private:
 void Init( const char *name, const char *value, int flags, const char *description,
         float valueMin, float valueMax, const char **valueStrings, argCompletion_t valueCompletion );

 virtual void InternalSetString( const char *newValue ) {}
 virtual void InternalSetBool( const bool newValue ) {}
 virtual void InternalSetInteger( const int newValue ) {}
 virtual void InternalSetFloat( const float newValue ) {}

 static idCVar * staticVars;
};

inline idCVar::idCVar( const char *name, const char *value, int flags, const char *description,
       argCompletion_t valueCompletion ) {
 if ( !valueCompletion && ( flags & CVAR_BOOL ) ) {
  valueCompletion = idCmdSystem::ArgCompletion_Boolean;
 }
 Init( name, value, flags, description, 1, -1, __null, valueCompletion );
}

inline idCVar::idCVar( const char *name, const char *value, int flags, const char *description,
       float valueMin, float valueMax, argCompletion_t valueCompletion ) {
 Init( name, value, flags, description, valueMin, valueMax, __null, valueCompletion );
}

inline idCVar::idCVar( const char *name, const char *value, int flags, const char *description,
       const char **valueStrings, argCompletion_t valueCompletion ) {
 Init( name, value, flags, description, 1, -1, valueStrings, valueCompletion );
}
# 208 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/CVarSystem.h"
class idCVarSystem {
public:
 virtual ~idCVarSystem( void ) {}

 virtual void Init( void ) = 0;
 virtual void Shutdown( void ) = 0;
 virtual bool IsInitialized( void ) const = 0;


 virtual void Register( idCVar *cvar ) = 0;



 virtual idCVar * Find( const char *name ) = 0;


 virtual void SetCVarString( const char *name, const char *value, int flags = 0 ) = 0;
 virtual void SetCVarBool( const char *name, const bool value, int flags = 0 ) = 0;
 virtual void SetCVarInteger( const char *name, const int value, int flags = 0 ) = 0;
 virtual void SetCVarFloat( const char *name, const float value, int flags = 0 ) = 0;


 virtual const char * GetCVarString( const char *name ) const = 0;
 virtual bool GetCVarBool( const char *name ) const = 0;
 virtual int GetCVarInteger( const char *name ) const = 0;
 virtual float GetCVarFloat( const char *name ) const = 0;



 virtual bool Command( const idCmdArgs &args ) = 0;


 virtual void CommandCompletion( void(*callback)( const char *s ) ) = 0;
 virtual void ArgCompletion( const char *cmdString, void(*callback)( const char *s ) ) = 0;


 virtual void SetModifiedFlags( int flags ) = 0;
 virtual int GetModifiedFlags( void ) const = 0;
 virtual void ClearModifiedFlags( int flags ) = 0;


 virtual void ResetFlaggedVariables( int flags ) = 0;


 virtual void RemoveFlaggedAutoCompletion( int flags ) = 0;


 virtual void WriteFlaggedVariables( int flags, const char *setCmd, idFile *f ) const = 0;


 virtual const idDict * MoveCVarsToDict( int flags ) const = 0;
 virtual void SetCVarsFromDict( const idDict &dict ) = 0;
};

extern idCVarSystem * cvarSystem;
# 278 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/CVarSystem.h"
inline void idCVar::Init( const char *name, const char *value, int flags, const char *description,
       float valueMin, float valueMax, const char **valueStrings, argCompletion_t valueCompletion ) {
 this->name = name;
 this->value = value;
 this->flags = flags;
 this->description = description;
 this->flags = flags | CVAR_STATIC;
 this->valueMin = valueMin;
 this->valueMax = valueMax;
 this->valueStrings = valueStrings;
 this->valueCompletion = valueCompletion;
 this->integerValue = 0;
 this->floatValue = 0.0f;
 this->internalVar = this;
 if ( staticVars != (idCVar *)0xFFFFFFFF ) {
  this->next = staticVars;
  staticVars = this;
 } else {
  cvarSystem->Register( this );
 }
}

inline void idCVar::RegisterStaticVars( void ) {
 if ( staticVars != (idCVar *)0xFFFFFFFF ) {
  for ( idCVar *cvar = staticVars; cvar; cvar = cvar->next ) {
   cvarSystem->Register( cvar );
  }
  staticVars = (idCVar *)0xFFFFFFFF;
 }
}
# 121 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Common.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Common.h"
typedef enum {
 EDITOR_NONE = 0,
 EDITOR_RADIANT = ( 1 << ( 1 ) ),
 EDITOR_GUI = ( 1 << ( 2 ) ),
 EDITOR_DEBUGGER = ( 1 << ( 3 ) ),
 EDITOR_SCRIPT = ( 1 << ( 4 ) ),
 EDITOR_LIGHT = ( 1 << ( 5 ) ),
 EDITOR_SOUND = ( 1 << ( 6 ) ),
 EDITOR_DECL = ( 1 << ( 7 ) ),
 EDITOR_AF = ( 1 << ( 8 ) ),
 EDITOR_PARTICLE = ( 1 << ( 9 ) ),
 EDITOR_PDA = ( 1 << ( 10 ) ),
 EDITOR_AAS = ( 1 << ( 11 ) ),
 EDITOR_MATERIAL = ( 1 << ( 12 ) )
} toolFlag_t;




extern idCVar com_version;
extern idCVar com_skipRenderer;
extern idCVar com_asyncInput;
extern idCVar com_asyncSound;
extern idCVar com_machineSpec;
extern idCVar com_purgeAll;
extern idCVar com_developer;
extern idCVar com_allowConsole;
extern idCVar com_speeds;
extern idCVar com_showFPS;
extern idCVar com_showMemoryUsage;
extern idCVar com_showAsyncStats;
extern idCVar com_showSoundDecoders;
extern idCVar com_makingBuild;
extern idCVar com_updateLoadSize;
extern idCVar com_videoRam;

extern int time_gameFrame;
extern int time_gameDraw;
extern int time_frontend;
extern int time_backend;

extern int com_frameTime;
extern volatile int com_ticNumber;
extern int com_editors;
extern bool com_editorActive;
# 93 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Common.h"
struct MemInfo_t {
 idStr filebase;

 int total;
 int assetTotals;


 int memoryManagerTotal;


 int gameSubsystemTotal;
 int renderSubsystemTotal;


 int imageAssetsTotal;
 int modelAssetsTotal;
 int soundAssetsTotal;
};

class idCommon {
public:
 virtual ~idCommon( void ) {}




 virtual void Init( int argc, const char **argv, const char *cmdline ) = 0;


 virtual void Shutdown( void ) = 0;


 virtual void Quit( void ) = 0;


 virtual bool IsInitialized( void ) const = 0;


 virtual void Frame( void ) = 0;


 virtual void GUIFrame( bool execCmd, bool network ) = 0;



 virtual void Async( void ) = 0;





 virtual void StartupVariable( const char *match, bool once ) = 0;


 virtual void InitTool( const toolFlag_t tool, const idDict *dict ) = 0;


 virtual void ActivateTool( bool active ) = 0;


 virtual void WriteConfigToFile( const char *filename ) = 0;


 virtual void WriteFlaggedCVarsToFile( const char *filename, int flags, const char *setCmd ) = 0;


 virtual void BeginRedirect( char *buffer, int buffersize, void (*flush)( const char * ) ) = 0;


 virtual void EndRedirect( void ) = 0;


 virtual void SetRefreshOnPrint( bool set ) = 0;


 virtual void Printf( const char *fmt, ... )__attribute__((format(printf,2,3))) = 0;


 virtual void VPrintf( const char *fmt, va_list arg ) = 0;



 virtual void DPrintf( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;


 virtual void Warning( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;


 virtual void DWarning( const char *fmt, ...) __attribute__((format(printf,2,3))) = 0;


 virtual void PrintWarnings( void ) = 0;


 virtual void ClearWarnings( const char *reason ) = 0;



 virtual void Error( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;



 virtual void FatalError( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;


 virtual const idLangDict * GetLanguageDict( void ) = 0;


 virtual const char * KeysFromBinding( const char *bind ) = 0;


 virtual const char * BindingFromKey( const char *key ) = 0;


 virtual int ButtonState( int key ) = 0;


 virtual int KeyState( int key ) = 0;
};

extern idCommon * common;
# 122 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/File.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/File.h"
typedef enum {
 FS_SEEK_CUR,
 FS_SEEK_END,
 FS_SEEK_SET
} fsOrigin_t;

typedef enum {
 FILETYPE_INZIP,
 FILETYPE_BITMSG,
 FILETYPE_MEMORY,
 FILETYPE_PERMANENT,
 FILETYPE_WHATEVER
} idFileType_t;

class idFileSystemLocal;


class idFile {
public:
 virtual ~idFile( void ) {};


 virtual idFileType_t GetFileType(void) { return FILETYPE_WHATEVER; };

 virtual const char * GetName( void );

 virtual const char * GetFullPath( void );

 virtual int Read( void *buffer, int len );

 virtual int Write( const void *buffer, int len );

 virtual int Length( void );

 virtual time_t Timestamp( void );

 virtual int Tell( void );

 virtual void ForceFlush( void );

 virtual void Flush( void );

 virtual int Seek( long offset, fsOrigin_t origin );

 virtual void Rewind( void );

 virtual int Printf( const char *fmt, ... ) __attribute__((format(printf,2,3)));

 virtual int VPrintf( const char *fmt, va_list arg );

 virtual int WriteFloatString( const char *fmt, ... ) __attribute__((format(printf,2,3)));


 virtual int ReadInt( int &value );
 virtual int ReadUnsignedInt( unsigned int &value );
 virtual int ReadShort( short &value );
 virtual int ReadUnsignedShort( unsigned short &value );
 virtual int ReadChar( char &value );
 virtual int ReadUnsignedChar( unsigned char &value );
 virtual int ReadFloat( float &value );
 virtual int ReadBool( bool &value );
 virtual int ReadString( idStr &string );
 virtual int ReadVec2( idVec2 &vec );
 virtual int ReadVec3( idVec3 &vec );
 virtual int ReadVec4( idVec4 &vec );
 virtual int ReadVec6( idVec6 &vec );
 virtual int ReadMat3( idMat3 &mat );


 virtual int WriteInt( const int value );
 virtual int WriteUnsignedInt( const unsigned int value );
 virtual int WriteShort( const short value );
 virtual int WriteUnsignedShort( unsigned short value );
 virtual int WriteChar( const char value );
 virtual int WriteUnsignedChar( const unsigned char value );
 virtual int WriteFloat( const float value );
 virtual int WriteBool( const bool value );
 virtual int WriteString( const char *string );
 virtual int WriteVec2( const idVec2 &vec );
 virtual int WriteVec3( const idVec3 &vec );
 virtual int WriteVec4( const idVec4 &vec );
 virtual int WriteVec6( const idVec6 &vec );
 virtual int WriteMat3( const idMat3 &mat );
};


class idFile_Memory : public idFile {
 friend class idFileSystemLocal;

public:
       idFile_Memory( void );
       idFile_Memory( const char *name );
       idFile_Memory( const char *name, char *data, int length );
       idFile_Memory( const char *name, const char *data, int length );
 virtual ~idFile_Memory( void );

 virtual const char * GetName( void ) { return name.c_str(); }
 virtual const char * GetFullPath( void ) { return name.c_str(); }
 virtual int Read( void *buffer, int len );
 virtual int Write( const void *buffer, int len );
 virtual int Length( void );
 virtual time_t Timestamp( void );
 virtual int Tell( void );
 virtual void ForceFlush( void );
 virtual void Flush( void );
 virtual int Seek( long offset, fsOrigin_t origin );


 virtual void MakeReadOnly( void );

 virtual void Clear( bool freeMemory = true );

 idFileType_t GetFileType(void);

 void SetData( const char *data, int length );

 const char * GetDataPtr( void ) const { return filePtr; }

 void SetGranularity( int g ) { ((void)0); granularity = g; }

private:
 idStr name;
 int mode;
 int maxSize;
 int fileSize;
 int allocated;
 int granularity;
 char * filePtr;
 char * curPtr;
};


class idFile_BitMsg : public idFile {
 friend class idFileSystemLocal;

public:
       idFile_BitMsg( idBitMsg &msg );
       idFile_BitMsg( const idBitMsg &msg );
 virtual ~idFile_BitMsg( void );

 virtual const char * GetName( void ) { return name.c_str(); }
 virtual const char * GetFullPath( void ) { return name.c_str(); }
 virtual int Read( void *buffer, int len );
 virtual int Write( const void *buffer, int len );
 virtual int Length( void );
 virtual time_t Timestamp( void );
 virtual int Tell( void );
 virtual void ForceFlush( void );
 virtual void Flush( void );
 virtual int Seek( long offset, fsOrigin_t origin );
 idFileType_t GetFileType(void);

private:
 idStr name;
 int mode;
 idBitMsg * msg;
};


class idFile_Permanent : public idFile {
 friend class idFileSystemLocal;

public:
       idFile_Permanent( void );
 virtual ~idFile_Permanent( void );

 virtual const char * GetName( void ) { return name.c_str(); }
 virtual const char * GetFullPath( void ) { return fullPath.c_str(); }
 virtual int Read( void *buffer, int len );
 virtual int Write( const void *buffer, int len );
 virtual int Length( void );
 virtual time_t Timestamp( void );
 virtual int Tell( void );
 virtual void ForceFlush( void );
 virtual void Flush( void );
 virtual int Seek( long offset, fsOrigin_t origin );

 idFileType_t GetFileType(void);

 FILE * GetFilePtr( void ) { return o; }

private:
 idStr name;
 idStr fullPath;
 int mode;
 int fileSize;
 FILE * o;
 bool handleSync;
};


class idFile_InZip : public idFile {
 friend class idFileSystemLocal;

public:
       idFile_InZip( void );
 virtual ~idFile_InZip( void );

 virtual const char * GetName( void ) { return name.c_str(); }
 virtual const char * GetFullPath( void ) { return fullPath.c_str(); }
 virtual int Read( void *buffer, int len );
 virtual int Write( const void *buffer, int len );
 virtual int Length( void );
 virtual time_t Timestamp( void );
 virtual int Tell( void );
 virtual void ForceFlush( void );
 virtual void Flush( void );
 virtual int Seek( long offset, fsOrigin_t origin );
 idFileType_t GetFileType(void);

private:
 idStr name;
 idStr fullPath;
 int zipFilePos;
 int fileSize;
 void * z;
};
# 123 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/FileSystem.h" 1
# 55 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/FileSystem.h"
static const time_t FILE_NOT_FOUND_TIMESTAMP = 0xFFFFFFFF;
static const int MAX_PURE_PAKS = 128;
static const int MAX_OSPATH = 256;


typedef enum {
 FS_READ = 0,
 FS_WRITE = 1,
 FS_APPEND = 2
} fsMode_t;

typedef enum {
 PURE_OK,
 PURE_RESTART,
 PURE_MISSING,
 PURE_NODLL
} fsPureReply_t;

typedef enum {
 DLTYPE_URL,
 DLTYPE_FILE
} dlType_t;

typedef enum {
 DL_WAIT,
 DL_INPROGRESS,
 DL_DONE,
 DL_ABORTING,
 DL_FAILED
} dlStatus_t;

typedef enum {
 FILE_EXEC,
 FILE_OPEN
} dlMime_t;

typedef enum {
 FIND_NO,
 FIND_YES,
 FIND_ADDON
} findFile_t;

typedef struct urlDownload_s {
 idStr url;
 char dlerror[ 1024 ];
 int dltotal;
 int dlnow;
 int dlstatus;
 dlStatus_t status;
} urlDownload_t;

typedef struct fileDownload_s {
 int position;
 int length;
 void * buffer;
} fileDownload_t;

typedef struct backgroundDownload_s {
 struct backgroundDownload_s *next;
 dlType_t opcode;
 idFile * f;
 fileDownload_t file;
 urlDownload_t url;
 volatile bool completed;
} backgroundDownload_t;


class idFileList {
 friend class idFileSystemLocal;
public:
 const char * GetBasePath( void ) const { return basePath; }
 int GetNumFiles( void ) const { return list.Num(); }
 const char * GetFile( int index ) const { return list[index]; }
 const idStrList & GetList( void ) const { return list; }

private:
 idStr basePath;
 idStrList list;
};


class idModList {
 friend class idFileSystemLocal;
public:
 int GetNumMods( void ) const { return mods.Num(); }
 const char * GetMod( int index ) const { return mods[index]; }
 const char * GetDescription( int index ) const { return descriptions[index]; }

private:
 idStrList mods;
 idStrList descriptions;
};

class idFileSystem {
public:
 virtual ~idFileSystem() {}

 virtual void Init( void ) = 0;

 virtual void Restart( void ) = 0;

 virtual void Shutdown( bool reloading ) = 0;

 virtual bool IsInitialized( void ) const = 0;

 virtual bool PerformingCopyFiles( void ) const = 0;



 virtual idModList * ListMods( void ) = 0;

 virtual void FreeModList( idModList *modList ) = 0;





 virtual idFileList * ListFiles( const char *relativePath, const char *extension, bool sort = false, bool fullRelativePath = false, const char* gamedir = __null ) = 0;




 virtual idFileList * ListFilesTree( const char *relativePath, const char *extension, bool sort = false, const char* gamedir = __null ) = 0;

 virtual void FreeFileList( idFileList *fileList ) = 0;

 virtual const char * OSPathToRelativePath( const char *OSPath ) = 0;

 virtual const char * RelativePathToOSPath( const char *relativePath, const char *basePath = "fs_devpath" ) = 0;

 virtual const char * BuildOSPath( const char *base, const char *game, const char *relativePath ) = 0;

 virtual void CreateOSPath( const char *OSPath ) = 0;

 virtual bool FileIsInPAK( const char *relativePath ) = 0;


 virtual void UpdatePureServerChecksums( void ) = 0;

 virtual bool UpdateGamePakChecksums( void ) = 0;







 virtual fsPureReply_t SetPureServerChecksums( const int pureChecksums[ MAX_PURE_PAKS ], int gamePakChecksum, int missingChecksums[ MAX_PURE_PAKS ], int *missingGamePakChecksum ) = 0;


 virtual void GetPureServerChecksums( int checksums[ MAX_PURE_PAKS ], int OS, int *gamePakChecksum ) = 0;


 virtual void SetRestartChecksums( const int pureChecksums[ MAX_PURE_PAKS ], int gamePakChecksum ) = 0;

 virtual void ClearPureChecksums( void ) = 0;

 virtual int GetOSMask( void ) = 0;







 virtual int ReadFile( const char *relativePath, void **buffer, time_t *timestamp = __null ) = 0;

 virtual void FreeFile( void *buffer ) = 0;


 virtual int WriteFile( const char *relativePath, const void *buffer, int size, const char *basePath = "fs_savepath" ) = 0;

 virtual void RemoveFile( const char *relativePath ) = 0;

 virtual idFile * OpenFileRead( const char *relativePath, bool allowCopyFiles = true, const char* gamedir = __null ) = 0;

 virtual idFile * OpenFileWrite( const char *relativePath, const char *basePath = "fs_savepath" ) = 0;

 virtual idFile * OpenFileAppend( const char *filename, bool sync = false, const char *basePath = "fs_basepath" ) = 0;

 virtual idFile * OpenFileByMode( const char *relativePath, fsMode_t mode ) = 0;

 virtual idFile * OpenExplicitFileRead( const char *OSPath ) = 0;

 virtual idFile * OpenExplicitFileWrite( const char *OSPath ) = 0;

 virtual void CloseFile( idFile *f ) = 0;

 virtual void BackgroundDownload( backgroundDownload_t *bgl ) = 0;

 virtual void ResetReadCount( void ) = 0;

 virtual int GetReadCount( void ) = 0;

 virtual void AddToReadCount( int c ) = 0;

 virtual void FindDLL( const char *basename, char dllPath[ MAX_OSPATH ], bool updateChecksum ) = 0;



 virtual void ClearDirCache( void ) = 0;


 virtual bool HasD3XP( void ) = 0;

 virtual bool RunningD3XP( void ) = 0;


 virtual void CopyFile( const char *fromOSPath, const char *toOSPath ) = 0;


 virtual int ValidateDownloadPakForChecksum( int checksum, char path[ 1024 ], bool isGamePak ) = 0;

 virtual idFile * MakeTemporaryFile( void ) = 0;


 virtual int AddZipFile( const char *path ) = 0;



 virtual findFile_t FindFile( const char *path, bool scheduleAddons = false ) = 0;



 virtual int GetNumMaps() = 0;
 virtual const idDict * GetMapDecl( int i ) = 0;
 virtual void FindMapScreenshot( const char *path, char *buf, int len ) = 0;


 virtual bool FilenameCompare( const char *s1, const char *s2 ) const = 0;
};

extern idFileSystem * fileSystem;
# 124 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/UsercmdGen.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/UsercmdGen.h"
const int USERCMD_HZ = 60;
const int USERCMD_MSEC = 1000 / USERCMD_HZ;


const int BUTTON_ATTACK = ( 1 << ( 0 ) );
const int BUTTON_RUN = ( 1 << ( 1 ) );
const int BUTTON_ZOOM = ( 1 << ( 2 ) );
const int BUTTON_SCORES = ( 1 << ( 3 ) );
const int BUTTON_MLOOK = ( 1 << ( 4 ) );
const int BUTTON_5 = ( 1 << ( 5 ) );
const int BUTTON_6 = ( 1 << ( 6 ) );
const int BUTTON_7 = ( 1 << ( 7 ) );


const int IMPULSE_0 = 0;
const int IMPULSE_1 = 1;
const int IMPULSE_2 = 2;
const int IMPULSE_3 = 3;
const int IMPULSE_4 = 4;
const int IMPULSE_5 = 5;
const int IMPULSE_6 = 6;
const int IMPULSE_7 = 7;
const int IMPULSE_8 = 8;
const int IMPULSE_9 = 9;
const int IMPULSE_10 = 10;
const int IMPULSE_11 = 11;
const int IMPULSE_12 = 12;
const int IMPULSE_13 = 13;
const int IMPULSE_14 = 14;
const int IMPULSE_15 = 15;
const int IMPULSE_16 = 16;
const int IMPULSE_17 = 17;
const int IMPULSE_18 = 18;
const int IMPULSE_19 = 19;
const int IMPULSE_20 = 20;
const int IMPULSE_21 = 21;
const int IMPULSE_22 = 22;
const int IMPULSE_23 = 23;
const int IMPULSE_24 = 24;
const int IMPULSE_25 = 25;
const int IMPULSE_26 = 26;
const int IMPULSE_27 = 27;
const int IMPULSE_28 = 28;
const int IMPULSE_29 = 29;
const int IMPULSE_40 = 40;


const int UCF_IMPULSE_SEQUENCE = 0x0001;

class usercmd_t {
public:
 int gameFrame;
 int gameTime;
 int duplicateCount;
 byte buttons;
 signed char forwardmove;
 signed char rightmove;
 signed char upmove;
 short angles[3];
 short mx;
 short my;
 signed char impulse;
 byte flags;
 int sequence;

public:
 void ByteSwap();
 bool operator==( const usercmd_t &rhs ) const;
};

typedef enum {
 INHIBIT_SESSION = 0,
 INHIBIT_ASYNC
} inhibit_t;

const int MAX_BUFFERED_USERCMD = 64;

class idUsercmdGen {
public:
 virtual ~idUsercmdGen( void ) {}


 virtual void Init( void ) = 0;


 virtual void InitForNewMap( void ) = 0;


 virtual void Shutdown( void ) = 0;


 virtual void Clear( void ) = 0;


 virtual void ClearAngles( void ) = 0;



 virtual void InhibitUsercmd( inhibit_t subsystem, bool inhibit ) = 0;


 virtual usercmd_t TicCmd( int ticNumber ) = 0;


 virtual void UsercmdInterrupt( void ) = 0;


 virtual int CommandStringUsercmdData( const char *cmdString ) = 0;


 virtual int GetNumUserCommands( void ) = 0;


 virtual const char *GetUserCommandName( int index ) = 0;


 virtual void MouseState( int *x, int *y, int *button, bool *down ) = 0;


 virtual int ButtonState( int key ) = 0;


 virtual int KeyState( int key ) = 0;


 virtual usercmd_t GetDirectUsercmd( void ) = 0;
};

extern idUsercmdGen *usercmdGen;
# 125 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclManager.h" 1
# 65 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclManager.h"
typedef enum {
 DECL_TABLE = 0,
 DECL_MATERIAL,
 DECL_SKIN,
 DECL_SOUND,
 DECL_ENTITYDEF,
 DECL_MODELDEF,
 DECL_FX,
 DECL_PARTICLE,
 DECL_AF,
 DECL_PDA,
 DECL_VIDEO,
 DECL_AUDIO,
 DECL_EMAIL,
 DECL_MODELEXPORT,
 DECL_MAPDEF,



 DECL_MAX_TYPES = 32
} declType_t;

typedef enum {
 DS_UNPARSED,
 DS_DEFAULTED,
 DS_PARSED
} declState_t;

const int DECL_LEXER_FLAGS = LEXFL_NOSTRINGCONCAT |
        LEXFL_NOSTRINGESCAPECHARS |
        LEXFL_ALLOWPATHNAMES |
        LEXFL_ALLOWMULTICHARLITERALS |
        LEXFL_ALLOWBACKSLASHSTRINGCONCAT |
        LEXFL_NOFATALERRORS;


class idDeclBase {
public:
 virtual ~idDeclBase() {};
 virtual const char * GetName( void ) const = 0;
 virtual declType_t GetType( void ) const = 0;
 virtual declState_t GetState( void ) const = 0;
 virtual bool IsImplicit( void ) const = 0;
 virtual bool IsValid( void ) const = 0;
 virtual void Invalidate( void ) = 0;
 virtual void Reload( void ) = 0;
 virtual void EnsureNotPurged( void ) = 0;
 virtual int Index( void ) const = 0;
 virtual int GetLineNum( void ) const = 0;
 virtual const char * GetFileName( void ) const = 0;
 virtual void GetText( char *text ) const = 0;
 virtual int GetTextLength( void ) const = 0;
 virtual void SetText( const char *text ) = 0;
 virtual bool ReplaceSourceFileText( void ) = 0;
 virtual bool SourceFileChanged( void ) const = 0;
 virtual void MakeDefault( void ) = 0;
 virtual bool EverReferenced( void ) const = 0;
 virtual bool SetDefaultText( void ) = 0;
 virtual const char * DefaultDefinition( void ) const = 0;
 virtual bool Parse( const char *text, const int textLength ) = 0;
 virtual void FreeData( void ) = 0;
 virtual size_t Size( void ) const = 0;
 virtual void List( void ) const = 0;
 virtual void Print( void ) const = 0;
};


class idDecl {
public:


       idDecl( void ) { base = __null; }
 virtual ~idDecl( void ) {};


 const char * GetName( void ) const { return base->GetName(); }


 declType_t GetType( void ) const { return base->GetType(); }


 declState_t GetState( void ) const { return base->GetState(); }


 bool IsImplicit( void ) const { return base->IsImplicit(); }




 bool IsValid( void ) const { return base->IsValid(); }



 void Invalidate( void ) { base->Invalidate(); }



 void EnsureNotPurged( void ) { base->EnsureNotPurged(); }


 int Index( void ) const { return base->Index(); }


 int GetLineNum( void ) const { return base->GetLineNum(); }


 const char * GetFileName( void ) const { return base->GetFileName(); }


 void GetText( char *text ) const { base->GetText( text ); }


 int GetTextLength( void ) const { return base->GetTextLength(); }


 void SetText( const char *text ) { base->SetText( text ); }



 bool ReplaceSourceFileText( void ) { return base->ReplaceSourceFileText(); }


 bool SourceFileChanged( void ) const { return base->SourceFileChanged(); }


 void MakeDefault( void ) { base->MakeDefault(); }


 bool EverReferenced( void ) const { return base->EverReferenced(); }

public:




 virtual bool SetDefaultText( void ) { return base->SetDefaultText(); }






 virtual const char * DefaultDefinition( void ) const { return base->DefaultDefinition(); }






 virtual bool Parse( const char *text, const int textLength ) { return base->Parse( text, textLength ); }





 virtual void FreeData( void ) { base->FreeData(); }


 virtual size_t Size( void ) const { return base->Size(); }




 virtual void List( void ) const { base->List(); }




 virtual void Print( void ) const { base->Print(); }

public:
 idDeclBase * base;
};


template< class type >
inline idDecl *idDeclAllocator( void ) {
 return new type;
}


class idMaterial;
class idDeclSkin;


class idDeclManager {
public:
 virtual ~idDeclManager( void ) {}

 virtual void Init( void ) = 0;
 virtual void Shutdown( void ) = 0;
 virtual void Reload( bool force ) = 0;

 virtual void VirtualizeAll() = 0;
 virtual void BeginLevelLoad() = 0;
 virtual void EndLevelLoad() = 0;
 virtual void SetInsideLevelLoad() = 0;


 virtual void RegisterDeclType( const char *typeName, declType_t type, idDecl *(*allocator)( void ) ) = 0;


 virtual void RegisterDeclFolder( const char *folder, const char *extension, declType_t defaultType ) = 0;


 virtual int GetChecksum( void ) const = 0;


 virtual int GetNumDeclTypes( void ) const = 0;


 virtual const char * GetDeclNameFromType( declType_t type ) const = 0;


 virtual declType_t GetDeclTypeFromName( const char *typeName ) const = 0;




 virtual const idDecl * FindType( declType_t type, const char *name, bool makeDefault = true, bool keep = false ) = 0;

 virtual const idDecl* FindDeclWithoutParsing( declType_t type, const char *name, bool makeDefault = true ) = 0;

 virtual void ReloadFile( const char* filename, bool force ) = 0;


 virtual int GetNumDecls( declType_t type ) = 0;




 virtual const idDecl * DeclByIndex( declType_t type, int index, bool forceParse = true ) = 0;


 virtual void ListType( const idCmdArgs &args, declType_t type ) = 0;
 virtual void PrintType( const idCmdArgs &args, declType_t type ) = 0;



 virtual idDecl * CreateNewDecl( declType_t type, const char *name, const char *fileName ) = 0;


 virtual bool RenameDecl( declType_t type, const char* oldName, const char* newName ) = 0;



 virtual void MediaPrint( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;

 virtual void WritePrecacheCommands( idFile *f ) = 0;


 virtual const idMaterial * FindMaterial( const char *name, bool makeDefault = true, bool keep = false ) = 0;


 virtual const idDeclSkin * FindSkin( const char *name, bool makeDefault = true ) = 0;


 virtual const idMaterial * MaterialByIndex( int index, bool forceParse = true ) = 0;
 virtual const idDeclSkin * SkinByIndex( int index, bool forceParse = true ) = 0;


};

extern idDeclManager * declManager;


template< declType_t type >
inline void idListDecls_f( const idCmdArgs &args ) {
 declManager->ListType( args, type );
}

template< declType_t type >
inline void idPrintDecls_f( const idCmdArgs &args ) {
 declManager->PrintType( args, type );
}
# 128 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclTable.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclTable.h"
class idDeclTable : public idDecl {
public:
 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 float TableLookup( float index ) const;

private:
 bool clamp;
 bool snap;
 idList<float> values;
};
# 129 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclSkin.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclSkin.h"
typedef struct {
 const idMaterial * from;
 const idMaterial * to;
} skinMapping_t;

class idDeclSkin : public idDecl {
public:
 virtual size_t Size( void ) const;
 virtual bool SetDefaultText( void );
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 const idMaterial * RemapShaderBySkin( const idMaterial *shader ) const;


 const int GetNumModelAssociations() const;
 const char * GetAssociatedModel( int index ) const;

private:
 idList<skinMapping_t> mappings;
 idStrList associatedModels;
};
# 130 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclEntityDef.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclEntityDef.h"
class idDeclEntityDef : public idDecl {
public:
 idDict dict;

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition() const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void );
};
# 131 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclFX.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclFX.h"
enum {
 FX_LIGHT,
 FX_PARTICLE,
 FX_DECAL,
 FX_MODEL,
 FX_SOUND,
 FX_SHAKE,
 FX_ATTACHLIGHT,
 FX_ATTACHENTITY,
 FX_LAUNCH,
 FX_SHOCKWAVE
};




typedef struct {
 int type;
 int sibling;

 idStr data;
 idStr name;
 idStr fire;

 float delay;
 float duration;
 float restart;
 float size;
 float fadeInTime;
 float fadeOutTime;
 float shakeTime;
 float shakeAmplitude;
 float shakeDistance;
 float shakeImpulse;
 float lightRadius;
 float rotate;
 float random1;
 float random2;

 idVec3 lightColor;
 idVec3 offset;
 idMat3 axis;

 bool soundStarted;
 bool shakeStarted;
 bool shakeFalloff;
 bool shakeIgnoreMaster;
 bool bindParticles;
 bool explicitAxis;
 bool noshadows;
 bool particleTrackVelocity;
 bool trackOrigin;
} idFXSingleAction;




class idDeclFX : public idDecl {
public:
 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 idList<idFXSingleAction>events;
 idStr joint;

private:
 void ParseSingleFXAction( idLexer &src, idFXSingleAction& FXAction );
};
# 132 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclParticle.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclParticle.h"
class idParticleParm {
public:
       idParticleParm( void ) { table = __null; from = to = 0.0f; }

 const idDeclTable * table;
 float from;
 float to;

 float Eval( float frac, idRandom &rand ) const;
 float Integrate( float frac, idRandom &rand ) const;
};


typedef enum {
 PDIST_RECT,
 PDIST_CYLINDER,
 PDIST_SPHERE


} prtDistribution_t;

typedef enum {
 PDIR_CONE,
 PDIR_OUTWARD
} prtDirection_t;

typedef enum {
 PPATH_STANDARD,
 PPATH_HELIX,
 PPATH_FLIES,
 PPATH_ORBIT,
 PPATH_DRIP
} prtCustomPth_t;

typedef enum {
 POR_VIEW,
 POR_AIMED,
 POR_X,
 POR_Y,
 POR_Z
} prtOrientation_t;

typedef struct renderEntity_s renderEntity_t;
typedef struct renderView_s renderView_t;

typedef struct {
 const renderEntity_t * renderEnt;
 const renderView_t * renderView;
 int index;
 float frac;
 idRandom random;
 idVec3 origin;
 idMat3 axis;


 float age;
 idRandom originalRandom;
 float animationFrameFrac;
} particleGen_t;





class idParticleStage {
public:
       idParticleStage( void );
 virtual ~idParticleStage( void ) {}

 void Default();
 virtual int NumQuadsPerParticle() const;

 virtual int CreateParticle( particleGen_t *g, idDrawVert *verts ) const;

 void ParticleOrigin( particleGen_t *g, idVec3 &origin ) const;
 int ParticleVerts( particleGen_t *g, const idVec3 origin, idDrawVert *verts ) const;
 void ParticleTexCoords( particleGen_t *g, idDrawVert *verts ) const;
 void ParticleColors( particleGen_t *g, idDrawVert *verts ) const;

 const char * GetCustomPathName();
 const char * GetCustomPathDesc();
 int NumCustomPathParms();
 void SetCustomPathType( const char *p );
 void operator=( const idParticleStage &src );




 const idMaterial * material;

 int totalParticles;
 float cycles;


 int cycleMsec;

 float spawnBunching;
 float particleLife;
 float timeOffset;
 float deadTime;



 prtDistribution_t distributionType;
 float distributionParms[4];

 prtDirection_t directionType;
 float directionParms[4];

 idParticleParm speed;
 float gravity;
 bool worldGravity;
 bool randomDistribution;
 bool entityColor;



 prtCustomPth_t customPathType;
 float customPathParms[8];



 idVec3 offset;

 int animationFrames;
 float animationRate;

 float initialAngle;
 idParticleParm rotationSpeed;

 prtOrientation_t orientation;
 float orientationParms[4];

 idParticleParm size;
 idParticleParm aspect;

 idVec4 color;
 idVec4 fadeColor;
 float fadeInFraction;
 float fadeOutFraction;
 float fadeIndexFraction;

 bool hidden;


 float boundsExpansion;

 idBounds bounds;
};





class idDeclParticle : public idDecl {
public:

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 bool Save( const char *fileName = __null );

 idList<idParticleStage *>stages;
 idBounds bounds;
 float depthHack;

private:
 bool RebuildTextSource( void );
 void GetStageBounds( idParticleStage *stage );
 idParticleStage * ParseParticleStage( idLexer &src );
 void ParseParms( idLexer &src, float *parms, int maxParms );
 void ParseParametric( idLexer &src, idParticleParm *parm );
 void WriteStage( idFile *f, idParticleStage *stage );
 void WriteParticleParm( idFile *f, idParticleParm *parm, const char *name );
};
# 133 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclAF.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclAF.h"
class idDeclAF;

typedef enum {
 DECLAF_CONSTRAINT_INVALID,
 DECLAF_CONSTRAINT_FIXED,
 DECLAF_CONSTRAINT_BALLANDSOCKETJOINT,
 DECLAF_CONSTRAINT_UNIVERSALJOINT,
 DECLAF_CONSTRAINT_HINGE,
 DECLAF_CONSTRAINT_SLIDER,
 DECLAF_CONSTRAINT_SPRING
} declAFConstraintType_t;

typedef enum {
 DECLAF_JOINTMOD_AXIS,
 DECLAF_JOINTMOD_ORIGIN,
 DECLAF_JOINTMOD_BOTH
} declAFJointMod_t;

typedef bool (*getJointTransform_t)( void *model, const idJointMat *frame, const char *jointName, idVec3 &origin, idMat3 &axis );

class idAFVector {
public:
 enum {
  VEC_COORDS = 0,
  VEC_JOINT,
  VEC_BONECENTER,
  VEC_BONEDIR
 } type;
 idStr joint1;
 idStr joint2;

public:
       idAFVector( void );

 bool Parse( idLexer &src );
 bool Finish( const char *fileName, const getJointTransform_t GetJointTransform, const idJointMat *frame, void *model ) const;
 bool Write( idFile *f ) const;
 const char * ToString( idStr &str, const int precision = 8 );
 const idVec3 & ToVec3( void ) const { return vec; }
 idVec3 & ToVec3( void ) { return vec; }

private:
 mutable idVec3 vec;
 bool negate;
};

class idDeclAF_Body {
public:
 idStr name;
 idStr jointName;
 declAFJointMod_t jointMod;
 int modelType;
 idAFVector v1, v2;
 int numSides;
 float width;
 float density;
 idAFVector origin;
 idAngles angles;
 int contents;
 int clipMask;
 bool selfCollision;
 idMat3 inertiaScale;
 float linearFriction;
 float angularFriction;
 float contactFriction;
 idStr containedJoints;
 idAFVector frictionDirection;
 idAFVector contactMotorDirection;
public:
 void SetDefault( const idDeclAF *file );
};

class idDeclAF_Constraint {
public:
 idStr name;
 idStr body1;
 idStr body2;
 declAFConstraintType_t type;
 float friction;
 float stretch;
 float compress;
 float damping;
 float restLength;
 float minLength;
 float maxLength;
 idAFVector anchor;
 idAFVector anchor2;
 idAFVector shaft[2];
 idAFVector axis;
 enum {
  LIMIT_NONE = -1,
  LIMIT_CONE,
  LIMIT_PYRAMID
 } limit;
 idAFVector limitAxis;
 float limitAngles[3];

public:
 void SetDefault( const idDeclAF *file );
};

class idDeclAF : public idDecl {
 friend class idAFFileManager;
public:
       idDeclAF( void );
 virtual ~idDeclAF( void );

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 virtual void Finish( const getJointTransform_t GetJointTransform, const idJointMat *frame, void *model ) const;

 bool Save( void );

 void NewBody( const char *name );
 void RenameBody( const char *oldName, const char *newName );
 void DeleteBody( const char *name );

 void NewConstraint( const char *name );
 void RenameConstraint( const char *oldName, const char *newName );
 void DeleteConstraint( const char *name );

 static int ContentsFromString( const char *str );
 static const char * ContentsToString( const int contents, idStr &str );

 static declAFJointMod_t JointModFromString( const char *str );
 static const char * JointModToString( declAFJointMod_t jointMod );

public:
 bool modified;
 idStr model;
 idStr skin;
 float defaultLinearFriction;
 float defaultAngularFriction;
 float defaultContactFriction;
 float defaultConstraintFriction;
 float totalMass;
 idVec2 suspendVelocity;
 idVec2 suspendAcceleration;
 float noMoveTime;
 float noMoveTranslation;
 float noMoveRotation;
 float minMoveTime;
 float maxMoveTime;
 int contents;
 int clipMask;
 bool selfCollision;
 idList<idDeclAF_Body *> bodies;
 idList<idDeclAF_Constraint *> constraints;

private:
 bool ParseContents( idLexer &src, int &c ) const;
 bool ParseBody( idLexer &src );
 bool ParseFixed( idLexer &src );
 bool ParseBallAndSocketJoint( idLexer &src );
 bool ParseUniversalJoint( idLexer &src );
 bool ParseHinge( idLexer &src );
 bool ParseSlider( idLexer &src );
 bool ParseSpring( idLexer &src );
 bool ParseSettings( idLexer &src );

 bool WriteBody( idFile *f, const idDeclAF_Body &body ) const;
 bool WriteFixed( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteBallAndSocketJoint( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteUniversalJoint( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteHinge( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteSlider( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteSpring( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteConstraint( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteSettings( idFile *f ) const;

 bool RebuildTextSource( void );
};
# 134 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclPDA.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DeclPDA.h"
class idDeclEmail : public idDecl {
public:
       idDeclEmail() {}

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 const char * GetFrom() const { return from; }
 const char * GetBody() const { return text; }
 const char * GetSubject() const { return subject; }
 const char * GetDate() const { return date; }
 const char * GetTo() const { return to; }
 const char * GetImage() const { return image; }

private:
 idStr text;
 idStr subject;
 idStr date;
 idStr to;
 idStr from;
 idStr image;
};


class idDeclVideo : public idDecl {
public:
       idDeclVideo() {};

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 const char * GetRoq() const { return video; }
 const char * GetWave() const { return audio; }
 const char * GetVideoName() const { return videoName; }
 const char * GetInfo() const { return info; }
 const char * GetPreview() const { return preview; }

private:
 idStr preview;
 idStr video;
 idStr videoName;
 idStr info;
 idStr audio;
};


class idDeclAudio : public idDecl {
public:
       idDeclAudio() {};

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 const char * GetAudioName() const { return audioName; }
 const char * GetWave() const { return audio; }
 const char * GetInfo() const { return info; }
 const char * GetPreview() const { return preview; }

private:
 idStr audio;
 idStr audioName;
 idStr info;
 idStr preview;
};


class idDeclPDA : public idDecl {
public:
       idDeclPDA() { originalEmails = originalVideos = 0; };

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 virtual void AddVideo( const char *name, bool unique = true ) const;
 virtual void AddAudio( const char *name, bool unique = true ) const;
 virtual void AddEmail( const char *name, bool unique = true ) const;
 virtual void RemoveAddedEmailsAndVideos() const;

 virtual const int GetNumVideos() const;
 virtual const int GetNumAudios() const;
 virtual const int GetNumEmails() const;
 virtual const idDeclVideo *GetVideoByIndex( int index ) const;
 virtual const idDeclAudio *GetAudioByIndex( int index ) const;
 virtual const idDeclEmail *GetEmailByIndex( int index ) const;

 virtual void SetSecurity( const char *sec ) const;

 const char * GetPdaName() const { return pdaName; }
 const char * GetSecurity() const {return security; }
 const char * GetFullName() const { return fullName; }
 const char * GetIcon() const { return icon; }
 const char * GetPost() const { return post; }
 const char * GetID() const { return id; }
 const char * GetTitle() const { return title; }

private:
 mutable idStrList videos;
 mutable idStrList audios;
 mutable idStrList emails;
 idStr pdaName;
 idStr fullName;
 idStr icon;
 idStr id;
 idStr post;
 idStr title;
 mutable idStr security;
 mutable int originalEmails;
 mutable int originalVideos;
};
# 135 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 143 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h"
const int MAX_EXPRESSION_OPS = 2048;
const int MAX_EXPRESSION_REGISTERS = 2048;



# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/qgl.h" 1
# 56 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/qgl.h"
# 1 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h" 1
# 133 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
extern "C" {
# 147 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef int GLsizei;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
# 774 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glClearIndex( GLfloat c );

__attribute__((visibility("default"))) void glClearColor( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha );

__attribute__((visibility("default"))) void glClear( GLbitfield mask );

__attribute__((visibility("default"))) void glIndexMask( GLuint mask );

__attribute__((visibility("default"))) void glColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha );

__attribute__((visibility("default"))) void glAlphaFunc( GLenum func, GLclampf ref );

__attribute__((visibility("default"))) void glBlendFunc( GLenum sfactor, GLenum dfactor );

__attribute__((visibility("default"))) void glLogicOp( GLenum opcode );

__attribute__((visibility("default"))) void glCullFace( GLenum mode );

__attribute__((visibility("default"))) void glFrontFace( GLenum mode );

__attribute__((visibility("default"))) void glPointSize( GLfloat size );

__attribute__((visibility("default"))) void glLineWidth( GLfloat width );

__attribute__((visibility("default"))) void glLineStipple( GLint factor, GLushort pattern );

__attribute__((visibility("default"))) void glPolygonMode( GLenum face, GLenum mode );

__attribute__((visibility("default"))) void glPolygonOffset( GLfloat factor, GLfloat units );

__attribute__((visibility("default"))) void glPolygonStipple( const GLubyte *mask );

__attribute__((visibility("default"))) void glGetPolygonStipple( GLubyte *mask );

__attribute__((visibility("default"))) void glEdgeFlag( GLboolean flag );

__attribute__((visibility("default"))) void glEdgeFlagv( const GLboolean *flag );

__attribute__((visibility("default"))) void glScissor( GLint x, GLint y, GLsizei width, GLsizei height);

__attribute__((visibility("default"))) void glClipPlane( GLenum plane, const GLdouble *equation );

__attribute__((visibility("default"))) void glGetClipPlane( GLenum plane, GLdouble *equation );

__attribute__((visibility("default"))) void glDrawBuffer( GLenum mode );

__attribute__((visibility("default"))) void glReadBuffer( GLenum mode );

__attribute__((visibility("default"))) void glEnable( GLenum cap );

__attribute__((visibility("default"))) void glDisable( GLenum cap );

__attribute__((visibility("default"))) GLboolean glIsEnabled( GLenum cap );


__attribute__((visibility("default"))) void glEnableClientState( GLenum cap );

__attribute__((visibility("default"))) void glDisableClientState( GLenum cap );


__attribute__((visibility("default"))) void glGetBooleanv( GLenum pname, GLboolean *params );

__attribute__((visibility("default"))) void glGetDoublev( GLenum pname, GLdouble *params );

__attribute__((visibility("default"))) void glGetFloatv( GLenum pname, GLfloat *params );

__attribute__((visibility("default"))) void glGetIntegerv( GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glPushAttrib( GLbitfield mask );

__attribute__((visibility("default"))) void glPopAttrib( void );


__attribute__((visibility("default"))) void glPushClientAttrib( GLbitfield mask );

__attribute__((visibility("default"))) void glPopClientAttrib( void );


__attribute__((visibility("default"))) GLint glRenderMode( GLenum mode );

__attribute__((visibility("default"))) GLenum glGetError( void );

__attribute__((visibility("default"))) const GLubyte * glGetString( GLenum name );

__attribute__((visibility("default"))) void glFinish( void );

__attribute__((visibility("default"))) void glFlush( void );

__attribute__((visibility("default"))) void glHint( GLenum target, GLenum mode );






__attribute__((visibility("default"))) void glClearDepth( GLclampd depth );

__attribute__((visibility("default"))) void glDepthFunc( GLenum func );

__attribute__((visibility("default"))) void glDepthMask( GLboolean flag );

__attribute__((visibility("default"))) void glDepthRange( GLclampd near_val, GLclampd far_val );






__attribute__((visibility("default"))) void glClearAccum( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );

__attribute__((visibility("default"))) void glAccum( GLenum op, GLfloat value );






__attribute__((visibility("default"))) void glMatrixMode( GLenum mode );

__attribute__((visibility("default"))) void glOrtho( GLdouble left, GLdouble right,
                                 GLdouble bottom, GLdouble top,
                                 GLdouble near_val, GLdouble far_val );

__attribute__((visibility("default"))) void glFrustum( GLdouble left, GLdouble right,
                                   GLdouble bottom, GLdouble top,
                                   GLdouble near_val, GLdouble far_val );

__attribute__((visibility("default"))) void glViewport( GLint x, GLint y,
                                    GLsizei width, GLsizei height );

__attribute__((visibility("default"))) void glPushMatrix( void );

__attribute__((visibility("default"))) void glPopMatrix( void );

__attribute__((visibility("default"))) void glLoadIdentity( void );

__attribute__((visibility("default"))) void glLoadMatrixd( const GLdouble *m );
__attribute__((visibility("default"))) void glLoadMatrixf( const GLfloat *m );

__attribute__((visibility("default"))) void glMultMatrixd( const GLdouble *m );
__attribute__((visibility("default"))) void glMultMatrixf( const GLfloat *m );

__attribute__((visibility("default"))) void glRotated( GLdouble angle,
                                   GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glRotatef( GLfloat angle,
                                   GLfloat x, GLfloat y, GLfloat z );

__attribute__((visibility("default"))) void glScaled( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glScalef( GLfloat x, GLfloat y, GLfloat z );

__attribute__((visibility("default"))) void glTranslated( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glTranslatef( GLfloat x, GLfloat y, GLfloat z );






__attribute__((visibility("default"))) GLboolean glIsList( GLuint list );

__attribute__((visibility("default"))) void glDeleteLists( GLuint list, GLsizei range );

__attribute__((visibility("default"))) GLuint glGenLists( GLsizei range );

__attribute__((visibility("default"))) void glNewList( GLuint list, GLenum mode );

__attribute__((visibility("default"))) void glEndList( void );

__attribute__((visibility("default"))) void glCallList( GLuint list );

__attribute__((visibility("default"))) void glCallLists( GLsizei n, GLenum type,
                                     const GLvoid *lists );

__attribute__((visibility("default"))) void glListBase( GLuint base );






__attribute__((visibility("default"))) void glBegin( GLenum mode );

__attribute__((visibility("default"))) void glEnd( void );


__attribute__((visibility("default"))) void glVertex2d( GLdouble x, GLdouble y );
__attribute__((visibility("default"))) void glVertex2f( GLfloat x, GLfloat y );
__attribute__((visibility("default"))) void glVertex2i( GLint x, GLint y );
__attribute__((visibility("default"))) void glVertex2s( GLshort x, GLshort y );

__attribute__((visibility("default"))) void glVertex3d( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glVertex3f( GLfloat x, GLfloat y, GLfloat z );
__attribute__((visibility("default"))) void glVertex3i( GLint x, GLint y, GLint z );
__attribute__((visibility("default"))) void glVertex3s( GLshort x, GLshort y, GLshort z );

__attribute__((visibility("default"))) void glVertex4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
__attribute__((visibility("default"))) void glVertex4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
__attribute__((visibility("default"))) void glVertex4i( GLint x, GLint y, GLint z, GLint w );
__attribute__((visibility("default"))) void glVertex4s( GLshort x, GLshort y, GLshort z, GLshort w );

__attribute__((visibility("default"))) void glVertex2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex2iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex2sv( const GLshort *v );

__attribute__((visibility("default"))) void glVertex3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex3iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex3sv( const GLshort *v );

__attribute__((visibility("default"))) void glVertex4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex4iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex4sv( const GLshort *v );


__attribute__((visibility("default"))) void glNormal3b( GLbyte nx, GLbyte ny, GLbyte nz );
__attribute__((visibility("default"))) void glNormal3d( GLdouble nx, GLdouble ny, GLdouble nz );
__attribute__((visibility("default"))) void glNormal3f( GLfloat nx, GLfloat ny, GLfloat nz );
__attribute__((visibility("default"))) void glNormal3i( GLint nx, GLint ny, GLint nz );
__attribute__((visibility("default"))) void glNormal3s( GLshort nx, GLshort ny, GLshort nz );

__attribute__((visibility("default"))) void glNormal3bv( const GLbyte *v );
__attribute__((visibility("default"))) void glNormal3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glNormal3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glNormal3iv( const GLint *v );
__attribute__((visibility("default"))) void glNormal3sv( const GLshort *v );


__attribute__((visibility("default"))) void glIndexd( GLdouble c );
__attribute__((visibility("default"))) void glIndexf( GLfloat c );
__attribute__((visibility("default"))) void glIndexi( GLint c );
__attribute__((visibility("default"))) void glIndexs( GLshort c );
__attribute__((visibility("default"))) void glIndexub( GLubyte c );

__attribute__((visibility("default"))) void glIndexdv( const GLdouble *c );
__attribute__((visibility("default"))) void glIndexfv( const GLfloat *c );
__attribute__((visibility("default"))) void glIndexiv( const GLint *c );
__attribute__((visibility("default"))) void glIndexsv( const GLshort *c );
__attribute__((visibility("default"))) void glIndexubv( const GLubyte *c );

__attribute__((visibility("default"))) void glColor3b( GLbyte red, GLbyte green, GLbyte blue );
__attribute__((visibility("default"))) void glColor3d( GLdouble red, GLdouble green, GLdouble blue );
__attribute__((visibility("default"))) void glColor3f( GLfloat red, GLfloat green, GLfloat blue );
__attribute__((visibility("default"))) void glColor3i( GLint red, GLint green, GLint blue );
__attribute__((visibility("default"))) void glColor3s( GLshort red, GLshort green, GLshort blue );
__attribute__((visibility("default"))) void glColor3ub( GLubyte red, GLubyte green, GLubyte blue );
__attribute__((visibility("default"))) void glColor3ui( GLuint red, GLuint green, GLuint blue );
__attribute__((visibility("default"))) void glColor3us( GLushort red, GLushort green, GLushort blue );

__attribute__((visibility("default"))) void glColor4b( GLbyte red, GLbyte green,
                                   GLbyte blue, GLbyte alpha );
__attribute__((visibility("default"))) void glColor4d( GLdouble red, GLdouble green,
                                   GLdouble blue, GLdouble alpha );
__attribute__((visibility("default"))) void glColor4f( GLfloat red, GLfloat green,
                                   GLfloat blue, GLfloat alpha );
__attribute__((visibility("default"))) void glColor4i( GLint red, GLint green,
                                   GLint blue, GLint alpha );
__attribute__((visibility("default"))) void glColor4s( GLshort red, GLshort green,
                                   GLshort blue, GLshort alpha );
__attribute__((visibility("default"))) void glColor4ub( GLubyte red, GLubyte green,
                                    GLubyte blue, GLubyte alpha );
__attribute__((visibility("default"))) void glColor4ui( GLuint red, GLuint green,
                                    GLuint blue, GLuint alpha );
__attribute__((visibility("default"))) void glColor4us( GLushort red, GLushort green,
                                    GLushort blue, GLushort alpha );


__attribute__((visibility("default"))) void glColor3bv( const GLbyte *v );
__attribute__((visibility("default"))) void glColor3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glColor3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glColor3iv( const GLint *v );
__attribute__((visibility("default"))) void glColor3sv( const GLshort *v );
__attribute__((visibility("default"))) void glColor3ubv( const GLubyte *v );
__attribute__((visibility("default"))) void glColor3uiv( const GLuint *v );
__attribute__((visibility("default"))) void glColor3usv( const GLushort *v );

__attribute__((visibility("default"))) void glColor4bv( const GLbyte *v );
__attribute__((visibility("default"))) void glColor4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glColor4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glColor4iv( const GLint *v );
__attribute__((visibility("default"))) void glColor4sv( const GLshort *v );
__attribute__((visibility("default"))) void glColor4ubv( const GLubyte *v );
__attribute__((visibility("default"))) void glColor4uiv( const GLuint *v );
__attribute__((visibility("default"))) void glColor4usv( const GLushort *v );


__attribute__((visibility("default"))) void glTexCoord1d( GLdouble s );
__attribute__((visibility("default"))) void glTexCoord1f( GLfloat s );
__attribute__((visibility("default"))) void glTexCoord1i( GLint s );
__attribute__((visibility("default"))) void glTexCoord1s( GLshort s );

__attribute__((visibility("default"))) void glTexCoord2d( GLdouble s, GLdouble t );
__attribute__((visibility("default"))) void glTexCoord2f( GLfloat s, GLfloat t );
__attribute__((visibility("default"))) void glTexCoord2i( GLint s, GLint t );
__attribute__((visibility("default"))) void glTexCoord2s( GLshort s, GLshort t );

__attribute__((visibility("default"))) void glTexCoord3d( GLdouble s, GLdouble t, GLdouble r );
__attribute__((visibility("default"))) void glTexCoord3f( GLfloat s, GLfloat t, GLfloat r );
__attribute__((visibility("default"))) void glTexCoord3i( GLint s, GLint t, GLint r );
__attribute__((visibility("default"))) void glTexCoord3s( GLshort s, GLshort t, GLshort r );

__attribute__((visibility("default"))) void glTexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
__attribute__((visibility("default"))) void glTexCoord4f( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
__attribute__((visibility("default"))) void glTexCoord4i( GLint s, GLint t, GLint r, GLint q );
__attribute__((visibility("default"))) void glTexCoord4s( GLshort s, GLshort t, GLshort r, GLshort q );

__attribute__((visibility("default"))) void glTexCoord1dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord1fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord1iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord1sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord2iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord2sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord3iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord3sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord4iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord4sv( const GLshort *v );


__attribute__((visibility("default"))) void glRasterPos2d( GLdouble x, GLdouble y );
__attribute__((visibility("default"))) void glRasterPos2f( GLfloat x, GLfloat y );
__attribute__((visibility("default"))) void glRasterPos2i( GLint x, GLint y );
__attribute__((visibility("default"))) void glRasterPos2s( GLshort x, GLshort y );

__attribute__((visibility("default"))) void glRasterPos3d( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glRasterPos3f( GLfloat x, GLfloat y, GLfloat z );
__attribute__((visibility("default"))) void glRasterPos3i( GLint x, GLint y, GLint z );
__attribute__((visibility("default"))) void glRasterPos3s( GLshort x, GLshort y, GLshort z );

__attribute__((visibility("default"))) void glRasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
__attribute__((visibility("default"))) void glRasterPos4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
__attribute__((visibility("default"))) void glRasterPos4i( GLint x, GLint y, GLint z, GLint w );
__attribute__((visibility("default"))) void glRasterPos4s( GLshort x, GLshort y, GLshort z, GLshort w );

__attribute__((visibility("default"))) void glRasterPos2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos2iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos2sv( const GLshort *v );

__attribute__((visibility("default"))) void glRasterPos3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos3iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos3sv( const GLshort *v );

__attribute__((visibility("default"))) void glRasterPos4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos4iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos4sv( const GLshort *v );


__attribute__((visibility("default"))) void glRectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 );
__attribute__((visibility("default"))) void glRectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 );
__attribute__((visibility("default"))) void glRecti( GLint x1, GLint y1, GLint x2, GLint y2 );
__attribute__((visibility("default"))) void glRects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 );


__attribute__((visibility("default"))) void glRectdv( const GLdouble *v1, const GLdouble *v2 );
__attribute__((visibility("default"))) void glRectfv( const GLfloat *v1, const GLfloat *v2 );
__attribute__((visibility("default"))) void glRectiv( const GLint *v1, const GLint *v2 );
__attribute__((visibility("default"))) void glRectsv( const GLshort *v1, const GLshort *v2 );






__attribute__((visibility("default"))) void glVertexPointer( GLint size, GLenum type,
                                       GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glNormalPointer( GLenum type, GLsizei stride,
                                       const GLvoid *ptr );

__attribute__((visibility("default"))) void glColorPointer( GLint size, GLenum type,
                                      GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glIndexPointer( GLenum type, GLsizei stride,
                                      const GLvoid *ptr );

__attribute__((visibility("default"))) void glTexCoordPointer( GLint size, GLenum type,
                                         GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glEdgeFlagPointer( GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glGetPointerv( GLenum pname, GLvoid **params );

__attribute__((visibility("default"))) void glArrayElement( GLint i );

__attribute__((visibility("default"))) void glDrawArrays( GLenum mode, GLint first, GLsizei count );

__attribute__((visibility("default"))) void glDrawElements( GLenum mode, GLsizei count,
                                      GLenum type, const GLvoid *indices );

__attribute__((visibility("default"))) void glInterleavedArrays( GLenum format, GLsizei stride,
                                           const GLvoid *pointer );





__attribute__((visibility("default"))) void glShadeModel( GLenum mode );

__attribute__((visibility("default"))) void glLightf( GLenum light, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glLighti( GLenum light, GLenum pname, GLint param );
__attribute__((visibility("default"))) void glLightfv( GLenum light, GLenum pname,
                                 const GLfloat *params );
__attribute__((visibility("default"))) void glLightiv( GLenum light, GLenum pname,
                                 const GLint *params );

__attribute__((visibility("default"))) void glGetLightfv( GLenum light, GLenum pname,
                                    GLfloat *params );
__attribute__((visibility("default"))) void glGetLightiv( GLenum light, GLenum pname,
                                    GLint *params );

__attribute__((visibility("default"))) void glLightModelf( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glLightModeli( GLenum pname, GLint param );
__attribute__((visibility("default"))) void glLightModelfv( GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glLightModeliv( GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glMaterialf( GLenum face, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glMateriali( GLenum face, GLenum pname, GLint param );
__attribute__((visibility("default"))) void glMaterialfv( GLenum face, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glMaterialiv( GLenum face, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetMaterialfv( GLenum face, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetMaterialiv( GLenum face, GLenum pname, GLint *params );

__attribute__((visibility("default"))) void glColorMaterial( GLenum face, GLenum mode );






__attribute__((visibility("default"))) void glPixelZoom( GLfloat xfactor, GLfloat yfactor );

__attribute__((visibility("default"))) void glPixelStoref( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glPixelStorei( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glPixelTransferf( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glPixelTransferi( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glPixelMapfv( GLenum map, GLsizei mapsize,
                                    const GLfloat *values );
__attribute__((visibility("default"))) void glPixelMapuiv( GLenum map, GLsizei mapsize,
                                     const GLuint *values );
__attribute__((visibility("default"))) void glPixelMapusv( GLenum map, GLsizei mapsize,
                                     const GLushort *values );

__attribute__((visibility("default"))) void glGetPixelMapfv( GLenum map, GLfloat *values );
__attribute__((visibility("default"))) void glGetPixelMapuiv( GLenum map, GLuint *values );
__attribute__((visibility("default"))) void glGetPixelMapusv( GLenum map, GLushort *values );

__attribute__((visibility("default"))) void glBitmap( GLsizei width, GLsizei height,
                                GLfloat xorig, GLfloat yorig,
                                GLfloat xmove, GLfloat ymove,
                                const GLubyte *bitmap );

__attribute__((visibility("default"))) void glReadPixels( GLint x, GLint y,
                                    GLsizei width, GLsizei height,
                                    GLenum format, GLenum type,
                                    GLvoid *pixels );

__attribute__((visibility("default"))) void glDrawPixels( GLsizei width, GLsizei height,
                                    GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glCopyPixels( GLint x, GLint y,
                                    GLsizei width, GLsizei height,
                                    GLenum type );





__attribute__((visibility("default"))) void glStencilFunc( GLenum func, GLint ref, GLuint mask );

__attribute__((visibility("default"))) void glStencilMask( GLuint mask );

__attribute__((visibility("default"))) void glStencilOp( GLenum fail, GLenum zfail, GLenum zpass );

__attribute__((visibility("default"))) void glClearStencil( GLint s );







__attribute__((visibility("default"))) void glTexGend( GLenum coord, GLenum pname, GLdouble param );
__attribute__((visibility("default"))) void glTexGenf( GLenum coord, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexGeni( GLenum coord, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexGendv( GLenum coord, GLenum pname, const GLdouble *params );
__attribute__((visibility("default"))) void glTexGenfv( GLenum coord, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glTexGeniv( GLenum coord, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetTexGendv( GLenum coord, GLenum pname, GLdouble *params );
__attribute__((visibility("default"))) void glGetTexGenfv( GLenum coord, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexGeniv( GLenum coord, GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexEnvf( GLenum target, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexEnvi( GLenum target, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexEnvfv( GLenum target, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glTexEnviv( GLenum target, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetTexEnvfv( GLenum target, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexEnviv( GLenum target, GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexParameterf( GLenum target, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexParameteri( GLenum target, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexParameterfv( GLenum target, GLenum pname,
                                          const GLfloat *params );
__attribute__((visibility("default"))) void glTexParameteriv( GLenum target, GLenum pname,
                                          const GLint *params );

__attribute__((visibility("default"))) void glGetTexParameterfv( GLenum target,
                                           GLenum pname, GLfloat *params);
__attribute__((visibility("default"))) void glGetTexParameteriv( GLenum target,
                                           GLenum pname, GLint *params );

__attribute__((visibility("default"))) void glGetTexLevelParameterfv( GLenum target, GLint level,
                                                GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexLevelParameteriv( GLenum target, GLint level,
                                                GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexImage1D( GLenum target, GLint level,
                                    GLint internalFormat,
                                    GLsizei width, GLint border,
                                    GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glTexImage2D( GLenum target, GLint level,
                                    GLint internalFormat,
                                    GLsizei width, GLsizei height,
                                    GLint border, GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glGetTexImage( GLenum target, GLint level,
                                     GLenum format, GLenum type,
                                     GLvoid *pixels );




__attribute__((visibility("default"))) void glGenTextures( GLsizei n, GLuint *textures );

__attribute__((visibility("default"))) void glDeleteTextures( GLsizei n, const GLuint *textures);

__attribute__((visibility("default"))) void glBindTexture( GLenum target, GLuint texture );

__attribute__((visibility("default"))) void glPrioritizeTextures( GLsizei n,
                                            const GLuint *textures,
                                            const GLclampf *priorities );

__attribute__((visibility("default"))) GLboolean glAreTexturesResident( GLsizei n,
                                                  const GLuint *textures,
                                                  GLboolean *residences );

__attribute__((visibility("default"))) GLboolean glIsTexture( GLuint texture );


__attribute__((visibility("default"))) void glTexSubImage1D( GLenum target, GLint level,
                                       GLint xoffset,
                                       GLsizei width, GLenum format,
                                       GLenum type, const GLvoid *pixels );


__attribute__((visibility("default"))) void glTexSubImage2D( GLenum target, GLint level,
                                       GLint xoffset, GLint yoffset,
                                       GLsizei width, GLsizei height,
                                       GLenum format, GLenum type,
                                       const GLvoid *pixels );


__attribute__((visibility("default"))) void glCopyTexImage1D( GLenum target, GLint level,
                                        GLenum internalformat,
                                        GLint x, GLint y,
                                        GLsizei width, GLint border );


__attribute__((visibility("default"))) void glCopyTexImage2D( GLenum target, GLint level,
                                        GLenum internalformat,
                                        GLint x, GLint y,
                                        GLsizei width, GLsizei height,
                                        GLint border );


__attribute__((visibility("default"))) void glCopyTexSubImage1D( GLenum target, GLint level,
                                           GLint xoffset, GLint x, GLint y,
                                           GLsizei width );


__attribute__((visibility("default"))) void glCopyTexSubImage2D( GLenum target, GLint level,
                                           GLint xoffset, GLint yoffset,
                                           GLint x, GLint y,
                                           GLsizei width, GLsizei height );






__attribute__((visibility("default"))) void glMap1d( GLenum target, GLdouble u1, GLdouble u2,
                               GLint stride,
                               GLint order, const GLdouble *points );
__attribute__((visibility("default"))) void glMap1f( GLenum target, GLfloat u1, GLfloat u2,
                               GLint stride,
                               GLint order, const GLfloat *points );

__attribute__((visibility("default"))) void glMap2d( GLenum target,
       GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
       GLdouble v1, GLdouble v2, GLint vstride, GLint vorder,
       const GLdouble *points );
__attribute__((visibility("default"))) void glMap2f( GLenum target,
       GLfloat u1, GLfloat u2, GLint ustride, GLint uorder,
       GLfloat v1, GLfloat v2, GLint vstride, GLint vorder,
       const GLfloat *points );

__attribute__((visibility("default"))) void glGetMapdv( GLenum target, GLenum query, GLdouble *v );
__attribute__((visibility("default"))) void glGetMapfv( GLenum target, GLenum query, GLfloat *v );
__attribute__((visibility("default"))) void glGetMapiv( GLenum target, GLenum query, GLint *v );

__attribute__((visibility("default"))) void glEvalCoord1d( GLdouble u );
__attribute__((visibility("default"))) void glEvalCoord1f( GLfloat u );

__attribute__((visibility("default"))) void glEvalCoord1dv( const GLdouble *u );
__attribute__((visibility("default"))) void glEvalCoord1fv( const GLfloat *u );

__attribute__((visibility("default"))) void glEvalCoord2d( GLdouble u, GLdouble v );
__attribute__((visibility("default"))) void glEvalCoord2f( GLfloat u, GLfloat v );

__attribute__((visibility("default"))) void glEvalCoord2dv( const GLdouble *u );
__attribute__((visibility("default"))) void glEvalCoord2fv( const GLfloat *u );

__attribute__((visibility("default"))) void glMapGrid1d( GLint un, GLdouble u1, GLdouble u2 );
__attribute__((visibility("default"))) void glMapGrid1f( GLint un, GLfloat u1, GLfloat u2 );

__attribute__((visibility("default"))) void glMapGrid2d( GLint un, GLdouble u1, GLdouble u2,
                                   GLint vn, GLdouble v1, GLdouble v2 );
__attribute__((visibility("default"))) void glMapGrid2f( GLint un, GLfloat u1, GLfloat u2,
                                   GLint vn, GLfloat v1, GLfloat v2 );

__attribute__((visibility("default"))) void glEvalPoint1( GLint i );

__attribute__((visibility("default"))) void glEvalPoint2( GLint i, GLint j );

__attribute__((visibility("default"))) void glEvalMesh1( GLenum mode, GLint i1, GLint i2 );

__attribute__((visibility("default"))) void glEvalMesh2( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );






__attribute__((visibility("default"))) void glFogf( GLenum pname, GLfloat param );

__attribute__((visibility("default"))) void glFogi( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glFogfv( GLenum pname, const GLfloat *params );

__attribute__((visibility("default"))) void glFogiv( GLenum pname, const GLint *params );






__attribute__((visibility("default"))) void glFeedbackBuffer( GLsizei size, GLenum type, GLfloat *buffer );

__attribute__((visibility("default"))) void glPassThrough( GLfloat token );

__attribute__((visibility("default"))) void glSelectBuffer( GLsizei size, GLuint *buffer );

__attribute__((visibility("default"))) void glInitNames( void );

__attribute__((visibility("default"))) void glLoadName( GLuint name );

__attribute__((visibility("default"))) void glPushName( GLuint name );

__attribute__((visibility("default"))) void glPopName( void );
# 1519 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glDrawRangeElements( GLenum mode, GLuint start,
 GLuint end, GLsizei count, GLenum type, const GLvoid *indices );

__attribute__((visibility("default"))) void glTexImage3D( GLenum target, GLint level,
                                      GLint internalFormat,
                                      GLsizei width, GLsizei height,
                                      GLsizei depth, GLint border,
                                      GLenum format, GLenum type,
                                      const GLvoid *pixels );

__attribute__((visibility("default"))) void glTexSubImage3D( GLenum target, GLint level,
                                         GLint xoffset, GLint yoffset,
                                         GLint zoffset, GLsizei width,
                                         GLsizei height, GLsizei depth,
                                         GLenum format,
                                         GLenum type, const GLvoid *pixels);

__attribute__((visibility("default"))) void glCopyTexSubImage3D( GLenum target, GLint level,
                                             GLint xoffset, GLint yoffset,
                                             GLint zoffset, GLint x,
                                             GLint y, GLsizei width,
                                             GLsizei height );

typedef void ( * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
typedef void ( * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 1629 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glColorTable( GLenum target, GLenum internalformat,
                                    GLsizei width, GLenum format,
                                    GLenum type, const GLvoid *table );

__attribute__((visibility("default"))) void glColorSubTable( GLenum target,
                                       GLsizei start, GLsizei count,
                                       GLenum format, GLenum type,
                                       const GLvoid *data );

__attribute__((visibility("default"))) void glColorTableParameteriv(GLenum target, GLenum pname,
                                              const GLint *params);

__attribute__((visibility("default"))) void glColorTableParameterfv(GLenum target, GLenum pname,
                                              const GLfloat *params);

__attribute__((visibility("default"))) void glCopyColorSubTable( GLenum target, GLsizei start,
                                           GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glCopyColorTable( GLenum target, GLenum internalformat,
                                        GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glGetColorTable( GLenum target, GLenum format,
                                       GLenum type, GLvoid *table );

__attribute__((visibility("default"))) void glGetColorTableParameterfv( GLenum target, GLenum pname,
                                                  GLfloat *params );

__attribute__((visibility("default"))) void glGetColorTableParameteriv( GLenum target, GLenum pname,
                                                  GLint *params );

__attribute__((visibility("default"))) void glBlendEquation( GLenum mode );

__attribute__((visibility("default"))) void glBlendColor( GLclampf red, GLclampf green,
                                    GLclampf blue, GLclampf alpha );

__attribute__((visibility("default"))) void glHistogram( GLenum target, GLsizei width,
       GLenum internalformat, GLboolean sink );

__attribute__((visibility("default"))) void glResetHistogram( GLenum target );

__attribute__((visibility("default"))) void glGetHistogram( GLenum target, GLboolean reset,
          GLenum format, GLenum type,
          GLvoid *values );

__attribute__((visibility("default"))) void glGetHistogramParameterfv( GLenum target, GLenum pname,
       GLfloat *params );

__attribute__((visibility("default"))) void glGetHistogramParameteriv( GLenum target, GLenum pname,
       GLint *params );

__attribute__((visibility("default"))) void glMinmax( GLenum target, GLenum internalformat,
    GLboolean sink );

__attribute__((visibility("default"))) void glResetMinmax( GLenum target );

__attribute__((visibility("default"))) void glGetMinmax( GLenum target, GLboolean reset,
                                   GLenum format, GLenum types,
                                   GLvoid *values );

__attribute__((visibility("default"))) void glGetMinmaxParameterfv( GLenum target, GLenum pname,
           GLfloat *params );

__attribute__((visibility("default"))) void glGetMinmaxParameteriv( GLenum target, GLenum pname,
           GLint *params );

__attribute__((visibility("default"))) void glConvolutionFilter1D( GLenum target,
 GLenum internalformat, GLsizei width, GLenum format, GLenum type,
 const GLvoid *image );

__attribute__((visibility("default"))) void glConvolutionFilter2D( GLenum target,
 GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
 GLenum type, const GLvoid *image );

__attribute__((visibility("default"))) void glConvolutionParameterf( GLenum target, GLenum pname,
 GLfloat params );

__attribute__((visibility("default"))) void glConvolutionParameterfv( GLenum target, GLenum pname,
 const GLfloat *params );

__attribute__((visibility("default"))) void glConvolutionParameteri( GLenum target, GLenum pname,
 GLint params );

__attribute__((visibility("default"))) void glConvolutionParameteriv( GLenum target, GLenum pname,
 const GLint *params );

__attribute__((visibility("default"))) void glCopyConvolutionFilter1D( GLenum target,
 GLenum internalformat, GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glCopyConvolutionFilter2D( GLenum target,
 GLenum internalformat, GLint x, GLint y, GLsizei width,
 GLsizei height);

__attribute__((visibility("default"))) void glGetConvolutionFilter( GLenum target, GLenum format,
 GLenum type, GLvoid *image );

__attribute__((visibility("default"))) void glGetConvolutionParameterfv( GLenum target, GLenum pname,
 GLfloat *params );

__attribute__((visibility("default"))) void glGetConvolutionParameteriv( GLenum target, GLenum pname,
 GLint *params );

__attribute__((visibility("default"))) void glSeparableFilter2D( GLenum target,
 GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
 GLenum type, const GLvoid *row, const GLvoid *column );

__attribute__((visibility("default"))) void glGetSeparableFilter( GLenum target, GLenum format,
 GLenum type, GLvoid *row, GLvoid *column, GLvoid *span );

typedef void ( * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void ( * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void ( * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
typedef void ( * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXPROC) (GLenum target);
# 1883 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glActiveTexture( GLenum texture );

__attribute__((visibility("default"))) void glClientActiveTexture( GLenum texture );

__attribute__((visibility("default"))) void glCompressedTexImage1D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexImage2D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexImage3D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glGetCompressedTexImage( GLenum target, GLint lod, GLvoid *img );

__attribute__((visibility("default"))) void glMultiTexCoord1d( GLenum target, GLdouble s );

__attribute__((visibility("default"))) void glMultiTexCoord1dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord1f( GLenum target, GLfloat s );

__attribute__((visibility("default"))) void glMultiTexCoord1fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord1i( GLenum target, GLint s );

__attribute__((visibility("default"))) void glMultiTexCoord1iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord1s( GLenum target, GLshort s );

__attribute__((visibility("default"))) void glMultiTexCoord1sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord2d( GLenum target, GLdouble s, GLdouble t );

__attribute__((visibility("default"))) void glMultiTexCoord2dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord2f( GLenum target, GLfloat s, GLfloat t );

__attribute__((visibility("default"))) void glMultiTexCoord2fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord2i( GLenum target, GLint s, GLint t );

__attribute__((visibility("default"))) void glMultiTexCoord2iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord2s( GLenum target, GLshort s, GLshort t );

__attribute__((visibility("default"))) void glMultiTexCoord2sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord3d( GLenum target, GLdouble s, GLdouble t, GLdouble r );

__attribute__((visibility("default"))) void glMultiTexCoord3dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord3f( GLenum target, GLfloat s, GLfloat t, GLfloat r );

__attribute__((visibility("default"))) void glMultiTexCoord3fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord3i( GLenum target, GLint s, GLint t, GLint r );

__attribute__((visibility("default"))) void glMultiTexCoord3iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord3s( GLenum target, GLshort s, GLshort t, GLshort r );

__attribute__((visibility("default"))) void glMultiTexCoord3sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord4d( GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q );

__attribute__((visibility("default"))) void glMultiTexCoord4dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord4f( GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q );

__attribute__((visibility("default"))) void glMultiTexCoord4fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord4i( GLenum target, GLint s, GLint t, GLint r, GLint q );

__attribute__((visibility("default"))) void glMultiTexCoord4iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord4s( GLenum target, GLshort s, GLshort t, GLshort r, GLshort q );

__attribute__((visibility("default"))) void glMultiTexCoord4sv( GLenum target, const GLshort *v );


__attribute__((visibility("default"))) void glLoadTransposeMatrixd( const GLdouble m[16] );

__attribute__((visibility("default"))) void glLoadTransposeMatrixf( const GLfloat m[16] );

__attribute__((visibility("default"))) void glMultTransposeMatrixd( const GLdouble m[16] );

__attribute__((visibility("default"))) void glMultTransposeMatrixf( const GLfloat m[16] );

__attribute__((visibility("default"))) void glSampleCoverage( GLclampf value, GLboolean invert );

typedef void ( * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat *m);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble *m);
typedef void ( * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, void *img);
# 2066 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glActiveTextureARB(GLenum texture);
__attribute__((visibility("default"))) void glClientActiveTextureARB(GLenum texture);
__attribute__((visibility("default"))) void glMultiTexCoord1dARB(GLenum target, GLdouble s);
__attribute__((visibility("default"))) void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord1fARB(GLenum target, GLfloat s);
__attribute__((visibility("default"))) void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord1iARB(GLenum target, GLint s);
__attribute__((visibility("default"))) void glMultiTexCoord1ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord1sARB(GLenum target, GLshort s);
__attribute__((visibility("default"))) void glMultiTexCoord1svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
__attribute__((visibility("default"))) void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
__attribute__((visibility("default"))) void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
__attribute__((visibility("default"))) void glMultiTexCoord2ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
__attribute__((visibility("default"))) void glMultiTexCoord2svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
__attribute__((visibility("default"))) void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
__attribute__((visibility("default"))) void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
__attribute__((visibility("default"))) void glMultiTexCoord3ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
__attribute__((visibility("default"))) void glMultiTexCoord3svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__attribute__((visibility("default"))) void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__attribute__((visibility("default"))) void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
__attribute__((visibility("default"))) void glMultiTexCoord4ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
__attribute__((visibility("default"))) void glMultiTexCoord4svARB(GLenum target, const GLshort *v);

typedef void ( * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
# 2150 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
# 1 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h" 1




extern "C" {
# 3388 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 3389 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h" 2


typedef char GLchar;




typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;




typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;




typedef char GLcharARB;
typedef unsigned int GLhandleARB;




typedef unsigned short GLhalfARB;



typedef unsigned short GLhalfNV;
# 3454 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 1 3
# 16 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdint.h" 1 3 4


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 1 3 4
# 13 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
extern "C" {
# 41 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed char int8_t ;
typedef unsigned char uint8_t ;




typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;




typedef signed short int16_t;
typedef unsigned short uint16_t;
# 67 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;
# 79 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed int int32_t;
typedef unsigned int uint32_t;
# 97 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;
# 119 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed long long int64_t;
typedef unsigned long long uint64_t;
# 129 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;
# 159 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef signed int int_fast8_t;
  typedef unsigned int uint_fast8_t;




  typedef signed int int_fast16_t;
  typedef unsigned int uint_fast16_t;




  typedef signed int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 213 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef int_least64_t int_fast64_t;
  typedef uint_least64_t uint_fast64_t;







  typedef long long int intmax_t;
# 231 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef long long unsigned int uintmax_t;
# 243 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed int intptr_t;
typedef unsigned int uintptr_t;
# 490 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
}
# 4 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdint.h" 2 3 4
# 17 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 2 3

# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 19 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 2 3
# 270 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 3
typedef struct {
  intmax_t quot;
  intmax_t rem;
} imaxdiv_t;


extern "C" {


extern intmax_t imaxabs(intmax_t j);
extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denomer);
extern intmax_t strtoimax(const char *__restrict, char **__restrict, int);
extern uintmax_t strtoumax(const char *__restrict, char **__restrict, int);
extern intmax_t wcstoimax(const wchar_t *__restrict, wchar_t **__restrict, int);
extern uintmax_t wcstoumax(const wchar_t *__restrict, wchar_t **__restrict, int);


}
# 3455 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h" 2




typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;
# 3692 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void ( * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void ( * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
typedef void ( * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVPROC) (const GLshort *v);
# 3762 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISQUERYPROC) (GLuint id);
typedef void ( * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLENDQUERYPROC) (GLenum target);
typedef void ( * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
typedef void ( * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
typedef void ( * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
typedef GLboolean ( * PFNGLISBUFFERPROC) (GLuint buffer);
typedef void ( * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
typedef void ( * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
typedef GLvoid* ( * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERPROC) (GLenum target);
typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid* *params);
# 3880 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum *bufs);
typedef void ( * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void ( * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar *name);
typedef void ( * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint ( * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint ( * PFNGLCREATESHADERPROC) (GLenum type);
typedef void ( * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void ( * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj);
typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void ( * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void ( * PFNGLGETSHADERSOURCEPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat *params);
typedef void ( * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean ( * PFNGLISSHADERPROC) (GLuint shader);
typedef void ( * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar* *string, const GLint *length);
typedef void ( * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
# 3985 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
# 4075 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);







typedef void ( * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
# 4108 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint level, GLvoid *img);
# 4127 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat *params);
# 4145 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLWEIGHTBVARBPROC) (GLint size, const GLbyte *weights);
typedef void ( * PFNGLWEIGHTSVARBPROC) (GLint size, const GLshort *weights);
typedef void ( * PFNGLWEIGHTIVARBPROC) (GLint size, const GLint *weights);
typedef void ( * PFNGLWEIGHTFVARBPROC) (GLint size, const GLfloat *weights);
typedef void ( * PFNGLWEIGHTDVARBPROC) (GLint size, const GLdouble *weights);
typedef void ( * PFNGLWEIGHTUBVARBPROC) (GLint size, const GLubyte *weights);
typedef void ( * PFNGLWEIGHTUSVARBPROC) (GLint size, const GLushort *weights);
typedef void ( * PFNGLWEIGHTUIVARBPROC) (GLint size, const GLuint *weights);
typedef void ( * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXBLENDARBPROC) (GLint count);
# 4166 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void ( * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, const GLubyte *indices);
typedef void ( * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, const GLushort *indices);
typedef void ( * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, const GLuint *indices);
typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 4221 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVARBPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVARBPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVARBPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVARBPROC) (const GLshort *v);
# 4305 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void ( * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void ( * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint *programs);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMARBPROC) (GLuint program);
# 4389 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint *buffers);
typedef void ( * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint *buffers);
typedef GLboolean ( * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void ( * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
typedef GLvoid* ( * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid* *params);
# 4414 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISQUERYARBPROC) (GLuint id);
typedef void ( * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void ( * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint *params);
# 4467 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void ( * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void ( * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB* *string, const GLint *length);
typedef void ( * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef void ( * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void ( * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint *params);
typedef void ( * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB *name);
typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
typedef void ( * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat *params);
typedef void ( * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint *params);
typedef void ( * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
# 4515 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
typedef void ( * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB *name);
# 4545 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum *bufs);
# 4557 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
# 4581 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);







typedef void ( * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
# 4602 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
# 4612 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat *weights);
typedef void ( * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);
# 4622 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
# 4635 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 4656 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXEXTPROC) (GLenum target);
# 4685 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
# 4715 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint *params);







typedef void ( * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
# 4742 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPIXELTEXGENPARAMETERISGISPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLPIXELTEXGENPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, GLint *params);
typedef void ( * PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, GLfloat *params);
# 4756 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
# 4778 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint *textures, GLboolean *residences);
typedef void ( * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void ( * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint *textures);
typedef void ( * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint *textures);
typedef GLboolean ( * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint *textures, const GLclampf *priorities);
# 4792 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
# 4802 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
# 4820 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
# 4841 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void ( * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void ( * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void ( * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
# 4881 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
# 4912 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, const GLint *params);
# 4928 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat *params);
# 4938 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPOINTPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
# 4952 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLint ( * PFNGLGETINSTRUMENTSSGIXPROC) (void);
typedef void ( * PFNGLINSTRUMENTSBUFFERSGIXPROC) (GLsizei size, GLint *buffer);
typedef GLint ( * PFNGLPOLLINSTRUMENTSSGIXPROC) (GLint *marker_p);
typedef void ( * PFNGLREADINSTRUMENTSSGIXPROC) (GLint marker);
typedef void ( * PFNGLSTARTINSTRUMENTSSGIXPROC) (void);
typedef void ( * PFNGLSTOPINSTRUMENTSSGIXPROC) (GLint marker);
# 4969 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);







typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
# 4988 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDEFORMATIONMAP3DSGIXPROC) (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
typedef void ( * PFNGLDEFORMATIONMAP3FSGIXPROC) (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
typedef void ( * PFNGLDEFORMSGIXPROC) (GLbitfield mask);
typedef void ( * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);







typedef void ( * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble *equation);







typedef void ( * PFNGLFLUSHRASTERSGIXPROC) (void);
# 5020 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETFOGFUNCSGISPROC) (GLfloat *points);
# 5038 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, GLfloat *params);
# 5060 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
# 5073 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLHINTPGIPROC) (GLenum target, GLint mode);
# 5084 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
# 5104 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, GLint *params);
typedef void ( * PFNGLLISTPARAMETERFSGIXPROC) (GLuint list, GLenum pname, GLfloat param);
typedef void ( * PFNGLLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLLISTPARAMETERISGIXPROC) (GLuint list, GLenum pname, GLint param);
typedef void ( * PFNGLLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, const GLint *params);
# 5137 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);







typedef void ( * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLclampf ref);
# 5158 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void ( * PFNGLUNLOCKARRAYSEXTPROC) (void);
# 5168 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble *params);
typedef void ( * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat *params);
# 5198 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, const GLint *params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint *params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint *params);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, GLint *params);
typedef void ( * PFNGLLIGHTENVISGIXPROC) (GLenum pname, GLint param);
# 5231 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
# 5249 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void ( * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void ( * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
# 5272 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint ( * PFNGLFINISHASYNCSGIXPROC) (GLuint *markerp);
typedef GLint ( * PFNGLPOLLASYNCSGIXPROC) (GLuint *markerp);
typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
# 5296 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
# 5314 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
# 5353 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);







typedef void ( * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
# 5386 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
# 5399 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
typedef void ( * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
# 5436 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTANGENT3BEXTPROC) (GLbyte tx, GLbyte ty, GLbyte tz);
typedef void ( * PFNGLTANGENT3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLTANGENT3DEXTPROC) (GLdouble tx, GLdouble ty, GLdouble tz);
typedef void ( * PFNGLTANGENT3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLTANGENT3FEXTPROC) (GLfloat tx, GLfloat ty, GLfloat tz);
typedef void ( * PFNGLTANGENT3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLTANGENT3IEXTPROC) (GLint tx, GLint ty, GLint tz);
typedef void ( * PFNGLTANGENT3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLTANGENT3SEXTPROC) (GLshort tx, GLshort ty, GLshort tz);
typedef void ( * PFNGLTANGENT3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLBINORMAL3BEXTPROC) (GLbyte bx, GLbyte by, GLbyte bz);
typedef void ( * PFNGLBINORMAL3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLBINORMAL3DEXTPROC) (GLdouble bx, GLdouble by, GLdouble bz);
typedef void ( * PFNGLBINORMAL3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLBINORMAL3FEXTPROC) (GLfloat bx, GLfloat by, GLfloat bz);
typedef void ( * PFNGLBINORMAL3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLBINORMAL3IEXTPROC) (GLint bx, GLint by, GLint bz);
typedef void ( * PFNGLBINORMAL3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLBINORMAL3SEXTPROC) (GLshort bx, GLshort by, GLshort bz);
typedef void ( * PFNGLBINORMAL3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
# 5481 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFINISHTEXTURESUNXPROC) (void);
# 5496 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
# 5517 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint *code);
typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort *code);
typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte *code);
typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const GLvoid* *pointer);
# 5570 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat *tc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint *rc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);







typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);







typedef void ( * PFNGLBLENDFUNCSEPARATEINGRPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 5671 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC) (const GLfloat *weight);
typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 5686 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void ( * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, const GLvoid *pointer);
# 5707 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint *params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint *params);
# 5743 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC) (void);
# 5774 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLWINDOWPOS4IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort *v);
# 5810 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount, GLint modestride);
# 5826 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean* *pointer, GLint ptrstride);
typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
# 5865 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
# 5874 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
# 5899 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXTURECOLORMASKSGISPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);







typedef void ( * PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, const GLvoid *params);
# 5929 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint *fences);
typedef void ( * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint *fences);
typedef GLboolean ( * PFNGLISFENCENVPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint *params);
typedef void ( * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
# 5951 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
typedef void ( * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
# 5972 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat *params);
# 6064 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint *programs, GLboolean *residences);
typedef void ( * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat *params);
typedef void ( * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint *programs);
typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte *program);
typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void ( * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble *v);
typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat *v);
typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLuint count, const GLdouble *v);
typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLuint count, const GLfloat *v);
typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei count, const GLubyte *v);
# 6162 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, const GLint *param);
typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, const GLfloat *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
# 6186 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void ( * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat *value);
# 6208 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
# 6228 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const GLvoid *pointer, GLenum usage);
typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint *params);
typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint *params);
typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint *params);
# 6288 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void ( * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void ( * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void ( * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC) (GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
typedef void ( * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
typedef void ( * PFNGLVARIANTBVEXTPROC) (GLuint id, const GLbyte *addr);
typedef void ( * PFNGLVARIANTSVEXTPROC) (GLuint id, const GLshort *addr);
typedef void ( * PFNGLVARIANTIVEXTPROC) (GLuint id, const GLint *addr);
typedef void ( * PFNGLVARIANTFVEXTPROC) (GLuint id, const GLfloat *addr);
typedef void ( * PFNGLVARIANTDVEXTPROC) (GLuint id, const GLdouble *addr);
typedef void ( * PFNGLVARIANTUBVEXTPROC) (GLuint id, const GLubyte *addr);
typedef void ( * PFNGLVARIANTUSVEXTPROC) (GLuint id, const GLushort *addr);
typedef void ( * PFNGLVARIANTUIVEXTPROC) (GLuint id, const GLuint *addr);
typedef void ( * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, GLvoid* *data);
typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
# 6381 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
typedef void ( * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void ( * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort nx, GLshort ny, GLshort nz);
typedef void ( * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint nx, GLint ny, GLint nz);
typedef void ( * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
typedef void ( * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
typedef void ( * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void ( * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
# 6435 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const GLvoid *pointer);
typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);







typedef void ( * PFNGLDRAWMESHARRAYSSUNPROC) (GLenum mode, GLint first, GLsizei count, GLsizei width);
# 6471 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint *params);
# 6486 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
# 6507 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
# 6527 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const GLvoid *pointer);
typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
# 6546 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint *fences);
typedef void ( * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint *fences);
typedef void ( * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
typedef void ( * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
# 6564 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint *arrays);
typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, GLuint *arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
# 6577 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
# 6595 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum *bufs);
# 6628 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
# 6686 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEX2HNVPROC) (GLhalfNV x, GLhalfNV y);
typedef void ( * PFNGLVERTEX2HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEX3HNVPROC) (GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void ( * PFNGLVERTEX3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEX4HNVPROC) (GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void ( * PFNGLVERTEX4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLNORMAL3HNVPROC) (GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
typedef void ( * PFNGLNORMAL3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLCOLOR3HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void ( * PFNGLCOLOR3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLCOLOR4HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
typedef void ( * PFNGLCOLOR4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD1HNVPROC) (GLhalfNV s);
typedef void ( * PFNGLTEXCOORD1HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD2HNVPROC) (GLhalfNV s, GLhalfNV t);
typedef void ( * PFNGLTEXCOORD2HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD3HNVPROC) (GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void ( * PFNGLTEXCOORD3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD4HNVPROC) (GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void ( * PFNGLTEXCOORD4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalfNV s);
typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t);
typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLFOGCOORDHNVPROC) (GLhalfNV fog);
typedef void ( * PFNGLFOGCOORDHVNVPROC) (const GLhalfNV *fog);
typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEXWEIGHTHNVPROC) (GLhalfNV weight);
typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalfNV *weight);
typedef void ( * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalfNV x);
typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y);
typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
# 6740 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
# 6750 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC) (void);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
# 6768 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLvoid* ( * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
# 6778 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
# 6789 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint *params);
# 6803 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
# 6815 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
# 6867 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint *renderbuffers);
typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint *renderbuffers);
typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint *framebuffers);
typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint *framebuffers);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void ( * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);







typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const GLvoid *string);
# 6903 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSTENCILCLEARTAGEXTPROC) (GLsizei stencilTagBits, GLuint stencilClearTag);
# 6915 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);







typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 6936 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);
# 6946 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
# 6956 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);
# 6980 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC) (GLenum target, GLuint index, GLint *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC) (GLenum target, GLuint index, GLuint *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERIIVNVPROC) (GLenum target, GLuint index, GLint *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC) (GLenum target, GLuint index, GLuint *params);
# 7006 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);







typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);
# 7047 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
# 7087 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
# 7106 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
# 7123 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 7145 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
typedef void ( * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void ( * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
# 7159 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 7177 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
# 7192 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum target, GLuint index, GLboolean *data);
typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLint *data);
typedef void ( * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
# 7215 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void ( * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
typedef void ( * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
# 7235 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);
typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
# 7250 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);
typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void ( * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);







typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC) (void);




}
# 2151 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h" 2
# 2165 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) GLhandleARB glCreateDebugObjectMESA (void);
__attribute__((visibility("default"))) void glClearDebugLogMESA (GLhandleARB obj, GLenum logType, GLenum shaderType);
__attribute__((visibility("default"))) void glGetDebugLogMESA (GLhandleARB obj, GLenum logType, GLenum shaderType, GLsizei maxLength,
                                         GLsizei *length, GLcharARB *debugLog);
__attribute__((visibility("default"))) GLsizei glGetDebugLogLengthMESA (GLhandleARB obj, GLenum logType, GLenum shaderType);
# 2204 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
typedef void (*GLprogramcallbackMESA)(GLenum target, GLvoid *data);

__attribute__((visibility("default"))) void glProgramCallbackMESA(GLenum target, GLprogramcallbackMESA callback, GLvoid *data);

__attribute__((visibility("default"))) void glGetProgramRegisterfvMESA(GLenum target, GLsizei len, const GLubyte *name, GLfloat *v);
# 2218 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glBlendEquationSeparateATI( GLenum modeRGB, GLenum modeA );
typedef void ( * PFNGLBLENDEQUATIONSEPARATEATIPROC) (GLenum modeRGB, GLenum modeA);
# 2249 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
}
# 57 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/qgl.h" 2
# 79 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/qgl.h"
typedef void (*GLExtension_t)(void);


 extern "C" {


GLExtension_t GLimp_ExtensionPointer( const char *name );


 }



extern void ( * qglMultiTexCoord2fARB )( GLenum texture, GLfloat s, GLfloat t );
extern void ( * qglMultiTexCoord2fvARB )( GLenum texture, GLfloat *st );
extern void ( * qglActiveTextureARB )( GLenum texture );
extern void ( * qglClientActiveTextureARB )( GLenum texture );


extern PFNGLBINDBUFFERARBPROC qglBindBufferARB;
extern PFNGLDELETEBUFFERSARBPROC qglDeleteBuffersARB;
extern PFNGLGENBUFFERSARBPROC qglGenBuffersARB;
extern PFNGLISBUFFERARBPROC qglIsBufferARB;
extern PFNGLBUFFERDATAARBPROC qglBufferDataARB;
extern PFNGLBUFFERSUBDATAARBPROC qglBufferSubDataARB;
extern PFNGLGETBUFFERSUBDATAARBPROC qglGetBufferSubDataARB;
extern PFNGLMAPBUFFERARBPROC qglMapBufferARB;
extern PFNGLUNMAPBUFFERARBPROC qglUnmapBufferARB;
extern PFNGLGETBUFFERPARAMETERIVARBPROC qglGetBufferParameterivARB;
extern PFNGLGETBUFFERPOINTERVARBPROC qglGetBufferPointervARB;



extern void ( *qglCombinerParameterfvNV )( GLenum pname, const GLfloat *params );
extern void ( *qglCombinerParameterivNV )( GLenum pname, const GLint *params );
extern void ( *qglCombinerParameterfNV )( GLenum pname, const GLfloat param );
extern void ( *qglCombinerParameteriNV )( GLenum pname, const GLint param );
extern void ( *qglCombinerInputNV )( GLenum stage, GLenum portion, GLenum variable, GLenum input,
             GLenum mapping, GLenum componentUsage );
extern void ( *qglCombinerOutputNV )( GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput,
              GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct,
              GLboolean cdDotProduct, GLboolean muxSum );
extern void ( *qglFinalCombinerInputNV )( GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage );


extern void ( *qglTexImage3D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);


extern void ( *qglColorTableEXT)( int, int, int, int, int, const void * );


extern PFNGLGENFRAGMENTSHADERSATIPROC qglGenFragmentShadersATI;
extern PFNGLBINDFRAGMENTSHADERATIPROC qglBindFragmentShaderATI;
extern PFNGLDELETEFRAGMENTSHADERATIPROC qglDeleteFragmentShaderATI;
extern PFNGLBEGINFRAGMENTSHADERATIPROC qglBeginFragmentShaderATI;
extern PFNGLENDFRAGMENTSHADERATIPROC qglEndFragmentShaderATI;
extern PFNGLPASSTEXCOORDATIPROC qglPassTexCoordATI;
extern PFNGLSAMPLEMAPATIPROC qglSampleMapATI;
extern PFNGLCOLORFRAGMENTOP1ATIPROC qglColorFragmentOp1ATI;
extern PFNGLCOLORFRAGMENTOP2ATIPROC qglColorFragmentOp2ATI;
extern PFNGLCOLORFRAGMENTOP3ATIPROC qglColorFragmentOp3ATI;
extern PFNGLALPHAFRAGMENTOP1ATIPROC qglAlphaFragmentOp1ATI;
extern PFNGLALPHAFRAGMENTOP2ATIPROC qglAlphaFragmentOp2ATI;
extern PFNGLALPHAFRAGMENTOP3ATIPROC qglAlphaFragmentOp3ATI;
extern PFNGLSETFRAGMENTSHADERCONSTANTATIPROC qglSetFragmentShaderConstantATI;


extern PFNGLACTIVESTENCILFACEEXTPROC qglActiveStencilFaceEXT;



extern PFNGLSTENCILOPSEPARATEATIPROC qglStencilOpSeparateATI;
extern PFNGLSTENCILFUNCSEPARATEATIPROC qglStencilFuncSeparateATI;


extern PFNGLCOMPRESSEDTEXIMAGE2DARBPROC qglCompressedTexImage2DARB;
extern PFNGLGETCOMPRESSEDTEXIMAGEARBPROC qglGetCompressedTexImageARB;


extern PFNGLVERTEXATTRIBPOINTERARBPROC qglVertexAttribPointerARB;
extern PFNGLENABLEVERTEXATTRIBARRAYARBPROC qglEnableVertexAttribArrayARB;
extern PFNGLDISABLEVERTEXATTRIBARRAYARBPROC qglDisableVertexAttribArrayARB;
extern PFNGLPROGRAMSTRINGARBPROC qglProgramStringARB;
extern PFNGLBINDPROGRAMARBPROC qglBindProgramARB;
extern PFNGLGENPROGRAMSARBPROC qglGenProgramsARB;
extern PFNGLPROGRAMENVPARAMETER4FVARBPROC qglProgramEnvParameter4fvARB;
extern PFNGLPROGRAMLOCALPARAMETER4FVARBPROC qglProgramLocalParameter4fvARB;


extern PFNGLDEPTHBOUNDSEXTPROC qglDepthBoundsEXT;






# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/qgl_linked.h" 1
# 176 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/qgl.h" 2
# 149 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Cinematic.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Cinematic.h"
typedef enum {
 FMV_IDLE,
 FMV_PLAY,
 FMV_EOF,
 FMV_ID_BLT,
 FMV_ID_IDLE,
 FMV_LOOPED,
 FMV_ID_WAIT
} cinStatus_t;


typedef struct {
 int imageWidth, imageHeight;
 const byte * image;
 int status;
} cinData_t;

class idCinematic {
public:

 static void InitCinematic( void );


 static void ShutdownCinematic( void );



 static idCinematic *Alloc();


 virtual ~idCinematic();


 virtual bool InitFromFile( const char *qpath, bool looping );


 virtual int AnimationLength();


 virtual cinData_t ImageForTime( int milliseconds );


 virtual void Close();


 virtual void ResetTime(int time);
};
# 100 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Cinematic.h"
class idSndWindow : public idCinematic {
public:

      idSndWindow() { showWaveform = false; }
      ~idSndWindow() {}

 bool InitFromFile( const char *qpath, bool looping );
 cinData_t ImageForTime( int milliseconds );
 int AnimationLength();

private:
 bool showWaveform;
};
# 150 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Material.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Material.h"
class idImage;
class idCinematic;
class idUserInterface;
class idMegaTexture;


typedef enum {
 TF_LINEAR,
 TF_NEAREST,
 TF_DEFAULT
} textureFilter_t;

typedef enum {
 TR_REPEAT,
 TR_CLAMP,
 TR_CLAMP_TO_BORDER,

 TR_CLAMP_TO_ZERO,

 TR_CLAMP_TO_ZERO_ALPHA

} textureRepeat_t;

typedef struct {
 int stayTime;
 int fadeTime;
 float start[4];
 float end[4];
} decalInfo_t;

typedef enum {
 DFRM_NONE,
 DFRM_SPRITE,
 DFRM_TUBE,
 DFRM_FLARE,
 DFRM_EXPAND,
 DFRM_MOVE,
 DFRM_EYEBALL,
 DFRM_PARTICLE,
 DFRM_PARTICLE2,
 DFRM_TURB
} deform_t;

typedef enum {
 DI_STATIC,
 DI_SCRATCH,
 DI_CUBE_RENDER,
 DI_MIRROR_RENDER,
 DI_XRAY_RENDER,
 DI_REMOTE_RENDER
} dynamicidImage_t;


typedef enum {
 OP_TYPE_ADD,
 OP_TYPE_SUBTRACT,
 OP_TYPE_MULTIPLY,
 OP_TYPE_DIVIDE,
 OP_TYPE_MOD,
 OP_TYPE_TABLE,
 OP_TYPE_GT,
 OP_TYPE_GE,
 OP_TYPE_LT,
 OP_TYPE_LE,
 OP_TYPE_EQ,
 OP_TYPE_NE,
 OP_TYPE_AND,
 OP_TYPE_OR,
 OP_TYPE_SOUND
} expOpType_t;

typedef enum {
 EXP_REG_TIME,

 EXP_REG_PARM0,
 EXP_REG_PARM1,
 EXP_REG_PARM2,
 EXP_REG_PARM3,
 EXP_REG_PARM4,
 EXP_REG_PARM5,
 EXP_REG_PARM6,
 EXP_REG_PARM7,
 EXP_REG_PARM8,
 EXP_REG_PARM9,
 EXP_REG_PARM10,
 EXP_REG_PARM11,

 EXP_REG_GLOBAL0,
 EXP_REG_GLOBAL1,
 EXP_REG_GLOBAL2,
 EXP_REG_GLOBAL3,
 EXP_REG_GLOBAL4,
 EXP_REG_GLOBAL5,
 EXP_REG_GLOBAL6,
 EXP_REG_GLOBAL7,

 EXP_REG_NUM_PREDEFINED
} expRegister_t;

typedef struct {
 expOpType_t opType;
 int a, b, c;
} expOp_t;

typedef struct {
 int registers[4];
} colorStage_t;

typedef enum {
 TG_EXPLICIT,
 TG_DIFFUSE_CUBE,
 TG_REFLECT_CUBE,
 TG_SKYBOX_CUBE,
 TG_WOBBLESKY_CUBE,
 TG_SCREEN,
 TG_SCREEN2,
 TG_GLASSWARP
} texgen_t;

typedef struct {
 idCinematic * cinematic;
 idImage * image;
 texgen_t texgen;
 bool hasMatrix;
 int matrix[2][3];


 dynamicidImage_t dynamic;
 int width, height;
 int dynamicFrameCount;
} textureStage_t;


typedef enum {
 SL_AMBIENT,
 SL_BUMP,
 SL_DIFFUSE,
 SL_SPECULAR
} stageLighting_t;



typedef enum {
 SVC_IGNORE,
 SVC_MODULATE,
 SVC_INVERSE_MODULATE
} stageVertexColor_t;

static const int MAX_FRAGMENT_IMAGES = 8;
static const int MAX_VERTEX_PARMS = 4;

typedef struct {
 int vertexProgram;
 int numVertexParms;
 int vertexParms[MAX_VERTEX_PARMS][4];

 int fragmentProgram;
 int numFragmentProgramImages;
 idImage * fragmentProgramImages[MAX_FRAGMENT_IMAGES];

 idMegaTexture *megaTexture;
} newShaderStage_t;

typedef struct {
 int conditionRegister;
 stageLighting_t lighting;
 int drawStateBits;
 colorStage_t color;
 bool hasAlphaTest;
 int alphaTestRegister;
 textureStage_t texture;
 stageVertexColor_t vertexColor;
 bool ignoreAlphaTest;

 float privatePolygonOffset;

 newShaderStage_t *newStage;
} shaderStage_t;

typedef enum {
 MC_BAD,
 MC_OPAQUE,
 MC_PERFORATED,
 MC_TRANSLUCENT
} materialCoverage_t;

typedef enum {
 SS_SUBVIEW = -3,
 SS_GUI = -2,
 SS_BAD = -1,
 SS_OPAQUE,

 SS_PORTAL_SKY,

 SS_DECAL,

 SS_FAR,
 SS_MEDIUM,
 SS_CLOSE,

 SS_ALMOST_NEAREST,

 SS_NEAREST,

 SS_POST_PROCESS = 100
} materialSort_t;

typedef enum {
 CT_FRONT_SIDED,
 CT_BACK_SIDED,
 CT_TWO_SIDED
} cullType_t;


const int MAX_SHADER_STAGES = 256;

const int MAX_TEXGEN_REGISTERS = 4;

const int MAX_ENTITY_SHADER_PARMS = 12;


typedef enum {
 MF_DEFAULTED = ( 1 << ( 0 ) ),
 MF_POLYGONOFFSET = ( 1 << ( 1 ) ),
 MF_NOSHADOWS = ( 1 << ( 2 ) ),
 MF_FORCESHADOWS = ( 1 << ( 3 ) ),
 MF_NOSELFSHADOW = ( 1 << ( 4 ) ),
 MF_NOPORTALFOG = ( 1 << ( 5 ) ),
 MF_EDITOR_VISIBLE = ( 1 << ( 6 ) )
} materialFlags_t;


typedef enum {
 CONTENTS_SOLID = ( 1 << ( 0 ) ),
 CONTENTS_OPAQUE = ( 1 << ( 1 ) ),
 CONTENTS_WATER = ( 1 << ( 2 ) ),
 CONTENTS_PLAYERCLIP = ( 1 << ( 3 ) ),
 CONTENTS_MONSTERCLIP = ( 1 << ( 4 ) ),
 CONTENTS_MOVEABLECLIP = ( 1 << ( 5 ) ),
 CONTENTS_IKCLIP = ( 1 << ( 6 ) ),
 CONTENTS_BLOOD = ( 1 << ( 7 ) ),
 CONTENTS_BODY = ( 1 << ( 8 ) ),
 CONTENTS_PROJECTILE = ( 1 << ( 9 ) ),
 CONTENTS_CORPSE = ( 1 << ( 10 ) ),
 CONTENTS_RENDERMODEL = ( 1 << ( 11 ) ),
 CONTENTS_TRIGGER = ( 1 << ( 12 ) ),
 CONTENTS_AAS_SOLID = ( 1 << ( 13 ) ),
 CONTENTS_AAS_OBSTACLE = ( 1 << ( 14 ) ),
 CONTENTS_FLASHLIGHT_TRIGGER = ( 1 << ( 15 ) ),


 CONTENTS_AREAPORTAL = ( 1 << ( 20 ) ),
 CONTENTS_NOCSG = ( 1 << ( 21 ) ),

 CONTENTS_REMOVE_UTIL = ~(CONTENTS_AREAPORTAL|CONTENTS_NOCSG)
} contentsFlags_t;


const int NUM_SURFACE_BITS = 4;
const int MAX_SURFACE_TYPES = 1 << NUM_SURFACE_BITS;

typedef enum {
 SURFTYPE_NONE,
    SURFTYPE_METAL,
 SURFTYPE_STONE,
 SURFTYPE_FLESH,
 SURFTYPE_WOOD,
 SURFTYPE_CARDBOARD,
 SURFTYPE_LIQUID,
 SURFTYPE_GLASS,
 SURFTYPE_PLASTIC,
 SURFTYPE_RICOCHET,
 SURFTYPE_10,
 SURFTYPE_11,
 SURFTYPE_12,
 SURFTYPE_13,
 SURFTYPE_14,
 SURFTYPE_15
} surfTypes_t;


typedef enum {
 SURF_TYPE_BIT0 = ( 1 << ( 0 ) ),
 SURF_TYPE_BIT1 = ( 1 << ( 1 ) ),
 SURF_TYPE_BIT2 = ( 1 << ( 2 ) ),
 SURF_TYPE_BIT3 = ( 1 << ( 3 ) ),
 SURF_TYPE_MASK = ( 1 << NUM_SURFACE_BITS ) - 1,

 SURF_NODAMAGE = ( 1 << ( 4 ) ),
 SURF_SLICK = ( 1 << ( 5 ) ),
 SURF_COLLISION = ( 1 << ( 6 ) ),
 SURF_LADDER = ( 1 << ( 7 ) ),
 SURF_NOIMPACT = ( 1 << ( 8 ) ),
 SURF_NOSTEPS = ( 1 << ( 9 ) ),
 SURF_DISCRETE = ( 1 << ( 10 ) ),
 SURF_NOFRAGMENT = ( 1 << ( 11 ) ),
 SURF_NULLNORMAL = ( 1 << ( 12 ) )

} surfaceFlags_t;

class idSoundEmitter;

class idMaterial : public idDecl {
public:
      idMaterial();
 virtual ~idMaterial();

 virtual size_t Size( void ) const;
 virtual bool SetDefaultText( void );
 virtual const char *DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;


 bool Save( const char *fileName = __null );




 virtual const char *ImageName( void ) const;

 void ReloadImages( bool force ) const;


 const int GetNumStages( void ) const { return numStages; }


 const shaderStage_t *GetStage( const int index ) const { ((void)0); return &stages[index]; }



 const shaderStage_t *GetBumpStage( void ) const;





 bool IsDrawn( void ) const { return ( numStages > 0 || entityGui != 0 || gui != __null ); }


 bool HasAmbient( void ) const { return ( numAmbientStages > 0 ); }


 bool HasGui( void ) const { return ( entityGui != 0 || gui != __null ); }



 bool HasSubview( void ) const { return hasSubview; }



 bool SurfaceCastsShadow( void ) const { return TestMaterialFlag( MF_FORCESHADOWS ) || !TestMaterialFlag( MF_NOSHADOWS ); }



 bool ReceivesFog( void ) const { return ( IsDrawn() && !noFog && coverage != MC_TRANSLUCENT ); }




 bool ReceivesLighting( void ) const { return numAmbientStages != numStages; }



 bool ReceivesLightingOnBackSides( void ) const { return ( materialFlags & (MF_NOSELFSHADOW|MF_NOSHADOWS) ) != 0; }






 bool ShouldCreateBackSides( void ) const { return shouldCreateBackSides; }




 bool UseUnsmoothedTangents( void ) const { return unsmoothedTangents; }




 bool AllowOverlays( void ) const { return allowOverlays; }





 materialCoverage_t Coverage( void ) const { return coverage; }


 bool HasHigherDmapPriority( const idMaterial &other ) const { return ( IsDrawn() && !other.IsDrawn() ) ||
                      ( Coverage() < other.Coverage() ); }


 idUserInterface * GlobalGui( void ) const { return gui; }





 bool IsDiscrete( void ) const { return ( entityGui || gui || deform != DFRM_NONE || sort == SS_SUBVIEW ||
            ( surfaceFlags & SURF_DISCRETE ) != 0 ); }
# 452 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Material.h"
 bool NoFragment( void ) const { return ( surfaceFlags & SURF_NOFRAGMENT ) != 0; }





 bool IsFogLight() const { return fogLight; }


 bool IsBlendLight() const { return blendLight; }


 bool IsAmbientLight() const { return ambientLight; }



 bool LightCastsShadows() const { return TestMaterialFlag( MF_FORCESHADOWS ) ||
        ( !fogLight && !ambientLight && !blendLight && !TestMaterialFlag( MF_NOSHADOWS ) ); }







 bool LightEffectsBackSides() const { return fogLight || ambientLight || blendLight; }


 idImage * LightFalloffImage() const { return lightFalloffImage; }




 const char * GetRenderBump() const { return renderBump; };


 void SetMaterialFlag( const int flag ) const { materialFlags |= flag; }


 void ClearMaterialFlag( const int flag ) const { materialFlags &= ~flag; }


 bool TestMaterialFlag( const int flag ) const { return ( materialFlags & flag ) != 0; }


 const int GetContentFlags( void ) const { return contentFlags; }


 const int GetSurfaceFlags( void ) const { return surfaceFlags; }


 const surfTypes_t GetSurfaceType( void ) const { return static_cast<surfTypes_t>( surfaceFlags & SURF_TYPE_MASK ); }


 const char * GetDescription( void ) const { return desc; }


 const float GetSort( void ) const { return sort; }



 void SetSort( float s ) const { sort = s; };


 deform_t Deform( void ) const { return deform; }


 const int GetDeformRegister( int index ) const { return deformRegisters[index]; }


 const idDecl *GetDeformDecl( void ) const { return deformDecl; }


 texgen_t Texgen() const;


 const int * GetTexGenRegisters( void ) const { return texGenRegisters; }


 const cullType_t GetCullType( void ) const { return cullType; }

 float GetEditorAlpha( void ) const { return editorAlpha; }

 int GetEntityGui( void ) const { return entityGui; }

 decalInfo_t GetDecalInfo( void ) const { return decalInfo; }



 int Spectrum( void ) const { return spectrum; }

 float GetPolygonOffset( void ) const { return polygonOffset; }

 float GetSurfaceArea( void ) const { return surfaceArea; }
 void AddToSurfaceArea( float area ) { surfaceArea += area; }





 int CinematicLength( void ) const;

 void CloseCinematic( void ) const;

 void ResetCinematicTime( int time ) const;

 void UpdateCinematic( int time ) const;




 idImage * GetEditorImage( void ) const;
 int GetImageWidth( void ) const;
 int GetImageHeight( void ) const;

 void SetGui( const char *_gui ) const;


 void SetImageClassifications( int tag ) const;




 const int GetNumRegisters() const { return numRegisters; }


 void EvaluateRegisters( float *regs, const float entityParms[MAX_ENTITY_SHADER_PARMS],
           const struct viewDef_s *view, idSoundEmitter *soundEmitter = __null ) const;




 const float * ConstantRegisters() const;

 bool SuppressInSubview() const { return suppressInSubview; };
 bool IsPortalSky() const { return portalSky; };
 void AddReference();

private:

 void CommonInit();
 void ParseMaterial( idLexer &src );
 bool MatchToken( idLexer &src, const char *match );
 void ParseSort( idLexer &src );
 void ParseBlend( idLexer &src, shaderStage_t *stage );
 void ParseVertexParm( idLexer &src, newShaderStage_t *newStage );
 void ParseFragmentMap( idLexer &src, newShaderStage_t *newStage );
 void ParseStage( idLexer &src, const textureRepeat_t trpDefault = TR_REPEAT );
 void ParseDeform( idLexer &src );
 void ParseDecalInfo( idLexer &src );
 bool CheckSurfaceParm( idToken *token );
 int GetExpressionConstant( float f );
 int GetExpressionTemporary( void );
 expOp_t * GetExpressionOp( void );
 int EmitOp( int a, int b, expOpType_t opType );
 int ParseEmitOp( idLexer &src, int a, expOpType_t opType, int priority );
 int ParseTerm( idLexer &src );
 int ParseExpressionPriority( idLexer &src, int priority );
 int ParseExpression( idLexer &src );
 void ClearStage( shaderStage_t *ss );
 int NameToSrcBlendMode( const idStr &name );
 int NameToDstBlendMode( const idStr &name );
 void MultiplyTextureMatrix( textureStage_t *ts, int registers[2][3] );
 void SortInteractionStages();
 void AddImplicitStages( const textureRepeat_t trpDefault = TR_REPEAT );
 void CheckForConstantRegisters();

private:
 idStr desc;
 idStr renderBump;

 idImage * lightFalloffImage;

 int entityGui;

 mutable idUserInterface *gui;

 bool noFog;

 int spectrum;

 float polygonOffset;

 int contentFlags;
 int surfaceFlags;
 mutable int materialFlags;

 decalInfo_t decalInfo;


 mutable float sort;
 deform_t deform;
 int deformRegisters[4];
 const idDecl *deformDecl;

 int texGenRegisters[MAX_TEXGEN_REGISTERS];

 materialCoverage_t coverage;
 cullType_t cullType;
 bool shouldCreateBackSides;

 bool fogLight;
 bool blendLight;
 bool ambientLight;
 bool unsmoothedTangents;
 bool hasSubview;
 bool allowOverlays;

 int numOps;
 expOp_t * ops;

 int numRegisters;
 float * expressionRegisters;

 float * constantRegisters;

 int numStages;
 int numAmbientStages;

 shaderStage_t * stages;

 struct mtrParsingData_s *pd;

 float surfaceArea;




 idStr editorImageName;
 mutable idImage * editorImage;
 float editorAlpha;

 bool suppressInSubview;
 bool portalSky;
 int refCount;
};

typedef idList<const idMaterial *> idMatList;
# 151 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Model.h" 1
# 52 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Model.h"
typedef int glIndex_t;
# 62 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Model.h"
typedef struct {

 glIndex_t p1, p2;
 glIndex_t v1, v2;
} silEdge_t;


typedef struct dominantTri_s {
 glIndex_t v2, v3;
 float normalizationScale[3];
} dominantTri_t;

typedef struct lightingCache_s {
 idVec3 localLightVector;

} lightingCache_t;

typedef struct shadowCache_s {
 idVec4 xyz;
} shadowCache_t;

const int SHADOW_CAP_INFINITE = 64;


typedef struct srfTriangles_s {
 idBounds bounds;

 int ambientViewCount;

 bool generateNormals;
 bool tangentsCalculated;
 bool facePlanesCalculated;
 bool perfectHull;
 bool deformedSurface;


 int numVerts;
 idDrawVert * verts;

 int numIndexes;
 glIndex_t * indexes;

 glIndex_t * silIndexes;

 int numMirroredVerts;
 int * mirroredVerts;

 int numDupVerts;
 int * dupVerts;

 int numSilEdges;
 silEdge_t * silEdges;

 idPlane * facePlanes;

 dominantTri_t * dominantTris;

 int numShadowIndexesNoFrontCaps;
 int numShadowIndexesNoCaps;

 int shadowCapPlaneBits;




 shadowCache_t * shadowVertexes;


 struct srfTriangles_s * ambientSurface;


 struct srfTriangles_s * nextDeferredFree;


 struct vertCache_s * indexCache;
 struct vertCache_s * ambientCache;
 struct vertCache_s * lightingCache;
 struct vertCache_s * shadowCache;
} srfTriangles_t;

typedef idList<srfTriangles_t *> idTriList;

typedef struct modelSurface_s {
 int id;
 const idMaterial * shader;
 srfTriangles_t * geometry;
} modelSurface_t;

typedef enum {
 DM_STATIC,
 DM_CACHED,
 DM_CONTINUOUS
} dynamicModel_t;

typedef enum {
 INVALID_JOINT = -1
} jointHandle_t;

class idMD5Joint {
public:
        idMD5Joint() { parent = __null; }
 idStr name;
 const idMD5Joint * parent;
};





class idRenderModel {
public:
 virtual ~idRenderModel() {};


 virtual void InitFromFile( const char *fileName ) = 0;



 virtual void PartialInitFromFile( const char *fileName ) = 0;



 virtual void InitEmpty( const char *name, const char *filename = __null, int fileoffset = 0 ) = 0;




 virtual void AddSurface( modelSurface_t surface ) = 0;






 virtual void FinishSurfaces() = 0;



 virtual void PurgeModel() = 0;



 virtual void Reset() = 0;



 virtual void LoadModel() = 0;


 virtual bool IsLoaded() = 0;
 virtual void SetLevelLoadReferenced( bool referenced ) = 0;
 virtual bool IsLevelLoadReferenced() = 0;




 virtual void TouchData() = 0;


 virtual void FreeVertexCache() = 0;


 virtual const char * Name() const = 0;
 virtual const char * GetFileName() const = 0;
 virtual int GetFileOffset() const = 0;


 virtual void Print() const = 0;


 virtual void List() const = 0;


 virtual int Memory() const = 0;


 virtual time_t Timestamp() const = 0;


 virtual int NumSurfaces() const = 0;


 virtual int NumBaseSurfaces() const = 0;


 virtual const modelSurface_t *Surface( int surfaceNum ) const = 0;





 virtual srfTriangles_t * AllocSurfaceTriangles( int numVerts, int numIndexes ) const = 0;


 virtual void FreeSurfaceTriangles( srfTriangles_t *tris ) const = 0;





 virtual srfTriangles_t * ShadowHull() const = 0;


 virtual bool IsStaticWorldModel() const = 0;



 virtual bool IsReloadable() const = 0;


 virtual dynamicModel_t IsDynamicModel() const = 0;


 virtual bool IsDefaultModel() const = 0;



 virtual idBounds Bounds( const struct renderEntity_s *ent = __null ) const = 0;


 virtual float DepthHack() const = 0;
# 291 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/Model.h"
 virtual idRenderModel * InstantiateDynamicModel( const struct renderEntity_s *ent, const struct viewDef_s *view, idRenderModel *cachedModel ) = 0;


 virtual int NumJoints( void ) const = 0;


 virtual const idMD5Joint * GetJoints( void ) const = 0;


 virtual jointHandle_t GetJointHandle( const char *name ) const = 0;


 virtual const char * GetJointName( jointHandle_t handle ) const = 0;


 virtual const idJointQuat * GetDefaultPose( void ) const = 0;


 virtual int NearestJoint( int surfaceNum, int a, int c, int b ) const = 0;


 virtual void ReadFromDemoFile( class idDemoFile *f ) = 0;
 virtual void WriteToDemoFile( class idDemoFile *f ) = 0;
};
# 152 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/ModelManager.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/ModelManager.h"
class idRenderModelManager {
public:
 virtual ~idRenderModelManager() {}


 virtual void Init() = 0;


 virtual void Shutdown() = 0;


 virtual void BeginLevelLoad() = 0;


 virtual void EndLevelLoad() = 0;


 virtual idRenderModel * AllocModel() = 0;


 virtual void FreeModel( idRenderModel *model ) = 0;



 virtual idRenderModel * FindModel( const char *modelName ) = 0;


 virtual idRenderModel * CheckModel( const char *modelName ) = 0;


 virtual idRenderModel * DefaultModel() = 0;


 virtual void AddModel( idRenderModel *model ) = 0;




 virtual void RemoveModel( idRenderModel *model ) = 0;


 virtual void VirtualizeAll( void ) = 0;



 virtual void ReloadModels( bool forceAll = false ) = 0;


 virtual void WritePrecacheCommands( idFile *f ) = 0;


 virtual void FreeModelVertexCaches() = 0;


 virtual void PrintMemInfo( MemInfo_t *mi ) = 0;
};


extern idRenderModelManager *renderModelManager;
# 153 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderSystem.h" 1
# 33 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderSystem.h"
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 1 3
# 39 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3
       
# 40 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 93 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 34 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderSystem.h" 2
using namespace std;
# 50 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderSystem.h"
typedef struct glconfig_s {
 const char *renderer_string;
 const char *vendor_string;
 const char *version_string;
 const char *extensions_string;
 const char *wgl_extensions_string;

 float glVersion;


 int maxTextureSize;
 int maxTextureUnits;
 int maxTextureCoords;
 int maxTextureImageUnits;
 float maxTextureAnisotropy;

 int colorBits, depthBits, stencilBits;

 bool multitextureAvailable;
 bool textureCompressionAvailable;
 bool anisotropicAvailable;
 bool textureLODBiasAvailable;
 bool textureEnvAddAvailable;
 bool textureEnvCombineAvailable;
 bool registerCombinersAvailable;
 bool cubeMapAvailable;
 bool envDot3Available;
 bool texture3DAvailable;
 bool sharedTexturePaletteAvailable;
 bool ARBVertexBufferObjectAvailable;
 bool ARBVertexProgramAvailable;
 bool ARBFragmentProgramAvailable;
 bool twoSidedStencilAvailable;
 bool textureNonPowerOfTwoAvailable;
 bool depthBoundsTestAvailable;


 bool atiFragmentShaderAvailable;


 bool atiTwoSidedStencilAvailable;

 int vidWidth, vidHeight;

 int displayFrequency;

 bool isFullscreen;

 bool allowNV30Path;
 bool allowNV20Path;
 bool allowNV10Path;
 bool allowR200Path;
 bool allowARB2Path;

 bool isInitialized;
} glconfig_t;



const int GLYPH_START = 0;
const int GLYPH_END = 255;
const int GLYPH_CHARSTART = 32;
const int GLYPH_CHAREND = 127;
const int GLYPHS_PER_FONT = GLYPH_END - GLYPH_START + 1;

typedef struct {
 int height;
 int top;
 int bottom;
 int pitch;
 int xSkip;
 int imageWidth;
 int imageHeight;
 float s;
 float t;
 float s2;
 float t2;
 const idMaterial * glyph;
 char shaderName[32];
} glyphInfo_t;

typedef struct {
 glyphInfo_t glyphs [GLYPHS_PER_FONT];
 float glyphScale;
 char name[64];
} fontInfo_t;


class fontInfoEx_t {
public:

 fontInfoEx_t(void);
 ~fontInfoEx_t(void) {};

 static void * operator new(size_t size) throw(std::bad_alloc);
 static void operator delete(void *pMem) throw();
 static void * operator new[](size_t size) throw(std::bad_alloc);
 static void operator delete[](void *pMem) throw();

 fontInfo_t fontInfoSmall;
 fontInfo_t fontInfoMedium;
 fontInfo_t fontInfoLarge;
 int maxHeight;
 int maxWidth;
 int maxHeightSmall;
 int maxWidthSmall;
 int maxHeightMedium;
 int maxWidthMedium;
 int maxHeightLarge;
 int maxWidthLarge;
 char name[64];
};
# 179 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderSystem.h"
const int SMALLCHAR_WIDTH = 8;
const int SMALLCHAR_HEIGHT = 16;
const int BIGCHAR_WIDTH = 16;
const int BIGCHAR_HEIGHT = 16;



const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;

class idRenderWorld;


class idRenderSystem {
public:

 virtual ~idRenderSystem() {};



 virtual void Init( void ) = 0;


 virtual void Shutdown( void ) = 0;

 virtual void InitOpenGL( void ) = 0;

 virtual void ShutdownOpenGL( void ) = 0;

 virtual bool IsOpenGLRunning( void ) const = 0;

 virtual bool IsFullScreen( void ) const = 0;
 virtual int GetScreenWidth( void ) const = 0;
 virtual int GetScreenHeight( void ) const = 0;


 virtual idRenderWorld * AllocRenderWorld( void ) = 0;
 virtual void FreeRenderWorld( idRenderWorld * rw ) = 0;





 virtual void BeginLevelLoad( void ) = 0;
 virtual void EndLevelLoad( void ) = 0;


 virtual bool RegisterFont( const char *fontName, fontInfoEx_t &font ) = 0;


 virtual void SetColor( const idVec4 &rgba ) = 0;
 virtual void SetColor4( float r, float g, float b, float a ) = 0;

 virtual void DrawStretchPic( const idDrawVert *verts, const glIndex_t *indexes, int vertCount, int indexCount, const idMaterial *material,
           bool clip = true, float min_x = 0.0f, float min_y = 0.0f, float max_x = 640.0f, float max_y = 480.0f ) = 0;
 virtual void DrawStretchPic( float x, float y, float w, float h, float s1, float t1, float s2, float t2, const idMaterial *material ) = 0;

 virtual void DrawStretchTri ( idVec2 p1, idVec2 p2, idVec2 p3, idVec2 t1, idVec2 t2, idVec2 t3, const idMaterial *material ) = 0;
 virtual void GlobalToNormalizedDeviceCoordinates( const idVec3 &global, idVec3 &ndc ) = 0;
 virtual void GetGLSettings( int& width, int& height ) = 0;
 virtual void PrintMemInfo( MemInfo_t *mi ) = 0;

 virtual void DrawSmallChar( int x, int y, int ch, const idMaterial *material ) = 0;
 virtual void DrawSmallStringExt( int x, int y, const char *string, const idVec4 &setColor, bool forceColor, const idMaterial *material ) = 0;
 virtual void DrawBigChar( int x, int y, int ch, const idMaterial *material ) = 0;
 virtual void DrawBigStringExt( int x, int y, const char *string, const idVec4 &setColor, bool forceColor, const idMaterial *material ) = 0;


 virtual void WriteDemoPics() = 0;


 virtual void DrawDemoPics() = 0;






 virtual void BeginFrame( int windowWidth, int windowHeight ) = 0;


 virtual void EndFrame( int *frontEndMsec, int *backEndMsec ) = 0;
# 269 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderSystem.h"
 virtual void TakeScreenshot( int width, int height, const char *fileName, int samples, struct renderView_s *ref ) = 0;
# 280 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderSystem.h"
 virtual void CropRenderSize( int width, int height, bool makePowerOfTwo = false, bool forceDimensions = false ) = 0;
 virtual void CaptureRenderToImage( const char *imageName ) = 0;


 virtual void CaptureRenderToFile( const char *fileName, bool fixAlpha = false ) = 0;
 virtual void UnCrop() = 0;
 virtual void GetCardCaps( bool &oldCard, bool &nv10or20 ) = 0;




 virtual bool UploadImage( const char *imageName, const byte *data, int width, int height ) = 0;
};

extern idRenderSystem * renderSystem;






void R_RenderLightFrustum( const struct renderLight_s &renderLight, idPlane lightFrustum[6] );


void R_LightProjectionMatrix( const idVec3 &origin, const idPlane &rearPlane, idVec4 mat[4] );


void R_ScreenshotFilename( int &lastNumber, const char *base, idStr &fileName );
# 154 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderWorld.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderWorld.h"
const int MAX_GLOBAL_SHADER_PARMS = 12;

const int SHADERPARM_RED = 0;
const int SHADERPARM_GREEN = 1;
const int SHADERPARM_BLUE = 2;
const int SHADERPARM_ALPHA = 3;
const int SHADERPARM_TIMESCALE = 3;
const int SHADERPARM_TIMEOFFSET = 4;
const int SHADERPARM_DIVERSITY = 5;
const int SHADERPARM_MODE = 7;
const int SHADERPARM_TIME_OF_DEATH = 7;


const int SHADERPARM_MD5_SKINSCALE = 8;

const int SHADERPARM_MD3_FRAME = 8;
const int SHADERPARM_MD3_LASTFRAME = 9;
const int SHADERPARM_MD3_BACKLERP = 10;

const int SHADERPARM_BEAM_END_X = 8;
const int SHADERPARM_BEAM_END_Y = 9;
const int SHADERPARM_BEAM_END_Z = 10;
const int SHADERPARM_BEAM_WIDTH = 11;

const int SHADERPARM_SPRITE_WIDTH = 8;
const int SHADERPARM_SPRITE_HEIGHT = 9;

const int SHADERPARM_PARTICLE_STOPTIME = 8;


const int MAX_RENDERENTITY_GUI = 3;


typedef bool(*deferredEntityCallback_t)( renderEntity_s *, const renderView_s * );


typedef struct renderEntity_s {
 idRenderModel * hModel;

 int entityNum;
 int bodyId;
# 95 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderWorld.h"
 idBounds bounds;
 deferredEntityCallback_t callback;

 void * callbackData;





 int suppressSurfaceInViewID;
 int suppressShadowInViewID;



 int suppressShadowInLightID;



 int allowSurfaceInViewID;





 idVec3 origin;
 idMat3 axis;


 const idMaterial * customShader;
 const idMaterial * referenceShader;
 const idDeclSkin * customSkin;
 class idSoundEmitter * referenceSound;
 float shaderParms[ MAX_ENTITY_SHADER_PARMS ];


 class idUserInterface * gui[ MAX_RENDERENTITY_GUI ];

 struct renderView_s * remoteRenderView;

 int numJoints;
 idJointMat * joints;


 float modelDepthHack;


 bool noSelfShadow;
 bool noShadow;

 bool noDynamicInteractions;




 bool weaponDepthHack;

 int forceUpdate;
 int timeGroup;
 int xrayIndex;
} renderEntity_t;


typedef struct renderLight_s {
 idMat3 axis;
 idVec3 origin;




 int suppressLightInViewID;



 int allowLightInViewID;




 bool noShadows;
 bool noSpecular;

 bool pointLight;
 bool parallel;
 idVec3 lightRadius;
 idVec3 lightCenter;





 idVec3 target;
 idVec3 right;
 idVec3 up;
 idVec3 start;
 idVec3 end;




 idRenderModel * prelightModel;


 int lightId;


 const idMaterial * shader;
 float shaderParms[MAX_ENTITY_SHADER_PARMS];
 idSoundEmitter * referenceSound;
} renderLight_t;


typedef struct renderView_s {


 int viewID;


 int x, y, width, height;

 float fov_x, fov_y;
 idVec3 vieworg;
 idMat3 viewaxis;

 bool cramZNear;
 bool forceUpdate;


 int time;
 float shaderParms[MAX_GLOBAL_SHADER_PARMS];
 const idMaterial *globalMaterial;
} renderView_t;



typedef struct {
 int areas[2];
 const idWinding * w;
 int blockingBits;
 qhandle_t portalHandle;
} exitPortal_t;



typedef struct {
 float x, y;
 int guiId;
} guiPoint_t;



typedef struct modelTrace_s {
 float fraction;
 idVec3 point;
 idVec3 normal;
 const idMaterial * material;
 const renderEntity_t * entity;
 int jointNumber;
} modelTrace_t;


static const int NUM_PORTAL_ATTRIBUTES = 3;

typedef enum {
 PS_BLOCK_NONE = 0,

 PS_BLOCK_VIEW = 1,
 PS_BLOCK_LOCATION = 2,
 PS_BLOCK_AIR = 4,

 PS_BLOCK_ALL = (1<<NUM_PORTAL_ATTRIBUTES)-1
} portalConnection_t;


class idRenderWorld {
public:
 virtual ~idRenderWorld() {};

 virtual bool ReloadModelFromMapFile( idRenderModel * model ) = 0;


 virtual bool InitFromMap( const char *mapName ) = 0;






 virtual qhandle_t AddEntityDef( const renderEntity_t *re ) = 0;
 virtual void UpdateEntityDef( qhandle_t entityHandle, const renderEntity_t *re ) = 0;
 virtual void FreeEntityDef( qhandle_t entityHandle ) = 0;
 virtual const renderEntity_t *GetRenderEntity( qhandle_t entityHandle ) const = 0;

 virtual qhandle_t AddLightDef( const renderLight_t *rlight ) = 0;
 virtual void UpdateLightDef( qhandle_t lightHandle, const renderLight_t *rlight ) = 0;
 virtual void FreeLightDef( qhandle_t lightHandle ) = 0;
 virtual const renderLight_t *GetRenderLight( qhandle_t lightHandle ) const = 0;



 virtual void GenerateAllInteractions() = 0;


 virtual bool CheckAreaForPortalSky( int areaNum ) = 0;
# 306 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderWorld.h"
 virtual void ProjectDecalOntoWorld( const idFixedWinding &winding, const idVec3 &projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime ) = 0;


 virtual void ProjectDecal( qhandle_t entityHandle, const idFixedWinding &winding, const idVec3 &projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime ) = 0;


 virtual void ProjectOverlay( qhandle_t entityHandle, const idPlane localTextureAxis[2], const idMaterial *material ) = 0;


 virtual void RemoveDecals( qhandle_t entityHandle ) = 0;





 virtual void SetRenderView( const renderView_t *renderView ) = 0;




 virtual void RenderScene( const renderView_t *renderView ) = 0;




 virtual int NumPortals( void ) const = 0;





 virtual qhandle_t FindPortal( const idBounds &b ) const = 0;



 virtual void SetPortalState( qhandle_t portal, int blockingBits ) = 0;
 virtual int GetPortalState( qhandle_t portal ) = 0;



 virtual bool AreasAreConnected( int areaNum1, int areaNum2, portalConnection_t connection ) = 0;



 virtual int NumAreas( void ) const = 0;



 virtual int PointInArea( const idVec3 &point ) const = 0;



 virtual int BoundsInAreas( const idBounds &bounds, int *areas, int maxAreas ) const = 0;


 virtual int NumPortalsInArea( int areaNum ) = 0;


 virtual exitPortal_t GetPortal( int areaNum, int portalNum ) = 0;







 virtual guiPoint_t GuiTrace( qhandle_t entityHandle, const idVec3 start, const idVec3 end ) const = 0;


 virtual bool ModelTrace( modelTrace_t &trace, qhandle_t entityHandle, const idVec3 &start, const idVec3 &end, const float radius ) const = 0;


 virtual bool Trace( modelTrace_t &trace, const idVec3 &start, const idVec3 &end, const float radius, bool skipDynamic = true, bool skipPlayer = false ) const = 0;


 virtual bool FastWorldTrace( modelTrace_t &trace, const idVec3 &start, const idVec3 &end ) const = 0;




 virtual void StartWritingDemo( idDemoFile *demo ) = 0;
 virtual void StopWritingDemo() = 0;
# 396 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../renderer/RenderWorld.h"
 virtual bool ProcessDemoCommand( idDemoFile *readDemo, renderView_t *demoRenderView, int *demoTimeOffset ) = 0;



 virtual void RegenerateWorld() = 0;




 virtual void DebugClearLines( int time ) = 0;
 virtual void DebugLine( const idVec4 &color, const idVec3 &start, const idVec3 &end, const int lifetime = 0, const bool depthTest = false ) = 0;
 virtual void DebugArrow( const idVec4 &color, const idVec3 &start, const idVec3 &end, int size, const int lifetime = 0 ) = 0;
 virtual void DebugWinding( const idVec4 &color, const idWinding &w, const idVec3 &origin, const idMat3 &axis, const int lifetime = 0, const bool depthTest = false ) = 0;
 virtual void DebugCircle( const idVec4 &color, const idVec3 &origin, const idVec3 &dir, const float radius, const int numSteps, const int lifetime = 0, const bool depthTest = false ) = 0;
 virtual void DebugSphere( const idVec4 &color, const idSphere &sphere, const int lifetime = 0, bool depthTest = false ) = 0;
 virtual void DebugBounds( const idVec4 &color, const idBounds &bounds, const idVec3 &org = vec3_origin, const int lifetime = 0 ) = 0;
 virtual void DebugBox( const idVec4 &color, const idBox &box, const int lifetime = 0 ) = 0;
 virtual void DebugFrustum( const idVec4 &color, const idFrustum &frustum, const bool showFromOrigin = false, const int lifetime = 0 ) = 0;
 virtual void DebugCone( const idVec4 &color, const idVec3 &apex, const idVec3 &dir, float radius1, float radius2, const int lifetime = 0 ) = 0;
 virtual void DebugAxis( const idVec3 &origin, const idMat3 &axis ) = 0;


 virtual void DebugClearPolygons( int time ) = 0;
 virtual void DebugPolygon( const idVec4 &color, const idWinding &winding, const int lifeTime = 0, const bool depthTest = false ) = 0;


 virtual void DrawText( const char *text, const idVec3 &origin, float scale, const idVec4 &color, const idMat3 &viewAxis, const int align = 1, const int lifetime = 0, bool depthTest = false ) = 0;
};
# 155 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sound/sound.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sound/sound.h"
const float DOOM_TO_METERS = 0.0254f;
const float METERS_TO_DOOM = (1.0f/DOOM_TO_METERS);

class idSoundSample;


static const int SSF_PRIVATE_SOUND = ( 1 << ( 0 ) );
static const int SSF_ANTI_PRIVATE_SOUND =( 1 << ( 1 ) );
static const int SSF_NO_OCCLUSION = ( 1 << ( 2 ) );
static const int SSF_GLOBAL = ( 1 << ( 3 ) );
static const int SSF_OMNIDIRECTIONAL = ( 1 << ( 4 ) );
static const int SSF_LOOPING = ( 1 << ( 5 ) );
static const int SSF_PLAY_ONCE = ( 1 << ( 6 ) );
static const int SSF_UNCLAMPED = ( 1 << ( 7 ) );
static const int SSF_NO_FLICKER = ( 1 << ( 8 ) );
static const int SSF_NO_DUPS = ( 1 << ( 9 ) );


typedef struct {
 float minDistance;
 float maxDistance;
 float volume;
 float shakes;
 int soundShaderFlags;
 int soundClass;
} soundShaderParms_t;


const int SOUND_MAX_LIST_WAVS = 32;



const int SOUND_MAX_CLASSES = 4;



class idSoundShader : public idDecl {
public:
       idSoundShader( void );
 virtual ~idSoundShader( void );

 virtual size_t Size( void ) const;
 virtual bool SetDefaultText( void );
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void List( void ) const;

 virtual const char * GetDescription() const;



 virtual float GetMinDistance() const;
 virtual float GetMaxDistance() const;



 virtual const idSoundShader *GetAltSound() const;

 virtual bool HasDefaultSound() const;

 virtual const soundShaderParms_t *GetParms() const;
 virtual int GetNumSounds() const;
 virtual const char * GetSound( int index ) const;

 virtual bool CheckShakesAndOgg( void ) const;

private:
 friend class idSoundWorldLocal;
 friend class idSoundEmitterLocal;
 friend class idSoundChannel;
 friend class idSoundCache;


 soundShaderParms_t parms;

 bool onDemand;
 int speakerMask;
 const idSoundShader * altSound;
 idStr desc;
 bool errorDuringParse;
 float leadinVolume;

 idSoundSample * leadins[SOUND_MAX_LIST_WAVS];
 int numLeadins;
 idSoundSample * entries[SOUND_MAX_LIST_WAVS];
 int numEntries;

private:
 void Init( void );
 bool ParseShader( idLexer &src );
};
# 144 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sound/sound.h"
static const int SCHANNEL_ANY = 0;

static const int SCHANNEL_ONE = 1;
typedef int s_channelType;


class idSoundEmitter {
public:
 virtual ~idSoundEmitter( void ) {}




 virtual void Free( bool immediate ) = 0;



 virtual void UpdateEmitter( const idVec3 &origin, int listenerId, const soundShaderParms_t *parms ) = 0;


 virtual int StartSound( const idSoundShader *shader, const s_channelType channel, float diversity = 0, int shaderFlags = 0, bool allowSlow = true ) = 0;


 virtual void ModifySound( const s_channelType channel, const soundShaderParms_t *parms ) = 0;
 virtual void StopSound( const s_channelType channel ) = 0;

 virtual void FadeSound( const s_channelType channel, float to, float over ) = 0;




 virtual bool CurrentlyPlaying( void ) const = 0;




 virtual float CurrentAmplitude( void ) = 0;


 virtual int Index( void ) const = 0;
};
# 197 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sound/sound.h"
class idSoundWorld {
public:
 virtual ~idSoundWorld( void ) {}


 virtual void ClearAllSoundEmitters( void ) = 0;
 virtual void StopAllSounds( void ) = 0;


 virtual idSoundEmitter *AllocSoundEmitter( void ) = 0;


 virtual idSoundEmitter *EmitterForIndex( int index ) = 0;


 virtual float CurrentShakeAmplitudeForPosition( const int time, const idVec3 &listenerPosition ) = 0;





 virtual void PlaceListener( const idVec3 &origin, const idMat3 &axis, const int listenerId, const int gameTime, const idStr& areaName ) = 0;



 virtual void FadeSoundClasses( const int soundClass, const float to, const float over ) = 0;


 virtual void PlayShaderDirectly( const char *name, int channel = -1 ) = 0;


 virtual void StartWritingDemo( idDemoFile *demo ) = 0;
 virtual void StopWritingDemo() = 0;


 virtual void ProcessDemoCommand( idDemoFile *demo ) = 0;


 virtual void Pause( void ) = 0;
 virtual void UnPause( void ) = 0;
 virtual bool IsPaused( void ) = 0;
# 248 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sound/sound.h"
 virtual void AVIOpen( const char *path, const char *name ) = 0;
 virtual void AVIClose( void ) = 0;


 virtual void WriteToSaveGame( idFile *savefile ) = 0;
 virtual void ReadFromSaveGame( idFile *savefile ) = 0;

 virtual void SetSlowmo( bool active ) = 0;
 virtual void SetSlowmoSpeed( float speed ) = 0;
 virtual void SetEnviroSuit( bool active ) = 0;
};
# 269 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../sound/sound.h"
typedef struct {
 idStr name;
 idStr format;
 int numChannels;
 int numSamplesPerSecond;
 int num44kHzSamples;
 int numBytes;
 bool looping;
 float lastVolume;
 int start44kHzTime;
 int current44kHzTime;
} soundDecoderInfo_t;


class idSoundSystem {
public:
 virtual ~idSoundSystem( void ) {}


 virtual void Init( void ) = 0;


 virtual void Shutdown( void ) = 0;




 virtual void ClearBuffer( void ) = 0;


 virtual bool InitHW( void ) = 0;
 virtual bool ShutdownHW( void ) = 0;


 virtual int AsyncUpdate( int time ) = 0;


 virtual int AsyncUpdateWrite( int time ) = 0;




 virtual void SetMute( bool mute ) = 0;


 virtual cinData_t ImageForTime( const int milliseconds, const bool waveform ) = 0;


 virtual int GetSoundDecoderInfo( int index, soundDecoderInfo_t &decoderInfo ) = 0;


 virtual idSoundWorld * AllocSoundWorld( idRenderWorld *rw ) = 0;


 virtual void SetPlayingSoundWorld( idSoundWorld *soundWorld ) = 0;



 virtual idSoundWorld * GetPlayingSoundWorld( void ) = 0;



 virtual void BeginLevelLoad( void ) = 0;




 virtual void EndLevelLoad( const char *mapString ) = 0;


 virtual int AsyncMix( int soundTime, float *mixBuffer ) = 0;


 virtual void PrintMemInfo( MemInfo_t *mi ) = 0;


 virtual int IsEAXAvailable( void ) = 0;
};

extern idSoundSystem *soundSystem;
# 158 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/NetworkSystem.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/NetworkSystem.h"
class idNetworkSystem {
public:
 virtual ~idNetworkSystem( void ) {}

 virtual void ServerSendReliableMessage( int clientNum, const idBitMsg &msg );
 virtual void ServerSendReliableMessageExcluding( int clientNum, const idBitMsg &msg );
 virtual int ServerGetClientPing( int clientNum );
 virtual int ServerGetClientPrediction( int clientNum );
 virtual int ServerGetClientTimeSinceLastPacket( int clientNum );
 virtual int ServerGetClientTimeSinceLastInput( int clientNum );
 virtual int ServerGetClientOutgoingRate( int clientNum );
 virtual int ServerGetClientIncomingRate( int clientNum );
 virtual float ServerGetClientIncomingPacketLoss( int clientNum );

 virtual void ClientSendReliableMessage( const idBitMsg &msg );
 virtual int ClientGetPrediction( void );
 virtual int ClientGetTimeSinceLastPacket( void );
 virtual int ClientGetOutgoingRate( void );
 virtual int ClientGetIncomingRate( void );
 virtual float ClientGetIncomingPacketLoss( void );
};

extern idNetworkSystem * networkSystem;
# 161 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../ui/ListGUI.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../ui/ListGUI.h"
class idListGUI {
public:
 virtual ~idListGUI() { }

 virtual void Config( idUserInterface *pGUI, const char *name ) = 0;
 virtual void Add( int id, const idStr& s ) = 0;

 virtual void Push( const idStr& s ) = 0;
 virtual bool Del( int id ) = 0;
 virtual void Clear( void ) = 0;
 virtual int Num( void ) = 0;
 virtual int GetSelection( char *s, int size, int sel = 0 ) const = 0;
 virtual void SetSelection( int sel ) = 0;
 virtual int GetNumSelections() = 0;
 virtual bool IsConfigured( void ) const = 0;

 virtual void SetStateChanges( bool enable ) = 0;
 virtual void Shutdown( void ) = 0;
};
# 164 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../ui/UserInterface.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../ui/UserInterface.h"
class idFile;
class idDemoFile;


class idUserInterface {
public:
 virtual ~idUserInterface() {};


 virtual const char * Name() const = 0;


 virtual const char * Comment() const = 0;


 virtual bool IsInteractive() const = 0;

 virtual bool IsUniqued() const = 0;

 virtual void SetUniqued( bool b ) = 0;

 virtual bool InitFromFile( const char *qpath, bool rebuild = true, bool cache = true ) = 0;



 virtual const char * HandleEvent( const sysEvent_t *event, int time, bool *updateVisuals = __null ) = 0;


 virtual void HandleNamedEvent( const char *eventName ) = 0;


 virtual void Redraw( int time ) = 0;


 virtual void DrawCursor() = 0;


 virtual const idDict & State() const = 0;


 virtual void DeleteStateVar( const char *varName ) = 0;


 virtual void SetStateString( const char *varName, const char *value ) = 0;
 virtual void SetStateBool( const char *varName, const bool value ) = 0;
 virtual void SetStateInt( const char *varName, const int value ) = 0;
 virtual void SetStateFloat( const char *varName, const float value ) = 0;


 virtual const char* GetStateString( const char *varName, const char* defaultString = "" ) const = 0;
 virtual bool GetStateBool( const char *varName, const char* defaultString = "0" ) const = 0;
 virtual int GetStateInt( const char *varName, const char* defaultString = "0" ) const = 0;
 virtual float GetStateFloat( const char *varName, const char* defaultString = "0" ) const = 0;


 virtual void StateChanged( int time, bool redraw = false ) = 0;


 virtual const char * Activate( bool activate, int time ) = 0;


 virtual void Trigger( int time ) = 0;

 virtual void ReadFromDemoFile( class idDemoFile *f ) = 0;
 virtual void WriteToDemoFile( class idDemoFile *f ) = 0;

 virtual bool WriteToSaveGame( idFile *savefile ) const = 0;
 virtual bool ReadFromSaveGame( idFile *savefile ) = 0;
 virtual void SetKeyBindingNames( void ) = 0;

 virtual void SetCursor( float x, float y ) = 0;
 virtual float CursorX() = 0;
 virtual float CursorY() = 0;
};


class idUserInterfaceManager {
public:
 virtual ~idUserInterfaceManager( void ) {};

 virtual void Init() = 0;
 virtual void Shutdown() = 0;
 virtual void Touch( const char *name ) = 0;
 virtual void WritePrecacheCommands( idFile *f ) = 0;


 virtual void SetSize( float width, float height ) = 0;

 virtual void VirtualizeAll() = 0;
 virtual void BeginLevelLoad() = 0;
 virtual void EndLevelLoad() = 0;


 virtual void Reload( bool all ) = 0;


 virtual void ListGuis() const = 0;


 virtual bool CheckGui( const char *qpath ) const = 0;


 virtual idUserInterface * Alloc( void ) const = 0;


 virtual void DeAlloc( idUserInterface *gui ) = 0;


 virtual idUserInterface * FindGui( const char *qpath, bool autoLoad = false, bool needUnique = false, bool forceUnique = false ) = 0;


 virtual idUserInterface * FindDemoGui( const char *qpath ) = 0;


 virtual idListGUI * AllocListGUI( void ) const = 0;


 virtual void FreeListGUI( idListGUI *listgui ) = 0;
};

extern idUserInterfaceManager * uiManager;
# 165 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../cm/CollisionModel.h" 1
# 52 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../cm/CollisionModel.h"
typedef enum {
 CONTACT_NONE,
 CONTACT_EDGE,
 CONTACT_MODELVERTEX,
 CONTACT_TRMVERTEX
} contactType_t;


typedef struct {
 contactType_t type;
 idVec3 point;
 idVec3 normal;
 float dist;
 int contents;
 const idMaterial * material;
 int modelFeature;
 int trmFeature;
 int entityNum;
 int id;
} contactInfo_t;


typedef struct trace_s {
 float fraction;
 idVec3 endpos;
 idMat3 endAxis;
 contactInfo_t c;
} trace_t;

typedef int cmHandle_t;





class idCollisionModelManager {
public:
 virtual ~idCollisionModelManager( void ) {}


 virtual void LoadMap( const idMapFile *mapFile ) = 0;

 virtual void FreeMap( void ) = 0;

 virtual void virtualizeAll( void ) = 0;

 virtual cmHandle_t LoadModel( const char *modelName, const bool precache ) = 0;

 virtual cmHandle_t SetupTrmModel( const idTraceModel &trm, const idMaterial *material ) = 0;

 virtual bool TrmFromModel( const char *modelName, idTraceModel &trm ) = 0;


 virtual const char * GetModelName( cmHandle_t model ) const = 0;

 virtual bool GetModelBounds( cmHandle_t model, idBounds &bounds ) const = 0;

 virtual bool GetModelContents( cmHandle_t model, int &contents ) const = 0;

 virtual bool GetModelVertex( cmHandle_t model, int vertexNum, idVec3 &vertex ) const = 0;

 virtual bool GetModelEdge( cmHandle_t model, int edgeNum, idVec3 &start, idVec3 &end ) const = 0;

 virtual bool GetModelPolygon( cmHandle_t model, int polygonNum, idFixedWinding &winding ) const = 0;


 virtual void Translation( trace_t *results, const idVec3 &start, const idVec3 &end,
        const idTraceModel *trm, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis ) = 0;

 virtual void Rotation( trace_t *results, const idVec3 &start, const idRotation &rotation,
        const idTraceModel *trm, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis ) = 0;

 virtual int Contents( const idVec3 &start,
        const idTraceModel *trm, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis ) = 0;

 virtual int Contacts( contactInfo_t *contacts, const int maxContacts, const idVec3 &start, const idVec6 &dir, const float depth,
        const idTraceModel *trm, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis ) = 0;


 virtual void DebugOutput( const idVec3 &origin ) = 0;

 virtual void DrawModel( cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis,
            const idVec3 &viewOrigin, const float radius ) = 0;

 virtual void ModelInfo( cmHandle_t model ) = 0;

 virtual void ListModels( void ) = 0;

 virtual bool WriteCollisionModelForMapEntity( const idMapEntity *mapEnt, const char *filename, const bool testTraceModel = true ) = 0;
};

extern idCollisionModelManager * collisionModelManager;
# 168 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/compilers/aas/AASFile.h" 1
# 93 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/compilers/aas/AASFile.h"
class idReachability {
public:
 int travelType;
 short toAreaNum;
 short fromAreaNum;
 idVec3 start;
 idVec3 end;
 int edgeNum;
 unsigned short travelTime;
 byte number;
 byte disableCount;
 idReachability * next;
 idReachability * rev_next;
 unsigned short * areaTravelTimes;
public:
 void CopyBase( idReachability &reach );
};

class idReachability_Walk : public idReachability {
};

class idReachability_BarrierJump : public idReachability {
};

class idReachability_WaterJump : public idReachability {
};

class idReachability_WalkOffLedge : public idReachability {
};

class idReachability_Swim : public idReachability {
};

class idReachability_Fly : public idReachability {
};

class idReachability_Special : public idReachability {
public:
 idDict dict;
};


typedef int aasIndex_t;


typedef idVec3 aasVertex_t;


typedef struct aasEdge_s {
 int vertexNum[2];
} aasEdge_t;


typedef struct aasFace_s {
 unsigned short planeNum;
 unsigned short flags;
 int numEdges;
 int firstEdge;
 short areas[2];
} aasFace_t;


typedef struct aasArea_s {
 int numFaces;
 int firstFace;
 idBounds bounds;
 idVec3 center;
 unsigned short flags;
 unsigned short contents;
 short cluster;
 short clusterAreaNum;
 int travelFlags;
 idReachability * reach;
 idReachability * rev_reach;
} aasArea_t;


typedef struct aasNode_s {
 unsigned short planeNum;
 int children[2];
} aasNode_t;


typedef struct aasPortal_s {
 short areaNum;
 short clusters[2];
 short clusterAreaNum[2];
 unsigned short maxAreaTravelTime;
} aasPortal_t;


typedef struct aasCluster_s {
 int numAreas;
 int numReachableAreas;
 int numPortals;
 int firstPortal;
} aasCluster_t;


typedef struct aasTrace_s {

 int flags;
 int travelFlags;
 int maxAreas;
 int getOutOfSolid;

 float fraction;
 idVec3 endpos;
 int planeNum;
 int lastAreaNum;
 int blockingAreaNum;
 int numAreas;
 int * areas;
 idVec3 * points;
        aasTrace_s( void ) { areas = __null; points = __null; getOutOfSolid = false; flags = travelFlags = maxAreas = 0; }
} aasTrace_t;


class idAASSettings {
public:

 int numBoundingBoxes;
 idBounds boundingBoxes[4];
 bool usePatches;
 bool writeBrushMap;
 bool playerFlood;
 bool noOptimize;
 bool allowSwimReachabilities;
 bool allowFlyReachabilities;
 idStr fileExtension;

 idVec3 gravity;
 idVec3 gravityDir;
 idVec3 invGravityDir;
 float gravityValue;
 float maxStepHeight;
 float maxBarrierHeight;
 float maxWaterJumpHeight;
 float maxFallHeight;
 float minFloorCos;

 int tt_barrierJump;
 int tt_startCrouching;
 int tt_waterJump;
 int tt_startWalkOffLedge;

public:
        idAASSettings( void );

 bool FromFile( const idStr &fileName );
 bool FromParser( idLexer &src );
 bool FromDict( const char *name, const idDict *dict );
 bool WriteToFile( idFile *fp ) const;
 bool ValidForBounds( const idBounds &bounds ) const;
 bool ValidEntity( const char *classname ) const;

private:
 bool ParseBool( idLexer &src, bool &b );
 bool ParseInt( idLexer &src, int &i );
 bool ParseFloat( idLexer &src, float &f );
 bool ParseVector( idLexer &src, idVec3 &vec );
 bool ParseBBoxes( idLexer &src );
};
# 282 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/compilers/aas/AASFile.h"
class idAASFile {
public:
 virtual ~idAASFile( void ) {}

 const char * GetName( void ) const { return name.c_str(); }
 unsigned int GetCRC( void ) const { return crc; }

 int GetNumPlanes( void ) const { return planeList.Num(); }
 const idPlane & GetPlane( int index ) const { return planeList[index]; }
 int GetNumVertices( void ) const { return vertices.Num(); }
 const aasVertex_t & GetVertex( int index ) const { return vertices[index]; }
 int GetNumEdges( void ) const { return edges.Num(); }
 const aasEdge_t & GetEdge( int index ) const { return edges[index]; }
 int GetNumEdgeIndexes( void ) const { return edgeIndex.Num(); }
 const aasIndex_t & GetEdgeIndex( int index ) const { return edgeIndex[index]; }
 int GetNumFaces( void ) const { return faces.Num(); }
 const aasFace_t & GetFace( int index ) const { return faces[index]; }
 int GetNumFaceIndexes( void ) const { return faceIndex.Num(); }
 const aasIndex_t & GetFaceIndex( int index ) const { return faceIndex[index]; }
 int GetNumAreas( void ) const { return areas.Num(); }
 const aasArea_t & GetArea( int index ) { return areas[index]; }
 int GetNumNodes( void ) const { return nodes.Num(); }
 const aasNode_t & GetNode( int index ) const { return nodes[index]; }
 int GetNumPortals( void ) const { return portals.Num(); }
 const aasPortal_t & GetPortal( int index ) { return portals[index]; }
 int GetNumPortalIndexes( void ) const { return portalIndex.Num(); }
 const aasIndex_t & GetPortalIndex( int index ) const { return portalIndex[index]; }
 int GetNumClusters( void ) const { return clusters.Num(); }
 const aasCluster_t & GetCluster( int index ) const { return clusters[index]; }

 const idAASSettings & GetSettings( void ) const { return settings; }

 void SetPortalMaxTravelTime( int index, int time ) { portals[index].maxAreaTravelTime = time; }
 void SetAreaTravelFlag( int index, int flag ) { areas[index].travelFlags |= flag; }
 void RemoveAreaTravelFlag( int index, int flag ) { areas[index].travelFlags &= ~flag; }

 virtual idVec3 EdgeCenter( int edgeNum ) const = 0;
 virtual idVec3 FaceCenter( int faceNum ) const = 0;
 virtual idVec3 AreaCenter( int areaNum ) const = 0;

 virtual idBounds EdgeBounds( int edgeNum ) const = 0;
 virtual idBounds FaceBounds( int faceNum ) const = 0;
 virtual idBounds AreaBounds( int areaNum ) const = 0;

 virtual int PointAreaNum( const idVec3 &origin ) const = 0;
 virtual int PointReachableAreaNum( const idVec3 &origin, const idBounds &searchBounds, const int areaFlags, const int excludeTravelFlags ) const = 0;
 virtual int BoundsReachableAreaNum( const idBounds &bounds, const int areaFlags, const int excludeTravelFlags ) const = 0;
 virtual void PushPointIntoAreaNum( int areaNum, idVec3 &point ) const = 0;
 virtual bool Trace( aasTrace_t &trace, const idVec3 &start, const idVec3 &end ) const = 0;
 virtual void PrintInfo( void ) const = 0;

protected:
 idStr name;
 unsigned int crc;

 idPlaneSet planeList;
 idList<aasVertex_t> vertices;
 idList<aasEdge_t> edges;
 idList<aasIndex_t> edgeIndex;
 idList<aasFace_t> faces;
 idList<aasIndex_t> faceIndex;
 idList<aasArea_t> areas;
 idList<aasNode_t> nodes;
 idList<aasPortal_t> portals;
 idList<aasIndex_t> portalIndex;
 idList<aasCluster_t> clusters;
 idAASSettings settings;
};
# 171 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/compilers/aas/AASFileManager.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/compilers/aas/AASFileManager.h"
class idAASFileManager {
public:
 virtual ~idAASFileManager( void ) {}

 virtual idAASFile * LoadAAS( const char *fileName, unsigned int mapFileCRC ) = 0;
 virtual void FreeAAS( idAASFile *file ) = 0;
};

extern idAASFileManager * AASFileManager;
# 172 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2





# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../game/Game.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../game/Game.h"
typedef struct {
 char sessionCommand[1024];
 int consistencyHash;
 int health;
 int heartRate;
 int stamina;
 int combat;
 bool syncNextGameFrame;

} gameReturn_t;

typedef enum {
 ALLOW_YES = 0,
 ALLOW_BADPASS,
 ALLOW_NOTYET,
 ALLOW_NO
} allowReply_t;

typedef enum {
 ESC_IGNORE = 0,
 ESC_MAIN,
 ESC_GUI
} escReply_t;




class idGame {
public:
 virtual ~idGame() {}


 virtual void Init( void ) = 0;


 virtual void Shutdown( void ) = 0;


 virtual void SetLocalClient( int clientNum ) = 0;




 virtual const idDict * SetUserInfo( int clientNum, const idDict &userInfo, bool isClient, bool canModify ) = 0;


 virtual const idDict * GetUserInfo( int clientNum ) = 0;


 virtual void ThrottleUserInfo( void ) = 0;


 virtual void SetServerInfo( const idDict &serverInfo ) = 0;


 virtual const idDict & GetPersistentPlayerInfo( int clientNum ) = 0;


 virtual void SetPersistentPlayerInfo( int clientNum, const idDict &playerInfo ) = 0;


 virtual void InitFromNewMap( const char *mapName, idRenderWorld *renderWorld, idSoundWorld *soundWorld, bool isServer, bool isClient, int randseed ) = 0;


 virtual bool InitFromSaveGame( const char *mapName, idRenderWorld *renderWorld, idSoundWorld *soundWorld, idFile *saveGameFile ) = 0;


 virtual void SaveGame( idFile *saveGameFile ) = 0;


 virtual void MapShutdown( void ) = 0;


 virtual void CacheDictionaryMedia( const idDict *dict ) = 0;


 virtual void SpawnPlayer( int clientNum ) = 0;


 virtual gameReturn_t RunFrame( const usercmd_t *clientCmds ) = 0;


 virtual bool Draw( int clientNum ) = 0;


 virtual escReply_t HandleESC( idUserInterface **gui ) = 0;


 virtual idUserInterface * StartMenu() = 0;



 virtual const char * HandleGuiCommands( const char *menuCommand ) = 0;


 virtual void HandleMainMenuCommands( const char *menuCommand, idUserInterface *gui ) = 0;


 virtual allowReply_t ServerAllowClient( int numClients, const char *IP, const char *guid, const char *password, char reason[1024] ) = 0;


 virtual void ServerClientConnect( int clientNum, const char *guid ) = 0;


 virtual void ServerClientBegin( int clientNum ) = 0;


 virtual void ServerClientDisconnect( int clientNum ) = 0;


 virtual void ServerWriteInitialReliableMessages( int clientNum ) = 0;


 virtual void ServerWriteSnapshot( int clientNum, int sequence, idBitMsg &msg, byte *clientInPVS, int numPVSClients ) = 0;


 virtual bool ServerApplySnapshot( int clientNum, int sequence ) = 0;


 virtual void ServerProcessReliableMessage( int clientNum, const idBitMsg &msg ) = 0;


 virtual void ClientReadSnapshot( int clientNum, int sequence, const int gameFrame, const int gameTime, const int dupeUsercmds, const int aheadOfServer, const idBitMsg &msg ) = 0;


 virtual bool ClientApplySnapshot( int clientNum, int sequence ) = 0;


 virtual void ClientProcessReliableMessage( int clientNum, const idBitMsg &msg ) = 0;


 virtual gameReturn_t ClientPrediction( int clientNum, const usercmd_t *clientCmds, bool lastPredictFrame ) = 0;


 virtual void SelectTimeGroup( int timeGroup ) = 0;
 virtual int GetTimeGroupTime( int timeGroup ) = 0;

 virtual void GetBestGameType( const char* map, const char* gametype, char buf[ 1024 ] ) = 0;


 virtual void GetClientStats( int clientNum, char *data, const int len ) = 0;


 virtual void SwitchTeam( int clientNum, int team ) = 0;

 virtual bool DownloadRequest( const char *IP, const char *guid, const char *paks, char urls[ 1024 ] ) = 0;

 virtual void GetMapLoadingGUI( char gui[ 1024 ] ) = 0;
};

extern idGame * game;
# 206 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../game/Game.h"
typedef struct {
 idSoundEmitter * referenceSound;

 idVec3 origin;
 int listenerId;

 const idSoundShader * shader;
 float diversity;

 bool waitfortrigger;
 soundShaderParms_t parms;
} refSound_t;

enum {
 TEST_PARTICLE_MODEL = 0,
 TEST_PARTICLE_IMPACT,
 TEST_PARTICLE_MUZZLE,
 TEST_PARTICLE_FLIGHT,
 TEST_PARTICLE_SELECTED
};

class idEntity;
class idMD5Anim;


class idGameEdit {
public:
 virtual ~idGameEdit( void ) {}


 virtual void ParseSpawnArgsToRenderLight( const idDict *args, renderLight_t *renderLight );
 virtual void ParseSpawnArgsToRenderEntity( const idDict *args, renderEntity_t *renderEntity );
 virtual void ParseSpawnArgsToRefSound( const idDict *args, refSound_t *refSound );


 virtual idRenderModel * ANIM_GetModelFromEntityDef( const char *classname );
 virtual const idVec3 &ANIM_GetModelOffsetFromEntityDef( const char *classname );
 virtual idRenderModel * ANIM_GetModelFromEntityDef( const idDict *args );
 virtual idRenderModel * ANIM_GetModelFromName( const char *modelName );
 virtual const idMD5Anim * ANIM_GetAnimFromEntityDef( const char *classname, const char *animname );
 virtual int ANIM_GetNumAnimsFromEntityDef( const idDict *args );
 virtual const char * ANIM_GetAnimNameFromEntityDef( const idDict *args, int animNum );
 virtual const idMD5Anim * ANIM_GetAnim( const char *fileName );
 virtual int ANIM_GetLength( const idMD5Anim *anim );
 virtual int ANIM_GetNumFrames( const idMD5Anim *anim );
 virtual void ANIM_CreateAnimFrame( const idRenderModel *model, const idMD5Anim *anim, int numJoints, idJointMat *frame, int time, const idVec3 &offset, bool remove_origin_offset );
 virtual idRenderModel * ANIM_CreateMeshForAnim( idRenderModel *model, const char *classname, const char *animname, int frame, bool remove_origin_offset );


 virtual bool AF_SpawnEntity( const char *fileName );
 virtual void AF_UpdateEntities( const char *fileName );
 virtual void AF_UndoChanges( void );
 virtual idRenderModel * AF_CreateMesh( const idDict &args, idVec3 &meshOrigin, idMat3 &meshAxis, bool &poseIsSet );



 virtual void ClearEntitySelection( void );
 virtual int GetSelectedEntities( idEntity *list[], int max );
 virtual void AddSelectedEntity( idEntity *ent );


 virtual void TriggerSelected();


 virtual const idDict * FindEntityDefDict( const char *name, bool makeDefault = true ) const;
 virtual void SpawnEntityDef( const idDict &args, idEntity **ent );
 virtual idEntity * FindEntity( const char *name ) const;
 virtual const char * GetUniqueEntityName( const char *classname ) const;


 virtual void EntityGetOrigin( idEntity *ent, idVec3 &org ) const;
 virtual void EntityGetAxis( idEntity *ent, idMat3 &axis ) const;
 virtual void EntitySetOrigin( idEntity *ent, const idVec3 &org );
 virtual void EntitySetAxis( idEntity *ent, const idMat3 &axis );
 virtual void EntityTranslate( idEntity *ent, const idVec3 &org );
 virtual const idDict * EntityGetSpawnArgs( idEntity *ent ) const;
 virtual void EntityUpdateChangeableSpawnArgs( idEntity *ent, const idDict *dict );
 virtual void EntityChangeSpawnArgs( idEntity *ent, const idDict *newArgs );
 virtual void EntityUpdateVisuals( idEntity *ent );
 virtual void EntitySetModel( idEntity *ent, const char *val );
 virtual void EntityStopSound( idEntity *ent );
 virtual void EntityDelete( idEntity *ent );
 virtual void EntitySetColor( idEntity *ent, const idVec3 color );


 virtual bool PlayerIsValid() const;
 virtual void PlayerGetOrigin( idVec3 &org ) const;
 virtual void PlayerGetAxis( idMat3 &axis ) const;
 virtual void PlayerGetViewAngles( idAngles &angles ) const;
 virtual void PlayerGetEyePosition( idVec3 &org ) const;


 virtual const idDict * MapGetEntityDict( const char *name ) const;
 virtual void MapSave( const char *path = __null ) const;
 virtual void MapSetEntityKeyVal( const char *name, const char *key, const char *val ) const ;
 virtual void MapCopyDictToEntity( const char *name, const idDict *dict ) const;
 virtual int MapGetUniqueMatchingKeyVals( const char *key, const char *list[], const int max ) const;
 virtual void MapAddEntity( const idDict *dict ) const;
 virtual int MapGetEntitiesMatchingClassWithString( const char *classname, const char *match, const char *list[], const int max ) const;
 virtual void MapRemoveEntity( const char *name ) const;
 virtual void MapEntityTranslate( const char *name, const idVec3 &v ) const;

};

extern idGameEdit * gameEdit;
# 321 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../game/Game.h"
const int GAME_API_VERSION = 8;

typedef struct {

 int version;
 idSys * sys;
 idCommon * common;
 idCmdSystem * cmdSystem;
 idCVarSystem * cvarSystem;
 idFileSystem * fileSystem;
 idNetworkSystem * networkSystem;
 idRenderSystem * renderSystem;
 idSoundSystem * soundSystem;
 idRenderModelManager * renderModelManager;
 idUserInterfaceManager * uiManager;
 idDeclManager * declManager;
 idAASFileManager * AASFileManager;
 idCollisionModelManager * collisionModelManager;

} gameImport_t;

typedef struct {

 int version;
 idGame * game;
 idGameEdit * gameEdit;

} gameExport_t;

extern "C" {
typedef gameExport_t * (*GetGameAPI_t)( gameImport_t *import );
}
# 178 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 195 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h"
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DemoChecksum.h" 1
# 196 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Compressor.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Compressor.h"
class idCompressor : public idFile {
public:

 static idCompressor * AllocNoCompression( void );
 static idCompressor * AllocBitStream( void );
 static idCompressor * AllocRunLength( void );
 static idCompressor * AllocRunLength_ZeroBased( void );
 static idCompressor * AllocHuffman( void );
 static idCompressor * AllocArithmetic( void );
 static idCompressor * AllocLZSS( void );
 static idCompressor * AllocLZSS_WordAligned( void );
 static idCompressor * AllocLZW( void );


 virtual void Init( idFile *f, bool compress, int wordLength ) = 0;
 virtual void FinishCompress( void ) = 0;
 virtual float GetCompressionRatio( void ) const = 0;


 virtual const char * GetName( void ) = 0;
 virtual const char * GetFullPath( void ) = 0;
 virtual int Read( void *outData, int outLength ) = 0;
 virtual int Write( const void *inData, int inLength ) = 0;
 virtual int Length( void ) = 0;
 virtual time_t Timestamp( void ) = 0;
 virtual int Tell( void ) = 0;
 virtual void ForceFlush( void ) = 0;
 virtual void Flush( void ) = 0;
 virtual int Seek( long offset, fsOrigin_t origin ) = 0;
};
# 199 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/EventLoop.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/EventLoop.h"
const int MAX_PUSHED_EVENTS = 64;

class idEventLoop {
public:
     idEventLoop( void );
     ~idEventLoop( void );

 void Init( void );


 void Shutdown( void );



 sysEvent_t GetEvent( void );


 int RunEventLoop( bool commandExecution = true );



 int Milliseconds( void );


 int JournalLevel( void ) const;


 idFile * com_journalFile;
 idFile * com_journalDataFile;

private:

 int initialTimeOffset;

 int com_pushedEventsHead, com_pushedEventsTail;
 sysEvent_t com_pushedEvents[MAX_PUSHED_EVENTS];

 static idCVar com_journal;

 sysEvent_t GetRealEvent( void );
 void ProcessEvent( sysEvent_t ev );
 void PushEvent( sysEvent_t *event );
};

extern idEventLoop *eventLoop;
# 200 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/KeyInput.h" 1
# 46 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/KeyInput.h"
typedef enum {
 K_TAB = 9,
 K_ENTER = 13,
 K_ESCAPE = 27,
 K_SPACE = 32,

 K_BACKSPACE = 127,

 K_COMMAND = 128,
 K_CAPSLOCK,
 K_SCROLL,
 K_POWER,
 K_PAUSE,

 K_UPARROW = 133,
 K_DOWNARROW,
 K_LEFTARROW,
 K_RIGHTARROW,


 K_LWIN = 137,
 K_RWIN,
 K_MENU,

 K_ALT = 140,
 K_CTRL,
 K_SHIFT,
 K_INS,
 K_DEL,
 K_PGDN,
 K_PGUP,
 K_HOME,
 K_END,

 K_F1 = 149,
 K_F2,
 K_F3,
 K_F4,
 K_F5,
 K_F6,
 K_F7,
 K_F8,
 K_F9,
 K_F10,
 K_F11,
 K_F12,
 K_INVERTED_EXCLAMATION = 161,
 K_F13,
 K_F14,
 K_F15,

 K_KP_HOME = 165,
 K_KP_UPARROW,
 K_KP_PGUP,
 K_KP_LEFTARROW,
 K_KP_5,
 K_KP_RIGHTARROW,
 K_KP_END,
 K_KP_DOWNARROW,
 K_KP_PGDN,
 K_KP_ENTER,
 K_KP_INS,
 K_KP_DEL,
 K_KP_SLASH,
 K_SUPERSCRIPT_TWO = 178,
 K_KP_MINUS,
 K_ACUTE_ACCENT = 180,
 K_KP_PLUS,
 K_KP_NUMLOCK,
 K_KP_STAR,
 K_KP_EQUALS,

 K_MASCULINE_ORDINATOR = 186,

 K_MOUSE1 = 187,
 K_MOUSE2,
 K_MOUSE3,
 K_MOUSE4,
 K_MOUSE5,
 K_MOUSE6,
 K_MOUSE7,
 K_MOUSE8,

 K_MWHEELDOWN = 195,
 K_MWHEELUP,

 K_JOY1 = 197,
 K_JOY2,
 K_JOY3,
 K_JOY4,
 K_JOY5,
 K_JOY6,
 K_JOY7,
 K_JOY8,
 K_JOY9,
 K_JOY10,
 K_JOY11,
 K_JOY12,
 K_JOY13,
 K_JOY14,
 K_JOY15,
 K_JOY16,
 K_JOY17,
 K_JOY18,
 K_JOY19,
 K_JOY20,
 K_JOY21,
 K_JOY22,
 K_JOY23,
 K_JOY24,
 K_JOY25,
 K_JOY26,
 K_JOY27,
 K_GRAVE_A = 224,
 K_JOY28,
 K_JOY29,
 K_JOY30,
 K_JOY31,
 K_JOY32,

 K_AUX1 = 230,
 K_CEDILLA_C = 231,
 K_GRAVE_E = 232,
 K_AUX2,
 K_AUX3,
 K_AUX4,
 K_GRAVE_I = 236,
 K_AUX5,
 K_AUX6,
 K_AUX7,
 K_AUX8,
 K_TILDE_N = 241,
 K_GRAVE_O = 242,
 K_AUX9,
 K_AUX10,
 K_AUX11,
 K_AUX12,
 K_AUX13,
 K_AUX14,
 K_GRAVE_U = 249,
 K_AUX15,
 K_AUX16,

 K_PRINT_SCR = 252,
 K_RIGHT_ALT = 253,
 K_LAST_KEY = 254
} keyNum_t;


class idKeyInput {
public:
 static void Init( void );
 static void Shutdown( void );

 static void ArgCompletion_KeyName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void PreliminaryKeyEvent( int keyNum, bool down );
 static bool IsDown( int keyNum );
 static int GetUsercmdAction( int keyNum );
 static bool GetOverstrikeMode( void );
 static void SetOverstrikeMode( bool state );
 static void ClearStates( void );
 static int StringToKeyNum( const char *str );
 static const char * KeyNumToString( int keyNum, bool localized );

 static void SetBinding( int keyNum, const char *binding );
 static const char * GetBinding( int keyNum );
 static bool UnbindBinding( const char *bind );
 static int NumBinds( const char *binding );
 static bool ExecKeyBinding( int keyNum );
 static const char * KeysFromBinding( const char *bind );
 static const char * BindingFromKey( const char *key );
 static bool KeyIsBoundTo( int keyNum, const char *binding );
 static void WriteBindings( idFile *f );
};
# 201 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/EditField.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/EditField.h"
const int MAX_EDIT_LINE = 256;

typedef struct autoComplete_s {
 bool valid;
 int length;
 char completionString[MAX_EDIT_LINE];
 char currentMatch[MAX_EDIT_LINE];
 int matchCount;
 int matchIndex;
 int findMatchIndex;
} autoComplete_t;

class idEditField {
public:
     idEditField();
     ~idEditField();

 void Clear( void );
 void SetWidthInChars( int w );
 void SetCursor( int c );
 int GetCursor( void ) const;
 void ClearAutoComplete( void );
 int GetAutoCompleteLength( void ) const;
 void AutoComplete( void );
 void CharEvent( int c );
 void KeyDownEvent( int key );
 void Paste( void );
 char * GetBuffer( void );
 void Draw( int x, int y, int width, bool showCursor, const idMaterial *material );
 void SetBuffer( const char *buffer );

private:
 int cursor;
 int scroll;
 int widthInChars;
 char buffer[MAX_EDIT_LINE];
 autoComplete_t autoComplete;
};
# 202 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Console.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Console.h"
class idConsole {
public:
 virtual ~idConsole( void ) {}

 virtual void Init( void ) = 0;
 virtual void Shutdown( void ) = 0;


 virtual void LoadGraphics() = 0;

 virtual bool ProcessEvent( const sysEvent_t *event, bool forceAccept ) = 0;


 virtual bool Active( void ) = 0;


 virtual void ClearNotifyLines( void ) = 0;


 virtual void Close( void ) = 0;

 virtual void Draw( bool forceFullScreen ) = 0;
 virtual void Print( const char *text ) = 0;
};

extern idConsole * console;
# 203 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DemoFile.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/DemoFile.h"
typedef enum {
 DS_FINISHED,
 DS_RENDER,
 DS_SOUND,
 DS_VERSION
} demoSystem_t;

class idDemoFile : public idFile {
public:
     idDemoFile();
     ~idDemoFile();

 const char * GetName( void ) { return (f?f->GetName():""); }
 const char * GetFullPath( void ) { return (f?f->GetFullPath():""); }

 void SetLog( bool b, const char *p );
 void Log( const char *p );
 bool OpenForReading( const char *fileName );
 bool OpenForWriting( const char *fileName );
 void Close();

 const char * ReadHashString();
 void WriteHashString( const char *str );

 void ReadDict( idDict &dict );
 void WriteDict( const idDict &dict );

 int Read( void *buffer, int len );
 int Write( const void *buffer, int len );

private:
 static idCompressor *AllocCompressor( int type );

 bool writing;
 byte * fileImage;
 idFile * f;
 idCompressor * compressor;

 idList<idStr*> demoStrings;
 idFile * fLog;
 bool log;
 idStr logStr;

 static idCVar com_logDemos;
 static idCVar com_compressDemos;
 static idCVar com_preloadDemos;
};
# 204 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Session.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/Session.h"
typedef struct {
 short health;
 short heartRate;
 short stamina;
 short combat;
} logStats_t;




static const int MAX_LOGGED_STATS = 2 * 120;


typedef enum {
 MSG_OK,
 MSG_ABORT,
 MSG_OKCANCEL,
 MSG_YESNO,
 MSG_PROMPT,
 MSG_CDKEY,
 MSG_INFO,
 MSG_WAIT
} msgBoxType_t;

typedef const char * (*HandleGuiCommand_t)( const char * );

class idSession {
public:
 virtual ~idSession() {}



 virtual void Init() = 0;


 virtual void Shutdown() = 0;


 virtual void Stop() = 0;





 virtual void UpdateScreen( bool outOfSequence = true ) = 0;



 virtual void PacifierUpdate() = 0;




 virtual void Frame() = 0;



 virtual bool IsMultiplayer() = 0;


 virtual bool ProcessEvent( const sysEvent_t *event ) = 0;


 virtual void StartMenu( bool playIntro = false ) = 0;

 virtual void SetGUI( idUserInterface *gui, HandleGuiCommand_t handle ) = 0;


 virtual void GuiFrameEvents() = 0;





 virtual const char *MessageBox( msgBoxType_t type, const char *message, const char *title = __null, bool wait = false, const char *fire_yes = __null, const char *fire_no = __null, bool network = false ) = 0;
 virtual void StopBox( void ) = 0;

 virtual void DownloadProgressBox( backgroundDownload_t *bgl, const char *title, int progress_start = 0, int progress_end = 100 ) = 0;

 virtual void SetPlayingSoundWorld() = 0;



 virtual void TimeHitch( int msec ) = 0;



 virtual void ReadCDKey( void ) = 0;
 virtual void WriteCDKey( void ) = 0;


 virtual const char *GetCDKey( bool xp ) = 0;



 virtual bool CheckKey( const char *key, bool netConnect, bool offline_valid[ 2 ] ) = 0;



 virtual bool CDKeysAreValid( bool strict ) = 0;

 virtual void ClearCDKey( bool valid[ 2 ] ) = 0;


 virtual void SetCDKeyGuiVars( void ) = 0;

 virtual bool WaitingForGameAuth( void ) = 0;


 virtual void CDKeysAuthReply( bool valid, const char *auth_msg ) = 0;

 virtual const char *GetCurrentMapName( void ) = 0;

 virtual int GetSaveGameVersion( void ) = 0;


 idRenderWorld * rw;
 idSoundWorld * sw;



 idDemoFile * readDemo;
 idDemoFile * writeDemo;
 int renderdemoVersion;
};

extern idSession * session;
# 205 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncNetwork.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncNetwork.h"
const int ASYNC_PROTOCOL_MINOR = 41;
const int ASYNC_PROTOCOL_VERSION = ( 1 << 16 ) + ASYNC_PROTOCOL_MINOR;



const int MAX_ASYNC_CLIENTS = 4;




const int MAX_USERCMD_BACKUP = 256;
const int MAX_USERCMD_DUPLICATION = 25;
const int MAX_USERCMD_RELAY = 10;



const int MAX_MASTER_SERVERS = 5;

const int MAX_NICKLEN = 32;


const int MAX_SERVER_PORTS = 8;


const int GAME_INIT_ID_INVALID = -1;
const int GAME_INIT_ID_MAP_LOAD = -2;


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/MsgChannel.h" 1
# 56 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/MsgChannel.h"
class idMsgQueue {
public:
     idMsgQueue();

 void Init( int sequence );

 bool Add( const byte *data, const int size );
 bool Get( byte *data, int &size );
 int GetTotalSize( void ) const;
 int GetSpaceLeft( void ) const;
 int GetFirst( void ) const { return first; }
 int GetLast( void ) const { return last; }
 void CopyToBuffer( byte *buf ) const;

private:
 byte buffer[16384];
 int first;
 int last;
 int startIndex;
 int endIndex;

 void WriteByte( byte b );
 byte ReadByte( void );
 void WriteShort( int s );
 int ReadShort( void );
 void WriteLong( int l );
 int ReadLong( void );
 void WriteData( const byte *data, const int size );
 void ReadData( byte *data, const int size );
};


class idMsgChannel {
public:
     idMsgChannel();

 void Init( const netadr_t adr, const int id );
 void Shutdown( void );
 void ResetRate( void );


 void SetMaxOutgoingRate( int rate ) { maxRate = rate; }


 int GetMaxOutgoingRate( void ) { return maxRate; }


 netadr_t GetRemoteAddress( void ) const { return remoteAddress; }


 int GetOutgoingRate( void ) const { return outgoingRateBytes; }


 int GetIncomingRate( void ) const { return incomingRateBytes; }


 float GetOutgoingCompression( void ) const { return outgoingCompression; }


 float GetIncomingCompression( void ) const { return incomingCompression; }


 float GetIncomingPacketLoss( void ) const;


 bool ReadyToSend( const int time ) const;


 int SendMessage( idPort &port, const int time, const idBitMsg &msg );


 void SendNextFragment( idPort &port, const int time );


 bool UnsentFragmentsLeft( void ) const { return unsentFragments; }





 bool Process( const netadr_t from, int time, idBitMsg &msg, int &sequence );


 bool SendReliableMessage( const idBitMsg &msg );


 bool GetReliableMessage( idBitMsg &msg );


 void ClearReliableMessages( void );

private:
 netadr_t remoteAddress;
 int id;
 int maxRate;
 idCompressor * compressor;


 int lastSendTime;
 int lastDataBytes;


 int outgoingRateTime;
 int outgoingRateBytes;
 int incomingRateTime;
 int incomingRateBytes;


 float outgoingCompression;
 float incomingCompression;


 float incomingReceivedPackets;
 float incomingDroppedPackets;
 int incomingPacketLossTime;


 int outgoingSequence;
 int incomingSequence;


 bool unsentFragments;
 int unsentFragmentStart;
 byte unsentBuffer[16384];
 idBitMsg unsentMsg;


 int fragmentSequence;
 int fragmentLength;
 byte fragmentBuffer[16384];


 idMsgQueue reliableSend;
 idMsgQueue reliableReceive;

private:
 void WriteMessageData( idBitMsg &out, const idBitMsg &msg );
 bool ReadMessageData( idBitMsg &out, const idBitMsg &msg );

 void UpdateOutgoingRate( const int time, const int size );
 void UpdateIncomingRate( const int time, const int size );

 void UpdatePacketLoss( const int time, const int numReceived, const int numDropped );
};
# 69 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncNetwork.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncServer.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncServer.h"
const int MAX_CHALLENGES = 64;



const int AUTHORIZE_TIMEOUT = 5000;


typedef enum {
 CDK_WAIT = 0,


 CDK_OK,
 CDK_ONLYLAN,
 CDK_PUREWAIT,
 CDK_PUREOK,
 CDK_MAXSTATES
} authState_t;


typedef enum {
 AUTH_NONE = 0,
 AUTH_OK,
 AUTH_WAIT,
 AUTH_DENY,
 AUTH_MAXSTATES
} authReply_t;



typedef enum {
 AUTH_REPLY_WAITING = 0,
 AUTH_REPLY_UNKNOWN,
 AUTH_REPLY_DENIED,
 AUTH_REPLY_PRINT,
 AUTH_REPLY_SRVWAIT,
 AUTH_REPLY_MAXSTATES
} authReplyMsg_t;

typedef struct challenge_s {
 netadr_t address;
 int clientId;
 int challenge;
 int time;
 int pingTime;
 bool connected;
 authState_t authState;
 authReply_t authReply;
 authReplyMsg_t authReplyMsg;
 idStr authReplyPrint;
 char guid[12];
 int OS;
} challenge_t;

typedef enum {
 SCS_FREE,
 SCS_ZOMBIE,
 SCS_PUREWAIT,
 SCS_CONNECTED,
 SCS_INGAME
} serverClientState_t;

typedef struct serverClient_s {
 int OS;
 int clientId;
 serverClientState_t clientState;
 int clientPrediction;
 int clientAheadTime;
 int clientRate;
 int clientPing;

 int gameInitSequence;
 int gameFrame;
 int gameTime;

 idMsgChannel channel;
 int lastConnectTime;
 int lastEmptyTime;
 int lastPingTime;
 int lastSnapshotTime;
 int lastPacketTime;
 int lastInputTime;
 int snapshotSequence;
 int acknowledgeSnapshotSequence;
 int numDuplicatedUsercmds;

 char guid[12];

} serverClient_t;


class idAsyncServer {
public:
      idAsyncServer();

 bool InitPort( void );
 void ClosePort( void );
 void Spawn( void );
 void Kill( void );
 void ExecuteMapChange( void );

 int GetPort( void ) const;
 netadr_t GetBoundAdr( void ) const;
 bool IsActive( void ) const { return active; }
 int GetDelay( void ) const { return gameTimeResidual; }
 int GetOutgoingRate( void ) const;
 int GetIncomingRate( void ) const;
 bool IsClientInGame( int clientNum ) const;
 int GetClientPing( int clientNum ) const;
 int GetClientPrediction( int clientNum ) const;
 int GetClientTimeSinceLastPacket( int clientNum ) const;
 int GetClientTimeSinceLastInput( int clientNum ) const;
 int GetClientOutgoingRate( int clientNum ) const;
 int GetClientIncomingRate( int clientNum ) const;
 float GetClientOutgoingCompression( int clientNum ) const;
 float GetClientIncomingCompression( int clientNum ) const;
 float GetClientIncomingPacketLoss( int clientNum ) const;
 int GetNumClients( void ) const;
 int GetNumIdleClients( void ) const;
 int GetLocalClientNum( void ) const { return localClientNum; }

 void RunFrame( void );
 void ProcessConnectionLessMessages( void );
 void RemoteConsoleOutput( const char *string );
 void SendReliableGameMessage( int clientNum, const idBitMsg &msg );
 void SendReliableGameMessageExcluding( int clientNum, const idBitMsg &msg );
 void LocalClientSendReliableMessage( const idBitMsg &msg );

 void MasterHeartbeat( bool force = false );
 void DropClient( int clientNum, const char *reason );

 void PacifierUpdate( void );

 void UpdateUI( int clientNum );

 void UpdateAsyncStatsAvg( void );
 void GetAsyncStatsAvgMsg( idStr &msg );

 void PrintLocalServerInfo( void );

private:
 bool active;
 int realTime;

 int serverTime;
 idPort serverPort;
 int serverId;
 int serverDataChecksum;
 int localClientNum;

 challenge_t challenges[MAX_CHALLENGES];
 serverClient_t clients[MAX_ASYNC_CLIENTS];
 usercmd_t userCmds[MAX_USERCMD_BACKUP][MAX_ASYNC_CLIENTS];

 int gameInitId;
 int gameFrame;
 int gameTime;
 int gameTimeResidual;

 netadr_t rconAddress;

 int nextHeartbeatTime;
 int nextAsyncStatsTime;

 bool serverReloadingEngine;

 bool noRconOutput;

 int lastAuthTime;



 static const int stats_numsamples = 60;
 int stats_outrate[ stats_numsamples ];
 int stats_current;
 int stats_average_sum;
 int stats_max;
 int stats_max_index;

 void PrintOOB( const netadr_t to, int opcode, const char *string );
 void DuplicateUsercmds( int frame, int time );
 void ClearClient( int clientNum );
 void InitClient( int clientNum, int clientId, int clientRate );
 void InitLocalClient( int clientNum );
 void BeginLocalClient( void );
 void LocalClientInput( void );
 void CheckClientTimeouts( void );
 void SendPrintBroadcast( const char *string );
 void SendPrintToClient( int clientNum, const char *string );
 void SendUserInfoBroadcast( int userInfoNum, const idDict &info, bool sendToAll = false );
 void SendUserInfoToClient( int clientNum, int userInfoNum, const idDict &info );
 void SendSyncedCvarsBroadcast( const idDict &cvars );
 void SendSyncedCvarsToClient( int clientNum, const idDict &cvars );
 void SendApplySnapshotToClient( int clientNum, int sequence );
 bool SendEmptyToClient( int clientNum, bool force = false );
 bool SendPingToClient( int clientNum );
 void SendGameInitToClient( int clientNum );
 bool SendSnapshotToClient( int clientNum );
 void ProcessUnreliableClientMessage( int clientNum, const idBitMsg &msg );
 void ProcessReliableClientMessages( int clientNum );
 void ProcessChallengeMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessConnectMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessRemoteConsoleMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessGetInfoMessage( const netadr_t from, const idBitMsg &msg );
 bool ConnectionlessMessage( const netadr_t from, const idBitMsg &msg );
 bool ProcessMessage( const netadr_t from, idBitMsg &msg );
 void ProcessAuthMessage( const idBitMsg &msg );
 bool SendPureServerMessage( const netadr_t to, int OS );
 void ProcessPureMessage( const netadr_t from, const idBitMsg &msg );
 int ValidateChallenge( const netadr_t from, int challenge, int clientId );
 bool SendReliablePureToClient( int clientNum );
 void ProcessReliablePure( int clientNum, const idBitMsg &msg );
 bool VerifyChecksumMessage( int clientNum, const netadr_t *from, const idBitMsg &msg, idStr &reply, int OS );
 void SendReliableMessage( int clientNum, const idBitMsg &msg );
 int UpdateTime( int clamp );
 void SendEnterGameToClient( int clientNum );
 void ProcessDownloadRequestMessage( const netadr_t from, const idBitMsg &msg );
};
# 70 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncNetwork.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/ServerScan.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/ServerScan.h"
typedef struct {
 netadr_t adr;
 int id;
 int time;
} inServer_t;


typedef struct {
 netadr_t adr;
 idDict serverInfo;
 int ping;
 int id;
 int clients;
 char nickname[ MAX_NICKLEN ][ MAX_ASYNC_CLIENTS ];
 short pings[ MAX_ASYNC_CLIENTS ];
 int rate[ MAX_ASYNC_CLIENTS ];
 int OSMask;
    int challenge;
} networkServer_t;

typedef enum {
 SORT_PING,
 SORT_SERVERNAME,
 SORT_PLAYERS,
 SORT_GAMETYPE,
 SORT_MAP,
 SORT_GAME
} serverSort_t;

class idServerScan : public idList<networkServer_t> {
public:
      idServerScan( );

 int InfoResponse( networkServer_t &server );


 void AddServer( int id, const char *srv );



 void StartServers( bool timeout );

 void EndServers( );


 void NetScan( );


 void Clear( );


 void RunFrame( );

 typedef enum {
  IDLE = 0,
  WAIT_ON_INIT,
  LAN_SCAN,
  NET_SCAN
 } scan_state_t;

 scan_state_t GetState() { return scan_state; }
 void SetState( scan_state_t );

 bool GetBestPing( networkServer_t &serv );


 void SetupLANScan( );

 void GUIConfig( idUserInterface *pGUI, const char *name );

 void GUIUpdateSelected( void );

 void Shutdown( );

 void ApplyFilter( );


 void SetSorting( serverSort_t sort );

 int GetChallenge( );

private:
 static const int MAX_PINGREQUESTS = 32;
 static const int REPLY_TIMEOUT = 999;
 static const int INCOMING_TIMEOUT = 1500;
 static const int REFRESH_START = 10000;

 scan_state_t scan_state;

 bool incoming_net;
 bool incoming_useTimeout;
 int incoming_lastTime;

 int lan_pingtime;




 idDict net_info;

 idList<inServer_t> net_servers;


 int cur_info;

 idUserInterface *m_pGUI;
 idListGUI * listGUI;

 serverSort_t m_sort;
 bool m_sortAscending;
 idList<int> m_sortedServers;

 idStr screenshot;
 int challenge;

 int endWaitTime;

private:
 void LocalClear( );

 void EmitGetInfo( netadr_t &serv );
 void GUIAdd( int id, const networkServer_t server );
 bool IsFiltered( const networkServer_t server );

 static int Cmp( const int *a, const int *b );
};
# 71 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncNetwork.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncClient.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncClient.h"
typedef enum {
 CS_DISCONNECTED,
 CS_PURERESTART,
 CS_CHALLENGING,
 CS_CONNECTING,
 CS_CONNECTED,
 CS_INGAME
} clientState_t;

typedef enum {
 AUTHKEY_BADKEY,
 AUTHKEY_GUID
} authKeyMsg_t;

typedef enum {
 AUTHKEY_BAD_INVALID,
 AUTHKEY_BAD_BANNED,
 AUTHKEY_BAD_INUSE,
 AUTHKEY_BAD_MSG
} authBadKeyStatus_t;

typedef enum {
 UPDATE_NONE,
 UPDATE_SENT,
 UPDATE_READY,
 UPDATE_DLING,
 UPDATE_DONE
} clientUpdateState_t;

typedef struct {
 idStr url;
 idStr filename;
 int size;
 int checksum;
} pakDlEntry_t;

class idAsyncClient {
public:
      idAsyncClient();

 void Shutdown( void );
 bool InitPort( void );
 void ClosePort( void );
 void ConnectToServer( const netadr_t adr );
 void ConnectToServer( const char *address );
 void Reconnect( void );
 void DisconnectFromServer( void );
 void GetServerInfo( const netadr_t adr );
 void GetServerInfo( const char *address );
 void GetLANServers( void );
 void GetNETServers( void );
 void ListServers( void );
 void ClearServers( void );
 void RemoteConsole( const char *command );
 bool IsPortInitialized() { return clientPort.GetPort() != 0; }

 bool IsActive( void ) const { return active; }
 int GetLocalClientNum( void ) const { return clientNum; }
 int GetPrediction( void ) const;
 int GetTimeSinceLastPacket( void ) const;
 int GetOutgoingRate( void ) const;
 int GetIncomingRate( void ) const;
 float GetOutgoingCompression( void ) const;
 float GetIncomingCompression( void ) const;
 float GetIncomingPacketLoss( void ) const;
 int GetPredictedFrames( void ) const { return lastFrameDelta; }

 void RunFrame( void );
 void SendReliableGameMessage( const idBitMsg &msg );

 void SendVersionCheck( bool fromMenu = false );


 bool SendAuthCheck( const char *cdkey, const char *xpkey );

 void PacifierUpdate( void );

 idServerScan serverList;

private:
 bool active;
 int realTime;

 int clientTime;
 idPort clientPort;
 int clientId;
 int clientDataChecksum;
 int clientNum;
 clientState_t clientState;
 int clientPrediction;
 int clientPredictTime;

 netadr_t serverAddress;
 int serverId;
 int serverChallenge;
 int serverMessageSequence;

 netadr_t lastRconAddress;
 int lastRconTime;

 idMsgChannel channel;
 int lastConnectTime;
 int lastEmptyTime;
 int lastPacketTime;
 int lastSnapshotTime;

 int snapshotSequence;
 int snapshotGameFrame;
 int snapshotGameTime;

 int gameInitId;
 int gameFrame;
 int gameTime;
 int gameTimeResidual;

 usercmd_t userCmds[MAX_USERCMD_BACKUP][MAX_ASYNC_CLIENTS];

 idUserInterface * guiNetMenu;

 clientUpdateState_t updateState;
 int updateSentTime;
 idStr updateMSG;
 idStr updateURL;
 bool updateDirectDownload;
 idStr updateFile;
 dlMime_t updateMime;
 idStr updateFallback;
 bool showUpdateMessage;

 backgroundDownload_t backgroundDownload;
 int dltotal;
 int dlnow;

 int lastFrameDelta;

 int dlRequest;
 int dlChecksums[ MAX_PURE_PAKS ];
 int dlCount;
 idList<pakDlEntry_t>dlList;
 int currentDlSize;
 int totalDlSize;

 void Clear( void );
 void ClearPendingPackets( void );
 void DuplicateUsercmds( int frame, int time );
 void SendUserInfoToServer( void );
 void SendEmptyToServer( bool force = false, bool mapLoad = false );
 void SendPingResponseToServer( int time );
 void SendUsercmdsToServer( void );
 void InitGame( int serverGameInitId, int serverGameFrame, int serverGameTime, const idDict &serverSI );
 void ProcessUnreliableServerMessage( const idBitMsg &msg );
 void ProcessReliableServerMessages( void );
 void ProcessChallengeResponseMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessConnectResponseMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessDisconnectMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessInfoResponseMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessPrintMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessServersListMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessAuthKeyMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessVersionMessage( const netadr_t from, const idBitMsg &msg );
 void ConnectionlessMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessMessage( const netadr_t from, idBitMsg &msg );
 void SetupConnection( void );
 void ProcessPureMessage( const netadr_t from, const idBitMsg &msg );
 bool ValidatePureServerChecksums( const netadr_t from, const idBitMsg &msg );
 void ProcessReliableMessagePure( const idBitMsg &msg );
 static const char* HandleGuiCommand( const char *cmd );
 const char* HandleGuiCommandInternal( const char *cmd );
 void SendVersionDLUpdate( int state );
 void HandleDownloads( void );
 void Idle( void );
 int UpdateTime( int clamp );
 void ReadLocalizedServerString( const idBitMsg &msg, char* out, int maxLen );
 bool CheckTimeout( void );
 void ProcessDownloadInfoMessage( const netadr_t from, const idBitMsg &msg );
 int GetDownloadRequest( const int checksums[ MAX_PURE_PAKS ], int count, int gamePakChecksum );
};
# 72 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncNetwork.h" 2
# 83 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../framework/async/AsyncNetwork.h"
enum {
 SERVER_UNRELIABLE_MESSAGE_EMPTY = 0,
 SERVER_UNRELIABLE_MESSAGE_PING,
 SERVER_UNRELIABLE_MESSAGE_GAMEINIT,
 SERVER_UNRELIABLE_MESSAGE_SNAPSHOT
};


enum {
 SERVER_RELIABLE_MESSAGE_PURE = 0,
 SERVER_RELIABLE_MESSAGE_RELOAD,
 SERVER_RELIABLE_MESSAGE_CLIENTINFO,
 SERVER_RELIABLE_MESSAGE_SYNCEDCVARS,
 SERVER_RELIABLE_MESSAGE_PRINT,
 SERVER_RELIABLE_MESSAGE_DISCONNECT,
 SERVER_RELIABLE_MESSAGE_APPLYSNAPSHOT,
 SERVER_RELIABLE_MESSAGE_GAME,
 SERVER_RELIABLE_MESSAGE_ENTERGAME
};


enum {
 CLIENT_UNRELIABLE_MESSAGE_EMPTY = 0,
 CLIENT_UNRELIABLE_MESSAGE_PINGRESPONSE,
 CLIENT_UNRELIABLE_MESSAGE_USERCMD
};


enum {
 CLIENT_RELIABLE_MESSAGE_PURE = 0,
 CLIENT_RELIABLE_MESSAGE_CLIENTINFO,
 CLIENT_RELIABLE_MESSAGE_PRINT,
 CLIENT_RELIABLE_MESSAGE_DISCONNECT,
 CLIENT_RELIABLE_MESSAGE_GAME
};


enum {
 SERVER_PRINT_MISC = 0,
 SERVER_PRINT_BADPROTOCOL,
 SERVER_PRINT_RCON,
 SERVER_PRINT_GAMEDENY,
 SERVER_PRINT_BADCHALLENGE
};

enum {
 SERVER_DL_REDIRECT = 1,
 SERVER_DL_LIST,
 SERVER_DL_NONE
};

enum {
 SERVER_PAK_NO = 0,
 SERVER_PAK_YES,
 SERVER_PAK_END
};

typedef struct master_s {
 idCVar * var;
 netadr_t address;
 bool resolved;
} master_t;


class idAsyncNetwork {
public:
       idAsyncNetwork();

 static void Init( void );
 static void Shutdown( void );
 static bool IsActive( void ) { return ( server.IsActive() || client.IsActive() ); }
 static void RunFrame( void );

 static void WriteUserCmdDelta( idBitMsg &msg, const usercmd_t &cmd, const usercmd_t *base );
 static void ReadUserCmdDelta( const idBitMsg &msg, usercmd_t &cmd, const usercmd_t *base );

 static bool DuplicateUsercmd( const usercmd_t &previousUserCmd, usercmd_t &currentUserCmd, int frame, int time );
 static bool UsercmdInputChanged( const usercmd_t &previousUserCmd, const usercmd_t &currentUserCmd );


 static bool GetMasterAddress( int index, netadr_t &adr );

 static netadr_t GetMasterAddress( void );

 static void GetNETServers( );

 static void ExecuteSessionCommand( const char *sessCmd );

 static idAsyncServer server;
 static idAsyncClient client;

 static idCVar verbose;
 static idCVar allowCheats;
 static idCVar serverDedicated;
 static idCVar serverSnapshotDelay;
 static idCVar serverMaxClientRate;
 static idCVar clientMaxRate;
 static idCVar serverMaxUsercmdRelay;
 static idCVar serverZombieTimeout;
 static idCVar serverClientTimeout;
 static idCVar clientServerTimeout;
 static idCVar serverDrawClient;
 static idCVar serverRemoteConsolePassword;
 static idCVar clientPrediction;
 static idCVar clientMaxPrediction;
 static idCVar clientUsercmdBackup;
 static idCVar clientRemoteConsoleAddress;
 static idCVar clientRemoteConsolePassword;
 static idCVar master0;
 static idCVar master1;
 static idCVar master2;
 static idCVar master3;
 static idCVar master4;
 static idCVar LANServer;
 static idCVar serverReloadEngine;
 static idCVar serverAllowServerMod;
 static idCVar idleServer;
 static idCVar clientDownload;


 static void BuildInvalidKeyMsg( idStr &msg, bool valid[ 2 ] );

private:
 static int realTime;
 static master_t masters[ MAX_MASTER_SERVERS];

 static void SpawnServer_f( const idCmdArgs &args );
 static void NextMap_f( const idCmdArgs &args );
 static void Connect_f( const idCmdArgs &args );
 static void Reconnect_f( const idCmdArgs &args );
 static void GetServerInfo_f( const idCmdArgs &args );
 static void GetLANServers_f( const idCmdArgs &args );
 static void ListServers_f( const idCmdArgs &args );
 static void RemoteConsole_f( const idCmdArgs &args );
 static void Heartbeat_f( const idCmdArgs &args );
 static void Kick_f( const idCmdArgs &args );
 static void CheckNewVersion_f( const idCmdArgs &args );
 static void UpdateUI_f( const idCmdArgs &args );
};
# 208 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2



# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/edit_public.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/edit_public.h"
class idProgram;
class idInterpreter;



void RadiantInit( void );
void RadiantShutdown( void );
void RadiantRun( void );
void RadiantPrint( const char *text );
void RadiantSync( const char *mapName, const idVec3 &viewOrg, const idAngles &viewAngles );



void LightEditorInit( const idDict *spawnArgs );
void LightEditorShutdown( void );
void LightEditorRun( void );



void SoundEditorInit( const idDict *spawnArgs );
void SoundEditorShutdown( void );
void SoundEditorRun( void );



void AFEditorInit( const idDict *spawnArgs );
void AFEditorShutdown( void );
void AFEditorRun( void );



void ParticleEditorInit( const idDict *spawnArgs );
void ParticleEditorShutdown( void );
void ParticleEditorRun( void );



void PDAEditorInit( const idDict *spawnArgs );
void PDAEditorShutdown( void );
void PDAEditorRun( void );



void ScriptEditorInit( const idDict *spawnArgs );
void ScriptEditorShutdown( void );
void ScriptEditorRun( void );



void DeclBrowserInit( const idDict *spawnArgs );
void DeclBrowserShutdown( void );
void DeclBrowserRun( void );
void DeclBrowserReloadDeclarations( void );



void GUIEditorInit( void );
void GUIEditorShutdown( void );
void GUIEditorRun( void );
bool GUIEditorHandleMessage( void *msg );



void DebuggerClientLaunch( void );
void DebuggerClientInit( const char *cmdline );
bool DebuggerServerInit( void );
void DebuggerServerShutdown( void );
void DebuggerServerPrint( const char *text );
void DebuggerServerCheckBreakpoint( idInterpreter *interpreter, idProgram *program, int instructionPointer );


void MaterialEditorInit( void );
void MaterialEditorRun( void );
void MaterialEditorShutdown( void );
void MaterialEditorPrintConsole( const char *msg );
# 212 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/compilers/compiler_public.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/../idlib/../tools/compilers/compiler_public.h"
void Dmap_f( const idCmdArgs &args );


void RenderBump_f( const idCmdArgs &args );
void RenderBumpFlat_f( const idCmdArgs &args );


void RunAAS_f( const idCmdArgs &args );
void RunAASDir_f( const idCmdArgs &args );
void RunReach_f( const idCmdArgs &args );


void RoQFileEncode_f( const idCmdArgs &args );
# 215 "d:/Data/Nintendo/DoomGX/src/game/../idlib/precompiled.h" 2
# 30 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp" 2
#pragma hdrstop

# 1 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 1
# 58 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h"
extern idRenderWorld * gameRenderWorld;
extern idSoundWorld * gameSoundWorld;





class idEntity;
class idActor;
class idPlayer;
class idCamera;
class idWorldspawn;
class idTestModel;
class idAAS;
class idAI;
class idSmokeParticles;
class idEntityFx;
class idTypeInfo;
class idProgram;
class idThread;
class idEditEntities;
class idLocationEntity;
# 95 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h"
void gameError( const char *fmt, ... );

# 1 "d:/Data/Nintendo/DoomGX/src/game/gamesys/Event.h" 1
# 50 "d:/Data/Nintendo/DoomGX/src/game/gamesys/Event.h"
class idClass;
class idTypeInfo;

class idEventDef {
private:
 const char *name;
 const char *formatspec;
 unsigned int formatspecIndex;
 int returnType;
 int numargs;
 size_t argsize;
 int argOffset[ 8 ];
 int eventnum;
 const idEventDef * next;

 static idEventDef * eventDefList[4096];
 static int numEventDefs;

public:
        idEventDef( const char *command, const char *formatspec = __null, char returnType = 0 );

 const char *GetName( void ) const;
 const char *GetArgFormat( void ) const;
 unsigned int GetFormatspecIndex( void ) const;
 char GetReturnType( void ) const;
 int GetEventNum( void ) const;
 int GetNumArgs( void ) const;
 size_t GetArgSize( void ) const;
 int GetArgOffset( int arg ) const;

 static int NumEventCommands( void );
 static const idEventDef *GetEventCommand( int eventnum );
 static const idEventDef *FindEvent( const char *name );
};

class idSaveGame;
class idRestoreGame;

class idEvent {
private:
 const idEventDef *eventdef;
 byte *data;
 int time;
 idClass *object;
 const idTypeInfo *typeinfo;

 idLinkList<idEvent> eventNode;

 static idDynamicBlockAlloc<byte, 16 * 1024, 256> eventDataAllocator;


public:
 static bool initialized;

        ~idEvent();

 static idEvent *Alloc( const idEventDef *evdef, int numargs, va_list args );
 static void CopyArgs( const idEventDef *evdef, int numargs, va_list args, int data[ 8 ] );

 void Free( void );
 void Schedule( idClass *object, const idTypeInfo *cls, int time );
 byte *GetData( void );

 static void CancelEvents( const idClass *obj, const idEventDef *evdef = __null );
 static void ClearEventList( void );
 static void ServiceEvents( void );
 static void Init( void );
 static void Shutdown( void );


 static void Save( idSaveGame *savefile );
 static void Restore( idRestoreGame *savefile );
 static void SaveTrace( idSaveGame *savefile, const trace_t &trace );
 static void RestoreTrace( idRestoreGame *savefile, trace_t &trace );

};






inline byte *idEvent::GetData( void ) {
 return data;
}






inline const char *idEventDef::GetName( void ) const {
 return name;
}






inline const char *idEventDef::GetArgFormat( void ) const {
 return formatspec;
}






inline unsigned int idEventDef::GetFormatspecIndex( void ) const {
 return formatspecIndex;
}






inline char idEventDef::GetReturnType( void ) const {
 return returnType;
}






inline int idEventDef::GetNumArgs( void ) const {
 return numargs;
}






inline size_t idEventDef::GetArgSize( void ) const {
 return argsize;
}






inline int idEventDef::GetArgOffset( int arg ) const {
 ((void)0);
 return argOffset[ arg ];
}






inline int idEventDef::GetEventNum( void ) const {
 return eventnum;
}
# 98 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/gamesys/Class.h" 1
# 38 "d:/Data/Nintendo/DoomGX/src/game/gamesys/Class.h"
class idClass;
class idTypeInfo;

extern const idEventDef EV_Remove;
extern const idEventDef EV_SafeRemove;

typedef void ( idClass::*eventCallback_t )( void );

template< class Type >
struct idEventFunc {
 const idEventDef *event;
 eventCallback_t function;
};






class idEventArg {
public:
 int type;
 int value;

 idEventArg() { type = 'd'; value = 0; };
 idEventArg( int data ) { type = 'd'; value = data; };
 idEventArg( float data ) { type = 'f'; value = *reinterpret_cast<int *>( &data ); };
 idEventArg( idVec3 &data ) { type = 'v'; value = reinterpret_cast<int>( &data ); };
 idEventArg( const idStr &data ) { type = 's'; value = reinterpret_cast<int>( data.c_str() ); };
 idEventArg( const char *data ) { type = 's'; value = reinterpret_cast<int>( data ); };
 idEventArg( const class idEntity *data ) { type = 'e'; value = reinterpret_cast<int>( data ); };
 idEventArg( const struct trace_s *data ) { type = 't'; value = reinterpret_cast<int>( data ); };
};

class idAllocError : public idException {
public:
 idAllocError( const char *text = "" ) : idException( text ) {}
};
# 169 "d:/Data/Nintendo/DoomGX/src/game/gamesys/Class.h"
typedef void ( idClass::*classSpawnFunc_t )( void );

class idSaveGame;
class idRestoreGame;

class idClass {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idClass> eventCallbacks[];




 void * operator new( size_t );
 void * operator new( size_t s, int, int, char *, int );
 void operator delete( void * );
 void operator delete( void *, int, int, char *, int );




 virtual ~idClass();

 void Spawn( void );
 void CallSpawn( void );
 bool IsType( const idTypeInfo &c ) const;
 const char * GetClassname( void ) const;
 const char * GetSuperclass( void ) const;
 void FindUninitializedMemory( void );

 void Save( idSaveGame *savefile ) const {};
 void Restore( idRestoreGame *savefile ) {};

 bool RespondsTo( const idEventDef &ev ) const;

 bool PostEventMS( const idEventDef *ev, int time );
 bool PostEventMS( const idEventDef *ev, int time, idEventArg arg1 );
 bool PostEventMS( const idEventDef *ev, int time, idEventArg arg1, idEventArg arg2 );
 bool PostEventMS( const idEventDef *ev, int time, idEventArg arg1, idEventArg arg2, idEventArg arg3 );
 bool PostEventMS( const idEventDef *ev, int time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4 );
 bool PostEventMS( const idEventDef *ev, int time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5 );
 bool PostEventMS( const idEventDef *ev, int time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6 );
 bool PostEventMS( const idEventDef *ev, int time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6, idEventArg arg7 );
 bool PostEventMS( const idEventDef *ev, int time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6, idEventArg arg7, idEventArg arg8 );

 bool PostEventSec( const idEventDef *ev, float time );
 bool PostEventSec( const idEventDef *ev, float time, idEventArg arg1 );
 bool PostEventSec( const idEventDef *ev, float time, idEventArg arg1, idEventArg arg2 );
 bool PostEventSec( const idEventDef *ev, float time, idEventArg arg1, idEventArg arg2, idEventArg arg3 );
 bool PostEventSec( const idEventDef *ev, float time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4 );
 bool PostEventSec( const idEventDef *ev, float time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5 );
 bool PostEventSec( const idEventDef *ev, float time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6 );
 bool PostEventSec( const idEventDef *ev, float time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6, idEventArg arg7 );
 bool PostEventSec( const idEventDef *ev, float time, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6, idEventArg arg7, idEventArg arg8 );

 bool ProcessEvent( const idEventDef *ev );
 bool ProcessEvent( const idEventDef *ev, idEventArg arg1 );
 bool ProcessEvent( const idEventDef *ev, idEventArg arg1, idEventArg arg2 );
 bool ProcessEvent( const idEventDef *ev, idEventArg arg1, idEventArg arg2, idEventArg arg3 );
 bool ProcessEvent( const idEventDef *ev, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4 );
 bool ProcessEvent( const idEventDef *ev, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5 );
 bool ProcessEvent( const idEventDef *ev, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6 );
 bool ProcessEvent( const idEventDef *ev, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6, idEventArg arg7 );
 bool ProcessEvent( const idEventDef *ev, idEventArg arg1, idEventArg arg2, idEventArg arg3, idEventArg arg4, idEventArg arg5, idEventArg arg6, idEventArg arg7, idEventArg arg8 );

 bool ProcessEventArgPtr( const idEventDef *ev, int *data );
 void CancelEvents( const idEventDef *ev );

 void Event_Remove( void );


 static void Init( void );
 static void Shutdown( void );
 static idTypeInfo * GetClass( const char *name );
 static void DisplayInfo_f( const idCmdArgs &args );
 static void ListClasses_f( const idCmdArgs &args );
 static idClass * CreateInstance( const char *name );
 static int GetNumTypes( void ) { return types.Num(); }
 static int GetTypeNumBits( void ) { return typeNumBits; }
 static idTypeInfo * GetType( int num );

private:
 classSpawnFunc_t CallSpawnFunc( idTypeInfo *cls );

 bool PostEventArgs( const idEventDef *ev, int time, int numargs, ... );
 bool ProcessEventArgs( const idEventDef *ev, int numargs, ... );

 void Event_SafeRemove( void );

 static bool initialized;
 static idList<idTypeInfo *> types;
 static idList<idTypeInfo *> typenums;
 static int typeNumBits;
 static int memused;
 static int numobjects;
};







class idTypeInfo {
public:
 const char * classname;
 const char * superclass;
 idClass * ( *CreateInstance )( void );
 void ( idClass::*Spawn )( void );
 void ( idClass::*Save )( idSaveGame *savefile ) const;
 void ( idClass::*Restore )( idRestoreGame *savefile );

 idEventFunc<idClass> * eventCallbacks;
 eventCallback_t * eventMap;
 idTypeInfo * super;
 idTypeInfo * next;
 bool freeEventMap;
 int typeNum;
 int lastChild;

 idHierarchy<idTypeInfo> node;

        idTypeInfo( const char *classname, const char *superclass,
            idEventFunc<idClass> *eventCallbacks, idClass *( *CreateInstance )( void ), void ( idClass::*Spawn )( void ),
            void ( idClass::*Save )( idSaveGame *savefile ) const, void ( idClass::*Restore )( idRestoreGame *savefile ) );
        ~idTypeInfo();

 void Init( void );
 void Shutdown( void );

 bool IsType( const idTypeInfo &superclass ) const;
 bool RespondsTo( const idEventDef &ev ) const;
};
# 310 "d:/Data/Nintendo/DoomGX/src/game/gamesys/Class.h"
inline bool idTypeInfo::IsType( const idTypeInfo &type ) const {
 return ( ( typeNum >= type.typeNum ) && ( typeNum <= type.lastChild ) );
}






inline bool idTypeInfo::RespondsTo( const idEventDef &ev ) const {
 ((void)0);
 if ( !eventMap[ ev.GetEventNum() ] ) {

  return false;
 }

 return true;
}
# 337 "d:/Data/Nintendo/DoomGX/src/game/gamesys/Class.h"
inline bool idClass::IsType( const idTypeInfo &superclass ) const {
 idTypeInfo *subclass;

 subclass = GetType();
 return subclass->IsType( superclass );
}






inline bool idClass::RespondsTo( const idEventDef &ev ) const {
 const idTypeInfo *c;

 ((void)0);
 c = GetType();
 return c->RespondsTo( ev );
}
# 99 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/gamesys/SysCvar.h" 1
# 32 "d:/Data/Nintendo/DoomGX/src/game/gamesys/SysCvar.h"
extern idCVar developer;

extern idCVar g_cinematic;
extern idCVar g_cinematicMaxSkipTime;

extern idCVar r_aspectRatio;

extern idCVar g_monsters;
extern idCVar g_decals;
extern idCVar g_knockback;
extern idCVar g_skill;
extern idCVar g_gravity;
extern idCVar g_skipFX;
extern idCVar g_skipParticles;
extern idCVar g_bloodEffects;
extern idCVar g_projectileLights;
extern idCVar g_doubleVision;
extern idCVar g_muzzleFlash;

extern idCVar g_disasm;
extern idCVar g_debugBounds;
extern idCVar g_debugAnim;
extern idCVar g_debugMove;
extern idCVar g_debugDamage;
extern idCVar g_debugWeapon;
extern idCVar g_debugScript;
extern idCVar g_debugMover;
extern idCVar g_debugTriggers;
extern idCVar g_debugCinematic;
extern idCVar g_stopTime;
extern idCVar g_armorProtection;
extern idCVar g_armorProtectionMP;
extern idCVar g_damageScale;
extern idCVar g_useDynamicProtection;
extern idCVar g_healthTakeTime;
extern idCVar g_healthTakeAmt;
extern idCVar g_healthTakeLimit;

extern idCVar g_showPVS;
extern idCVar g_showTargets;
extern idCVar g_showTriggers;
extern idCVar g_showCollisionWorld;
extern idCVar g_showCollisionModels;
extern idCVar g_showCollisionTraces;
extern idCVar g_maxShowDistance;
extern idCVar g_showEntityInfo;
extern idCVar g_showviewpos;
extern idCVar g_showcamerainfo;
extern idCVar g_showTestModelFrame;
extern idCVar g_showActiveEntities;
extern idCVar g_showEnemies;

extern idCVar g_frametime;
extern idCVar g_timeentities;

extern idCVar ai_debugScript;
extern idCVar ai_debugMove;
extern idCVar ai_debugTrajectory;
extern idCVar ai_testPredictPath;
extern idCVar ai_showCombatNodes;
extern idCVar ai_showPaths;
extern idCVar ai_showObstacleAvoidance;
extern idCVar ai_blockedFailSafe;

extern idCVar g_dvTime;
extern idCVar g_dvAmplitude;
extern idCVar g_dvFrequency;

extern idCVar g_kickTime;
extern idCVar g_kickAmplitude;
extern idCVar g_blobTime;
extern idCVar g_blobSize;

extern idCVar g_testHealthVision;
extern idCVar g_editEntityMode;
extern idCVar g_dragEntity;
extern idCVar g_dragDamping;
extern idCVar g_dragShowSelection;
extern idCVar g_dropItemRotation;

extern idCVar g_vehicleVelocity;
extern idCVar g_vehicleForce;
extern idCVar g_vehicleSuspensionUp;
extern idCVar g_vehicleSuspensionDown;
extern idCVar g_vehicleSuspensionKCompress;
extern idCVar g_vehicleSuspensionDamping;
extern idCVar g_vehicleTireFriction;

extern idCVar ik_enable;
extern idCVar ik_debug;

extern idCVar af_useLinearTime;
extern idCVar af_useImpulseFriction;
extern idCVar af_useJointImpulseFriction;
extern idCVar af_useSymmetry;
extern idCVar af_skipSelfCollision;
extern idCVar af_skipLimits;
extern idCVar af_skipFriction;
extern idCVar af_forceFriction;
extern idCVar af_maxLinearVelocity;
extern idCVar af_maxAngularVelocity;
extern idCVar af_timeScale;
extern idCVar af_jointFrictionScale;
extern idCVar af_contactFrictionScale;
extern idCVar af_highlightBody;
extern idCVar af_highlightConstraint;
extern idCVar af_showTimings;
extern idCVar af_showConstraints;
extern idCVar af_showConstraintNames;
extern idCVar af_showConstrainedBodies;
extern idCVar af_showPrimaryOnly;
extern idCVar af_showTrees;
extern idCVar af_showLimits;
extern idCVar af_showBodies;
extern idCVar af_showBodyNames;
extern idCVar af_showMass;
extern idCVar af_showTotalMass;
extern idCVar af_showInertia;
extern idCVar af_showVelocity;
extern idCVar af_showActive;
extern idCVar af_testSolid;

extern idCVar rb_showTimings;
extern idCVar rb_showBodies;
extern idCVar rb_showMass;
extern idCVar rb_showInertia;
extern idCVar rb_showVelocity;
extern idCVar rb_showActive;

extern idCVar pm_jumpheight;
extern idCVar pm_stepsize;
extern idCVar pm_crouchspeed;
extern idCVar pm_walkspeed;
extern idCVar pm_runspeed;
extern idCVar pm_noclipspeed;
extern idCVar pm_spectatespeed;
extern idCVar pm_spectatebbox;
extern idCVar pm_usecylinder;
extern idCVar pm_minviewpitch;
extern idCVar pm_maxviewpitch;
extern idCVar pm_stamina;
extern idCVar pm_staminathreshold;
extern idCVar pm_staminarate;
extern idCVar pm_crouchheight;
extern idCVar pm_crouchviewheight;
extern idCVar pm_normalheight;
extern idCVar pm_normalviewheight;
extern idCVar pm_deadheight;
extern idCVar pm_deadviewheight;
extern idCVar pm_crouchrate;
extern idCVar pm_bboxwidth;
extern idCVar pm_crouchbob;
extern idCVar pm_walkbob;
extern idCVar pm_runbob;
extern idCVar pm_runpitch;
extern idCVar pm_runroll;
extern idCVar pm_bobup;
extern idCVar pm_bobpitch;
extern idCVar pm_bobroll;
extern idCVar pm_thirdPersonRange;
extern idCVar pm_thirdPersonHeight;
extern idCVar pm_thirdPersonAngle;
extern idCVar pm_thirdPersonClip;
extern idCVar pm_thirdPerson;
extern idCVar pm_thirdPersonDeath;
extern idCVar pm_modelView;
extern idCVar pm_airTics;

extern idCVar g_showPlayerShadow;
extern idCVar g_showHud;
extern idCVar g_showProjectilePct;
extern idCVar g_showBrass;
extern idCVar g_gun_x;
extern idCVar g_gun_y;
extern idCVar g_gun_z;
extern idCVar g_viewNodalX;
extern idCVar g_viewNodalZ;
extern idCVar g_fov;
extern idCVar g_testDeath;
extern idCVar g_skipViewEffects;
extern idCVar g_mpWeaponAngleScale;

extern idCVar g_testParticle;
extern idCVar g_testParticleName;

extern idCVar g_testPostProcess;

extern idCVar g_testModelRotate;
extern idCVar g_testModelAnimate;
extern idCVar g_testModelBlend;
extern idCVar g_exportMask;
extern idCVar g_flushSave;

extern idCVar aas_test;
extern idCVar aas_showAreas;
extern idCVar aas_showPath;
extern idCVar aas_showFlyPath;
extern idCVar aas_showWallEdges;
extern idCVar aas_showHideArea;
extern idCVar aas_pullPlayer;
extern idCVar aas_randomPullPlayer;
extern idCVar aas_goalArea;
extern idCVar aas_showPushIntoArea;

extern idCVar net_clientPredictGUI;

extern idCVar g_voteFlags;
extern idCVar g_mapCycle;
extern idCVar g_balanceTDM;

extern idCVar si_timeLimit;
extern idCVar si_fragLimit;
extern idCVar si_gameType;
extern idCVar si_map;
extern idCVar si_spectators;

extern idCVar net_clientSelfSmoothing;
extern idCVar net_clientLagOMeter;

extern const char *si_gameTypeArgs[];

extern const char *ui_skinArgs[];
# 100 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/gamesys/SysCmds.h" 1
# 32 "d:/Data/Nintendo/DoomGX/src/game/gamesys/SysCmds.h"
void D_DrawDebugLines( void );
# 101 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/gamesys/SaveGame.h" 1
# 38 "d:/Data/Nintendo/DoomGX/src/game/gamesys/SaveGame.h"
const int INITIAL_RELEASE_BUILD_NUMBER = 1262;

class idSaveGame {
public:
       idSaveGame( idFile *savefile );
       ~idSaveGame();

 void Close( void );

 void AddObject( const idClass *obj );
 void WriteObjectList( void );

 void Write( const void *buffer, int len );
 void WriteInt( const int value );
 void WriteJoint( const jointHandle_t value );
 void WriteShort( const short value );
 void WriteByte( const byte value );
 void WriteSignedChar( const signed char value );
 void WriteFloat( const float value );
 void WriteBool( const bool value );
 void WriteString( const char *string );
 void WriteVec2( const idVec2 &vec );
 void WriteVec3( const idVec3 &vec );
 void WriteVec4( const idVec4 &vec );
 void WriteVec6( const idVec6 &vec );
 void WriteWinding( const idWinding &winding );
 void WriteBounds( const idBounds &bounds );
 void WriteMat3( const idMat3 &mat );
 void WriteAngles( const idAngles &angles );
 void WriteObject( const idClass *obj );
 void WriteStaticObject( const idClass &obj );
 void WriteDict( const idDict *dict );
 void WriteMaterial( const idMaterial *material );
 void WriteSkin( const idDeclSkin *skin );
 void WriteParticle( const idDeclParticle *particle );
 void WriteFX( const idDeclFX *fx );
 void WriteSoundShader( const idSoundShader *shader );
 void WriteModelDef( const class idDeclModelDef *modelDef );
 void WriteModel( const idRenderModel *model );
 void WriteUserInterface( const idUserInterface *ui, bool unique );
 void WriteRenderEntity( const renderEntity_t &renderEntity );
 void WriteRenderLight( const renderLight_t &renderLight );
 void WriteRefSound( const refSound_t &refSound );
 void WriteRenderView( const renderView_t &view );
 void WriteUsercmd( const usercmd_t &usercmd );
 void WriteContactInfo( const contactInfo_t &contactInfo );
 void WriteTrace( const trace_t &trace );
 void WriteTraceModel( const idTraceModel &trace );
 void WriteClipModel( const class idClipModel *clipModel );
 void WriteSoundCommands( void );

 void WriteBuildNumber( const int value );

private:
 idFile * file;

 idList<const idClass *> objects;

 void CallSave_r( const idTypeInfo *cls, const idClass *obj );
};

class idRestoreGame {
public:
       idRestoreGame( idFile *savefile );
       ~idRestoreGame();

 void CreateObjects( void );
 void RestoreObjects( void );
 void DeleteObjects( void );

 void Error( const char *fmt, ... ) __attribute__((format(printf,2,3)));

 void Read( void *buffer, int len );
 void ReadInt( int &value );
 void ReadJoint( jointHandle_t &value );
 void ReadShort( short &value );
 void ReadByte( byte &value );
 void ReadSignedChar( signed char &value );
 void ReadFloat( float &value );
 void ReadBool( bool &value );
 void ReadString( idStr &string );
 void ReadVec2( idVec2 &vec );
 void ReadVec3( idVec3 &vec );
 void ReadVec4( idVec4 &vec );
 void ReadVec6( idVec6 &vec );
 void ReadWinding( idWinding &winding );
 void ReadBounds( idBounds &bounds );
 void ReadMat3( idMat3 &mat );
 void ReadAngles( idAngles &angles );
 void ReadObject( idClass *&obj );
 void ReadStaticObject( idClass &obj );
 void ReadDict( idDict *dict );
 void ReadMaterial( const idMaterial *&material );
 void ReadSkin( const idDeclSkin *&skin );
 void ReadParticle( const idDeclParticle *&particle );
 void ReadFX( const idDeclFX *&fx );
 void ReadSoundShader( const idSoundShader *&shader );
 void ReadModelDef( const idDeclModelDef *&modelDef );
 void ReadModel( idRenderModel *&model );
 void ReadUserInterface( idUserInterface *&ui );
 void ReadRenderEntity( renderEntity_t &renderEntity );
 void ReadRenderLight( renderLight_t &renderLight );
 void ReadRefSound( refSound_t &refSound );
 void ReadRenderView( renderView_t &view );
 void ReadUsercmd( usercmd_t &usercmd );
 void ReadContactInfo( contactInfo_t &contactInfo );
 void ReadTrace( trace_t &trace );
 void ReadTraceModel( idTraceModel &trace );
 void ReadClipModel( idClipModel *&clipModel );
 void ReadSoundCommands( void );

 void ReadBuildNumber( void );


 int GetBuildNumber( void );

private:
 int buildNumber;

 idFile * file;

 idList<idClass *> objects;

 void CallRestore_r( const idTypeInfo *cls, idClass *obj );
};
# 102 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/gamesys/DebugGraph.h" 1
# 29 "d:/Data/Nintendo/DoomGX/src/game/gamesys/DebugGraph.h"
class idDebugGraph {
public:
     idDebugGraph();
 void SetNumSamples( int num );
 void AddValue( float value );
 void Draw( const idVec4 &color, float scale ) const;

private:
 idList<float> samples;
 int index;
};
# 103 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h" 1
# 32 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h"
class idScriptObject;
class idEventDef;
class idVarDef;
class idTypeDef;
class idEntity;
class idThread;
class idSaveGame;
class idRestoreGame;







typedef enum {
 ev_error = -1, ev_void, ev_scriptevent, ev_namespace, ev_string, ev_float, ev_vector, ev_entity, ev_field, ev_function, ev_virtualfunction, ev_pointer, ev_object, ev_jumpoffset, ev_argsize, ev_boolean
} etype_t;

class function_t {
public:
      function_t();

 size_t Allocated( void ) const;
 void SetName( const char *name );
 const char *Name( void ) const;
 void Clear( void );

private:
 idStr name;
public:
 const idEventDef *eventdef;
 idVarDef *def;
 const idTypeDef *type;
 int firstStatement;
 int numStatements;
 int parmTotal;
 int locals;
 int filenum;
 idList<int> parmSize;
};

typedef union eval_s {
 const char *stringPtr;
 float _float;
 float vector[ 3 ];
 function_t *function;
 int _int;
 int entity;
} eval_t;
# 91 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h"
class idTypeDef {
private:
 etype_t type;
 idStr name;
 int size;


 idTypeDef *auxType;
 idList<idTypeDef *> parmTypes;
 idStrList parmNames;
 idList<const function_t *> functions;

public:
 idVarDef *def;

      idTypeDef( const idTypeDef &other );
      idTypeDef( etype_t etype, idVarDef *edef, const char *ename, int esize, idTypeDef *aux );

 static void * operator new(size_t size) throw(std::bad_alloc);
 static void operator delete(void *pMem) throw();


 void operator=( const idTypeDef& other );
 size_t Allocated( void ) const;

 bool Inherits( const idTypeDef *basetype ) const;
 bool MatchesType( const idTypeDef &matchtype ) const;
 bool MatchesVirtualFunction( const idTypeDef &matchfunc ) const;
 void AddFunctionParm( idTypeDef *parmtype, const char *name );
 void AddField( idTypeDef *fieldtype, const char *name );

 void SetName( const char *newname );
 const char *Name( void ) const;

 etype_t Type( void ) const;
 int Size( void ) const;

 idTypeDef *SuperClass( void ) const;

 idTypeDef *ReturnType( void ) const;
 void SetReturnType( idTypeDef *type );

 idTypeDef *FieldType( void ) const;
 void SetFieldType( idTypeDef *type );

 idTypeDef *PointerType( void ) const;
 void SetPointerType( idTypeDef *type );

 int NumParameters( void ) const;
 idTypeDef *GetParmType( int parmNumber ) const;
 const char *GetParmName( int parmNumber ) const;

 int NumFunctions( void ) const;
 int GetFunctionNumber( const function_t *func ) const;
 const function_t *GetFunction( int funcNumber ) const;
 void AddFunction( const function_t *func );
};
# 158 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h"
class idScriptObject {
private:
 idTypeDef *type;

public:
 byte *data;

        idScriptObject();
        ~idScriptObject();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Free( void );
 bool SetType( const char *typeName );
 void ClearObject( void );
 bool HasObject( void ) const;
 idTypeDef *GetTypeDef( void ) const;
 const char *GetTypeName( void ) const;
 const function_t *GetConstructor( void ) const;
 const function_t *GetDestructor( void ) const;
 const function_t *GetFunction( const char *name ) const;

 byte *GetVariable( const char *name, etype_t etype ) const;
};
# 194 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h"
template<class type, etype_t etype, class returnType>
class idScriptVariable {
private:
 type *data;

public:
      idScriptVariable();
 bool IsLinked( void ) const;
 void Unlink( void );
 void LinkTo( idScriptObject &obj, const char *name );
 idScriptVariable &operator=( const returnType &value );
      operator returnType() const;
};

template<class type, etype_t etype, class returnType>
inline idScriptVariable<type, etype, returnType>::idScriptVariable() {
 data = __null;
}

template<class type, etype_t etype, class returnType>
inline bool idScriptVariable<type, etype, returnType>::IsLinked( void ) const {
 return ( data != __null );
}

template<class type, etype_t etype, class returnType>
inline void idScriptVariable<type, etype, returnType>::Unlink( void ) {
 data = __null;
}

template<class type, etype_t etype, class returnType>
inline void idScriptVariable<type, etype, returnType>::LinkTo( idScriptObject &obj, const char *name ) {
 data = ( type * )obj.GetVariable( name, etype );
 if ( !data ) {
  gameError( "Missing '%s' field in script object '%s'", name, obj.GetTypeName() );
 }
}

template<class type, etype_t etype, class returnType>
inline idScriptVariable<type, etype, returnType> &idScriptVariable<type, etype, returnType>::operator=( const returnType &value ) {

 ((void)0);


 if ( data ) {
  *data = ( type )value;
 }
 return *this;
}

template<class type, etype_t etype, class returnType>
inline idScriptVariable<type, etype, returnType>::operator returnType() const {

 ((void)0);


 if ( data ) {
  return ( const returnType )*data;
 } else {

  return ( const returnType )0;
 }
}
# 268 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h"
typedef idScriptVariable<int, ev_boolean, int> idScriptBool;
typedef idScriptVariable<float, ev_float, float> idScriptFloat;
typedef idScriptVariable<float, ev_float, int> idScriptInt;
typedef idScriptVariable<idVec3, ev_vector, idVec3> idScriptVector;
typedef idScriptVariable<idStr, ev_string, const char *> idScriptString;
# 283 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h"
class idCompileError : public idException {
public:
 idCompileError( const char *text ) : idException( text ) {}
};
# 297 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h"
typedef union varEval_s {
 idScriptObject **objectPtrPtr;
 char *stringPtr;
 float *floatPtr;
 idVec3 *vectorPtr;
 function_t *functionPtr;
 int *intPtr;
 byte *bytePtr;
 int *entityNumberPtr;
 int virtualFunction;
 int jumpOffset;
 int stackOffset;
 int argSize;
 varEval_s *evalPtr;
 int ptrOffset;
} varEval_t;

class idVarDefName;

class idVarDef {
 friend class idVarDefName;

public:
 int num;
 varEval_t value;
 idVarDef * scope;
 int numUsers;

 typedef enum {
  uninitialized, initializedVariable, initializedConstant, stackVariable
 } initialized_t;

 initialized_t initialized;

public:
       idVarDef( idTypeDef *typeptr = __null );
       ~idVarDef();


 static void * operator new(size_t size) throw(std::bad_alloc);
 static void operator delete(void *pMem) throw();


 const char * Name( void ) const;
 const char * GlobalName( void ) const;

 void SetTypeDef( idTypeDef *_type ) { typeDef = _type; }
 idTypeDef * TypeDef( void ) const { return typeDef; }
 etype_t Type( void ) const { return ( typeDef != __null ) ? typeDef->Type() : ev_void; }

 int DepthOfScope( const idVarDef *otherScope ) const;

 void SetFunction( function_t *func );
 void SetObject( idScriptObject *object );
 void SetValue( const eval_t &value, bool constant );
 void SetString( const char *string, bool constant );

 idVarDef * Next( void ) const { return next; }

 void PrintInfo( idFile *file, int instructionPointer ) const;

private:
 idTypeDef * typeDef;
 idVarDefName * name;
 idVarDef * next;
};







class idVarDefName {
public:
       idVarDefName( void ) { defs = __null; }
       idVarDefName( const char *n ) { name = n; defs = __null; }

 const char * Name( void ) const { return name; }
 idVarDef * GetDefs( void ) const { return defs; }

 void AddDef( idVarDef *def );
 void RemoveDef( idVarDef *def );

private:
 idStr name;
 idVarDef * defs;
};







extern idTypeDef type_void;
extern idTypeDef type_scriptevent;
extern idTypeDef type_namespace;
extern idTypeDef type_string;
extern idTypeDef type_float;
extern idTypeDef type_vector;
extern idTypeDef type_entity;
extern idTypeDef type_field;
extern idTypeDef type_function;
extern idTypeDef type_virtualfunction;
extern idTypeDef type_pointer;
extern idTypeDef type_object;
extern idTypeDef type_jumpoffset;
extern idTypeDef type_argsize;
extern idTypeDef type_boolean;

extern idVarDef def_void;
extern idVarDef def_scriptevent;
extern idVarDef def_namespace;
extern idVarDef def_string;
extern idVarDef def_float;
extern idVarDef def_vector;
extern idVarDef def_entity;
extern idVarDef def_field;
extern idVarDef def_function;
extern idVarDef def_virtualfunction;
extern idVarDef def_pointer;
extern idVarDef def_object;
extern idVarDef def_jumpoffset;
extern idVarDef def_argsize;
extern idVarDef def_boolean;

typedef struct statement_s {
 unsigned short op;
 idVarDef *a;
 idVarDef *b;
 idVarDef *c;
 unsigned short linenumber;
 unsigned short file;
} statement_t;
# 444 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Program.h"
class idProgram {
private:
 idStrList fileList;
 idStr filename;
 int filenum;

 int numVariables;
 byte variables[ 196608 ];
 idStaticList<byte,196608> variableDefaults;
 idStaticList<function_t,3072> functions;
 idStaticList<statement_t,81920> statements;
 idList<idTypeDef *> types;
 idList<idVarDefName *> varDefNames;
 idHashIndex varDefNameHash;
 idList<idVarDef *> varDefs;

 idVarDef *sysDef;

 int top_functions;
 int top_statements;
 int top_types;
 int top_defs;
 int top_files;

 void CompileStats( void );

public:
 idVarDef *returnDef;
 idVarDef *returnStringDef;

            idProgram();
            ~idProgram();


 void Save( idSaveGame *savefile ) const;
 bool Restore( idRestoreGame *savefile );
 int CalculateChecksum( void ) const;


 void Startup( const char *defaultScript );
 void Restart( void );
 bool CompileText( const char *source, const char *text, bool console );
 const function_t *CompileFunction( const char *functionName, const char *text );
 void CompileFile( const char *filename );
 void BeginCompilation( void );
 void FinishCompilation( void );
 void DisassembleStatement( idFile *file, int instructionPointer ) const;
 void Disassemble( void ) const;
 void FreeData( void );

 const char *GetFilename( int num );
 int GetFilenum( const char *name );
 int GetLineNumberForStatement( int index );
 const char *GetFilenameForStatement( int index );

 idTypeDef *AllocType( idTypeDef &type );
 idTypeDef *AllocType( etype_t etype, idVarDef *edef, const char *ename, int esize, idTypeDef *aux );
 idTypeDef *GetType( idTypeDef &type, bool allocate );
 idTypeDef *FindType( const char *name );

 idVarDef *AllocDef( idTypeDef *type, const char *name, idVarDef *scope, bool constant );
 idVarDef *GetDef( const idTypeDef *type, const char *name, const idVarDef *scope ) const;
 void FreeDef( idVarDef *d, const idVarDef *scope );
 idVarDef *FindFreeResultDef( idTypeDef *type, const char *name, idVarDef *scope, const idVarDef *a, const idVarDef *b );
 idVarDef *GetDefList( const char *name ) const;
 void AddDefToNameList( idVarDef *def, const char *name );

 function_t *FindFunction( const char *name ) const;
 function_t *FindFunction( const char *name, const idTypeDef *type ) const;
 function_t &AllocFunction( idVarDef *def );
 function_t *GetFunction( int index );
 int GetFunctionIndex( const function_t *func );

 void SetEntity( const char *name, idEntity *ent );

 statement_t *AllocStatement( void );
 statement_t &GetStatement( int index );
 int NumStatements( void ) { return statements.Num(); }

 int GetReturnedInteger( void );

 void ReturnFloat( float value );
 void ReturnInteger( int value );
 void ReturnVector( idVec3 const &vec );
 void ReturnString( const char *string );
 void ReturnEntity( idEntity *ent );

 int NumFilenames( void ) { return fileList.Num( ); }
};






inline statement_t &idProgram::GetStatement( int index ) {
 return statements[ index ];
}






inline function_t *idProgram::GetFunction( int index ) {
 return &functions[ index ];
}






inline int idProgram::GetFunctionIndex( const function_t *func ) {
 return func - &functions[0];
}






inline int idProgram::GetReturnedInteger( void ) {
 return *returnDef->value.intPtr;
}






inline void idProgram::ReturnFloat( float value ) {
 *returnDef->value.floatPtr = value;
}






inline void idProgram::ReturnInteger( int value ) {
 *returnDef->value.intPtr = value;
}






inline void idProgram::ReturnVector( idVec3 const &vec ) {
 *returnDef->value.vectorPtr = vec;
}






inline void idProgram::ReturnString( const char *string ) {
 idStr::Copynz( returnStringDef->value.stringPtr, string, 128 );
}






inline const char *idProgram::GetFilename( int num ) {
 return fileList[ num ];
}






inline int idProgram::GetLineNumberForStatement( int index ) {
 return statements[ index ].linenumber;
}






inline const char *idProgram::GetFilenameForStatement( int index ) {
 return GetFilename( statements[ index ].file );
}
# 105 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h" 1
# 34 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
const int ANIM_NumAnimChannels = 5;
const int ANIM_MaxAnimsPerChannel = 3;
const int ANIM_MaxSyncedAnims = 3;




const int ANIMCHANNEL_ALL = 0;
const int ANIMCHANNEL_TORSO = 1;
const int ANIMCHANNEL_LEGS = 2;
const int ANIMCHANNEL_HEAD = 3;
const int ANIMCHANNEL_EYELIDS = 4;


inline int FRAME2MS( int framenum ) {
 return ( framenum * 1000 ) / 24;
}

class idRenderModel;
class idAnimator;
class idAnimBlend;
class function_t;
class idEntity;
class idSaveGame;
class idRestoreGame;

typedef struct {
 int cycleCount;
 int frame1;
 int frame2;
 float frontlerp;
 float backlerp;
} frameBlend_t;

typedef struct {
 int nameIndex;
 int parentNum;
 int animBits;
 int firstComponent;
} jointAnimInfo_t;

typedef struct {
 jointHandle_t num;
 jointHandle_t parentNum;
 int channel;
} jointInfo_t;




typedef enum {
 JOINTMOD_NONE,
 JOINTMOD_LOCAL,
 JOINTMOD_LOCAL_OVERRIDE,
 JOINTMOD_WORLD,
 JOINTMOD_WORLD_OVERRIDE
} jointModTransform_t;

typedef struct {
 jointHandle_t jointnum;
 idMat3 mat;
 idVec3 pos;
 jointModTransform_t transform_pos;
 jointModTransform_t transform_axis;
} jointMod_t;
# 107 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
typedef enum {
 FC_SCRIPTFUNCTION,
 FC_SCRIPTFUNCTIONOBJECT,
 FC_EVENTFUNCTION,
 FC_SOUND,
 FC_SOUND_VOICE,
 FC_SOUND_VOICE2,
 FC_SOUND_BODY,
 FC_SOUND_BODY2,
 FC_SOUND_BODY3,
 FC_SOUND_WEAPON,
 FC_SOUND_ITEM,
 FC_SOUND_GLOBAL,
 FC_SOUND_CHATTER,
 FC_SKIN,
 FC_TRIGGER,
 FC_TRIGGER_SMOKE_PARTICLE,
 FC_MELEE,
 FC_DIRECTDAMAGE,
 FC_BEGINATTACK,
 FC_ENDATTACK,
 FC_MUZZLEFLASH,
 FC_CREATEMISSILE,
 FC_LAUNCHMISSILE,
 FC_FIREMISSILEATTARGET,
 FC_FOOTSTEP,
 FC_LEFTFOOT,
 FC_RIGHTFOOT,
 FC_ENABLE_EYE_FOCUS,
 FC_DISABLE_EYE_FOCUS,
 FC_FX,
 FC_DISABLE_GRAVITY,
 FC_ENABLE_GRAVITY,
 FC_JUMP,
 FC_ENABLE_CLIP,
 FC_DISABLE_CLIP,
 FC_ENABLE_WALK_IK,
 FC_DISABLE_WALK_IK,
 FC_ENABLE_LEG_IK,
 FC_DISABLE_LEG_IK,
 FC_RECORDDEMO,
 FC_AVIGAME
} frameCommandType_t;

typedef struct {
 int num;
 int firstCommand;
} frameLookup_t;

typedef struct {
 frameCommandType_t type;
 idStr *string;

 union {
  const idSoundShader *soundShader;
  const function_t *function;
  const idDeclSkin *skin;
  int index;
 };
} frameCommand_t;

typedef struct {
 bool prevent_idle_override : 1;
 bool random_cycle_start : 1;
 bool ai_no_turn : 1;
 bool anim_turn : 1;
} animFlags_t;
# 184 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
class idModelExport {
private:
 void Reset( void );
 bool ParseOptions( idLexer &lex );
 int ParseExportSection( idParser &parser );

 static bool CheckMayaInstall( void );
 static void LoadMayaDll( void );

 bool ConvertMayaToMD5( void );
 static bool initialized;

public:
 idStr commandLine;
 idStr src;
 idStr dest;
 bool force;

       idModelExport();

 static void Shutdown( void );

 int ExportDefFile( const char *filename );
 bool ExportModel( const char *model );
 bool ExportAnim( const char *anim );
 int ExportModels( const char *pathname, const char *extension );
};
# 220 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
class idMD5Anim {
private:
 int numFrames;
 int frameRate;
 int animLength;
 int numJoints;
 int numAnimatedComponents;
 idList<idBounds> bounds;
 idList<jointAnimInfo_t> jointInfo;
 idList<idJointQuat> baseFrame;
 idList<float> componentFrames;
 idStr name;
 idVec3 totaldelta;
 mutable int ref_count;
 bool isVirtual;

public:
       idMD5Anim();
       ~idMD5Anim();

 void MakeVirtual( void );
 void EnsureLoaded( void );

 void Free( void );
 bool Reload( void );
 size_t Allocated( void ) const;
 size_t Size( void ) const { return sizeof( *this ) + Allocated(); };
 bool LoadAnim( const char *filename );

 void IncreaseRefs( void ) const;
 void DecreaseRefs( void ) const;
 int NumRefs( void ) const;

 void CheckModelHierarchy( const idRenderModel *model ) const;
 void GetInterpolatedFrame( frameBlend_t &frame, idJointQuat *joints, const int *index, int numIndexes ) const;
 void GetSingleFrame( int framenum, idJointQuat *joints, const int *index, int numIndexes ) const;
 int Length( void ) const;
 int NumFrames( void ) const;
 int NumJoints( void ) const;
 const idVec3 &TotalMovementDelta( void ) const;
 const char *Name( void ) const;

 void GetFrameBlend( int framenum, frameBlend_t &frame ) const;
 void ConvertTimeToFrame( int time, int cyclecount, frameBlend_t &frame ) const;

 void GetOrigin( idVec3 &offset, int currentTime, int cyclecount ) const;
 void GetOriginRotation( idQuat &rotation, int time, int cyclecount ) const;
 void GetBounds( idBounds &bounds, int currentTime, int cyclecount ) const;
};
# 278 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
class idAnim {
private:
 const class idDeclModelDef *modelDef;
 const idMD5Anim *anims[ ANIM_MaxSyncedAnims ];
 int numAnims;
 idStr name;
 idStr realname;
 idList<frameLookup_t> frameLookup;
 idList<frameCommand_t> frameCommands;
 animFlags_t flags;

public:
        idAnim();
        idAnim( const idDeclModelDef *modelDef, const idAnim *anim );
        ~idAnim();

 void SetAnim( const idDeclModelDef *modelDef, const char *sourcename, const char *animname, int num, const idMD5Anim *md5anims[ ANIM_MaxSyncedAnims ] );
 const char *Name( void ) const;
 const char *FullName( void ) const;
 const idMD5Anim *MD5Anim( int num ) const;
 const idDeclModelDef *ModelDef( void ) const;
 int Length( void ) const;
 int NumFrames( void ) const;
 int NumAnims( void ) const;
 const idVec3 &TotalMovementDelta( void ) const;
 bool GetOrigin( idVec3 &offset, int animNum, int time, int cyclecount ) const;
 bool GetOriginRotation( idQuat &rotation, int animNum, int currentTime, int cyclecount ) const;
 bool GetBounds( idBounds &bounds, int animNum, int time, int cyclecount ) const;
 const char *AddFrameCommand( const class idDeclModelDef *modelDef, int framenum, idLexer &src, const idDict *def );
 void CallFrameCommands( idEntity *ent, int from, int to ) const;
 bool HasFrameCommands( void ) const;


 int FindFrameForFrameCommand( frameCommandType_t framecommand, const frameCommand_t **command ) const;
 void SetAnimFlags( const animFlags_t &animflags );
 const animFlags_t &GetAnimFlags( void ) const;
};
# 324 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
class idDeclModelDef : public idDecl {
public:
        idDeclModelDef();
        ~idDeclModelDef();

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 void Touch( void ) const;

 const idDeclSkin * GetDefaultSkin( void ) const;
 const idJointQuat * GetDefaultPose( void ) const;
 void SetupJoints( int *numJoints, idJointMat **jointList, idBounds &frameBounds, bool removeOriginOffset ) const;
 idRenderModel * ModelHandle( void ) const;
 void GetJointList( const char *jointnames, idList<jointHandle_t> &jointList ) const;
 const jointInfo_t * FindJoint( const char *name ) const;

 int NumAnims( void ) const;
 const idAnim * GetAnim( int index ) const;
 int GetSpecificAnim( const char *name ) const;
 int GetAnim( const char *name ) const;
 bool HasAnim( const char *name ) const;
 const idDeclSkin * GetSkin( void ) const;
 const char * GetModelName( void ) const;
 const idList<jointInfo_t> & Joints( void ) const;
 const int * JointParents( void ) const;
 int NumJoints( void ) const;
 const jointInfo_t * GetJoint( int jointHandle ) const;
 const char * GetJointName( int jointHandle ) const;
 int NumJointsOnChannel( int channel ) const;
 const int * GetChannelJoints( int channel ) const;

 const idVec3 & GetVisualOffset( void ) const;

private:
 void CopyDecl( const idDeclModelDef *decl );
 bool ParseAnim( idLexer &src, int numDefaultAnims );

private:
 idVec3 offset;
 idList<jointInfo_t> joints;
 idList<int> jointParents;
 idList<int> channelJoints[ ANIM_NumAnimChannels ];
 idRenderModel * modelHandle;
 idList<idAnim *> anims;
 const idDeclSkin * skin;
};
# 382 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
class idAnimBlend {
private:
 const class idDeclModelDef *modelDef;
 int starttime;
 int endtime;
 int timeOffset;
 float rate;

 int blendStartTime;
 int blendDuration;
 float blendStartValue;
 float blendEndValue;

 float animWeights[ ANIM_MaxSyncedAnims ];
 short cycle;
 short frame;
 short animNum;
 bool allowMove;
 bool allowFrameCommands;

 friend class idAnimator;

 void Reset( const idDeclModelDef *_modelDef );
 void CallFrameCommands( idEntity *ent, int fromtime, int totime ) const;
 void SetFrame( const idDeclModelDef *modelDef, int animnum, int frame, int currenttime, int blendtime );
 void CycleAnim( const idDeclModelDef *modelDef, int animnum, int currenttime, int blendtime );
 void PlayAnim( const idDeclModelDef *modelDef, int animnum, int currenttime, int blendtime );
 bool BlendAnim( int currentTime, int channel, int numJoints, idJointQuat *blendFrame, float &blendWeight, bool removeOrigin, bool overrideBlend, bool printInfo ) const;
 void BlendOrigin( int currentTime, idVec3 &blendPos, float &blendWeight, bool removeOriginOffset ) const;
 void BlendDelta( int fromtime, int totime, idVec3 &blendDelta, float &blendWeight ) const;
 void BlendDeltaRotation( int fromtime, int totime, idQuat &blendDelta, float &blendWeight ) const;
 bool AddBounds( int currentTime, idBounds &bounds, bool removeOriginOffset ) const;

public:
        idAnimBlend();
 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile, const idDeclModelDef *modelDef );
 const char *AnimName( void ) const;
 const char *AnimFullName( void ) const;
 float GetWeight( int currenttime ) const;
 float GetFinalWeight( void ) const;
 void SetWeight( float newweight, int currenttime, int blendtime );
 int NumSyncedAnims( void ) const;
 bool SetSyncedAnimWeight( int num, float weight );
 void Clear( int currentTime, int clearTime );
 bool IsDone( int currentTime ) const;
 bool FrameHasChanged( int currentTime ) const;
 int GetCycleCount( void ) const;
 void SetCycleCount( int count );
 void SetPlaybackRate( int currentTime, float newRate );
 float GetPlaybackRate( void ) const;
 void SetStartTime( int startTime );
 int GetStartTime( void ) const;
 int GetEndTime( void ) const;
 int GetFrameNumber( int currenttime ) const;
 int AnimTime( int currenttime ) const;
 int NumFrames( void ) const;
 int Length( void ) const;
 int PlayLength( void ) const;
 void AllowMovement( bool allow );
 void AllowFrameCommands( bool allow );
 const idAnim *Anim( void ) const;
 int AnimNum( void ) const;
};
# 455 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
typedef enum {
 AF_JOINTMOD_AXIS,
 AF_JOINTMOD_ORIGIN,
 AF_JOINTMOD_BOTH
} AFJointModType_t;

class idAFPoseJointMod {
public:
        idAFPoseJointMod( void );

 AFJointModType_t mod;
 idMat3 axis;
 idVec3 origin;
};

inline idAFPoseJointMod::idAFPoseJointMod( void ) {
 mod = AF_JOINTMOD_AXIS;
 axis.Identity();
 origin.Zero();
}
# 484 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
class idAnimator {
public:
        idAnimator();
        ~idAnimator();

 size_t Allocated( void ) const;
 size_t Size( void ) const;

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void SetEntity( idEntity *ent );
 idEntity *GetEntity( void ) const ;
 void RemoveOriginOffset( bool remove );
 bool RemoveOrigin( void ) const;

 void GetJointList( const char *jointnames, idList<jointHandle_t> &jointList ) const;

 int NumAnims( void ) const;
 const idAnim *GetAnim( int index ) const;
 int GetAnim( const char *name ) const;
 bool HasAnim( const char *name ) const;

 void ServiceAnims( int fromtime, int totime );
 bool IsAnimating( int currentTime ) const;

 void GetJoints( int *numJoints, idJointMat **jointsPtr );
 int NumJoints( void ) const;
 jointHandle_t GetFirstChild( jointHandle_t jointnum ) const;
 jointHandle_t GetFirstChild( const char *name ) const;

 idRenderModel *SetModel( const char *modelname );
 idRenderModel *ModelHandle( void ) const;
 const idDeclModelDef *ModelDef( void ) const;

 void ForceUpdate( void );
 void ClearForceUpdate( void );
 bool CreateFrame( int animtime, bool force );
 bool FrameHasChanged( int animtime ) const;
 void GetDelta( int fromtime, int totime, idVec3 &delta ) const;
 bool GetDeltaRotation( int fromtime, int totime, idMat3 &delta ) const;
 void GetOrigin( int currentTime, idVec3 &pos ) const;
 bool GetBounds( int currentTime, idBounds &bounds );

 idAnimBlend *CurrentAnim( int channelNum );
 void Clear( int channelNum, int currentTime, int cleartime );
 void SetFrame( int channelNum, int animnum, int frame, int currenttime, int blendtime );
 void CycleAnim( int channelNum, int animnum, int currenttime, int blendtime );
 void PlayAnim( int channelNum, int animnum, int currenttime, int blendTime );



 void SyncAnimChannels( int channelNum, int fromChannelNum, int currenttime, int blendTime );

 void SetJointPos( jointHandle_t jointnum, jointModTransform_t transform_type, const idVec3 &pos );
 void SetJointAxis( jointHandle_t jointnum, jointModTransform_t transform_type, const idMat3 &mat );
 void ClearJoint( jointHandle_t jointnum );
 void ClearAllJoints( void );

 void InitAFPose( void );
 void SetAFPoseJointMod( const jointHandle_t jointNum, const AFJointModType_t mod, const idMat3 &axis, const idVec3 &origin );
 void FinishAFPose( int animnum, const idBounds &bounds, const int time );
 void SetAFPoseBlendWeight( float blendWeight );
 bool BlendAFPose( idJointQuat *blendFrame ) const;
 void ClearAFPose( void );

 void ClearAllAnims( int currentTime, int cleartime );

 jointHandle_t GetJointHandle( const char *name ) const;
 const char * GetJointName( jointHandle_t handle ) const;
 int GetChannelForJoint( jointHandle_t joint ) const;
 bool GetJointTransform( jointHandle_t jointHandle, int currenttime, idVec3 &offset, idMat3 &axis );
 bool GetJointLocalTransform( jointHandle_t jointHandle, int currentTime, idVec3 &offset, idMat3 &axis );

 const animFlags_t GetAnimFlags( int animnum ) const;
 int NumFrames( int animnum ) const;
 int NumSyncedAnims( int animnum ) const;
 const char *AnimName( int animnum ) const;
 const char *AnimFullName( int animnum ) const;
 int AnimLength( int animnum ) const;
 const idVec3 &TotalMovementDelta( int animnum ) const;

private:
 void FreeData( void );
 void PushAnims( int channel, int currentTime, int blendTime );

private:
 const idDeclModelDef * modelDef;
 idEntity * entity;

 idAnimBlend channels[ ANIM_NumAnimChannels ][ ANIM_MaxAnimsPerChannel ];
 idList<jointMod_t *> jointMods;
 int numJoints;
 idJointMat * joints;

 mutable int lastTransformTime;
 mutable bool stoppedAnimatingUpdate;
 bool removeOriginOffset;
 bool forceUpdate;

 idBounds frameBounds;

 float AFPoseBlendWeight;
 idList<int> AFPoseJoints;
 idList<idAFPoseJointMod> AFPoseJointMods;
 idList<idJointQuat> AFPoseJointFrame;
 idBounds AFPoseBounds;
 int AFPoseTime;
};
# 602 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim.h"
class idAnimManager {
public:
        idAnimManager();
        ~idAnimManager();

 static bool forceExport;

 void Shutdown( void );
 idMD5Anim * GetAnim( const char *name );
 void ReloadAnims( void );
 void ListAnims( void ) const;
 int JointIndex( const char *name );
 const char * JointName( int index ) const;

 void ClearAnimsInUse( void );
 void FlushUnusedAnims( void );
 void VirtualizeAll(void );

private:
 idHashTable<idMD5Anim *> animations;
 idStrList jointnames;
 idHashIndex jointnamesHash;
};
# 107 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/ai/AAS.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/ai/AAS.h"
enum {
 PATHTYPE_WALK,
 PATHTYPE_WALKOFFLEDGE,
 PATHTYPE_BARRIERJUMP,
 PATHTYPE_JUMP
};

typedef struct aasPath_s {
 int type;
 idVec3 moveGoal;
 int moveAreaNum;
 idVec3 secondaryGoal;
 const idReachability * reachability;
} aasPath_t;


typedef struct aasGoal_s {
 int areaNum;
 idVec3 origin;
} aasGoal_t;


typedef struct aasObstacle_s {
 idBounds absBounds;
 idBounds expAbsBounds;
} aasObstacle_t;

class idAASCallback {
public:
 virtual ~idAASCallback() {};
 virtual bool TestArea( const class idAAS *aas, int areaNum ) = 0;
};

typedef int aasHandle_t;

class idAAS {
public:
 static idAAS * Alloc( void );
 virtual ~idAAS( void ) = 0;

 virtual bool Init( const idStr &mapName, unsigned int mapFileCRC ) = 0;

 virtual void Stats( void ) const = 0;

 virtual void Test( const idVec3 &origin ) = 0;

 virtual const idAASSettings *GetSettings( void ) const = 0;

 virtual int PointAreaNum( const idVec3 &origin ) const = 0;

 virtual int PointReachableAreaNum( const idVec3 &origin, const idBounds &bounds, const int areaFlags ) const = 0;

 virtual int BoundsReachableAreaNum( const idBounds &bounds, const int areaFlags ) const = 0;

 virtual void PushPointIntoAreaNum( int areaNum, idVec3 &origin ) const = 0;

 virtual idVec3 AreaCenter( int areaNum ) const = 0;

 virtual int AreaFlags( int areaNum ) const = 0;

 virtual int AreaTravelFlags( int areaNum ) const = 0;

 virtual bool Trace( aasTrace_t &trace, const idVec3 &start, const idVec3 &end ) const = 0;

 virtual const idPlane & GetPlane( int planeNum ) const = 0;

 virtual int GetWallEdges( int areaNum, const idBounds &bounds, int travelFlags, int *edges, int maxEdges ) const = 0;

 virtual void SortWallEdges( int *edges, int numEdges ) const = 0;

 virtual void GetEdgeVertexNumbers( int edgeNum, int verts[2] ) const = 0;

 virtual void GetEdge( int edgeNum, idVec3 &start, idVec3 &end ) const = 0;

 virtual bool SetAreaState( const idBounds &bounds, const int areaContents, bool disabled ) = 0;

 virtual aasHandle_t AddObstacle( const idBounds &bounds ) = 0;

 virtual void RemoveObstacle( const aasHandle_t handle ) = 0;

 virtual void RemoveAllObstacles( void ) = 0;

 virtual int TravelTimeToGoalArea( int areaNum, const idVec3 &origin, int goalAreaNum, int travelFlags ) const = 0;

 virtual bool RouteToGoalArea( int areaNum, const idVec3 origin, int goalAreaNum, int travelFlags, int &travelTime, idReachability **reach ) const = 0;

 virtual bool WalkPathToGoal( aasPath_t &path, int areaNum, const idVec3 &origin, int goalAreaNum, const idVec3 &goalOrigin, int travelFlags ) const = 0;

 virtual bool WalkPathValid( int areaNum, const idVec3 &origin, int goalAreaNum, const idVec3 &goalOrigin, int travelFlags, idVec3 &endPos, int &endAreaNum ) const = 0;

 virtual bool FlyPathToGoal( aasPath_t &path, int areaNum, const idVec3 &origin, int goalAreaNum, const idVec3 &goalOrigin, int travelFlags ) const = 0;

 virtual bool FlyPathValid( int areaNum, const idVec3 &origin, int goalAreaNum, const idVec3 &goalOrigin, int travelFlags, idVec3 &endPos, int &endAreaNum ) const = 0;

 virtual void ShowWalkPath( const idVec3 &origin, int goalAreaNum, const idVec3 &goalOrigin ) const = 0;

 virtual void ShowFlyPath( const idVec3 &origin, int goalAreaNum, const idVec3 &goalOrigin ) const = 0;

 virtual bool FindNearestGoal( aasGoal_t &goal, int areaNum, const idVec3 origin, const idVec3 &target, int travelFlags, aasObstacle_t *obstacles, int numObstacles, idAASCallback &callback ) const = 0;
};
# 109 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Clip.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/physics/Clip.h"
class idClip;
class idClipModel;
class idEntity;
# 54 "d:/Data/Nintendo/DoomGX/src/game/physics/Clip.h"
class idClipModel {

 friend class idClip;

public:
       idClipModel( void );
       explicit idClipModel( const char *name );
       explicit idClipModel( const idTraceModel &trm );
       explicit idClipModel( const int renderModelHandle );
       explicit idClipModel( const idClipModel *model );
       ~idClipModel( void );

 bool LoadModel( const char *name );
 void LoadModel( const idTraceModel &trm );
 void LoadModel( const int renderModelHandle );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Link( idClip &clp );
 void Link( idClip &clp, idEntity *ent, int newId, const idVec3 &newOrigin, const idMat3 &newAxis, int renderModelHandle = -1 );
 void Unlink( void );
 void SetPosition( const idVec3 &newOrigin, const idMat3 &newAxis );
 void Translate( const idVec3 &translation );
 void Rotate( const idRotation &rotation );
 void Enable( void );
 void Disable( void );
 void SetMaterial( const idMaterial *m );
 const idMaterial * GetMaterial( void ) const;
 void SetContents( int newContents );
 int GetContents( void ) const;
 void SetEntity( idEntity *newEntity );
 idEntity * GetEntity( void ) const;
 void SetId( int newId );
 int GetId( void ) const;
 void SetOwner( idEntity *newOwner );
 idEntity * GetOwner( void ) const;
 const idBounds & GetBounds( void ) const;
 const idBounds & GetAbsBounds( void ) const;
 const idVec3 & GetOrigin( void ) const;
 const idMat3 & GetAxis( void ) const;
 bool IsTraceModel( void ) const;
 bool IsRenderModel( void ) const;
 bool IsLinked( void ) const;
 bool IsEnabled( void ) const;
 bool IsEqual( const idTraceModel &trm ) const;
 cmHandle_t Handle( void ) const;
 const idTraceModel * GetTraceModel( void ) const;
 void GetMassProperties( const float density, float &mass, idVec3 &centerOfMass, idMat3 &inertiaTensor ) const;

 static cmHandle_t CheckModel( const char *name );
 static void ClearTraceModelCache( void );
 static int TraceModelCacheSize( void );

 static void SaveTraceModels( idSaveGame *savefile );
 static void RestoreTraceModels( idRestoreGame *savefile );

private:
 bool enabled;
 idEntity * entity;
 int id;
 idEntity * owner;
 idVec3 origin;
 idMat3 axis;
 idBounds bounds;
 idBounds absBounds;
 const idMaterial * material;
 int contents;
 cmHandle_t collisionModelHandle;
 int traceModelIndex;
 int renderModelHandle;

 struct clipLink_s * clipLinks;
 int touchCount;

 void Init( void );
 void Link_r( struct clipSector_s *node );

 static int AllocTraceModel( const idTraceModel &trm );
 static void FreeTraceModel( int traceModelIndex );
 static idTraceModel * GetCachedTraceModel( int traceModelIndex );
 static int GetTraceModelHashKey( const idTraceModel &trm );
};


inline void idClipModel::Translate( const idVec3 &translation ) {
 Unlink();
 origin += translation;
}

inline void idClipModel::Rotate( const idRotation &rotation ) {
 Unlink();
 origin *= rotation;
 axis *= rotation.ToMat3();
}

inline void idClipModel::Enable( void ) {
 enabled = true;
}

inline void idClipModel::Disable( void ) {
 enabled = false;
}

inline void idClipModel::SetMaterial( const idMaterial *m ) {
 material = m;
}

inline const idMaterial * idClipModel::GetMaterial( void ) const {
 return material;
}

inline void idClipModel::SetContents( int newContents ) {
 contents = newContents;
}

inline int idClipModel::GetContents( void ) const {
 return contents;
}

inline void idClipModel::SetEntity( idEntity *newEntity ) {
 entity = newEntity;
}

inline idEntity *idClipModel::GetEntity( void ) const {
 return entity;
}

inline void idClipModel::SetId( int newId ) {
 id = newId;
}

inline int idClipModel::GetId( void ) const {
 return id;
}

inline void idClipModel::SetOwner( idEntity *newOwner ) {
 owner = newOwner;
}

inline idEntity *idClipModel::GetOwner( void ) const {
 return owner;
}

inline const idBounds &idClipModel::GetBounds( void ) const {
 return bounds;
}

inline const idBounds &idClipModel::GetAbsBounds( void ) const {
 return absBounds;
}

inline const idVec3 &idClipModel::GetOrigin( void ) const {
 return origin;
}

inline const idMat3 &idClipModel::GetAxis( void ) const {
 return axis;
}

inline bool idClipModel::IsRenderModel( void ) const {
 return ( renderModelHandle != -1 );
}

inline bool idClipModel::IsTraceModel( void ) const {
 return ( traceModelIndex != -1 );
}

inline bool idClipModel::IsLinked( void ) const {
 return ( clipLinks != __null );
}

inline bool idClipModel::IsEnabled( void ) const {
 return enabled;
}

inline bool idClipModel::IsEqual( const idTraceModel &trm ) const {
 return ( traceModelIndex != -1 && *GetCachedTraceModel( traceModelIndex ) == trm );
}

inline const idTraceModel *idClipModel::GetTraceModel( void ) const {
 if ( !IsTraceModel() ) {
  return __null;
 }
 return idClipModel::GetCachedTraceModel( traceModelIndex );
}
# 248 "d:/Data/Nintendo/DoomGX/src/game/physics/Clip.h"
class idClip {

 friend class idClipModel;

public:
       idClip( void );

 void Init( void );
 void Shutdown( void );


 bool Translation( trace_t &results, const idVec3 &start, const idVec3 &end,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask, const idEntity *passEntity );
 bool Rotation( trace_t &results, const idVec3 &start, const idRotation &rotation,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask, const idEntity *passEntity );
 bool Motion( trace_t &results, const idVec3 &start, const idVec3 &end, const idRotation &rotation,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask, const idEntity *passEntity );
 int Contacts( contactInfo_t *contacts, const int maxContacts, const idVec3 &start, const idVec6 &dir, const float depth,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask, const idEntity *passEntity );
 int Contents( const idVec3 &start,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask, const idEntity *passEntity );


 bool TracePoint( trace_t &results, const idVec3 &start, const idVec3 &end,
        int contentMask, const idEntity *passEntity );
 bool TraceBounds( trace_t &results, const idVec3 &start, const idVec3 &end, const idBounds &bounds,
        int contentMask, const idEntity *passEntity );


 void TranslationModel( trace_t &results, const idVec3 &start, const idVec3 &end,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis );
 void RotationModel( trace_t &results, const idVec3 &start, const idRotation &rotation,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis );
 int ContactsModel( contactInfo_t *contacts, const int maxContacts, const idVec3 &start, const idVec6 &dir, const float depth,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis );
 int ContentsModel( const idVec3 &start,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis );


 void TranslationEntities( trace_t &results, const idVec3 &start, const idVec3 &end,
        const idClipModel *mdl, const idMat3 &trmAxis, int contentMask, const idEntity *passEntity );


 bool GetModelContactFeature( const contactInfo_t &contact, const idClipModel *clipModel, idFixedWinding &winding ) const;


 int EntitiesTouchingBounds( const idBounds &bounds, int contentMask, idEntity **entityList, int maxCount ) const;
 int ClipModelsTouchingBounds( const idBounds &bounds, int contentMask, idClipModel **clipModelList, int maxCount ) const;

 const idBounds & GetWorldBounds( void ) const;
 idClipModel * DefaultClipModel( void );


 void PrintStatistics( void );
 void DrawClipModels( const idVec3 &eye, const float radius, const idEntity *passEntity );
 bool DrawModelContactFeature( const contactInfo_t &contact, const idClipModel *clipModel, int lifetime ) const;

private:
 int numClipSectors;
 struct clipSector_s * clipSectors;
 idBounds worldBounds;
 idClipModel temporaryClipModel;
 idClipModel defaultClipModel;
 mutable int touchCount;

 int numTranslations;
 int numRotations;
 int numMotions;
 int numRenderModelTraces;
 int numContents;
 int numContacts;

private:
 struct clipSector_s * CreateClipSectors_r( const int depth, const idBounds &bounds, idVec3 &maxSector );
 void ClipModelsTouchingBounds_r( const struct clipSector_s *node, struct listParms_s &parms ) const;
 const idTraceModel * TraceModelForClipModel( const idClipModel *mdl ) const;
 int GetTraceClipModels( const idBounds &bounds, int contentMask, const idEntity *passEntity, idClipModel **clipModelList ) const;
 void TraceRenderModel( trace_t &trace, const idVec3 &start, const idVec3 &end, const float radius, const idMat3 &axis, idClipModel *touch ) const;
};


inline bool idClip::TracePoint( trace_t &results, const idVec3 &start, const idVec3 &end, int contentMask, const idEntity *passEntity ) {
 Translation( results, start, end, __null, mat3_identity, contentMask, passEntity );
 return ( results.fraction < 1.0f );
}

inline bool idClip::TraceBounds( trace_t &results, const idVec3 &start, const idVec3 &end, const idBounds &bounds, int contentMask, const idEntity *passEntity ) {
 temporaryClipModel.LoadModel( idTraceModel( bounds ) );
 Translation( results, start, end, &temporaryClipModel, mat3_identity, contentMask, passEntity );
 return ( results.fraction < 1.0f );
}

inline const idBounds & idClip::GetWorldBounds( void ) const {
 return worldBounds;
}

inline idClipModel *idClip::DefaultClipModel( void ) {
 return &defaultClipModel;
}
# 111 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Push.h" 1
# 48 "d:/Data/Nintendo/DoomGX/src/game/physics/Push.h"
class idPush {
public:



 float ClipTranslationalPush( trace_t &results, idEntity *pusher, const int flags,
           const idVec3 &newOrigin, const idVec3 &move );

 float ClipRotationalPush( trace_t &results, idEntity *pusher, const int flags,
           const idMat3 &newAxis, const idRotation &rotation );

 float ClipPush( trace_t &results, idEntity *pusher, const int flags,
           const idVec3 &oldOrigin, const idMat3 &oldAxis,
            idVec3 &newOrigin, idMat3 &newAxis );


 void InitSavingPushedEntityPositions( void );

 void RestorePushedEntityPositions( void );

 int GetNumPushedEntities( void ) const { return numPushed; }

 idEntity * GetPushedEntity( int i ) const { ((void)0); return pushed[i].ent; }

private:
 struct pushed_s {
  idEntity * ent;
  idAngles deltaViewAngles;
 } pushed[(1<<12)];
 int numPushed;

 struct pushedGroup_s {
  idEntity * ent;
  float fraction;
  bool groundContact;
  bool test;
 } pushedGroup[(1<<12)];
 int pushedGroupSize;

private:
 void SaveEntityPosition( idEntity *ent );
 bool RotateEntityToAxial( idEntity *ent, idVec3 rotationPoint );
# 101 "d:/Data/Nintendo/DoomGX/src/game/physics/Push.h"
 void ClipEntityRotation( trace_t &trace, const idEntity *ent, const idClipModel *clipModel,
          idClipModel *skip, const idRotation &rotation );
 void ClipEntityTranslation( trace_t &trace, const idEntity *ent, const idClipModel *clipModel,
          idClipModel *skip, const idVec3 &translation );
 int TryTranslatePushEntity( trace_t &results, idEntity *check, idClipModel *clipModel, const int flags,
            const idVec3 &newOrigin, const idVec3 &move );
 int TryRotatePushEntity( trace_t &results, idEntity *check, idClipModel *clipModel, const int flags,
            const idMat3 &newAxis, const idRotation &rotation );
 int DiscardEntities( idEntity *entityList[], int numEntities, int flags, idEntity *pusher );

};
# 112 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/Pvs.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/Pvs.h"
typedef struct pvsHandle_s {
 int i;
 unsigned int h;
} pvsHandle_t;


typedef struct pvsCurrent_s {
 pvsHandle_t handle;
 byte * pvs;
} pvsCurrent_t;



typedef enum {
 PVS_NORMAL = 0,
 PVS_ALL_PORTALS_OPEN = 1,
 PVS_CONNECTED_AREAS = 2
} pvsType_t;


class idPVS {
public:
      idPVS( void );
      ~idPVS( void );

 void Init( void );
 void Shutdown( void );

 int GetPVSArea( const idVec3 &point ) const;
 int GetPVSAreas( const idBounds &bounds, int *areas, int maxAreas ) const;

 pvsHandle_t SetupCurrentPVS( const idVec3 &source, const pvsType_t type = PVS_NORMAL ) const;
 pvsHandle_t SetupCurrentPVS( const idBounds &source, const pvsType_t type = PVS_NORMAL ) const;
 pvsHandle_t SetupCurrentPVS( const int sourceArea, const pvsType_t type = PVS_NORMAL ) const;
 pvsHandle_t SetupCurrentPVS( const int *sourceAreas, const int numSourceAreas, const pvsType_t type = PVS_NORMAL ) const;
 pvsHandle_t MergeCurrentPVS( pvsHandle_t pvs1, pvsHandle_t pvs2 ) const;
 void FreeCurrentPVS( pvsHandle_t handle ) const;

 bool InCurrentPVS( const pvsHandle_t handle, const idVec3 &target ) const;
 bool InCurrentPVS( const pvsHandle_t handle, const idBounds &target ) const;
 bool InCurrentPVS( const pvsHandle_t handle, const int targetArea ) const;
 bool InCurrentPVS( const pvsHandle_t handle, const int *targetAreas, int numTargetAreas ) const;

 void DrawPVS( const idVec3 &source, const pvsType_t type = PVS_NORMAL ) const;
 void DrawPVS( const idBounds &source, const pvsType_t type = PVS_NORMAL ) const;

 void DrawCurrentPVS( const pvsHandle_t handle, const idVec3 &source ) const;






private:
 int numAreas;
 int numPortals;
 bool * connectedAreas;
 int * areaQueue;
 byte * areaPVS;

 mutable pvsCurrent_t currentPVS[8];

 int portalVisBytes;
 int portalVisLongs;
 int areaVisBytes;
 int areaVisLongs;
 struct pvsPortal_s *pvsPortals;
 struct pvsArea_s * pvsAreas;

private:
 int GetPortalCount( void ) const;
 void CreatePVSData( void );
 void DestroyPVSData( void );
 void CopyPortalPVSToMightSee( void ) const;
 void FloodFrontPortalPVS_r( struct pvsPortal_s *portal, int areaNum ) const;
 void FrontPortalPVS( void ) const;
 struct pvsStack_s * FloodPassagePVS_r( struct pvsPortal_s *source, const struct pvsPortal_s *portal, struct pvsStack_s *prevStack ) const;
 void PassagePVS( void ) const;
 void AddPassageBoundaries( const idWinding &source, const idWinding &pass, bool flipClip, idPlane *bounds, int &numBounds, int maxBounds ) const;
 void CreatePassages( void ) const;
 void DestroyPassages( void ) const;
 int AreaPVSFromPortalPVS( void ) const;
 void GetConnectedAreas( int srcArea, bool *connectedAreas ) const;
 pvsHandle_t AllocCurrentPVS( unsigned int h ) const;
};
# 114 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/MultiplayerGame.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/MultiplayerGame.h"
class idPlayer;

typedef enum {
 GAME_SP,
 GAME_DM,
 GAME_TOURNEY,
 GAME_TDM,
 GAME_LASTMAN
} gameType_t;

typedef enum {
  PLAYER_VOTE_NONE,
  PLAYER_VOTE_NO,
  PLAYER_VOTE_YES,
  PLAYER_VOTE_WAIT
} playerVote_t;

typedef struct mpPlayerState_s {
 int ping;
 int fragCount;
 int teamFragCount;
 int wins;
 playerVote_t vote;
 bool scoreBoardUp;
 bool ingame;
} mpPlayerState_t;

const int NUM_CHAT_NOTIFY = 5;
const int CHAT_FADE_TIME = 400;
const int FRAGLIMIT_DELAY = 2000;

const int MP_PLAYER_MINFRAGS = -100;
const int MP_PLAYER_MAXFRAGS = 100;
const int MP_PLAYER_MAXWINS = 100;
const int MP_PLAYER_MAXPING = 999;

typedef struct mpChatLine_s {
 idStr line;
 short fade;
} mpChatLine_t;

typedef enum {
 SND_YOUWIN = 0,
 SND_YOULOSE,
 SND_FIGHT,
 SND_VOTE,
 SND_VOTE_PASSED,
 SND_VOTE_FAILED,
 SND_THREE,
 SND_TWO,
 SND_ONE,
 SND_SUDDENDEATH,
 SND_COUNT
} snd_evt_t;

class idMultiplayerGame {
public:

     idMultiplayerGame();

 void Shutdown( void );


 void Reset( void );


 void SpawnPlayer( int clientNum );


 void Run( void );


 bool Draw( int clientNum );


 void PlayerVote( int clientNum, playerVote_t vote );


 void PlayerDeath( idPlayer *dead, idPlayer *killer, bool telefrag );

 void AddChatLine( const char *fmt, ... ) __attribute__((format(printf,2,3)));

 void UpdateMainGui( void );
 idUserInterface*StartMenu( void );
 const char* HandleGuiCommands( const char *menuCommand );
 void SetMenuSkin( void );

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );


 typedef enum {
  INACTIVE = 0,
  WARMUP,
  COUNTDOWN,
  GAMEON,
  SUDDENDEATH,
  GAMEREVIEW,
  NEXTGAME,
  STATE_COUNT
 } gameState_t;
 static const char *GameStateStrings[ STATE_COUNT ];
 idMultiplayerGame::gameState_t GetGameState( void ) const;

 static const char *GlobalSoundStrings[ SND_COUNT ];
 void PlayGlobalSound( int to, snd_evt_t evt, const char *shader = __null );


 typedef enum {
  MSG_SUICIDE = 0,
  MSG_KILLED,
  MSG_KILLEDTEAM,
  MSG_DIED,
  MSG_VOTE,
  MSG_VOTEPASSED,
  MSG_VOTEFAILED,
  MSG_SUDDENDEATH,
  MSG_FORCEREADY,
  MSG_JOINEDSPEC,
  MSG_TIMELIMIT,
  MSG_FRAGLIMIT,
  MSG_TELEFRAGGED,
  MSG_JOINTEAM,
  MSG_HOLYSHIT,
  MSG_COUNT
 } msg_evt_t;
 void PrintMessageEvent( int to, msg_evt_t evt, int parm1 = -1, int parm2 = -1 );

 void DisconnectClient( int clientNum );
 static void ForceReady_f( const idCmdArgs &args );
 static void DropWeapon_f( const idCmdArgs &args );
 static void MessageMode_f( const idCmdArgs &args );
 static void VoiceChat_f( const idCmdArgs &args );
 static void VoiceChatTeam_f( const idCmdArgs &args );

 typedef enum {
  VOTE_RESTART = 0,
  VOTE_TIMELIMIT,
  VOTE_FRAGLIMIT,
  VOTE_GAMETYPE,
  VOTE_KICK,
  VOTE_MAP,
  VOTE_SPECTATORS,
  VOTE_NEXTMAP,
  VOTE_COUNT,
  VOTE_NONE
 } vote_flags_t;

 typedef enum {
  VOTE_UPDATE,
  VOTE_FAILED,
  VOTE_PASSED,
  VOTE_ABORTED,
  VOTE_RESET
 } vote_result_t;

 static void Vote_f( const idCmdArgs &args );
 static void CallVote_f( const idCmdArgs &args );
 void ClientCallVote( vote_flags_t voteIndex, const char *voteValue );
 void ServerCallVote( int clientNum, const idBitMsg &msg );
 void ClientStartVote( int clientNum, const char *voteString );
 void ServerStartVote( int clientNum, vote_flags_t voteIndex, const char *voteValue );
 void ClientUpdateVote( vote_result_t result, int yesCount, int noCount );
 void CastVote( int clientNum, bool vote );
 void ExecuteVote( void );

 void WantKilled( int clientNum );
 int NumActualClients( bool countSpectators, int *teamcount = __null );
 void DropWeapon( int clientNum );
 void MapRestart( void );

 void SwitchToTeam( int clientNum, int oldteam, int newteam );
 bool IsPureReady( void ) const;
 void ProcessChatMessage( int clientNum, bool team, const char *name, const char *text, const char *sound );
 void ProcessVoiceChat( int clientNum, bool team, int index );

 void Precache( void );


 void ThrottleUserInfo( void );
 void ToggleSpectate( void );
 void ToggleReady( void );
 void ToggleTeam( void );

 void ClearFrags( int clientNum );

 void EnterGame( int clientNum );
 bool CanPlay( idPlayer *p );
 bool IsInGame( int clientNum );
 bool WantRespawn( idPlayer *p );

 void ServerWriteInitialReliableMessages( int clientNum );
 void ClientReadStartState( const idBitMsg &msg );
 void ClientReadWarmupTime( const idBitMsg &msg );

 void ServerClientConnect( int clientNum );

 void PlayerStats( int clientNum, char *data, const int len );

private:
 static const char *MPGuis[];
 static const char *ThrottleVars[];
 static const char *ThrottleVarsInEnglish[];
 static const int ThrottleDelay[];


 gameState_t gameState;
 gameState_t nextState;
 int pingUpdateTime;

 mpPlayerState_t playerState[ 4 ];




 vote_flags_t vote;
 int voteTimeOut;
 int voteExecTime;
 float yesVotes;
 float noVotes;
 idStr voteValue;
 idStr voteString;
 bool voted;
 int kickVoteMap[ 4 ];


 int nextStateSwitch;
 int warmupEndTime;
 int matchStartedTime;


 int currentTourneyPlayer[2];
 int lastWinner;


 idStr warmupText;
 bool one, two, three;


 idUserInterface *scoreBoard;
 idUserInterface *spectateGui;
 idUserInterface *guiChat;
 idUserInterface *mainGui;
 idListGUI *mapList;
 idUserInterface *msgmodeGui;
 int currentMenu;
 int nextMenu;
 bool bCurrentMenuMsg;


 mpChatLine_t chatHistory[ NUM_CHAT_NOTIFY ];
 int chatHistoryIndex;
 int chatHistorySize;
 bool chatDataUpdated;
 int lastChatLineTime;


 int numRankedPlayers;
 idPlayer * rankedPlayers[4];

 bool pureReady;
 int fragLimitTimeout;

 int switchThrottle[ 3 ];
 int voiceChatThrottle;

 gameType_t lastGameType;
 int startFragLimit;

private:
 void UpdatePlayerRanks();


 void UpdateRankColor( idUserInterface *gui, const char *mask, int i, const idVec3 &vec );
 void UpdateScoreboard( idUserInterface *scoreBoard, idPlayer *player );

 void ClearGuis( void );
 void DrawScoreBoard( idPlayer *player );
 void UpdateHud( idPlayer *player, idUserInterface *hud );
 bool Warmup( void );
 void CheckVote( void );
 bool AllPlayersReady( void );
 idPlayer * FragLimitHit( void );
 idPlayer * FragLeader( void );
 bool TimeLimitHit( void );
 void NewState( gameState_t news, idPlayer *player = __null );
 void UpdateWinsLosses( idPlayer *winner );

 void FillTourneySlots( void );
 void CycleTourneyPlayers( void );

 void UpdateTourneyLine( void );
 const char * GameTime( void );
 void Clear( void );
 bool EnoughClientsToPlay( void );
 void ClearChatData( void );
 void DrawChat( void );



 void CheckRespawns( idPlayer *spectator = __null );
 void ForceReady();

 void CheckAbortGame( void );
 void MessageMode( const idCmdArgs &args );
 void DisableMenu( void );
 void SetMapShot( void );

 void TeamScore( int entityNumber, int team, int delta );
 void VoiceChat( const idCmdArgs &args, bool team );
 void DumpTourneyLine( void );
 void SuddenRespawn( void );
};

inline idMultiplayerGame::gameState_t idMultiplayerGame::GetGameState( void ) const {
 return gameState;
}

inline bool idMultiplayerGame::IsPureReady( void ) const {
 return pureReady;
}

inline void idMultiplayerGame::ClearFrags( int clientNum ) {
 playerState[ clientNum ].fragCount = 0;
}

inline bool idMultiplayerGame::IsInGame( int clientNum ) {
 return playerState[ clientNum ].ingame;
}
# 115 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2



const int MAX_GAME_MESSAGE_SIZE = 8192;
const int MAX_ENTITY_STATE_SIZE = 512;
const int ENTITY_PVS_SIZE = (((1<<12)+31)>>5);
const int NUM_RENDER_PORTAL_BITS = idMath::BitsForInteger( PS_BLOCK_ALL );

typedef struct entityState_s {
 int entityNumber;
 idBitMsg state;
 byte stateBuf[MAX_ENTITY_STATE_SIZE];
 struct entityState_s * next;
} entityState_t;

typedef struct snapshot_s {
 int sequence;
 entityState_t * firstEntityState;
 int pvs[ENTITY_PVS_SIZE];
 struct snapshot_s * next;
} snapshot_t;

const int MAX_EVENT_PARAM_SIZE = 128;

typedef struct entityNetEvent_s {
 int spawnId;
 int event;
 int time;
 int paramsSize;
 byte paramsBuf[MAX_EVENT_PARAM_SIZE];
 struct entityNetEvent_s *next;
 struct entityNetEvent_s *prev;
} entityNetEvent_t;

enum {
 GAME_RELIABLE_MESSAGE_INIT_DECL_REMAP,
 GAME_RELIABLE_MESSAGE_REMAP_DECL,
 GAME_RELIABLE_MESSAGE_SPAWN_PLAYER,
 GAME_RELIABLE_MESSAGE_DELETE_ENT,
 GAME_RELIABLE_MESSAGE_CHAT,
 GAME_RELIABLE_MESSAGE_TCHAT,
 GAME_RELIABLE_MESSAGE_SOUND_EVENT,
 GAME_RELIABLE_MESSAGE_SOUND_INDEX,
 GAME_RELIABLE_MESSAGE_DB,
 GAME_RELIABLE_MESSAGE_KILL,
 GAME_RELIABLE_MESSAGE_DROPWEAPON,
 GAME_RELIABLE_MESSAGE_RESTART,
 GAME_RELIABLE_MESSAGE_SERVERINFO,
 GAME_RELIABLE_MESSAGE_TOURNEYLINE,
 GAME_RELIABLE_MESSAGE_CALLVOTE,
 GAME_RELIABLE_MESSAGE_CASTVOTE,
 GAME_RELIABLE_MESSAGE_STARTVOTE,
 GAME_RELIABLE_MESSAGE_UPDATEVOTE,
 GAME_RELIABLE_MESSAGE_PORTALSTATES,
 GAME_RELIABLE_MESSAGE_PORTAL,
 GAME_RELIABLE_MESSAGE_VCHAT,
 GAME_RELIABLE_MESSAGE_STARTSTATE,
 GAME_RELIABLE_MESSAGE_MENU,
 GAME_RELIABLE_MESSAGE_WARMUPTIME,
 GAME_RELIABLE_MESSAGE_EVENT
};

typedef enum {
 GAMESTATE_UNINITIALIZED,
 GAMESTATE_NOMAP,
 GAMESTATE_STARTUP,
 GAMESTATE_ACTIVE,
 GAMESTATE_SHUTDOWN
} gameState_t;

typedef struct {
 idEntity *ent;
 int dist;
} spawnSpot_t;



class idEventQueue {
public:
 typedef enum {
  OUTOFORDER_IGNORE,
  OUTOFORDER_DROP,
  OUTOFORDER_SORT
 } outOfOrderBehaviour_t;

       idEventQueue() : start( __null ), end( __null ) {}

 entityNetEvent_t * Alloc();
 void Free( entityNetEvent_t *event );
 void Shutdown();

 void Init();
 void Enqueue( entityNetEvent_t* event, outOfOrderBehaviour_t oooBehaviour );
 entityNetEvent_t * Dequeue( void );
 entityNetEvent_t * RemoveLast( void );

 entityNetEvent_t * Start( void ) { return start; }

private:
 entityNetEvent_t * start;
 entityNetEvent_t * end;
 idBlockAlloc<entityNetEvent_t,32> eventAllocator;
};



template< class type >
class idEntityPtr {
public:
       idEntityPtr();


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 idEntityPtr<type> & operator=( type *ent );


 int GetSpawnId( void ) const { return spawnId; }
 bool SetSpawnId( int id );
 bool UpdateSpawnId( void );

 bool IsValid( void ) const;
 type * GetEntity( void ) const;
 int GetEntityNum( void ) const;

private:
 int spawnId;
};



class idGameLocal : public idGame {
public:
 idDict serverInfo;
 int numClients;
 idDict userInfo[4];
 usercmd_t usercmds[4];
 idDict persistentPlayerInfo[4];
 idEntity * entities[(1<<12)];
 int spawnIds[(1<<12)];
 int firstFreeIndex;
 int num_entities;
 idHashIndex entityHash;
 idWorldspawn * world;
 idLinkList<idEntity> spawnedEntities;
 idLinkList<idEntity> activeEntities;
 int numEntitiesToDeactivate;
 bool sortPushers;
 bool sortTeamMasters;
 idDict persistentLevelInfo;


 float globalShaderParms[ MAX_GLOBAL_SHADER_PARMS ];

 idRandom random;

 idProgram program;
 idThread * frameCommandThread;

 idClip clip;
 idPush push;
 idPVS pvs;

 idTestModel * testmodel;
 idEntityFx * testFx;

 idStr sessionCommand;

 idMultiplayerGame mpGame;

 idSmokeParticles * smokeParticles;
 idEditEntities * editEntities;

 int cinematicSkipTime;
 int cinematicStopTime;
 int cinematicMaxSkipTime;
 bool inCinematic;
 bool skipCinematic;


 int framenum;
 int previousTime;
 int time;
 static const int msec = USERCMD_MSEC;

 int vacuumAreaNum;

 gameType_t gameType;
 bool isMultiplayer;
 bool isServer;
 bool isClient;


 int localClientNum;
 idLinkList<idEntity> snapshotEntities;
 int realClientTime;
 bool isNewFrame;
 float clientSmoothing;
 int entityDefBits;

 static const char * sufaceTypeNames[ MAX_SURFACE_TYPES ];

 idEntityPtr<idEntity> lastGUIEnt;
 int lastGUI;



       idGameLocal();

 virtual void Init( void );
 virtual void Shutdown( void );
 virtual void SetLocalClient( int clientNum );
 virtual void ThrottleUserInfo( void );
 virtual const idDict * SetUserInfo( int clientNum, const idDict &userInfo, bool isClient, bool canModify );
 virtual const idDict * GetUserInfo( int clientNum );
 virtual void SetServerInfo( const idDict &serverInfo );

 virtual const idDict & GetPersistentPlayerInfo( int clientNum );
 virtual void SetPersistentPlayerInfo( int clientNum, const idDict &playerInfo );
 virtual void InitFromNewMap( const char *mapName, idRenderWorld *renderWorld, idSoundWorld *soundWorld, bool isServer, bool isClient, int randSeed );
 virtual bool InitFromSaveGame( const char *mapName, idRenderWorld *renderWorld, idSoundWorld *soundWorld, idFile *saveGameFile );
 virtual void SaveGame( idFile *saveGameFile );
 virtual void MapShutdown( void );
 virtual void CacheDictionaryMedia( const idDict *dict );
 virtual void SpawnPlayer( int clientNum );
 virtual gameReturn_t RunFrame( const usercmd_t *clientCmds );
 virtual bool Draw( int clientNum );
 virtual escReply_t HandleESC( idUserInterface **gui );
 virtual idUserInterface *StartMenu( void );
 virtual const char * HandleGuiCommands( const char *menuCommand );
 virtual void HandleMainMenuCommands( const char *menuCommand, idUserInterface *gui );
 virtual allowReply_t ServerAllowClient( int numClients, const char *IP, const char *guid, const char *password, char reason[1024] );
 virtual void ServerClientConnect( int clientNum, const char *guid );
 virtual void ServerClientBegin( int clientNum );
 virtual void ServerClientDisconnect( int clientNum );
 virtual void ServerWriteInitialReliableMessages( int clientNum );
 virtual void ServerWriteSnapshot( int clientNum, int sequence, idBitMsg &msg, byte *clientInPVS, int numPVSClients );
 virtual bool ServerApplySnapshot( int clientNum, int sequence );
 virtual void ServerProcessReliableMessage( int clientNum, const idBitMsg &msg );
 virtual void ClientReadSnapshot( int clientNum, int sequence, const int gameFrame, const int gameTime, const int dupeUsercmds, const int aheadOfServer, const idBitMsg &msg );
 virtual bool ClientApplySnapshot( int clientNum, int sequence );
 virtual void ClientProcessReliableMessage( int clientNum, const idBitMsg &msg );
 virtual gameReturn_t ClientPrediction( int clientNum, const usercmd_t *clientCmds, bool lastPredictFrame );

 virtual void GetClientStats( int clientNum, char *data, const int len );
 virtual void SwitchTeam( int clientNum, int team );

 virtual bool DownloadRequest( const char *IP, const char *guid, const char *paks, char urls[ 1024 ] );



 void Printf( const char *fmt, ... ) const __attribute__((format(printf,2,3)));
 void DPrintf( const char *fmt, ... ) const __attribute__((format(printf,2,3)));
 void Warning( const char *fmt, ... ) const __attribute__((format(printf,2,3)));
 void DWarning( const char *fmt, ... ) const __attribute__((format(printf,2,3)));
 void Error( const char *fmt, ... ) const __attribute__((format(printf,2,3)));


 void LoadMap( const char *mapName, int randseed );

 void LocalMapRestart( void );
 void MapRestart( void );
 static void MapRestart_f( const idCmdArgs &args );
 bool NextMap( void );
 static void NextMap_f( const idCmdArgs &args );

 idMapFile * GetLevelMap( void );
 const char * GetMapName( void ) const;

 int NumAAS( void ) const;
 idAAS * GetAAS( int num ) const;
 idAAS * GetAAS( const char *name ) const;
 void SetAASAreaState( const idBounds &bounds, const int areaContents, bool closed );
 aasHandle_t AddAASObstacle( const idBounds &bounds );
 void RemoveAASObstacle( const aasHandle_t handle );
 void RemoveAllAASObstacles( void );

 bool CheatsOk( bool requirePlayer = true );
 void SetSkill( int value );
 gameState_t GameState( void ) const;
 idEntity * SpawnEntityType( const idTypeInfo &classdef, const idDict *args = __null, bool bIsClientReadSnapshot = false );
 bool SpawnEntityDef( const idDict &args, idEntity **ent = __null, bool setDefaults = true );
 int GetSpawnId( const idEntity *ent ) const;

 const idDeclEntityDef * FindEntityDef( const char *name, bool makeDefault = true, bool parse = true ) const;
 const idDict * FindEntityDefDict( const char *name, bool makeDefault = true ) const;

 void RegisterEntity( idEntity *ent );
 void UnregisterEntity( idEntity *ent );

 bool RequirementMet( idEntity *activator, const idStr &requires, int removeItem );

 void AlertAI( idEntity *ent );
 idActor * GetAlertEntity( void );

 bool InPlayerPVS( idEntity *ent ) const;
 bool InPlayerConnectedArea( idEntity *ent ) const;

 void SetCamera( idCamera *cam );
 idCamera * GetCamera( void ) const;
 bool SkipCinematic( void );
 void CalcFov( float base_fov, float &fov_x, float &fov_y ) const;

 void AddEntityToHash( const char *name, idEntity *ent );
 bool RemoveEntityFromHash( const char *name, idEntity *ent );
 int GetTargets( const idDict &args, idList< idEntityPtr<idEntity> > &list, const char *ref ) const;


 idEntity * GetTraceEntity( const trace_t &trace ) const;

 static void ArgCompletion_EntityName( const idCmdArgs &args, void(*callback)( const char *s ) );
 idEntity * FindTraceEntity( idVec3 start, idVec3 end, const idTypeInfo &c, const idEntity *skip ) const;
 idEntity * FindEntity( const char *name ) const;
 idEntity * FindEntityUsingDef( idEntity *from, const char *match ) const;
 int EntitiesWithinRadius( const idVec3 org, float radius, idEntity **entityList, int maxCount ) const;

 void KillBox( idEntity *ent, bool catch_teleport = false );
 void RadiusDamage( const idVec3 &origin, idEntity *inflictor, idEntity *attacker, idEntity *ignoreDamage, idEntity *ignorePush, const char *damageDefName, float dmgPower = 1.0f );
 void RadiusPush( const idVec3 &origin, const float radius, const float push, const idEntity *inflictor, const idEntity *ignore, float inflictorScale, const bool quake );
 void RadiusPushClipModel( const idVec3 &origin, const float push, const idClipModel *clipModel );

 void ProjectDecal( const idVec3 &origin, const idVec3 &dir, float depth, bool parallel, float size, const char *material, float angle = 0 );
 void BloodSplat( const idVec3 &origin, const idVec3 &dir, float size, const char *material );

 void CallFrameCommand( idEntity *ent, const function_t *frameCommand );
 void CallObjectFrameCommand( idEntity *ent, const char *frameCommand );

 const idVec3 & GetGravity( void ) const;


 int GetFrameNum() const { return framenum; };
 int GetTime() const { return time; };
 int GetMSec() const { return msec; };

 int GetNextClientNum( int current ) const;
 idPlayer * GetClientByNum( int current ) const;
 idPlayer * GetClientByName( const char *name ) const;
 idPlayer * GetClientByCmdArgs( const idCmdArgs &args ) const;

 idPlayer * GetLocalPlayer() const;

 void SpreadLocations();
 idLocationEntity * LocationForPoint( const idVec3 &point );
 idEntity * SelectInitialSpawnPoint( idPlayer *player );

 void SetPortalState( qhandle_t portal, int blockingBits );
 void SaveEntityNetworkEvent( const idEntity *ent, int event, const idBitMsg *msg );
 void ServerSendChatMessage( int to, const char *name, const char *text );
 int ServerRemapDecl( int clientNum, declType_t type, int index );
 int ClientRemapDecl( declType_t type, int index );

 void SetGlobalMaterial( const idMaterial *mat );
 const idMaterial * GetGlobalMaterial();

 void SetGibTime( int _time ) { nextGibTime = _time; };
 int GetGibTime() { return nextGibTime; };

 bool NeedRestart();

private:
 const static int INITIAL_SPAWN_COUNT = 1;

 idStr mapFileName;
 idMapFile * mapFile;
 bool mapCycleLoaded;

 int spawnCount;
 int mapSpawnCount;

 idLocationEntity ** locationEntities;

 idCamera * camera;
 const idMaterial * globalMaterial;

 idList<idAAS *> aasList;
 idStrList aasNames;

 idEntityPtr<idActor> lastAIAlertEntity;
 int lastAIAlertTime;

 idDict spawnArgs;

 pvsHandle_t playerPVS;
 pvsHandle_t playerConnectedAreas;

 idVec3 gravity;
 gameState_t gamestate;
 bool influenceActive;
 int nextGibTime;

 idList<int> clientDeclRemap[4][DECL_MAX_TYPES];

 entityState_t * clientEntityStates[4][(1<<12)];
 int clientPVS[4][ENTITY_PVS_SIZE];
 snapshot_t * clientSnapshots[4];
 idBlockAlloc<entityState_t,256>entityStateAllocator;
 idBlockAlloc<snapshot_t,64>snapshotAllocator;

 idEventQueue eventQueue;
 idEventQueue savedEventQueue;

 idStaticList<spawnSpot_t, (1<<12)> spawnSpots;
 idStaticList<idEntity *, (1<<12)> initialSpots;
 int currentInitialSpot;

 idDict newInfo;

 idStrList shakeSounds;

 byte lagometer[ 64 ][ 64 ][ 4 ];

 void Clear( void );

 bool InhibitEntitySpawn( idDict &spawnArgs );

 void SpawnMapEntities( void );

 void MapPopulate( void );
 void MapClear( bool clearClients );

 pvsHandle_t GetClientPVS( idPlayer *player, pvsType_t type );
 void SetupPlayerPVS( void );
 void FreePlayerPVS( void );
 void UpdateGravity( void );
 void SortActiveEntityList( void );
 void ShowTargets( void );
 void RunDebugInfo( void );

 void InitScriptForMap( void );

 void InitConsoleCommands( void );
 void ShutdownConsoleCommands( void );

 void InitAsyncNetwork( void );
 void ShutdownAsyncNetwork( void );
 void InitLocalClient( int clientNum );
 void InitClientDeclRemap( int clientNum );
 void ServerSendDeclRemapToClient( int clientNum, declType_t type, int index );
 void FreeSnapshotsOlderThanSequence( int clientNum, int sequence );
 bool ApplySnapshot( int clientNum, int sequence );
 void WriteGameStateToSnapshot( idBitMsgDelta &msg ) const;
 void ReadGameStateFromSnapshot( const idBitMsgDelta &msg );
 void NetworkEventWarning( const entityNetEvent_t *event, const char *fmt, ... ) __attribute__((format(printf,3,4)));
 void ServerProcessEntityNetworkEventQueue( void );
 void ClientProcessEntityNetworkEventQueue( void );
 void ClientShowSnapshot( int clientNum ) const;

 void UpdateServerInfoFlags( void );
 void RandomizeInitialSpawns( void );
 static int sortSpawnPoints( const void *ptr1, const void *ptr2 );

 void DumpOggSounds( void );
 void GetShakeSounds( const idDict *dict );

 void SelectTimeGroup( int timeGroup );
 int GetTimeGroupTime( int timeGroup );
 void GetBestGameType( const char* map, const char* gametype, char buf[ 1024 ] );

 void Tokenize( idStrList &out, const char *in );

 void UpdateLagometer( int aheadOfServer, int dupeUsercmds );

 void GetMapLoadingGUI( char gui[ 1024 ] );
};



extern idGameLocal gameLocal;
extern idAnimManager animationLib;



template< class type >
inline idEntityPtr<type>::idEntityPtr() {
 spawnId = 0;
}

template< class type >
inline void idEntityPtr<type>::Save( idSaveGame *savefile ) const {
 savefile->WriteInt( spawnId );
}

template< class type >
inline void idEntityPtr<type>::Restore( idRestoreGame *savefile ) {
 savefile->ReadInt( spawnId );
}

template< class type >
inline idEntityPtr<type> &idEntityPtr<type>::operator=( type *ent ) {
 if ( ent == __null ) {
  spawnId = 0;
 } else {
  spawnId = ( gameLocal.spawnIds[ent->entityNumber] << 12 ) | ent->entityNumber;
 }
 return *this;
}

template< class type >
inline bool idEntityPtr<type>::SetSpawnId( int id ) {


 if ( id == spawnId ) {
  return false;
 }
 if ( ( id >> 12 ) == gameLocal.spawnIds[ id & ( ( 1 << 12 ) - 1 ) ] ) {
  spawnId = id;
  return true;
 }
 return false;
}

template< class type >
inline bool idEntityPtr<type>::IsValid( void ) const {
 return ( gameLocal.spawnIds[ spawnId & ( ( 1 << 12 ) - 1 ) ] == ( spawnId >> 12 ) );
}

template< class type >
inline type *idEntityPtr<type>::GetEntity( void ) const {
 int entityNum = spawnId & ( ( 1 << 12 ) - 1 );
 if ( ( gameLocal.spawnIds[ entityNum ] == ( spawnId >> 12 ) ) ) {
  return static_cast<type *>( gameLocal.entities[ entityNum ] );
 }
 return __null;
}

template< class type >
inline int idEntityPtr<type>::GetEntityNum( void ) const {
 return ( spawnId & ( ( 1 << 12 ) - 1 ) );
}



class idGameError : public idException {
public:
 idGameError( const char *text ) : idException( text ) {}
};
# 660 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h"
typedef enum {
 SND_CHANNEL_ANY = SCHANNEL_ANY,
 SND_CHANNEL_VOICE = SCHANNEL_ONE,
 SND_CHANNEL_VOICE2,
 SND_CHANNEL_BODY,
 SND_CHANNEL_BODY2,
 SND_CHANNEL_BODY3,
 SND_CHANNEL_WEAPON,
 SND_CHANNEL_ITEM,
 SND_CHANNEL_HEART,
 SND_CHANNEL_PDA,
 SND_CHANNEL_DEMONIC,
 SND_CHANNEL_RADIO,


 SND_CHANNEL_AMBIENT,
 SND_CHANNEL_DAMAGE
} gameSoundChannel_t;
# 690 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h"
const float DEFAULT_GRAVITY = 1066.0f;

const idVec3 DEFAULT_GRAVITY_VEC3( 0, 0, -DEFAULT_GRAVITY );

const int CINEMATIC_SKIP_DELAY = ( idMath::FtoiFast( (2.0f) * idMath::M_SEC2MS ) );



# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Force.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/physics/Force.h"
class idEntity;
class idPhysics;

class idForce : public idClass {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idForce> eventCallbacks[];

      idForce( void );
 virtual ~idForce( void );
 static void DeletePhysics( const idPhysics *phys );
 static void ClearForceList( void );

public:

 virtual void Evaluate( int time );

 virtual void RemovePhysics( const idPhysics *phys );

private:

 static idList<idForce*> forceList;
};
# 699 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Force_Constant.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/physics/Force_Constant.h"
class idForce_Constant : public idForce {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idForce_Constant> eventCallbacks[];

      idForce_Constant( void );
 virtual ~idForce_Constant( void );


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );


 void SetForce( const idVec3 &force );

 void SetPosition( idPhysics *physics, int id, const idVec3 &point );

 void SetPhysics( idPhysics *physics );

public:
 virtual void Evaluate( int time );
 virtual void RemovePhysics( const idPhysics *phys );

private:

 idVec3 force;
 idPhysics * physics;
 int id;
 idVec3 point;
};
# 700 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Force_Drag.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/physics/Force_Drag.h"
class idForce_Drag : public idForce {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idForce_Drag> eventCallbacks[];

      idForce_Drag( void );
 virtual ~idForce_Drag( void );

 void Init( float damping );

 void SetPhysics( idPhysics *physics, int id, const idVec3 &p );

 void SetDragPosition( const idVec3 &pos );

 const idVec3 & GetDragPosition( void ) const;

 const idVec3 GetDraggedPosition( void ) const;

public:
 virtual void Evaluate( int time );
 virtual void RemovePhysics( const idPhysics *phys );

private:


 float damping;


 idPhysics * physics;
 int id;
 idVec3 p;
 idVec3 dragPosition;
};
# 701 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Force_Field.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/physics/Force_Field.h"
enum forceFieldType {
 FORCEFIELD_UNIFORM,
 FORCEFIELD_EXPLOSION,
 FORCEFIELD_IMPLOSION
};

enum forceFieldApplyType {
 FORCEFIELD_APPLY_FORCE,
 FORCEFIELD_APPLY_VELOCITY,
 FORCEFIELD_APPLY_IMPULSE
};

class idForce_Field : public idForce {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idForce_Field> eventCallbacks[];

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

      idForce_Field( void );
 virtual ~idForce_Field( void );

 void Uniform( const idVec3 &force );

 void Explosion( float force );

 void Implosion( float force );

 void RandomTorque( float force );

 void SetApplyType( const forceFieldApplyType type ) { applyType = type; }

 void SetPlayerOnly( bool set ) { playerOnly = set; }

 void SetMonsterOnly( bool set ) { monsterOnly = set; }

 void SetClipModel( idClipModel *clipModel );

public:
 virtual void Evaluate( int time );

private:

 forceFieldType type;
 forceFieldApplyType applyType;
 float magnitude;
 idVec3 dir;
 float randomTorque;
 bool playerOnly;
 bool monsterOnly;
 idClipModel * clipModel;
};
# 702 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Force_Spring.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/physics/Force_Spring.h"
class idForce_Spring : public idForce {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idForce_Spring> eventCallbacks[];

      idForce_Spring( void );
 virtual ~idForce_Spring( void );

 void InitSpring( float Kstretch, float Kcompress, float damping, float restLength );

 void SetPosition( idPhysics *physics1, int id1, const idVec3 &p1,
          idPhysics *physics2, int id2, const idVec3 &p2 );

public:
 virtual void Evaluate( int time );
 virtual void RemovePhysics( const idPhysics *phys );

private:


 float Kstretch;
 float Kcompress;
 float damping;
 float restLength;


 idPhysics * physics1;
 int id1;
 idVec3 p1;
 idPhysics * physics2;
 int id2;
 idVec3 p2;

};
# 703 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics.h" 1
# 66 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics.h"
class idEntity;

typedef struct impactInfo_s {
 float invMass;
 idMat3 invInertiaTensor;
 idVec3 position;
 idVec3 velocity;
} impactInfo_t;


class idPhysics : public idClass {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics> eventCallbacks[];

 virtual ~idPhysics( void );
 static int SnapTimeToPhysicsFrame( int t );


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

public:

 virtual void SetSelf( idEntity *e ) = 0;

 virtual void SetClipModel( idClipModel *model, float density, int id = 0, bool freeOld = true ) = 0;
 virtual void SetClipBox( const idBounds &bounds, float density );
 virtual idClipModel * GetClipModel( int id = 0 ) const = 0;
 virtual int GetNumClipModels( void ) const = 0;

 virtual void SetMass( float mass, int id = -1 ) = 0;
 virtual float GetMass( int id = -1 ) const = 0;

 virtual void SetContents( int contents, int id = -1 ) = 0;
 virtual int GetContents( int id = -1 ) const = 0;

 virtual void SetClipMask( int mask, int id = -1 ) = 0;
 virtual int GetClipMask( int id = -1 ) const = 0;

 virtual const idBounds & GetBounds( int id = -1 ) const = 0;
 virtual const idBounds & GetAbsBounds( int id = -1 ) const = 0;

 virtual bool Evaluate( int timeStepMSec, int endTimeMSec ) = 0;

 virtual void UpdateTime( int endTimeMSec ) = 0;

 virtual int GetTime( void ) const = 0;

 virtual void GetImpactInfo( const int id, const idVec3 &point, impactInfo_t *info ) const = 0;
 virtual void ApplyImpulse( const int id, const idVec3 &point, const idVec3 &impulse ) = 0;
 virtual void AddForce( const int id, const idVec3 &point, const idVec3 &force ) = 0;
 virtual void Activate( void ) = 0;
 virtual void PutToRest( void ) = 0;
 virtual bool IsAtRest( void ) const = 0;
 virtual int GetRestStartTime( void ) const = 0;
 virtual bool IsPushable( void ) const = 0;

 virtual void SaveState( void ) = 0;
 virtual void RestoreState( void ) = 0;

 virtual void SetOrigin( const idVec3 &newOrigin, int id = -1 ) = 0;
 virtual void SetAxis( const idMat3 &newAxis, int id = -1 ) = 0;

 virtual void Translate( const idVec3 &translation, int id = -1 ) = 0;
 virtual void Rotate( const idRotation &rotation, int id = -1 ) = 0;

 virtual const idVec3 & GetOrigin( int id = 0 ) const = 0;
 virtual const idMat3 & GetAxis( int id = 0 ) const = 0;

 virtual void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 ) = 0;
 virtual void SetAngularVelocity( const idVec3 &newAngularVelocity, int id = 0 ) = 0;

 virtual const idVec3 & GetLinearVelocity( int id = 0 ) const = 0;
 virtual const idVec3 & GetAngularVelocity( int id = 0 ) const = 0;

 virtual void SetGravity( const idVec3 &newGravity ) = 0;
 virtual const idVec3 & GetGravity( void ) const = 0;
 virtual const idVec3 & GetGravityNormal( void ) const = 0;

 virtual void ClipTranslation( trace_t &results, const idVec3 &translation, const idClipModel *model ) const = 0;
 virtual void ClipRotation( trace_t &results, const idRotation &rotation, const idClipModel *model ) const = 0;
 virtual int ClipContents( const idClipModel *model ) const = 0;

 virtual void DisableClip( void ) = 0;
 virtual void EnableClip( void ) = 0;

 virtual void UnlinkClip( void ) = 0;
 virtual void LinkClip( void ) = 0;

 virtual bool EvaluateContacts( void ) = 0;
 virtual int GetNumContacts( void ) const = 0;
 virtual const contactInfo_t &GetContact( int num ) const = 0;
 virtual void ClearContacts( void ) = 0;
 virtual void AddContactEntity( idEntity *e ) = 0;
 virtual void RemoveContactEntity( idEntity *e ) = 0;

 virtual bool HasGroundContacts( void ) const = 0;
 virtual bool IsGroundEntity( int entityNum ) const = 0;
 virtual bool IsGroundClipModel( int entityNum, int id ) const = 0;

 virtual void SetMaster( idEntity *master, const bool orientated = true ) = 0;

 virtual void SetPushed( int deltaTime ) = 0;
 virtual const idVec3 & GetPushedLinearVelocity( const int id = 0 ) const = 0;
 virtual const idVec3 & GetPushedAngularVelocity( const int id = 0 ) const = 0;

 virtual const trace_t * GetBlockingInfo( void ) const = 0;
 virtual idEntity * GetBlockingEntity( void ) const = 0;

 virtual int GetLinearEndTime( void ) const = 0;
 virtual int GetAngularEndTime( void ) const = 0;

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const = 0;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg ) = 0;
};
# 704 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Static.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Static.h"
typedef struct staticPState_s {
 idVec3 origin;
 idMat3 axis;
 idVec3 localOrigin;
 idMat3 localAxis;
} staticPState_t;

class idPhysics_Static : public idPhysics {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_Static> eventCallbacks[];

       idPhysics_Static( void );
       ~idPhysics_Static( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

public:
 void SetSelf( idEntity *e );

 void SetClipModel( idClipModel *model, float density, int id = 0, bool freeOld = true );
 idClipModel * GetClipModel( int id = 0 ) const;
 int GetNumClipModels( void ) const;

 void SetMass( float mass, int id = -1 );
 float GetMass( int id = -1 ) const;

 void SetContents( int contents, int id = -1 );
 int GetContents( int id = -1 ) const;

 void SetClipMask( int mask, int id = -1 );
 int GetClipMask( int id = -1 ) const;

 const idBounds & GetBounds( int id = -1 ) const;
 const idBounds & GetAbsBounds( int id = -1 ) const;

 bool Evaluate( int timeStepMSec, int endTimeMSec );
 void UpdateTime( int endTimeMSec );
 int GetTime( void ) const;

 void GetImpactInfo( const int id, const idVec3 &point, impactInfo_t *info ) const;
 void ApplyImpulse( const int id, const idVec3 &point, const idVec3 &impulse );
 void AddForce( const int id, const idVec3 &point, const idVec3 &force );
 void Activate( void );
 void PutToRest( void );
 bool IsAtRest( void ) const;
 int GetRestStartTime( void ) const;
 bool IsPushable( void ) const;

 void SaveState( void );
 void RestoreState( void );

 void SetOrigin( const idVec3 &newOrigin, int id = -1 );
 void SetAxis( const idMat3 &newAxis, int id = -1 );

 void Translate( const idVec3 &translation, int id = -1 );
 void Rotate( const idRotation &rotation, int id = -1 );

 const idVec3 & GetOrigin( int id = 0 ) const;
 const idMat3 & GetAxis( int id = 0 ) const;

 void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 );
 void SetAngularVelocity( const idVec3 &newAngularVelocity, int id = 0 );

 const idVec3 & GetLinearVelocity( int id = 0 ) const;
 const idVec3 & GetAngularVelocity( int id = 0 ) const;

 void SetGravity( const idVec3 &newGravity );
 const idVec3 & GetGravity( void ) const;
 const idVec3 & GetGravityNormal( void ) const;

 void ClipTranslation( trace_t &results, const idVec3 &translation, const idClipModel *model ) const;
 void ClipRotation( trace_t &results, const idRotation &rotation, const idClipModel *model ) const;
 int ClipContents( const idClipModel *model ) const;

 void DisableClip( void );
 void EnableClip( void );

 void UnlinkClip( void );
 void LinkClip( void );

 bool EvaluateContacts( void );
 int GetNumContacts( void ) const;
 const contactInfo_t & GetContact( int num ) const;
 void ClearContacts( void );
 void AddContactEntity( idEntity *e );
 void RemoveContactEntity( idEntity *e );

 bool HasGroundContacts( void ) const;
 bool IsGroundEntity( int entityNum ) const;
 bool IsGroundClipModel( int entityNum, int id ) const;

 void SetPushed( int deltaTime );
 const idVec3 & GetPushedLinearVelocity( const int id = 0 ) const;
 const idVec3 & GetPushedAngularVelocity( const int id = 0 ) const;

 void SetMaster( idEntity *master, const bool orientated = true );

 const trace_t * GetBlockingInfo( void ) const;
 idEntity * GetBlockingEntity( void ) const;

 int GetLinearEndTime( void ) const;
 int GetAngularEndTime( void ) const;

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );

protected:
 idEntity * self;
 staticPState_t current;
 idClipModel * clipModel;


 bool hasMaster;
 bool isOrientated;
};
# 705 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_StaticMulti.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_StaticMulti.h"
class idPhysics_StaticMulti : public idPhysics {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_StaticMulti> eventCallbacks[];

       idPhysics_StaticMulti( void );
       ~idPhysics_StaticMulti( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void RemoveIndex( int id = 0, bool freeClipModel = true );

public:

 void SetSelf( idEntity *e );

 void SetClipModel( idClipModel *model, float density, int id = 0, bool freeOld = true );
 idClipModel * GetClipModel( int id = 0 ) const;
 int GetNumClipModels( void ) const;

 void SetMass( float mass, int id = -1 );
 float GetMass( int id = -1 ) const;

 void SetContents( int contents, int id = -1 );
 int GetContents( int id = -1 ) const;

 void SetClipMask( int mask, int id = -1 );
 int GetClipMask( int id = -1 ) const;

 const idBounds & GetBounds( int id = -1 ) const;
 const idBounds & GetAbsBounds( int id = -1 ) const;

 bool Evaluate( int timeStepMSec, int endTimeMSec );
 void UpdateTime( int endTimeMSec );
 int GetTime( void ) const;

 void GetImpactInfo( const int id, const idVec3 &point, impactInfo_t *info ) const;
 void ApplyImpulse( const int id, const idVec3 &point, const idVec3 &impulse );
 void AddForce( const int id, const idVec3 &point, const idVec3 &force );
 void Activate( void );
 void PutToRest( void );
 bool IsAtRest( void ) const;
 int GetRestStartTime( void ) const;
 bool IsPushable( void ) const;

 void SaveState( void );
 void RestoreState( void );

 void SetOrigin( const idVec3 &newOrigin, int id = -1 );
 void SetAxis( const idMat3 &newAxis, int id = -1 );

 void Translate( const idVec3 &translation, int id = -1 );
 void Rotate( const idRotation &rotation, int id = -1 );

 const idVec3 & GetOrigin( int id = 0 ) const;
 const idMat3 & GetAxis( int id = 0 ) const;

 void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 );
 void SetAngularVelocity( const idVec3 &newAngularVelocity, int id = 0 );

 const idVec3 & GetLinearVelocity( int id = 0 ) const;
 const idVec3 & GetAngularVelocity( int id = 0 ) const;

 void SetGravity( const idVec3 &newGravity );
 const idVec3 & GetGravity( void ) const;
 const idVec3 & GetGravityNormal( void ) const;

 void ClipTranslation( trace_t &results, const idVec3 &translation, const idClipModel *model ) const;
 void ClipRotation( trace_t &results, const idRotation &rotation, const idClipModel *model ) const;
 int ClipContents( const idClipModel *model ) const;

 void DisableClip( void );
 void EnableClip( void );

 void UnlinkClip( void );
 void LinkClip( void );

 bool EvaluateContacts( void );
 int GetNumContacts( void ) const;
 const contactInfo_t & GetContact( int num ) const;
 void ClearContacts( void );
 void AddContactEntity( idEntity *e );
 void RemoveContactEntity( idEntity *e );

 bool HasGroundContacts( void ) const;
 bool IsGroundEntity( int entityNum ) const;
 bool IsGroundClipModel( int entityNum, int id ) const;

 void SetPushed( int deltaTime );
 const idVec3 & GetPushedLinearVelocity( const int id = 0 ) const;
 const idVec3 & GetPushedAngularVelocity( const int id = 0 ) const;

 void SetMaster( idEntity *master, const bool orientated = true );

 const trace_t * GetBlockingInfo( void ) const;
 idEntity * GetBlockingEntity( void ) const;

 int GetLinearEndTime( void ) const;
 int GetAngularEndTime( void ) const;

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );

protected:
 idEntity * self;
 idList<staticPState_t> current;
 idList<idClipModel *> clipModels;


 bool hasMaster;
 bool isOrientated;
};
# 706 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Base.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Base.h"
class idPhysics_Base : public idPhysics {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_Base> eventCallbacks[];

       idPhysics_Base( void );
       ~idPhysics_Base( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

public:

 void SetSelf( idEntity *e );

 void SetClipModel( idClipModel *model, float density, int id = 0, bool freeOld = true );
 idClipModel * GetClipModel( int id = 0 ) const;
 int GetNumClipModels( void ) const;

 void SetMass( float mass, int id = -1 );
 float GetMass( int id = -1 ) const;

 void SetContents( int contents, int id = -1 );
 int GetContents( int id = -1 ) const;

 void SetClipMask( int mask, int id = -1 );
 int GetClipMask( int id = -1 ) const;

 const idBounds & GetBounds( int id = -1 ) const;
 const idBounds & GetAbsBounds( int id = -1 ) const;

 bool Evaluate( int timeStepMSec, int endTimeMSec );
 void UpdateTime( int endTimeMSec );
 int GetTime( void ) const;

 void GetImpactInfo( const int id, const idVec3 &point, impactInfo_t *info ) const;
 void ApplyImpulse( const int id, const idVec3 &point, const idVec3 &impulse );
 void AddForce( const int id, const idVec3 &point, const idVec3 &force );
 void Activate( void );
 void PutToRest( void );
 bool IsAtRest( void ) const;
 int GetRestStartTime( void ) const;
 bool IsPushable( void ) const;

 void SaveState( void );
 void RestoreState( void );

 void SetOrigin( const idVec3 &newOrigin, int id = -1 );
 void SetAxis( const idMat3 &newAxis, int id = -1 );

 void Translate( const idVec3 &translation, int id = -1 );
 void Rotate( const idRotation &rotation, int id = -1 );

 const idVec3 & GetOrigin( int id = 0 ) const;
 const idMat3 & GetAxis( int id = 0 ) const;

 void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 );
 void SetAngularVelocity( const idVec3 &newAngularVelocity, int id = 0 );

 const idVec3 & GetLinearVelocity( int id = 0 ) const;
 const idVec3 & GetAngularVelocity( int id = 0 ) const;

 void SetGravity( const idVec3 &newGravity );
 const idVec3 & GetGravity( void ) const;
 const idVec3 & GetGravityNormal( void ) const;

 void ClipTranslation( trace_t &results, const idVec3 &translation, const idClipModel *model ) const;
 void ClipRotation( trace_t &results, const idRotation &rotation, const idClipModel *model ) const;
 int ClipContents( const idClipModel *model ) const;

 void DisableClip( void );
 void EnableClip( void );

 void UnlinkClip( void );
 void LinkClip( void );

 bool EvaluateContacts( void );
 int GetNumContacts( void ) const;
 const contactInfo_t & GetContact( int num ) const;
 void ClearContacts( void );
 void AddContactEntity( idEntity *e );
 void RemoveContactEntity( idEntity *e );

 bool HasGroundContacts( void ) const;
 bool IsGroundEntity( int entityNum ) const;
 bool IsGroundClipModel( int entityNum, int id ) const;

 void SetPushed( int deltaTime );
 const idVec3 & GetPushedLinearVelocity( const int id = 0 ) const;
 const idVec3 & GetPushedAngularVelocity( const int id = 0 ) const;

 void SetMaster( idEntity *master, const bool orientated = true );

 const trace_t * GetBlockingInfo( void ) const;
 idEntity * GetBlockingEntity( void ) const;

 int GetLinearEndTime( void ) const;
 int GetAngularEndTime( void ) const;

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );

protected:
 idEntity * self;
 int clipMask;
 idVec3 gravityVector;
 idVec3 gravityNormal;
 idList<contactInfo_t> contacts;
 idList<idEntityPtr<idEntity> > contactEntities;

protected:

 void AddGroundContacts( const idClipModel *clipModel );

 void AddContactEntitiesForContacts( void );

 void ActivateContactEntities( void );

 bool IsOutsideWorld( void ) const;

 void DrawVelocity( int id, float linearScale, float angularScale ) const;
};
# 707 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Actor.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Actor.h"
class idPhysics_Actor : public idPhysics_Base {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_Actor> eventCallbacks[];

       idPhysics_Actor( void );
       ~idPhysics_Actor( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );


 float GetMasterDeltaYaw( void ) const;

 idEntity * GetGroundEntity( void ) const;

 void SetClipModelAxis( void );

public:
 void SetClipModel( idClipModel *model, float density, int id = 0, bool freeOld = true );
 idClipModel * GetClipModel( int id = 0 ) const;
 int GetNumClipModels( void ) const;

 void SetMass( float mass, int id = -1 );
 float GetMass( int id = -1 ) const;

 void SetContents( int contents, int id = -1 );
 int GetContents( int id = -1 ) const;

 const idBounds & GetBounds( int id = -1 ) const;
 const idBounds & GetAbsBounds( int id = -1 ) const;

 bool IsPushable( void ) const;

 const idVec3 & GetOrigin( int id = 0 ) const;
 const idMat3 & GetAxis( int id = 0 ) const;

 void SetGravity( const idVec3 &newGravity );
 const idMat3 & GetGravityAxis( void ) const;

 void ClipTranslation( trace_t &results, const idVec3 &translation, const idClipModel *model ) const;
 void ClipRotation( trace_t &results, const idRotation &rotation, const idClipModel *model ) const;
 int ClipContents( const idClipModel *model ) const;

 void DisableClip( void );
 void EnableClip( void );

 void UnlinkClip( void );
 void LinkClip( void );

 bool EvaluateContacts( void );

protected:
 idClipModel * clipModel;
 idMat3 clipModelAxis;


 float mass;
 float invMass;


 idEntity * masterEntity;
 float masterYaw;
 float masterDeltaYaw;


 idEntityPtr<idEntity> groundEntityPtr;
};
# 708 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Monster.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Monster.h"
typedef enum {
 MM_OK,
 MM_SLIDING,
 MM_BLOCKED,
 MM_STEPPED,
 MM_FALLING
} monsterMoveResult_t;

typedef struct monsterPState_s {
 int atRest;
 bool onGround;
 idVec3 origin;
 idVec3 velocity;
 idVec3 localOrigin;
 idVec3 pushVelocity;
} monsterPState_t;

class idPhysics_Monster : public idPhysics_Actor {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_Monster> eventCallbacks[];

       idPhysics_Monster( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );


 void SetMaxStepHeight( const float newMaxStepHeight );
 float GetMaxStepHeight( void ) const;

 void SetMinFloorCosine( const float newMinFloorCosine );

 void SetDelta( const idVec3 &d );

 bool OnGround( void ) const;

 monsterMoveResult_t GetMoveResult( void ) const;

 void ForceDeltaMove( bool force );

 void UseFlyMove( bool force );

 void UseVelocityMove( bool force );

 idEntity * GetSlideMoveEntity( void ) const;

 void EnableImpact( void );
 void DisableImpact( void );

public:
 bool Evaluate( int timeStepMSec, int endTimeMSec );
 void UpdateTime( int endTimeMSec );
 int GetTime( void ) const;

 void GetImpactInfo( const int id, const idVec3 &point, impactInfo_t *info ) const;
 void ApplyImpulse( const int id, const idVec3 &point, const idVec3 &impulse );
 void Activate( void );
 void PutToRest( void );
 bool IsAtRest( void ) const;
 int GetRestStartTime( void ) const;

 void SaveState( void );
 void RestoreState( void );

 void SetOrigin( const idVec3 &newOrigin, int id = -1 );
 void SetAxis( const idMat3 &newAxis, int id = -1 );

 void Translate( const idVec3 &translation, int id = -1 );
 void Rotate( const idRotation &rotation, int id = -1 );

 void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 );

 const idVec3 & GetLinearVelocity( int id = 0 ) const;

 void SetPushed( int deltaTime );
 const idVec3 & GetPushedLinearVelocity( const int id = 0 ) const;

 void SetMaster( idEntity *master, const bool orientated = true );

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );

private:

 monsterPState_t current;
 monsterPState_t saved;


 float maxStepHeight;
 float minFloorCosine;
 idVec3 delta;

 bool forceDeltaMove;
 bool fly;
 bool useVelocityMove;
 bool noImpact;


 monsterMoveResult_t moveResult;
 idEntity * blockingEntity;

private:
 void CheckGround( monsterPState_t &state );
 monsterMoveResult_t SlideMove( idVec3 &start, idVec3 &velocity, const idVec3 &delta );
 monsterMoveResult_t StepMove( idVec3 &start, idVec3 &velocity, const idVec3 &delta );
 void Rest( void );
};
# 709 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Player.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Player.h"
typedef enum {
 PM_NORMAL,
 PM_DEAD,
 PM_SPECTATOR,
 PM_FREEZE,
 PM_NOCLIP
} pmtype_t;

typedef enum {
 WATERLEVEL_NONE,
 WATERLEVEL_FEET,
 WATERLEVEL_WAIST,
 WATERLEVEL_HEAD
} waterLevel_t;



typedef struct playerPState_s {
 idVec3 origin;
 idVec3 velocity;
 idVec3 localOrigin;
 idVec3 pushVelocity;
 float stepUp;
 int movementType;
 int movementFlags;
 int movementTime;
} playerPState_t;

class idPhysics_Player : public idPhysics_Actor {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_Player> eventCallbacks[];

       idPhysics_Player( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );


 void SetSpeed( const float newWalkSpeed, const float newCrouchSpeed );
 void SetMaxStepHeight( const float newMaxStepHeight );
 float GetMaxStepHeight( void ) const;
 void SetMaxJumpHeight( const float newMaxJumpHeight );
 void SetMovementType( const pmtype_t type );
 void SetPlayerInput( const usercmd_t &cmd, const idAngles &newViewAngles );
 void SetKnockBack( const int knockBackTime );
 void SetDebugLevel( bool set );

 waterLevel_t GetWaterLevel( void ) const;
 int GetWaterType( void ) const;
 bool HasJumped( void ) const;
 bool HasSteppedUp( void ) const;
 float GetStepUp( void ) const;
 bool IsCrouching( void ) const;
 bool OnLadder( void ) const;
 const idVec3 & PlayerGetOrigin( void ) const;

public:
 bool Evaluate( int timeStepMSec, int endTimeMSec );
 void UpdateTime( int endTimeMSec );
 int GetTime( void ) const;

 void GetImpactInfo( const int id, const idVec3 &point, impactInfo_t *info ) const;
 void ApplyImpulse( const int id, const idVec3 &point, const idVec3 &impulse );
 bool IsAtRest( void ) const;
 int GetRestStartTime( void ) const;

 void SaveState( void );
 void RestoreState( void );

 void SetOrigin( const idVec3 &newOrigin, int id = -1 );
 void SetAxis( const idMat3 &newAxis, int id = -1 );

 void Translate( const idVec3 &translation, int id = -1 );
 void Rotate( const idRotation &rotation, int id = -1 );

 void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 );

 const idVec3 & GetLinearVelocity( int id = 0 ) const;

 void SetPushed( int deltaTime );
 const idVec3 & GetPushedLinearVelocity( const int id = 0 ) const;
 void ClearPushedVelocity( void );

 void SetMaster( idEntity *master, const bool orientated = true );

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );

private:

 playerPState_t current;
 playerPState_t saved;


 float walkSpeed;
 float crouchSpeed;
 float maxStepHeight;
 float maxJumpHeight;
 int debugLevel;


 usercmd_t command;
 idAngles viewAngles;


 int framemsec;
 float frametime;
 float playerSpeed;
 idVec3 viewForward;
 idVec3 viewRight;


 bool walking;
 bool groundPlane;
 trace_t groundTrace;
 const idMaterial * groundMaterial;


 bool ladder;
 idVec3 ladderNormal;


 waterLevel_t waterLevel;
 int waterType;

private:
 float CmdScale( const usercmd_t &cmd ) const;
 void Accelerate( const idVec3 &wishdir, const float wishspeed, const float accel );
 bool SlideMove( bool gravity, bool stepUp, bool stepDown, bool push );
 void Friction( void );
 void WaterJumpMove( void );
 void WaterMove( void );
 void FlyMove( void );
 void AirMove( void );
 void WalkMove( void );
 void DeadMove( void );
 void NoclipMove( void );
 void SpectatorMove( void );
 void LadderMove( void );
 void CorrectAllSolid( trace_t &trace, int contents );
 void CheckGround( void );
 void CheckDuck( void );
 void CheckLadder( void );
 bool CheckJump( void );
 bool CheckWaterJump( void );
 void SetWaterLevel( void );
 void DropTimers( void );
 void MovePlayer( int msec );
};
# 710 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Parametric.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_Parametric.h"
typedef struct parametricPState_s {
 int time;
 int atRest;
 idVec3 origin;
 idAngles angles;
 idMat3 axis;
 idVec3 localOrigin;
 idAngles localAngles;
 idExtrapolate<idVec3> linearExtrapolation;
 idExtrapolate<idAngles> angularExtrapolation;
 idInterpolateAccelDecelLinear<idVec3> linearInterpolation;
 idInterpolateAccelDecelLinear<idAngles> angularInterpolation;
 idCurve_Spline<idVec3> * spline;
 idInterpolateAccelDecelLinear<float> splineInterpolate;
 bool useSplineAngles;
} parametricPState_t;

class idPhysics_Parametric : public idPhysics_Base {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_Parametric> eventCallbacks[];

       idPhysics_Parametric( void );
       ~idPhysics_Parametric( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void SetPusher( int flags );
 bool IsPusher( void ) const;

 void SetLinearExtrapolation( extrapolation_t type, int time, int duration, const idVec3 &base, const idVec3 &speed, const idVec3 &baseSpeed );
 void SetAngularExtrapolation( extrapolation_t type, int time, int duration, const idAngles &base, const idAngles &speed, const idAngles &baseSpeed );
 extrapolation_t GetLinearExtrapolationType( void ) const;
 extrapolation_t GetAngularExtrapolationType( void ) const;

 void SetLinearInterpolation( int time, int accelTime, int decelTime, int duration, const idVec3 &startPos, const idVec3 &endPos );
 void SetAngularInterpolation( int time, int accelTime, int decelTime, int duration, const idAngles &startAng, const idAngles &endAng );

 void SetSpline( idCurve_Spline<idVec3> *spline, int accelTime, int decelTime, bool useSplineAngles );
 idCurve_Spline<idVec3> *GetSpline( void ) const;
 int GetSplineAcceleration( void ) const;
 int GetSplineDeceleration( void ) const;
 bool UsingSplineAngles( void ) const;

 void GetLocalOrigin( idVec3 &curOrigin ) const;
 void GetLocalAngles( idAngles &curAngles ) const;

 void GetAngles( idAngles &curAngles ) const;

public:
 void SetClipModel( idClipModel *model, float density, int id = 0, bool freeOld = true );
 idClipModel * GetClipModel( int id = 0 ) const;
 int GetNumClipModels( void ) const;

 void SetMass( float mass, int id = -1 );
 float GetMass( int id = -1 ) const;

 void SetContents( int contents, int id = -1 );
 int GetContents( int id = -1 ) const;

 const idBounds & GetBounds( int id = -1 ) const;
 const idBounds & GetAbsBounds( int id = -1 ) const;

 bool Evaluate( int timeStepMSec, int endTimeMSec );
 void UpdateTime( int endTimeMSec );
 int GetTime( void ) const;

 void Activate( void );
 bool IsAtRest( void ) const;
 int GetRestStartTime( void ) const;
 bool IsPushable( void ) const;

 void SaveState( void );
 void RestoreState( void );

 void SetOrigin( const idVec3 &newOrigin, int id = -1 );
 void SetAxis( const idMat3 &newAxis, int id = -1 );

 void Translate( const idVec3 &translation, int id = -1 );
 void Rotate( const idRotation &rotation, int id = -1 );

 const idVec3 & GetOrigin( int id = 0 ) const;
 const idMat3 & GetAxis( int id = 0 ) const;

 void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 );
 void SetAngularVelocity( const idVec3 &newAngularVelocity, int id = 0 );

 const idVec3 & GetLinearVelocity( int id = 0 ) const;
 const idVec3 & GetAngularVelocity( int id = 0 ) const;

 void DisableClip( void );
 void EnableClip( void );

 void UnlinkClip( void );
 void LinkClip( void );

 void SetMaster( idEntity *master, const bool orientated = true );

 const trace_t * GetBlockingInfo( void ) const;
 idEntity * GetBlockingEntity( void ) const;

 int GetLinearEndTime( void ) const;
 int GetAngularEndTime( void ) const;

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );

private:

 parametricPState_t current;
 parametricPState_t saved;


 bool isPusher;
 idClipModel * clipModel;
 int pushFlags;


 trace_t pushResults;
 bool isBlocked;


 bool hasMaster;
 bool isOrientated;

private:
 bool TestIfAtRest( void ) const;
 void Rest( void );
};
# 711 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_RigidBody.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_RigidBody.h"
extern const float RB_VELOCITY_MAX;
extern const int RB_VELOCITY_TOTAL_BITS;
extern const int RB_VELOCITY_EXPONENT_BITS;
extern const int RB_VELOCITY_MANTISSA_BITS;

typedef struct rididBodyIState_s {
 idVec3 position;
 idMat3 orientation;
 idVec3 linearMomentum;
 idVec3 angularMomentum;
} rigidBodyIState_t;

typedef struct rigidBodyPState_s {
 int atRest;
 float lastTimeStep;
 idVec3 localOrigin;
 idMat3 localAxis;
 idVec6 pushVelocity;
 idVec3 externalForce;
 idVec3 externalTorque;
 rigidBodyIState_t i;
} rigidBodyPState_t;

class idPhysics_RigidBody : public idPhysics_Base {

public:

 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_RigidBody> eventCallbacks[];

       idPhysics_RigidBody( void );
       ~idPhysics_RigidBody( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );


 void SetFriction( const float linear, const float angular, const float contact );
 void SetBouncyness( const float b );

 void DropToFloor( void );

 void NoContact( void );

 void EnableImpact( void );
 void DisableImpact( void );

public:
 void SetClipModel( idClipModel *model, float density, int id = 0, bool freeOld = true );
 idClipModel * GetClipModel( int id = 0 ) const;
 int GetNumClipModels( void ) const;

 void SetMass( float mass, int id = -1 );
 float GetMass( int id = -1 ) const;

 void SetContents( int contents, int id = -1 );
 int GetContents( int id = -1 ) const;

 const idBounds & GetBounds( int id = -1 ) const;
 const idBounds & GetAbsBounds( int id = -1 ) const;

 bool Evaluate( int timeStepMSec, int endTimeMSec );
 void UpdateTime( int endTimeMSec );
 int GetTime( void ) const;

 void GetImpactInfo( const int id, const idVec3 &point, impactInfo_t *info ) const;
 void ApplyImpulse( const int id, const idVec3 &point, const idVec3 &impulse );
 void AddForce( const int id, const idVec3 &point, const idVec3 &force );
 void Activate( void );
 void PutToRest( void );
 bool IsAtRest( void ) const;
 int GetRestStartTime( void ) const;
 bool IsPushable( void ) const;

 void SaveState( void );
 void RestoreState( void );

 void SetOrigin( const idVec3 &newOrigin, int id = -1 );
 void SetAxis( const idMat3 &newAxis, int id = -1 );

 void Translate( const idVec3 &translation, int id = -1 );
 void Rotate( const idRotation &rotation, int id = -1 );

 const idVec3 & GetOrigin( int id = 0 ) const;
 const idMat3 & GetAxis( int id = 0 ) const;

 void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 );
 void SetAngularVelocity( const idVec3 &newAngularVelocity, int id = 0 );

 const idVec3 & GetLinearVelocity( int id = 0 ) const;
 const idVec3 & GetAngularVelocity( int id = 0 ) const;

 void ClipTranslation( trace_t &results, const idVec3 &translation, const idClipModel *model ) const;
 void ClipRotation( trace_t &results, const idRotation &rotation, const idClipModel *model ) const;
 int ClipContents( const idClipModel *model ) const;

 void DisableClip( void );
 void EnableClip( void );

 void UnlinkClip( void );
 void LinkClip( void );

 bool EvaluateContacts( void );

 void SetPushed( int deltaTime );
 const idVec3 & GetPushedLinearVelocity( const int id = 0 ) const;
 const idVec3 & GetPushedAngularVelocity( const int id = 0 ) const;

 void SetMaster( idEntity *master, const bool orientated );

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );

private:

 rigidBodyPState_t current;
 rigidBodyPState_t saved;


 float linearFriction;
 float angularFriction;
 float contactFriction;
 float bouncyness;
 idClipModel * clipModel;


 float mass;
 float inverseMass;
 idVec3 centerOfMass;
 idMat3 inertiaTensor;
 idMat3 inverseInertiaTensor;

 idODE * integrator;
 bool dropToFloor;
 bool testSolid;
 bool noImpact;
 bool noContact;


 bool hasMaster;
 bool isOrientated;

private:
 friend void RigidBodyDerivatives( const float t, const void *clientData, const float *state, float *derivatives );
 void Integrate( const float deltaTime, rigidBodyPState_t &next );
 bool CheckForCollisions( const float deltaTime, rigidBodyPState_t &next, trace_t &collision );
 bool CollisionImpulse( const trace_t &collision, idVec3 &impulse );
 void ContactFriction( float deltaTime );
 void DropToFloorAndRest( void );
 bool TestIfAtRest( void ) const;
 void Rest( void );
 void DebugDraw( void );
};
# 712 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_AF.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_AF.h"
class idAFConstraint;
class idAFConstraint_Fixed;
class idAFConstraint_BallAndSocketJoint;
class idAFConstraint_BallAndSocketJointFriction;
class idAFConstraint_UniversalJoint;
class idAFConstraint_UniversalJointFriction;
class idAFConstraint_CylindricalJoint;
class idAFConstraint_Hinge;
class idAFConstraint_HingeFriction;
class idAFConstraint_HingeSteering;
class idAFConstraint_Slider;
class idAFConstraint_Line;
class idAFConstraint_Plane;
class idAFConstraint_Spring;
class idAFConstraint_Contact;
class idAFConstraint_ContactFriction;
class idAFConstraint_ConeLimit;
class idAFConstraint_PyramidLimit;
class idAFConstraint_Suspension;
class idAFBody;
class idAFTree;
class idPhysics_AF;

typedef enum {
 CONSTRAINT_INVALID,
 CONSTRAINT_FIXED,
 CONSTRAINT_BALLANDSOCKETJOINT,
 CONSTRAINT_UNIVERSALJOINT,
 CONSTRAINT_HINGE,
 CONSTRAINT_HINGESTEERING,
 CONSTRAINT_SLIDER,
 CONSTRAINT_CYLINDRICALJOINT,
 CONSTRAINT_LINE,
 CONSTRAINT_PLANE,
 CONSTRAINT_SPRING,
 CONSTRAINT_CONTACT,
 CONSTRAINT_FRICTION,
 CONSTRAINT_CONELIMIT,
 CONSTRAINT_PYRAMIDLIMIT,
 CONSTRAINT_SUSPENSION
} constraintType_t;
# 93 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_AF.h"
class idAFConstraint {

 friend class idPhysics_AF;
 friend class idAFTree;

public:
       idAFConstraint( void );
 virtual ~idAFConstraint( void );
 constraintType_t GetType( void ) const { return type; }
 const idStr & GetName( void ) const { return name; }
 idAFBody * GetBody1( void ) const { return body1; }
 idAFBody * GetBody2( void ) const { return body2; }
 void SetPhysics( idPhysics_AF *p ) { physics = p; }
 const idVecX & GetMultiplier( void );
 virtual void SetBody1( idAFBody *body );
 virtual void SetBody2( idAFBody *body );
 virtual void DebugDraw( void );
 virtual void GetForce( idAFBody *body, idVec6 &force );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void GetCenter( idVec3 &center );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 constraintType_t type;
 idStr name;
 idAFBody * body1;
 idAFBody * body2;
 idPhysics_AF * physics;


 idMatX J1, J2;
 idVecX c1, c2;
 idVecX lo, hi, e;
 idAFConstraint * boxConstraint;
 int boxIndex[6];


 idMatX invI;
 idMatX J;
 idVecX s;
 idVecX lm;
 int firstIndex;

 struct constraintFlags_s {
  bool allowPrimary : 1;
  bool frameConstraint : 1;
  bool noCollision : 1;
  bool isPrimary : 1;
  bool isZero : 1;
 } fl;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
 void InitSize( int size );
};



class idAFConstraint_Fixed : public idAFConstraint {

public:
       idAFConstraint_Fixed( const idStr &name, idAFBody *body1, idAFBody *body2 );
 void SetRelativeOrigin( const idVec3 &origin ) { this->offset = origin; }
 void SetRelativeAxis( const idMat3 &axis ) { this->relAxis = axis; }
 virtual void SetBody1( idAFBody *body );
 virtual void SetBody2( idAFBody *body );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void GetCenter( idVec3 &center );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 offset;
 idMat3 relAxis;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
 void InitOffset( void );
};



class idAFConstraint_BallAndSocketJoint : public idAFConstraint {

public:
       idAFConstraint_BallAndSocketJoint( const idStr &name, idAFBody *body1, idAFBody *body2 );
       ~idAFConstraint_BallAndSocketJoint( void );
 void SetAnchor( const idVec3 &worldPosition );
 idVec3 GetAnchor( void ) const;
 void SetNoLimit( void );
 void SetConeLimit( const idVec3 &coneAxis, const float coneAngle, const idVec3 &body1Axis );
 void SetPyramidLimit( const idVec3 &pyramidAxis, const idVec3 &baseAxis,
           const float angle1, const float angle2, const idVec3 &body1Axis );
 void SetLimitEpsilon( const float e );
 void SetFriction( const float f ) { friction = f; }
 float GetFriction( void ) const;
 virtual void DebugDraw( void );
 virtual void GetForce( idAFBody *body, idVec6 &force );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void GetCenter( idVec3 &center );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 anchor1;
 idVec3 anchor2;
 float friction;
 idAFConstraint_ConeLimit *coneLimit;
 idAFConstraint_PyramidLimit *pyramidLimit;
 idAFConstraint_BallAndSocketJointFriction *fc;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_BallAndSocketJointFriction : public idAFConstraint {

public:
       idAFConstraint_BallAndSocketJointFriction( void );
 void Setup( idAFConstraint_BallAndSocketJoint *cc );
 bool Add( idPhysics_AF *phys, float invTimeStep );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );

protected:
 idAFConstraint_BallAndSocketJoint *joint;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};



class idAFConstraint_UniversalJoint : public idAFConstraint {

public:
       idAFConstraint_UniversalJoint( const idStr &name, idAFBody *body1, idAFBody *body2 );
       ~idAFConstraint_UniversalJoint( void );
 void SetAnchor( const idVec3 &worldPosition );
 idVec3 GetAnchor( void ) const;
 void SetShafts( const idVec3 &cardanShaft1, const idVec3 &cardanShaft2 );
 void GetShafts( idVec3 &cardanShaft1, idVec3 &cardanShaft2 ) { cardanShaft1 = shaft1; cardanShaft2 = shaft2; }
 void SetNoLimit( void );
 void SetConeLimit( const idVec3 &coneAxis, const float coneAngle );
 void SetPyramidLimit( const idVec3 &pyramidAxis, const idVec3 &baseAxis,
           const float angle1, const float angle2 );
 void SetLimitEpsilon( const float e );
 void SetFriction( const float f ) { friction = f; }
 float GetFriction( void ) const;
 virtual void DebugDraw( void );
 virtual void GetForce( idAFBody *body, idVec6 &force );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void GetCenter( idVec3 &center );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 anchor1;
 idVec3 anchor2;
 idVec3 shaft1;
 idVec3 shaft2;
 idVec3 axis1;
 idVec3 axis2;
 float friction;
 idAFConstraint_ConeLimit *coneLimit;
 idAFConstraint_PyramidLimit *pyramidLimit;
 idAFConstraint_UniversalJointFriction *fc;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_UniversalJointFriction : public idAFConstraint {

public:
       idAFConstraint_UniversalJointFriction( void );
 void Setup( idAFConstraint_UniversalJoint *cc );
 bool Add( idPhysics_AF *phys, float invTimeStep );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );

protected:
 idAFConstraint_UniversalJoint *joint;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};



class idAFConstraint_CylindricalJoint : public idAFConstraint {

public:
       idAFConstraint_CylindricalJoint( const idStr &name, idAFBody *body1, idAFBody *body2 );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );

protected:

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};



class idAFConstraint_Hinge : public idAFConstraint {

public:
       idAFConstraint_Hinge( const idStr &name, idAFBody *body1, idAFBody *body2 );
       ~idAFConstraint_Hinge( void );
 void SetAnchor( const idVec3 &worldPosition );
 idVec3 GetAnchor( void ) const;
 void SetAxis( const idVec3 &axis );
 void GetAxis( idVec3 &a1, idVec3 &a2 ) const { a1 = axis1; a2 = axis2; }
 idVec3 GetAxis( void ) const;
 void SetNoLimit( void );
 void SetLimit( const idVec3 &axis, const float angle, const idVec3 &body1Axis );
 void SetLimitEpsilon( const float e );
 float GetAngle( void ) const;
 void SetSteerAngle( const float degrees );
 void SetSteerSpeed( const float speed );
 void SetFriction( const float f ) { friction = f; }
 float GetFriction( void ) const;
 virtual void DebugDraw( void );
 virtual void GetForce( idAFBody *body, idVec6 &force );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void GetCenter( idVec3 &center );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 anchor1;
 idVec3 anchor2;
 idVec3 axis1;
 idVec3 axis2;
 idMat3 initialAxis;
 float friction;
 idAFConstraint_ConeLimit *coneLimit;
 idAFConstraint_HingeSteering *steering;
 idAFConstraint_HingeFriction *fc;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_HingeFriction : public idAFConstraint {

public:
       idAFConstraint_HingeFriction( void );
 void Setup( idAFConstraint_Hinge *cc );
 bool Add( idPhysics_AF *phys, float invTimeStep );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );

protected:
 idAFConstraint_Hinge * hinge;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_HingeSteering : public idAFConstraint {

public:
       idAFConstraint_HingeSteering( void );
 void Setup( idAFConstraint_Hinge *cc );
 void SetSteerAngle( const float degrees ) { steerAngle = degrees; }
 void SetSteerSpeed( const float speed ) { steerSpeed = speed; }
 void SetEpsilon( const float e ) { epsilon = e; }
 bool Add( idPhysics_AF *phys, float invTimeStep );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );

 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idAFConstraint_Hinge * hinge;
 float steerAngle;
 float steerSpeed;
 float epsilon;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};



class idAFConstraint_Slider : public idAFConstraint {

public:
       idAFConstraint_Slider( const idStr &name, idAFBody *body1, idAFBody *body2 );
 void SetAxis( const idVec3 &ax );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void GetCenter( idVec3 &center );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 axis;
 idVec3 offset;
 idMat3 relAxis;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};



class idAFConstraint_Line : public idAFConstraint {

public:
       idAFConstraint_Line( const idStr &name, idAFBody *body1, idAFBody *body2 );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );

protected:

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};



class idAFConstraint_Plane : public idAFConstraint {

public:
       idAFConstraint_Plane( const idStr &name, idAFBody *body1, idAFBody *body2 );
 void SetPlane( const idVec3 &normal, const idVec3 &anchor );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 anchor1;
 idVec3 anchor2;
 idVec3 planeNormal;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};



class idAFConstraint_Spring : public idAFConstraint {

public:
       idAFConstraint_Spring( const idStr &name, idAFBody *body1, idAFBody *body2 );
 void SetAnchor( const idVec3 &worldAnchor1, const idVec3 &worldAnchor2 );
 void SetSpring( const float stretch, const float compress, const float damping, const float restLength );
 void SetLimit( const float minLength, const float maxLength );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void GetCenter( idVec3 &center );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 anchor1;
 idVec3 anchor2;
 float kstretch;
 float kcompress;
 float damping;
 float restLength;
 float minLength;
 float maxLength;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_Contact : public idAFConstraint {

public:
       idAFConstraint_Contact( void );
       ~idAFConstraint_Contact( void );
 void Setup( idAFBody *b1, idAFBody *b2, contactInfo_t &c );
 const contactInfo_t & GetContact( void ) const { return contact; }
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void GetCenter( idVec3 &center );

protected:
 contactInfo_t contact;
 idAFConstraint_ContactFriction *fc;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_ContactFriction : public idAFConstraint {

public:
       idAFConstraint_ContactFriction( void );
 void Setup( idAFConstraint_Contact *cc );
 bool Add( idPhysics_AF *phys, float invTimeStep );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );

protected:
 idAFConstraint_Contact *cc;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_ConeLimit : public idAFConstraint {

public:
       idAFConstraint_ConeLimit( void );
 void Setup( idAFBody *b1, idAFBody *b2, const idVec3 &coneAnchor, const idVec3 &coneAxis,
         const float coneAngle, const idVec3 &body1Axis );
 void SetAnchor( const idVec3 &coneAnchor );
 void SetBody1Axis( const idVec3 &body1Axis );
 void SetEpsilon( const float e ) { epsilon = e; }
 bool Add( idPhysics_AF *phys, float invTimeStep );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 coneAnchor;
 idVec3 coneAxis;
 idVec3 body1Axis;
 float cosAngle;
 float sinHalfAngle;
 float cosHalfAngle;
 float epsilon;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_PyramidLimit : public idAFConstraint {

public:
       idAFConstraint_PyramidLimit( void );
 void Setup( idAFBody *b1, idAFBody *b2, const idVec3 &pyramidAnchor,
         const idVec3 &pyramidAxis, const idVec3 &baseAxis,
         const float pyramidAngle1, const float pyramidAngle2, const idVec3 &body1Axis );
 void SetAnchor( const idVec3 &pyramidAxis );
 void SetBody1Axis( const idVec3 &body1Axis );
 void SetEpsilon( const float e ) { epsilon = e; }
 bool Add( idPhysics_AF *phys, float invTimeStep );
 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );
 virtual void Save( idSaveGame *saveFile ) const;
 virtual void Restore( idRestoreGame *saveFile );

protected:
 idVec3 pyramidAnchor;
 idMat3 pyramidBasis;
 idVec3 body1Axis;
 float cosAngle[2];
 float sinHalfAngle[2];
 float cosHalfAngle[2];
 float epsilon;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};


class idAFConstraint_Suspension : public idAFConstraint {

public:
       idAFConstraint_Suspension( void );

 void Setup( const char *name, idAFBody *body, const idVec3 &origin, const idMat3 &axis, idClipModel *clipModel );
 void SetSuspension( const float up, const float down, const float k, const float d, const float f );

 void SetSteerAngle( const float degrees ) { steerAngle = degrees; }
 void EnableMotor( const bool enable ) { motorEnabled = enable; }
 void SetMotorForce( const float force ) { motorForce = force; }
 void SetMotorVelocity( const float vel ) { motorVelocity = vel; }
 void SetEpsilon( const float e ) { epsilon = e; }
 const idVec3 GetWheelOrigin( void ) const;

 virtual void DebugDraw( void );
 virtual void Translate( const idVec3 &translation );
 virtual void Rotate( const idRotation &rotation );

protected:
 idVec3 localOrigin;
 idMat3 localAxis;
 float suspensionUp;
 float suspensionDown;
 float suspensionKCompress;
 float suspensionDamping;
 float steerAngle;
 float friction;
 bool motorEnabled;
 float motorForce;
 float motorVelocity;
 idClipModel * wheelModel;
 idVec3 wheelOffset;
 trace_t trace;
 float epsilon;

protected:
 virtual void Evaluate( float invTimeStep );
 virtual void ApplyFriction( float invTimeStep );
};
# 649 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_AF.h"
typedef struct AFBodyPState_s {
 idVec3 worldOrigin;
 idMat3 worldAxis;
 idVec6 spatialVelocity;
 idVec6 externalForce;
} AFBodyPState_t;


class idAFBody {

 friend class idPhysics_AF;
 friend class idAFTree;

public:
       idAFBody( void );
       idAFBody( const idStr &name, idClipModel *clipModel, float density );
       ~idAFBody( void );

 void Init( void );
 const idStr & GetName( void ) const { return name; }
 const idVec3 & GetWorldOrigin( void ) const { return current->worldOrigin; }
 const idMat3 & GetWorldAxis( void ) const { return current->worldAxis; }
 const idVec3 & GetLinearVelocity( void ) const { return current->spatialVelocity.SubVec3(0); }
 const idVec3 & GetAngularVelocity( void ) const { return current->spatialVelocity.SubVec3(1); }
 idVec3 GetPointVelocity( const idVec3 &point ) const;
 const idVec3 & GetCenterOfMass( void ) const { return centerOfMass; }
 void SetClipModel( idClipModel *clipModel );
 idClipModel * GetClipModel( void ) const { return clipModel; }
 void SetClipMask( const int mask ) { clipMask = mask; fl.clipMaskSet = true; }
 int GetClipMask( void ) const { return clipMask; }
 void SetSelfCollision( const bool enable ) { fl.selfCollision = enable; }
 void SetWorldOrigin( const idVec3 &origin ) { current->worldOrigin = origin; }
 void SetWorldAxis( const idMat3 &axis ) { current->worldAxis = axis; }
 void SetLinearVelocity( const idVec3 &linear ) const { current->spatialVelocity.SubVec3(0) = linear; }
 void SetAngularVelocity( const idVec3 &angular ) const { current->spatialVelocity.SubVec3(1) = angular; }
 void SetFriction( float linear, float angular, float contact );
 float GetContactFriction( void ) const { return contactFriction; }
 void SetBouncyness( float bounce );
 float GetBouncyness( void ) const { return bouncyness; }
 void SetDensity( float density, const idMat3 &inertiaScale = mat3_identity );
 float GetInverseMass( void ) const { return invMass; }
 idMat3 GetInverseWorldInertia( void ) const { return current->worldAxis.Transpose() * inverseInertiaTensor * current->worldAxis; }

 void SetFrictionDirection( const idVec3 &dir );
 bool GetFrictionDirection( idVec3 &dir ) const;

 void SetContactMotorDirection( const idVec3 &dir );
 bool GetContactMotorDirection( idVec3 &dir ) const;
 void SetContactMotorVelocity( float vel ) { contactMotorVelocity = vel; }
 float GetContactMotorVelocity( void ) const { return contactMotorVelocity; }
 void SetContactMotorForce( float force ) { contactMotorForce = force; }
 float GetContactMotorForce( void ) const { return contactMotorForce; }

 void AddForce( const idVec3 &point, const idVec3 &force );
 void InverseWorldSpatialInertiaMultiply( idVecX &dst, const float *v ) const;
 idVec6 & GetResponseForce( int index ) { return reinterpret_cast<idVec6 &>(response[ index * 8 ]); }

 void Save( idSaveGame *saveFile );
 void Restore( idRestoreGame *saveFile );

private:

 idStr name;
 idAFBody * parent;
 idList<idAFBody *> children;
 idClipModel * clipModel;
 idAFConstraint * primaryConstraint;
 idList<idAFConstraint *>constraints;
 idAFTree * tree;
 float linearFriction;
 float angularFriction;
 float contactFriction;
 float bouncyness;
 int clipMask;
 idVec3 frictionDir;
 idVec3 contactMotorDir;
 float contactMotorVelocity;
 float contactMotorForce;


 float mass;
 float invMass;
 idVec3 centerOfMass;
 idMat3 inertiaTensor;
 idMat3 inverseInertiaTensor;


 AFBodyPState_t state[2];
 AFBodyPState_t * current;
 AFBodyPState_t * next;
 AFBodyPState_t saved;
 idVec3 atRestOrigin;
 idMat3 atRestAxis;


 idMatX inverseWorldSpatialInertia;
 idMatX I, invI;
 idMatX J;
 idVecX s;
 idVecX totalForce;
 idVecX auxForce;
 idVecX acceleration;
 float * response;
 int * responseIndex;
 int numResponses;
 int maxAuxiliaryIndex;
 int maxSubTreeAuxiliaryIndex;

 struct bodyFlags_s {
  bool clipMaskSet : 1;
  bool selfCollision : 1;
  bool spatialInertiaSparse: 1;
  bool useFrictionDir : 1;
  bool useContactMotorDir : 1;
  bool isZero : 1;
 } fl;
};
# 774 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_AF.h"
class idAFTree {
 friend class idPhysics_AF;

public:
 void Factor( void ) const;
 void Solve( int auxiliaryIndex = 0 ) const;
 void Response( const idAFConstraint *constraint, int row, int auxiliaryIndex ) const;
 void CalculateForces( float timeStep ) const;
 void SetMaxSubTreeAuxiliaryIndex( void );
 void SortBodies( void );
 void SortBodies_r( idList<idAFBody*>&sortedList, idAFBody *body );
 void DebugDraw( const idVec4 &color ) const;

private:
 idList<idAFBody *> sortedBodies;
};
# 798 "d:/Data/Nintendo/DoomGX/src/game/physics/Physics_AF.h"
typedef struct AFPState_s {
 int atRest;
 float noMoveTime;
 float activateTime;
 float lastTimeStep;
 idVec6 pushVelocity;
} AFPState_t;

typedef struct AFCollision_s {
 trace_t trace;
 idAFBody * body;
} AFCollision_t;


class idPhysics_AF : public idPhysics_Base {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhysics_AF> eventCallbacks[];

       idPhysics_AF( void );
       ~idPhysics_AF( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );


 int AddBody( idAFBody *body );
 void AddConstraint( idAFConstraint *constraint );
 void AddFrameConstraint( idAFConstraint *constraint );

 void ForceBodyId( idAFBody *body, int newId );

 int GetBodyId( idAFBody *body ) const;
 int GetBodyId( const char *bodyName ) const;
 int GetConstraintId( idAFConstraint *constraint ) const;
 int GetConstraintId( const char *constraintName ) const;

 int GetNumBodies( void ) const;
 int GetNumConstraints( void ) const;

 idAFBody * GetBody( const char *bodyName ) const;
 idAFBody * GetBody( const int id ) const;
 idAFBody * GetMasterBody( void ) const { return masterBody; }
 idAFConstraint * GetConstraint( const char *constraintName ) const;
 idAFConstraint * GetConstraint( const int id ) const;

 void DeleteBody( const char *bodyName );
 void DeleteBody( const int id );
 void DeleteConstraint( const char *constraintName );
 void DeleteConstraint( const int id );

 int GetBodyContactConstraints( const int id, idAFConstraint_Contact *contacts[], int maxContacts ) const;

 void SetDefaultFriction( float linear, float angular, float contact );

 void SetSuspendSpeed( const idVec2 &velocity, const idVec2 &acceleration );

 void SetSuspendTolerance( const float noMoveTime, const float translationTolerance, const float rotationTolerance );

 void SetSuspendTime( const float minTime, const float maxTime );

 void SetTimeScale( const float ts ) { timeScale = ts; }

 void SetTimeScaleRamp( const float start, const float end );

 void SetJointFrictionScale( const float scale ) { jointFrictionScale = scale; }

 void SetJointFrictionDent( const float dent, const float start, const float end );

 float GetJointFrictionScale( void ) const;

 void SetContactFrictionScale( const float scale ) { contactFrictionScale = scale; }

 void SetContactFrictionDent( const float dent, const float start, const float end );

 float GetContactFrictionScale( void ) const;

 void SetCollision( const bool enable ) { enableCollision = enable; }

 void SetSelfCollision( const bool enable ) { selfCollision = enable; }

 void SetComeToRest( bool enable ) { comeToRest = enable; }

 void SetChanged( void ) { changedAF = true; }

 void EnableImpact( void );
 void DisableImpact( void );

 void LockWorldConstraints( const bool lock ) { worldConstraintsLocked = lock; }

 void SetForcePushable( const bool enable ) { forcePushable = enable; }

 void UpdateClipModels( void );

public:
 void SetClipModel( idClipModel *model, float density, int id = 0, bool freeOld = true );
 idClipModel * GetClipModel( int id = 0 ) const;
 int GetNumClipModels( void ) const;

 void SetMass( float mass, int id = -1 );
 float GetMass( int id = -1 ) const;

 void SetContents( int contents, int id = -1 );
 int GetContents( int id = -1 ) const;

 const idBounds & GetBounds( int id = -1 ) const;
 const idBounds & GetAbsBounds( int id = -1 ) const;

 bool Evaluate( int timeStepMSec, int endTimeMSec );
 void UpdateTime( int endTimeMSec );
 int GetTime( void ) const;

 void GetImpactInfo( const int id, const idVec3 &point, impactInfo_t *info ) const;
 void ApplyImpulse( const int id, const idVec3 &point, const idVec3 &impulse );
 void AddForce( const int id, const idVec3 &point, const idVec3 &force );
 bool IsAtRest( void ) const;
 int GetRestStartTime( void ) const;
 void Activate( void );
 void PutToRest( void );
 bool IsPushable( void ) const;

 void SaveState( void );
 void RestoreState( void );

 void SetOrigin( const idVec3 &newOrigin, int id = -1 );
 void SetAxis( const idMat3 &newAxis, int id = -1 );

 void Translate( const idVec3 &translation, int id = -1 );
 void Rotate( const idRotation &rotation, int id = -1 );

 const idVec3 & GetOrigin( int id = 0 ) const;
 const idMat3 & GetAxis( int id = 0 ) const;

 void SetLinearVelocity( const idVec3 &newLinearVelocity, int id = 0 );
 void SetAngularVelocity( const idVec3 &newAngularVelocity, int id = 0 );

 const idVec3 & GetLinearVelocity( int id = 0 ) const;
 const idVec3 & GetAngularVelocity( int id = 0 ) const;

 void ClipTranslation( trace_t &results, const idVec3 &translation, const idClipModel *model ) const;
 void ClipRotation( trace_t &results, const idRotation &rotation, const idClipModel *model ) const;
 int ClipContents( const idClipModel *model ) const;

 void DisableClip( void );
 void EnableClip( void );

 void UnlinkClip( void );
 void LinkClip( void );

 bool EvaluateContacts( void );

 void SetPushed( int deltaTime );
 const idVec3 & GetPushedLinearVelocity( const int id = 0 ) const;
 const idVec3 & GetPushedAngularVelocity( const int id = 0 ) const;

 void SetMaster( idEntity *master, const bool orientated = true );

 void WriteToSnapshot( idBitMsgDelta &msg ) const;
 void ReadFromSnapshot( const idBitMsgDelta &msg );

private:

 idList<idAFTree *> trees;
 idList<idAFBody *> bodies;
 idList<idAFConstraint *>constraints;
 idList<idAFConstraint *>primaryConstraints;
 idList<idAFConstraint *>auxiliaryConstraints;
 idList<idAFConstraint *>frameConstraints;
 idList<idAFConstraint_Contact *>contactConstraints;
 idList<int> contactBodies;
 idList<AFCollision_t> collisions;
 bool changedAF;


 float linearFriction;
 float angularFriction;
 float contactFriction;
 float bouncyness;
 float totalMass;
 float forceTotalMass;

 idVec2 suspendVelocity;
 idVec2 suspendAcceleration;
 float noMoveTime;
 float noMoveTranslation;
 float noMoveRotation;
 float minMoveTime;
 float maxMoveTime;
 float impulseThreshold;

 float timeScale;
 float timeScaleRampStart;
 float timeScaleRampEnd;

 float jointFrictionScale;
 float jointFrictionDent;
 float jointFrictionDentStart;
 float jointFrictionDentEnd;
 float jointFrictionDentScale;

 float contactFrictionScale;
 float contactFrictionDent;
 float contactFrictionDentStart;
 float contactFrictionDentEnd;
 float contactFrictionDentScale;

 bool enableCollision;
 bool selfCollision;
 bool comeToRest;
 bool linearTime;
 bool noImpact;
 bool worldConstraintsLocked;
 bool forcePushable;


 AFPState_t current;
 AFPState_t saved;

 idAFBody * masterBody;
 idLCP * lcp;

private:
 void BuildTrees( void );
 bool IsClosedLoop( const idAFBody *body1, const idAFBody *body2 ) const;
 void PrimaryFactor( void );
 void EvaluateBodies( float timeStep );
 void EvaluateConstraints( float timeStep );
 void AddFrameConstraints( void );
 void RemoveFrameConstraints( void );
 void ApplyFriction( float timeStep, float endTimeMSec );
 void PrimaryForces( float timeStep );
 void AuxiliaryForces( float timeStep );
 void VerifyContactConstraints( void );
 void SetupContactConstraints( void );
 void ApplyContactForces( void );
 void Evolve( float timeStep );
 idEntity * SetupCollisionForBody( idAFBody *body ) const;
 bool CollisionImpulse( float timeStep, idAFBody *body, trace_t &collision );
 bool ApplyCollisions( float timeStep );
 void CheckForCollisions( float timeStep );
 void ClearExternalForce( void );
 void AddGravity( void );
 void SwapStates( void );
 bool TestIfAtRest( float timeStep );
 void Rest( void );
 void AddPushVelocity( const idVec6 &pushVelocity );
 void DebugDraw( void );
};
# 713 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/SmokeParticles.h" 1
# 54 "d:/Data/Nintendo/DoomGX/src/game/SmokeParticles.h"
typedef struct singleSmoke_s {
 struct singleSmoke_s * next;
 int privateStartTime;
 int index;
 idRandom random;
 idVec3 origin;
 idMat3 axis;
} singleSmoke_t;

typedef struct {
 const idParticleStage * stage;
 singleSmoke_t * smokes;
} activeSmokeStage_t;


class idSmokeParticles {
public:
        idSmokeParticles( void );


 void Init( void );
 void Shutdown( void );


 bool EmitSmoke( const idDeclParticle *smoke, const int startTime, const float diversity,
           const idVec3 &origin, const idMat3 &axis );


 void FreeSmokes( void );

private:
 bool initialized;

 renderEntity_t renderEntity;
 int renderEntityHandle;

 static const int MAX_SMOKE_PARTICLES = 2500;
 singleSmoke_t smokes[MAX_SMOKE_PARTICLES];

 idList<activeSmokeStage_t> activeStages;
 singleSmoke_t * freeSmokes;
 int numActiveSmokes;
 int currentParticleTime;

 bool UpdateRenderEntity( renderEntity_s *renderEntity, const renderView_t *renderView );
 static bool ModelCallback( renderEntity_s *renderEntity, const renderView_t *renderView );
};
# 715 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/Entity.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Entity.h"
static const int DELAY_DORMANT_TIME = 3000;

extern const idEventDef EV_PostSpawn;
extern const idEventDef EV_FindTargets;
extern const idEventDef EV_Touch;
extern const idEventDef EV_Use;
extern const idEventDef EV_Activate;
extern const idEventDef EV_ActivateTargets;
extern const idEventDef EV_Hide;
extern const idEventDef EV_Show;
extern const idEventDef EV_GetShaderParm;
extern const idEventDef EV_SetShaderParm;
extern const idEventDef EV_SetOwner;
extern const idEventDef EV_GetAngles;
extern const idEventDef EV_SetAngles;
extern const idEventDef EV_SetLinearVelocity;
extern const idEventDef EV_SetAngularVelocity;
extern const idEventDef EV_SetSkin;
extern const idEventDef EV_StartSoundShader;
extern const idEventDef EV_StopSound;
extern const idEventDef EV_CacheSoundShader;


enum {
 TH_ALL = -1,
 TH_THINK = 1,
 TH_PHYSICS = 2,
 TH_ANIMATE = 4,
 TH_UPDATEVISUALS = 8,
 TH_UPDATEPARTICLES = 16
};





typedef enum {
 SIG_TOUCH,
 SIG_USE,
 SIG_TRIGGER,
 SIG_REMOVED,
 SIG_DAMAGE,
 SIG_BLOCKED,

 SIG_MOVER_POS1,
 SIG_MOVER_POS2,
 SIG_MOVER_1TO2,
 SIG_MOVER_2TO1,

 NUM_SIGNALS
} signalNum_t;





struct signal_t {
 int threadnum;
 const function_t *function;
};

class signalList_t {
public:
 idList<signal_t> signal[ NUM_SIGNALS ];
};


class idEntity : public idClass {
public:
 static const int MAX_PVS_AREAS = 4;

 int entityNumber;
 int entityDefNumber;

 idLinkList<idEntity> spawnNode;
 idLinkList<idEntity> activeNode;

 idLinkList<idEntity> snapshotNode;
 int snapshotSequence;
 int snapshotBits;

 idStr name;
 idDict spawnArgs;
 idScriptObject scriptObject;

 int thinkFlags;
 int dormantStart;
 bool cinematic;

 renderView_t * renderView;
 idEntity * cameraTarget;

 idList< idEntityPtr<idEntity> > targets;

 int health;

 struct entityFlags_s {
  bool notarget :1;
  bool noknockback :1;
  bool takedamage :1;
  bool hidden :1;
  bool bindOrientated :1;
  bool solidForTeam :1;
  bool forcePhysicsUpdate :1;
  bool selected :1;
  bool neverDormant :1;
  bool isDormant :1;
  bool hasAwakened :1;
  bool networkSync :1;
 } fl;

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idEntity> eventCallbacks[];

       idEntity();
       ~idEntity();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 const char * GetEntityDefName( void ) const;
 void SetName( const char *name );
 const char * GetName( void ) const;
 virtual void UpdateChangeableSpawnArgs( const idDict *source );



 virtual renderView_t * GetRenderView();


 virtual void Think( void );
 bool CheckDormant( void );
 virtual void DormantBegin( void );
 virtual void DormantEnd( void );
 bool IsActive( void ) const;
 void BecomeActive( int flags );
 void BecomeInactive( int flags );
 void UpdatePVSAreas( const idVec3 &pos );


 virtual void Present( void );
 virtual renderEntity_t *GetRenderEntity( void );
 virtual int GetModelDefHandle( void );
 virtual void SetModel( const char *modelname );
 void SetSkin( const idDeclSkin *skin );
 const idDeclSkin * GetSkin( void ) const;
 void SetShaderParm( int parmnum, float value );
 virtual void SetColor( float red, float green, float blue );
 virtual void SetColor( const idVec3 &color );
 virtual void GetColor( idVec3 &out ) const;
 virtual void SetColor( const idVec4 &color );
 virtual void GetColor( idVec4 &out ) const;
 virtual void FreeModelDef( void );
 virtual void FreeLightDef( void );
 virtual void Hide( void );
 virtual void Show( void );
 bool IsHidden( void ) const;
 void UpdateVisuals( void );
 void UpdateModel( void );
 void UpdateModelTransform( void );
 virtual void ProjectOverlay( const idVec3 &origin, const idVec3 &dir, float size, const char *material );
 int GetNumPVSAreas( void );
 const int * GetPVSAreas( void );
 void ClearPVSAreas( void );
 bool PhysicsTeamInPVS( pvsHandle_t pvsHandle );


 virtual bool UpdateAnimationControllers( void );
 bool UpdateRenderEntity( renderEntity_s *renderEntity, const renderView_t *renderView );
 static bool ModelCallback( renderEntity_s *renderEntity, const renderView_t *renderView );
 virtual idAnimator * GetAnimator( void );


 virtual bool CanPlayChatterSounds( void ) const;
 bool StartSound( const char *soundName, const s_channelType channel, int soundShaderFlags, bool broadcast, int *length );
 bool StartSoundShader( const idSoundShader *shader, const s_channelType channel, int soundShaderFlags, bool broadcast, int *length );
 void StopSound( const s_channelType channel, bool broadcast );
 void SetSoundVolume( float volume );
 void UpdateSound( void );
 int GetListenerId( void ) const;
 idSoundEmitter * GetSoundEmitter( void ) const;
 void FreeSoundEmitter( bool immediate );


 virtual void PreBind( void );
 virtual void PostBind( void );
 virtual void PreUnbind( void );
 virtual void PostUnbind( void );
 void JoinTeam( idEntity *teammember );
 void Bind( idEntity *master, bool orientated );
 void BindToJoint( idEntity *master, const char *jointname, bool orientated );
 void BindToJoint( idEntity *master, jointHandle_t jointnum, bool orientated );
 void BindToBody( idEntity *master, int bodyId, bool orientated );
 void Unbind( void );
 bool IsBound( void ) const;
 bool IsBoundTo( idEntity *master ) const;
 idEntity * GetBindMaster( void ) const;
 jointHandle_t GetBindJoint( void ) const;
 int GetBindBody( void ) const;
 idEntity * GetTeamMaster( void ) const;
 idEntity * GetNextTeamEntity( void ) const;
 void ConvertLocalToWorldTransform( idVec3 &offset, idMat3 &axis );
 idVec3 GetLocalVector( const idVec3 &vec ) const;
 idVec3 GetLocalCoordinates( const idVec3 &vec ) const;
 idVec3 GetWorldVector( const idVec3 &vec ) const;
 idVec3 GetWorldCoordinates( const idVec3 &vec ) const;
 bool GetMasterPosition( idVec3 &masterOrigin, idMat3 &masterAxis ) const;
 void GetWorldVelocities( idVec3 &linearVelocity, idVec3 &angularVelocity ) const;



 void SetPhysics( idPhysics *phys );

 idPhysics * GetPhysics( void ) const;

 void RestorePhysics( idPhysics *phys );

 bool RunPhysics( void );

 void SetOrigin( const idVec3 &org );

 void SetAxis( const idMat3 &axis );

 void SetAngles( const idAngles &ang );

 bool GetFloorPos( float max_dist, idVec3 &floorpos ) const;

 virtual bool GetPhysicsToVisualTransform( idVec3 &origin, idMat3 &axis );

 virtual bool GetPhysicsToSoundTransform( idVec3 &origin, idMat3 &axis );

 virtual bool Collide( const trace_t &collision, const idVec3 &velocity );

 virtual void GetImpactInfo( idEntity *ent, int id, const idVec3 &point, impactInfo_t *info );

 virtual void ApplyImpulse( idEntity *ent, int id, const idVec3 &point, const idVec3 &impulse );

 virtual void AddForce( idEntity *ent, int id, const idVec3 &point, const idVec3 &force );

 virtual void ActivatePhysics( idEntity *ent );

 virtual bool IsAtRest( void ) const;

 virtual int GetRestStartTime( void ) const;

 virtual void AddContactEntity( idEntity *ent );

 virtual void RemoveContactEntity( idEntity *ent );



 virtual bool CanDamage( const idVec3 &origin, idVec3 &damagePoint ) const;

 virtual void Damage( idEntity *inflictor, idEntity *attacker, const idVec3 &dir, const char *damageDefName, const float damageScale, const int location );

 virtual void AddDamageEffect( const trace_t &collision, const idVec3 &velocity, const char *damageDefName );

 virtual void DamageFeedback( idEntity *victim, idEntity *inflictor, int &damage );

 virtual bool Pain( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );

 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );


 virtual bool ShouldConstructScriptObjectAtSpawn( void ) const;
 virtual idThread * ConstructScriptObject( void );
 virtual void DeconstructScriptObject( void );
 void SetSignal( signalNum_t signalnum, idThread *thread, const function_t *function );
 void ClearSignal( idThread *thread, signalNum_t signalnum );
 void ClearSignalThread( signalNum_t signalnum, idThread *thread );
 bool HasSignal( signalNum_t signalnum ) const;
 void Signal( signalNum_t signalnum );
 void SignalEvent( idThread *thread, signalNum_t signalnum );


 void TriggerGuis( void );
 bool HandleGuiCommands( idEntity *entityGui, const char *cmds );
 virtual bool HandleSingleGuiCommand( idEntity *entityGui, idLexer *src );


 void FindTargets( void );
 void RemoveNullTargets( void );
 void ActivateTargets( idEntity *activator ) const;


 virtual void Teleport( const idVec3 &origin, const idAngles &angles, idEntity *destination );
 bool TouchTriggers( void ) const;
 idCurve_Spline<idVec3> *GetSpline( void ) const;
 virtual void ShowEditingDialog( void );

 enum {
  EVENT_STARTSOUNDSHADER,
  EVENT_STOPSOUNDSHADER,
  EVENT_MAXEVENTS
 };

 virtual void ClientPredictionThink( void );
 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );
 virtual bool ServerReceiveEvent( int event, int time, const idBitMsg &msg );
 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );

 void WriteBindToSnapshot( idBitMsgDelta &msg ) const;
 void ReadBindFromSnapshot( const idBitMsgDelta &msg );
 void WriteColorToSnapshot( idBitMsgDelta &msg ) const;
 void ReadColorFromSnapshot( const idBitMsgDelta &msg );
 void WriteGUIToSnapshot( idBitMsgDelta &msg ) const;
 void ReadGUIFromSnapshot( const idBitMsgDelta &msg );

 void ServerSendEvent( int eventId, const idBitMsg *msg, bool saveEvent, int excludeClient ) const;
 void ClientSendEvent( int eventId, const idBitMsg *msg ) const;

protected:
 renderEntity_t renderEntity;
 int modelDefHandle;
 refSound_t refSound;

private:
 idPhysics_Static defaultPhysicsObj;
 idPhysics * physics;
 idEntity * bindMaster;
 jointHandle_t bindJoint;
 int bindBody;
 idEntity * teamMaster;
 idEntity * teamChain;

 int numPVSAreas;
 int PVSAreas[MAX_PVS_AREAS];

 signalList_t * signals;

 int mpGUIState;

private:
 void FixupLocalizedStrings();

 bool DoDormantTests( void );



 void InitDefaultPhysics( const idVec3 &origin, const idMat3 &axis );

 void UpdateFromPhysics( bool moveBack );


 bool InitBind( idEntity *master );
 void FinishBind( void );
 void RemoveBinds( void );
 void QuitTeam( void );

 void UpdatePVSAreas( void );


 void Event_GetName( void );
 void Event_SetName( const char *name );
 void Event_FindTargets( void );
 void Event_ActivateTargets( idEntity *activator );
 void Event_NumTargets( void );
 void Event_GetTarget( float index );
 void Event_RandomTarget( const char *ignore );
 void Event_Bind( idEntity *master );
 void Event_BindPosition( idEntity *master );
 void Event_BindToJoint( idEntity *master, const char *jointname, float orientated );
 void Event_Unbind( void );
 void Event_RemoveBinds( void );
 void Event_SpawnBind( void );
 void Event_SetOwner( idEntity *owner );
 void Event_SetModel( const char *modelname );
 void Event_SetSkin( const char *skinname );
 void Event_GetShaderParm( int parmnum );
 void Event_SetShaderParm( int parmnum, float value );
 void Event_SetShaderParms( float parm0, float parm1, float parm2, float parm3 );
 void Event_SetColor( float red, float green, float blue );
 void Event_GetColor( void );
 void Event_IsHidden( void );
 void Event_Hide( void );
 void Event_Show( void );
 void Event_CacheSoundShader( const char *soundName );
 void Event_StartSoundShader( const char *soundName, int channel );
 void Event_StopSound( int channel, int netSync );
 void Event_StartSound( const char *soundName, int channel, int netSync );
 void Event_FadeSound( int channel, float to, float over );
 void Event_GetWorldOrigin( void );
 void Event_SetWorldOrigin( idVec3 const &org );
 void Event_GetOrigin( void );
 void Event_SetOrigin( const idVec3 &org );
 void Event_GetAngles( void );
 void Event_SetAngles( const idAngles &ang );
 void Event_SetLinearVelocity( const idVec3 &velocity );
 void Event_GetLinearVelocity( void );
 void Event_SetAngularVelocity( const idVec3 &velocity );
 void Event_GetAngularVelocity( void );
 void Event_SetSize( const idVec3 &mins, const idVec3 &maxs );
 void Event_GetSize( void );
 void Event_GetMins( void );
 void Event_GetMaxs( void );
 void Event_Touches( idEntity *ent );
 void Event_SetGuiParm( const char *key, const char *val );
 void Event_SetGuiFloat( const char *key, float f );
 void Event_GetNextKey( const char *prefix, const char *lastMatch );
 void Event_SetKey( const char *key, const char *value );
 void Event_GetKey( const char *key );
 void Event_GetIntKey( const char *key );
 void Event_GetFloatKey( const char *key );
 void Event_GetVectorKey( const char *key );
 void Event_GetEntityKey( const char *key );
 void Event_RestorePosition( void );
 void Event_UpdateCameraTarget( void );
 void Event_DistanceTo( idEntity *ent );
 void Event_DistanceToPoint( const idVec3 &point );
 void Event_StartFx( const char *fx );
 void Event_WaitFrame( void );
 void Event_Wait( float time );
 void Event_HasFunction( const char *name );
 void Event_CallFunction( const char *name );
 void Event_SetNeverDormant( int enable );
};
# 468 "d:/Data/Nintendo/DoomGX/src/game/Entity.h"
typedef struct damageEffect_s {
 jointHandle_t jointNum;
 idVec3 localOrigin;
 idVec3 localNormal;
 int time;
 const idDeclParticle* type;
 struct damageEffect_s * next;
} damageEffect_t;

class idAnimatedEntity : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAnimatedEntity> eventCallbacks[];

       idAnimatedEntity();
       ~idAnimatedEntity();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void ClientPredictionThink( void );
 virtual void Think( void );

 void UpdateAnimation( void );

 virtual idAnimator * GetAnimator( void );
 virtual void SetModel( const char *modelname );

 bool GetJointWorldTransform( jointHandle_t jointHandle, int currentTime, idVec3 &offset, idMat3 &axis );
 bool GetJointTransformForAnim( jointHandle_t jointHandle, int animNum, int currentTime, idVec3 &offset, idMat3 &axis ) const;

 virtual int GetDefaultSurfaceType( void ) const;
 virtual void AddDamageEffect( const trace_t &collision, const idVec3 &velocity, const char *damageDefName );
 void AddLocalDamageEffect( jointHandle_t jointNum, const idVec3 &localPoint, const idVec3 &localNormal, const idVec3 &localDir, const idDeclEntityDef *def, const idMaterial *collisionMaterial );
 void UpdateDamageEffects( void );

 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );

 enum {
  EVENT_ADD_DAMAGE_EFFECT = idEntity::EVENT_MAXEVENTS,
  EVENT_MAXEVENTS
 };

protected:
 idAnimator animator;
 damageEffect_t * damageEffects;

private:
 void Event_GetJointHandle( const char *jointname );
 void Event_ClearAllJoints( void );
 void Event_ClearJoint( jointHandle_t jointnum );
 void Event_SetJointPos( jointHandle_t jointnum, jointModTransform_t transform_type, const idVec3 &pos );
 void Event_SetJointAngle( jointHandle_t jointnum, jointModTransform_t transform_type, const idAngles &angles );
 void Event_GetJointPos( jointHandle_t jointnum );
 void Event_GetJointAngle( jointHandle_t jointnum );
};
# 717 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/GameEdit.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/GameEdit.h"
class idCursor3D : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idCursor3D> eventCallbacks[];

       idCursor3D( void );
       ~idCursor3D( void );

 void Spawn( void );
 void Present( void );
 void Think( void );

 idForce_Drag drag;
 idVec3 draggedPosition;
};
# 65 "d:/Data/Nintendo/DoomGX/src/game/GameEdit.h"
class idDragEntity {
public:
       idDragEntity( void );
       ~idDragEntity( void );

 void Clear();
 void Update( idPlayer *player );
 void SetSelected( idEntity *ent );
 idEntity * GetSelected( void ) const { return selected.GetEntity(); }
 void DeleteSelected( void );
 void BindSelected( void );
 void UnbindSelected( void );

private:
 idEntityPtr<idEntity> dragEnt;
 jointHandle_t joint;
 int id;
 idVec3 localEntityPoint;
 idVec3 localPlayerPoint;
 idStr bodyName;
 idCursor3D * cursor;
 idEntityPtr<idEntity> selected;

 void StopDrag( void );
};
# 99 "d:/Data/Nintendo/DoomGX/src/game/GameEdit.h"
typedef struct selectedTypeInfo_s {
 idTypeInfo *typeInfo;
 idStr textKey;
} selectedTypeInfo_t;

class idEditEntities {
public:
       idEditEntities( void );
 bool SelectEntity( const idVec3 &origin, const idVec3 &dir, const idEntity *skip );
 void AddSelectedEntity( idEntity *ent );
 void RemoveSelectedEntity( idEntity *ent );
 void ClearSelectedEntities( void );
 void DisplayEntities( void );
 bool EntityIsSelectable( idEntity *ent, idVec4 *color = __null, idStr *text = __null );
private:
 int nextSelectTime;
 idList<selectedTypeInfo_t> selectableEntityClasses;
 idList<idEntity *> selectedEntities;
};
# 718 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/AF.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/AF.h"
typedef struct jointConversion_s {
 int bodyId;
 jointHandle_t jointHandle;
 AFJointModType_t jointMod;
 idVec3 jointBodyOrigin;
 idMat3 jointBodyAxis;
} jointConversion_t;

typedef struct afTouch_s {
 idEntity * touchedEnt;
 idClipModel * touchedClipModel;
 idAFBody * touchedByBody;
} afTouch_t;

class idAF {
public:
       idAF( void );
       ~idAF( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void SetAnimator( idAnimator *a ) { animator = a; }
 bool Load( idEntity *ent, const char *fileName );
 bool IsLoaded( void ) const { return isLoaded && self != __null; }
 const char * GetName( void ) const { return name.c_str(); }
 void SetupPose( idEntity *ent, int time );
 void ChangePose( idEntity *ent, int time );
 int EntitiesTouchingAF( afTouch_t touchList[ (1<<12) ] ) const;
 void Start( void );
 void StartFromCurrentPose( int inheritVelocityTime );
 void Stop( void );
 void Rest( void );
 bool IsActive( void ) const { return isActive; }
 void SetConstraintPosition( const char *name, const idVec3 &pos );

 idPhysics_AF * GetPhysics( void ) { return &physicsObj; }
 const idPhysics_AF * GetPhysics( void ) const { return &physicsObj; }
 idBounds GetBounds( void ) const;
 bool UpdateAnimation( void );

 void GetPhysicsToVisualTransform( idVec3 &origin, idMat3 &axis ) const;
 void GetImpactInfo( idEntity *ent, int id, const idVec3 &point, impactInfo_t *info );
 void ApplyImpulse( idEntity *ent, int id, const idVec3 &point, const idVec3 &impulse );
 void AddForce( idEntity *ent, int id, const idVec3 &point, const idVec3 &force );
 int BodyForClipModelId( int id ) const;

 void SaveState( idDict &args ) const;
 void LoadState( const idDict &args );

 void AddBindConstraints( void );
 void RemoveBindConstraints( void );

protected:
 idStr name;
 idPhysics_AF physicsObj;
 idEntity * self;
 idAnimator * animator;
 int modifiedAnim;
 idVec3 baseOrigin;
 idMat3 baseAxis;
 idList<jointConversion_t>jointMods;
 idList<int> jointBody;
 int poseTime;
 int restStartTime;
 bool isLoaded;
 bool isActive;
 bool hasBindConstraints;

protected:
 void SetBase( idAFBody *body, const idJointMat *joints );
 void AddBody( idAFBody *body, const idJointMat *joints, const char *jointName, const AFJointModType_t mod );

 bool LoadBody( const idDeclAF_Body *fb, const idJointMat *joints );
 bool LoadConstraint( const idDeclAF_Constraint *fc );

 bool TestSolid( void ) const;
};
# 719 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/IK.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/IK.h"
class idIK {
public:
       idIK( void );
 virtual ~idIK( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 bool IsInitialized( void ) const;

 virtual bool Init( idEntity *self, const char *anim, const idVec3 &modelOffset );
 virtual void Evaluate( void );
 virtual void ClearJointMods( void );

 bool SolveTwoBones( const idVec3 &startPos, const idVec3 &endPos, const idVec3 &dir, float len0, float len1, idVec3 &jointPos );
 float GetBoneAxis( const idVec3 &startPos, const idVec3 &endPos, const idVec3 &dir, idMat3 &axis );

protected:
 bool initialized;
 bool ik_activate;
 idEntity * self;
 idAnimator * animator;
 int modifiedAnim;
 idVec3 modelOffset;
};
# 77 "d:/Data/Nintendo/DoomGX/src/game/IK.h"
class idIK_Walk : public idIK {
public:

       idIK_Walk( void );
 virtual ~idIK_Walk( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual bool Init( idEntity *self, const char *anim, const idVec3 &modelOffset );
 virtual void Evaluate( void );
 virtual void ClearJointMods( void );

 void EnableAll( void );
 void DisableAll( void );
 void EnableLeg( int num );
 void DisableLeg( int num );

private:
 static const int MAX_LEGS = 8;

 idClipModel * footModel;

 int numLegs;
 int enabledLegs;
 jointHandle_t footJoints[MAX_LEGS];
 jointHandle_t ankleJoints[MAX_LEGS];
 jointHandle_t kneeJoints[MAX_LEGS];
 jointHandle_t hipJoints[MAX_LEGS];
 jointHandle_t dirJoints[MAX_LEGS];
 jointHandle_t waistJoint;

 idVec3 hipForward[MAX_LEGS];
 idVec3 kneeForward[MAX_LEGS];

 float upperLegLength[MAX_LEGS];
 float lowerLegLength[MAX_LEGS];

 idMat3 upperLegToHipJoint[MAX_LEGS];
 idMat3 lowerLegToKneeJoint[MAX_LEGS];

 float smoothing;
 float waistSmoothing;
 float footShift;
 float waistShift;
 float minWaistFloorDist;
 float minWaistAnkleDist;
 float footUpTrace;
 float footDownTrace;
 bool tiltWaist;
 bool usePivot;


 int pivotFoot;
 float pivotYaw;
 idVec3 pivotPos;
 bool oldHeightsValid;
 float oldWaistHeight;
 float oldAnkleHeights[MAX_LEGS];
 idVec3 waistOffset;
};
# 148 "d:/Data/Nintendo/DoomGX/src/game/IK.h"
class idIK_Reach : public idIK {
public:

       idIK_Reach( void );
 virtual ~idIK_Reach( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual bool Init( idEntity *self, const char *anim, const idVec3 &modelOffset );
 virtual void Evaluate( void );
 virtual void ClearJointMods( void );

private:

 static const int MAX_ARMS = 2;

 int numArms;
 int enabledArms;
 jointHandle_t handJoints[MAX_ARMS];
 jointHandle_t elbowJoints[MAX_ARMS];
 jointHandle_t shoulderJoints[MAX_ARMS];
 jointHandle_t dirJoints[MAX_ARMS];

 idVec3 shoulderForward[MAX_ARMS];
 idVec3 elbowForward[MAX_ARMS];

 float upperArmLength[MAX_ARMS];
 float lowerArmLength[MAX_ARMS];

 idMat3 upperArmToShoulderJoint[MAX_ARMS];
 idMat3 lowerArmToElbowJoint[MAX_ARMS];
};
# 720 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
const int GIB_DELAY = 200;

class idMultiModelAF : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idMultiModelAF> eventCallbacks[];

 void Spawn( void );
       ~idMultiModelAF( void );

 virtual void Think( void );
 virtual void Present( void );

protected:
 idPhysics_AF physicsObj;

 void SetModelForId( int id, const idStr &modelName );

private:
 idList<idRenderModel *> modelHandles;
 idList<int> modelDefHandles;
};
# 76 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idChain : public idMultiModelAF {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idChain> eventCallbacks[];

 void Spawn( void );

protected:
 void BuildChain( const idStr &name, const idVec3 &origin, float linkLength, float linkWidth, float density, int numLinks, bool bindToWorld = true );
};
# 95 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFAttachment : public idAnimatedEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFAttachment> eventCallbacks[];

       idAFAttachment( void );
 virtual ~idAFAttachment( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void SetBody( idEntity *bodyEnt, const char *headModel, jointHandle_t attachJoint );
 void ClearBody( void );
 idEntity * GetBody( void ) const;

 virtual void Think( void );

 virtual void Hide( void );
 virtual void Show( void );

 void PlayIdleAnim( int blendTime );

 virtual void GetImpactInfo( idEntity *ent, int id, const idVec3 &point, impactInfo_t *info );
 virtual void ApplyImpulse( idEntity *ent, int id, const idVec3 &point, const idVec3 &impulse );
 virtual void AddForce( idEntity *ent, int id, const idVec3 &point, const idVec3 &force );

 virtual void Damage( idEntity *inflictor, idEntity *attacker, const idVec3 &dir, const char *damageDefName, const float damageScale, const int location );
 virtual void AddDamageEffect( const trace_t &collision, const idVec3 &velocity, const char *damageDefName );

 void SetCombatModel( void );
 idClipModel * GetCombatModel( void ) const;
 virtual void LinkCombat( void );
 virtual void UnlinkCombat( void );

protected:
 idEntity * body;
 idClipModel * combatModel;
 int idleAnim;
 jointHandle_t attachJoint;
};
# 146 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_Base : public idAnimatedEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_Base> eventCallbacks[];

       idAFEntity_Base( void );
 virtual ~idAFEntity_Base( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );
 virtual void GetImpactInfo( idEntity *ent, int id, const idVec3 &point, impactInfo_t *info );
 virtual void ApplyImpulse( idEntity *ent, int id, const idVec3 &point, const idVec3 &impulse );
 virtual void AddForce( idEntity *ent, int id, const idVec3 &point, const idVec3 &force );
 virtual bool Collide( const trace_t &collision, const idVec3 &velocity );
 virtual bool GetPhysicsToVisualTransform( idVec3 &origin, idMat3 &axis );
 virtual bool UpdateAnimationControllers( void );
 virtual void FreeModelDef( void );

 virtual bool LoadAF( void );
 bool IsActiveAF( void ) const { return af.IsActive(); }
 const char * GetAFName( void ) const { return af.GetName(); }
 idPhysics_AF * GetAFPhysics( void ) { return af.GetPhysics(); }

 void SetCombatModel( void );
 idClipModel * GetCombatModel( void ) const;

 void SetCombatContents( bool enable );
 virtual void LinkCombat( void );
 virtual void UnlinkCombat( void );

 int BodyForClipModelId( int id ) const;

 void SaveState( idDict &args ) const;
 void LoadState( const idDict &args );

 void AddBindConstraints( void );
 void RemoveBindConstraints( void );

 virtual void ShowEditingDialog( void );

 static void DropAFs( idEntity *ent, const char *type, idList<idEntity *> *list );

protected:
 idAF af;
 idClipModel * combatModel;
 int combatModelContents;
 idVec3 spawnOrigin;
 idMat3 spawnAxis;
 int nextSoundTime;

 void Event_SetConstraintPosition( const char *name, const idVec3 &pos );
};
# 210 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
extern const idEventDef EV_Gib;
extern const idEventDef EV_Gibbed;

class idAFEntity_Gibbable : public idAFEntity_Base {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_Gibbable> eventCallbacks[];

       idAFEntity_Gibbable( void );
       ~idAFEntity_Gibbable( void );

 void Spawn( void );
 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );
 virtual void Present( void );
 virtual void Damage( idEntity *inflictor, idEntity *attacker, const idVec3 &dir, const char *damageDefName, const float damageScale, const int location );
 virtual void SpawnGibs( const idVec3 &dir, const char *damageDefName );

protected:
 idRenderModel * skeletonModel;
 int skeletonModelDefHandle;
 bool gibbed;

 virtual void Gib( const idVec3 &dir, const char *damageDefName );
 void InitSkeletonModel( void );

 void Event_Gib( const char *damageDefName );
};
# 246 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_Generic : public idAFEntity_Gibbable {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_Generic> eventCallbacks[];

       idAFEntity_Generic( void );
       ~idAFEntity_Generic( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );
 void KeepRunningPhysics( void ) { keepRunningPhysics = true; }

private:
 void Event_Activate( idEntity *activator );

 bool keepRunningPhysics;
};
# 276 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_WithAttachedHead : public idAFEntity_Gibbable {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_WithAttachedHead> eventCallbacks[];

       idAFEntity_WithAttachedHead();
       ~idAFEntity_WithAttachedHead();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void SetupHead( void );

 virtual void Think( void );

 virtual void Hide( void );
 virtual void Show( void );
 virtual void ProjectOverlay( const idVec3 &origin, const idVec3 &dir, float size, const char *material );

 virtual void LinkCombat( void );
 virtual void UnlinkCombat( void );

protected:
 virtual void Gib( const idVec3 &dir, const char *damageDefName );

private:
 idEntityPtr<idAFAttachment> head;

 void Event_Gib( const char *damageDefName );
 void Event_Activate( idEntity *activator );
};
# 318 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_Vehicle : public idAFEntity_Base {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_Vehicle> eventCallbacks[];

       idAFEntity_Vehicle( void );

 void Spawn( void );
 void Use( idPlayer *player );

protected:
 idPlayer * player;
 jointHandle_t eyesJoint;
 jointHandle_t steeringWheelJoint;
 float wheelRadius;
 float steerAngle;
 float steerSpeed;
 const idDeclParticle * dustSmoke;

 float GetSteerAngle( void );
};
# 348 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_VehicleSimple : public idAFEntity_Vehicle {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_VehicleSimple> eventCallbacks[];

       idAFEntity_VehicleSimple( void );
       ~idAFEntity_VehicleSimple( void );

 void Spawn( void );
 virtual void Think( void );

protected:
 idClipModel * wheelModel;
 idAFConstraint_Suspension * suspension[4];
 jointHandle_t wheelJoints[4];
 float wheelAngles[4];
};
# 374 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_VehicleFourWheels : public idAFEntity_Vehicle {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_VehicleFourWheels> eventCallbacks[];

       idAFEntity_VehicleFourWheels( void );

 void Spawn( void );
 virtual void Think( void );

protected:
 idAFBody * wheels[4];
 idAFConstraint_Hinge * steering[2];
 jointHandle_t wheelJoints[4];
 float wheelAngles[4];
};
# 399 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_VehicleSixWheels : public idAFEntity_Vehicle {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_VehicleSixWheels> eventCallbacks[];

       idAFEntity_VehicleSixWheels( void );

 void Spawn( void );
 virtual void Think( void );

private:
 idAFBody * wheels[6];
 idAFConstraint_Hinge * steering[4];
 jointHandle_t wheelJoints[6];
 float wheelAngles[6];
};
# 424 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_SteamPipe : public idAFEntity_Base {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_SteamPipe> eventCallbacks[];

       idAFEntity_SteamPipe( void );
       ~idAFEntity_SteamPipe( void );

 void Spawn( void );
 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

private:
 int steamBody;
 float steamForce;
 float steamUpForce;
 idForce_Constant force;
 renderEntity_t steamRenderEntity;
 qhandle_t steamModelDefHandle;

 void InitSteamRenderEntity( void );
};
# 457 "d:/Data/Nintendo/DoomGX/src/game/AFEntity.h"
class idAFEntity_ClawFourFingers : public idAFEntity_Base {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAFEntity_ClawFourFingers> eventCallbacks[];

       idAFEntity_ClawFourFingers( void );

 void Spawn( void );
 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 idAFConstraint_Hinge * fingers[4];

 void Event_SetFingerAngle( float angle );
 void Event_StopFingers( void );
};
# 721 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Misc.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idSpawnableEntity : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idSpawnableEntity> eventCallbacks[];

 void Spawn( void );

private:
};
# 66 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idPlayerStart : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPlayerStart> eventCallbacks[];

 enum {
  EVENT_TELEPORTPLAYER = idEntity::EVENT_MAXEVENTS,
  EVENT_MAXEVENTS
 };

      idPlayerStart( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );

private:
 int teleportStage;

 void Event_TeleportPlayer( idEntity *activator );
 void Event_TeleportStage( idEntity *player );
 void TeleportPlayer( idPlayer *player );
};
# 104 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idActivator : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idActivator> eventCallbacks[];

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

private:
 bool stay_on;

 void Event_Activate( idEntity *activator );
};
# 129 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idPathCorner : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPathCorner> eventCallbacks[];

 void Spawn( void );

 static void DrawDebugInfo( void );

 static idPathCorner *RandomPath( const idEntity *source, const idEntity *ignore );

private:
 void Event_RandomPath( void );
};
# 152 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idDamagable : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idDamagable> eventCallbacks[];

      idDamagable( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );

private:
 int count;
 int nextTriggerTime;

 void BecomeBroken( idEntity *activator );
 void Event_BecomeBroken( idEntity *activator );
 void Event_RestoreDamagable( void );
};
# 182 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idExplodable : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idExplodable> eventCallbacks[];

 void Spawn( void );

private:
 void Event_Explode( idEntity *activator );
};
# 201 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idSpring : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idSpring> eventCallbacks[];

 void Spawn( void );

 virtual void Think( void );

private:
 idEntity * ent1;
 idEntity * ent2;
 int id1;
 int id2;
 idVec3 p1;
 idVec3 p2;
 idForce_Spring spring;

 void Event_LinkSpring( void );
};
# 230 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idForceField : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idForceField> eventCallbacks[];

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

 virtual void Think( void );

private:
 idForce_Field forceField;

 void Toggle( void );

 void Event_Activate( idEntity *activator );
 void Event_Toggle( void );
 void Event_FindTargets( void );
};
# 260 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idAnimated : public idAFEntity_Gibbable {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAnimated> eventCallbacks[];

       idAnimated();
       ~idAnimated();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 virtual bool LoadAF( void );
 bool StartRagdoll( void );
 virtual bool GetPhysicsToSoundTransform( idVec3 &origin, idMat3 &axis );

private:
 int num_anims;
 int current_anim_index;
 int anim;
 int blendFrames;
 jointHandle_t soundJoint;
 idEntityPtr<idEntity> activator;
 bool activated;

 void PlayNextAnim( void );

 void Event_Activate( idEntity *activator );
 void Event_Start( void );
 void Event_StartRagdoll( void );
 void Event_AnimDone( int animIndex );
 void Event_Footstep( void );
 void Event_LaunchMissiles( const char *projectilename, const char *sound, const char *launchjoint, const char *targetjoint, int numshots, int framedelay );
 void Event_LaunchMissilesUpdate( int launchjoint, int targetjoint, int numshots, int framedelay );
};
# 304 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idStaticEntity : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idStaticEntity> eventCallbacks[];

      idStaticEntity( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 void ShowEditingDialog( void );
 virtual void Hide( void );
 virtual void Show( void );
 void Fade( const idVec4 &to, float fadeTime );
 virtual void Think( void );

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

private:
 void Event_Activate( idEntity *activator );

 int spawnTime;
 bool active;
 idVec4 fadeFrom;
 idVec4 fadeTo;
 int fadeStart;
 int fadeEnd;
 bool runGui;
};
# 344 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idFuncEmitter : public idStaticEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idFuncEmitter> eventCallbacks[];

      idFuncEmitter( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 void Event_Activate( idEntity *activator );

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

private:
 bool hidden;

};
# 373 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idFuncSmoke : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idFuncSmoke> eventCallbacks[];

       idFuncSmoke();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );
 void Event_Activate( idEntity *activator );

private:
 int smokeTime;
 const idDeclParticle * smoke;
 bool restart;
};
# 402 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idFuncSplat : public idFuncEmitter {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idFuncSplat> eventCallbacks[];

 idFuncSplat( void );

 void Spawn( void );

private:
 void Event_Activate( idEntity *activator );
 void Event_Splat();
};
# 424 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idTextEntity : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTextEntity> eventCallbacks[];

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

private:
 idStr text;
 bool playerOriented;
};
# 449 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idLocationEntity : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idLocationEntity> eventCallbacks[];

 void Spawn( void );

 const char * GetLocation( void ) const;

private:
};

class idLocationSeparatorEntity : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idLocationSeparatorEntity> eventCallbacks[];

 void Spawn( void );

private:
};

class idVacuumSeparatorEntity : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idVacuumSeparatorEntity> eventCallbacks[];

      idVacuumSeparatorEntity( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Event_Activate( idEntity *activator );

private:
 qhandle_t portal;
};

class idVacuumEntity : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idVacuumEntity> eventCallbacks[];

 void Spawn( void );

private:
};
# 504 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idBeam : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idBeam> eventCallbacks[];

      idBeam();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

 void SetMaster( idBeam *masterbeam );
 void SetBeamTarget( const idVec3 &origin );

 virtual void Show( void );

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

private:
 void Event_MatchTarget( void );
 void Event_Activate( idEntity *activator );

 idEntityPtr<idBeam> target;
 idEntityPtr<idBeam> master;
};
# 542 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idRenderModelLiquid;

class idLiquid : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idLiquid> eventCallbacks[];

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 void Event_Touch( idEntity *other, trace_t *trace );


 idRenderModelLiquid *model;
};
# 569 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idShaking : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idShaking> eventCallbacks[];

       idShaking();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 idPhysics_Parametric physicsObj;
 bool active;

 void BeginShaking( void );
 void Event_Activate( idEntity *activator );
};
# 597 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idEarthQuake : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idEarthQuake> eventCallbacks[];

      idEarthQuake();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

private:
 int nextTriggerTime;
 int shakeStopTime;
 float wait;
 float random;
 bool triggered;
 bool playerOriented;
 bool disabled;
 float shakeTime;

 void Event_Activate( idEntity *activator );
};
# 632 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idFuncPortal : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idFuncPortal> eventCallbacks[];

      idFuncPortal();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 qhandle_t portal;
 bool state;

 void Event_Activate( idEntity *activator );
};
# 658 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idFuncAASPortal : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idFuncAASPortal> eventCallbacks[];

      idFuncAASPortal();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 bool state;

 void Event_Activate( idEntity *activator );
};
# 683 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idFuncAASObstacle : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idFuncAASObstacle> eventCallbacks[];

      idFuncAASObstacle();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 bool state;

 void Event_Activate( idEntity *activator );
};
# 709 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idFuncRadioChatter : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idFuncRadioChatter> eventCallbacks[];

      idFuncRadioChatter();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 float time;
 void Event_Activate( idEntity *activator );
 void Event_ResetRadioHud( idEntity *activator );
};
# 735 "d:/Data/Nintendo/DoomGX/src/game/Misc.h"
class idPhantomObjects : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPhantomObjects> eventCallbacks[];

      idPhantomObjects();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

private:
 void Event_Activate( idEntity *activator );
 void Event_Throw( void );
 void Event_ShakeObject( idEntity *object, int starttime );

 int end_time;
 float throw_time;
 float shake_time;
 idVec3 shake_ang;
 float speed;
 int min_wait;
 int max_wait;
 idEntityPtr<idActor>target;
 idList<int> targetTime;
 idList<idVec3> lastTargetPos;
};
# 722 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Actor.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Actor.h"
extern const idEventDef AI_EnableEyeFocus;
extern const idEventDef AI_DisableEyeFocus;
extern const idEventDef EV_Footstep;
extern const idEventDef EV_FootstepLeft;
extern const idEventDef EV_FootstepRight;
extern const idEventDef EV_EnableWalkIK;
extern const idEventDef EV_DisableWalkIK;
extern const idEventDef EV_EnableLegIK;
extern const idEventDef EV_DisableLegIK;
extern const idEventDef AI_SetAnimPrefix;
extern const idEventDef AI_PlayAnim;
extern const idEventDef AI_PlayCycle;
extern const idEventDef AI_AnimDone;
extern const idEventDef AI_SetBlendFrames;
extern const idEventDef AI_GetBlendFrames;

class idDeclParticle;

class idAnimState {
public:
 bool idleAnim;
 idStr state;
 int animBlendFrames;
 int lastAnimBlendFrames;

public:
       idAnimState();
       ~idAnimState();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Init( idActor *owner, idAnimator *_animator, int animchannel );
 void Shutdown( void );
 void SetState( const char *name, int blendFrames );
 void StopAnim( int frames );
 void PlayAnim( int anim );
 void CycleAnim( int anim );
 void BecomeIdle( void );
 bool UpdateState( void );
 bool Disabled( void ) const;
 void Enable( int blendFrames );
 void Disable( void );
 bool AnimDone( int blendFrames ) const;
 bool IsIdle( void ) const;
 animFlags_t GetAnimFlags( void ) const;

private:
 idActor * self;
 idAnimator * animator;
 idThread * thread;
 int channel;
 bool disabled;
};

class idAttachInfo {
public:
 idEntityPtr<idEntity> ent;
 int channel;
};

typedef struct {
 jointModTransform_t mod;
 jointHandle_t from;
 jointHandle_t to;
} copyJoints_t;

class idActor : public idAFEntity_Gibbable {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idActor> eventCallbacks[];

 int team;
 int rank;
 idMat3 viewAxis;

 idLinkList<idActor> enemyNode;
 idLinkList<idActor> enemyList;

public:
       idActor( void );
 virtual ~idActor( void );

 void Spawn( void );
 virtual void Restart( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Hide( void );
 virtual void Show( void );
 virtual int GetDefaultSurfaceType( void ) const;
 virtual void ProjectOverlay( const idVec3 &origin, const idVec3 &dir, float size, const char *material );

 virtual bool LoadAF( void );
 void SetupBody( void );

 void CheckBlink( void );

 virtual bool GetPhysicsToVisualTransform( idVec3 &origin, idMat3 &axis );
 virtual bool GetPhysicsToSoundTransform( idVec3 &origin, idMat3 &axis );


 void ShutdownThreads( void );
 virtual bool ShouldConstructScriptObjectAtSpawn( void ) const;
 virtual idThread * ConstructScriptObject( void );
 void UpdateScript( void );
 const function_t *GetScriptFunction( const char *funcname );
 void SetState( const function_t *newState );
 void SetState( const char *statename );


 void SetEyeHeight( float height );
 float EyeHeight( void ) const;
 idVec3 EyeOffset( void ) const;
 idVec3 GetEyePosition( void ) const;
 virtual void GetViewPos( idVec3 &origin, idMat3 &axis ) const;
 void SetFOV( float fov );
 bool CheckFOV( const idVec3 &pos ) const;
 bool CanSee( idEntity *ent, bool useFOV ) const;
 bool PointVisible( const idVec3 &point ) const;
 virtual void GetAIAimTargets( const idVec3 &lastSightPos, idVec3 &headPos, idVec3 &chestPos );


 void SetupDamageGroups( void );
 virtual void Damage( idEntity *inflictor, idEntity *attacker, const idVec3 &dir, const char *damageDefName, const float damageScale, const int location );
 int GetDamageForLocation( int damage, int location );
 const char * GetDamageGroup( int location );
 void ClearPain( void );
 virtual bool Pain( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );


 void SetCombatModel( void );
 idClipModel * GetCombatModel( void ) const;
 virtual void LinkCombat( void );
 virtual void UnlinkCombat( void );
 bool StartRagdoll( void );
 void StopRagdoll( void );
 virtual bool UpdateAnimationControllers( void );


 const idAngles & GetDeltaViewAngles( void ) const;
 void SetDeltaViewAngles( const idAngles &delta );

 bool HasEnemies( void ) const;
 idActor * ClosestEnemyToPoint( const idVec3 &pos );
 idActor * EnemyWithMostHealth();

 virtual bool OnLadder( void ) const;

 virtual void GetAASLocation( idAAS *aas, idVec3 &pos, int &areaNum ) const;

 void Attach( idEntity *ent );

 virtual void Teleport( const idVec3 &origin, const idAngles &angles, idEntity *destination );

 virtual renderView_t * GetRenderView();


 int GetAnim( int channel, const char *name );
 void UpdateAnimState( void );
 void SetAnimState( int channel, const char *name, int blendFrames );
 const char * GetAnimState( int channel ) const;
 bool InAnimState( int channel, const char *name ) const;
 const char * WaitState( void ) const;
 void SetWaitState( const char *_waitstate );
 bool AnimDone( int channel, int blendFrames ) const;
 virtual void SpawnGibs( const idVec3 &dir, const char *damageDefName );

protected:
 friend class idAnimState;

 float fovDot;
 idVec3 eyeOffset;
 idVec3 modelOffset;

 idAngles deltaViewAngles;

 int pain_debounce_time;
 int pain_delay;
 int pain_threshold;

 idStrList damageGroups;
 idList<float> damageScale;

 bool use_combat_bbox;
 idEntityPtr<idAFAttachment> head;
 idList<copyJoints_t> copyJoints;


 const function_t *state;
 const function_t *idealState;


 jointHandle_t leftEyeJoint;
 jointHandle_t rightEyeJoint;
 jointHandle_t soundJoint;

 idIK_Walk walkIK;

 idStr animPrefix;
 idStr painAnim;


 int blink_anim;
 int blink_time;
 int blink_min;
 int blink_max;


 idThread * scriptThread;
 idStr waitState;
 idAnimState headAnim;
 idAnimState torsoAnim;
 idAnimState legsAnim;

 bool allowPain;
 bool allowEyeFocus;
 bool finalBoss;

 int painTime;

 idList<idAttachInfo> attachments;

 virtual void Gib( const idVec3 &dir, const char *damageDefName );


 void RemoveAttachments( void );


 void CopyJointsFromBodyToHead( void );

private:
 void SyncAnimChannels( int channel, int syncToChannel, int blendFrames );
 void FinishSetup( void );
 void SetupHead( void );
 void PlayFootStepSound( void );

 void Event_EnableEyeFocus( void );
 void Event_DisableEyeFocus( void );
 void Event_Footstep( void );
 void Event_EnableWalkIK( void );
 void Event_DisableWalkIK( void );
 void Event_EnableLegIK( int num );
 void Event_DisableLegIK( int num );
 void Event_SetAnimPrefix( const char *name );
 void Event_LookAtEntity( idEntity *ent, float duration );
 void Event_PreventPain( float duration );
 void Event_DisablePain( void );
 void Event_EnablePain( void );
 void Event_GetPainAnim( void );
 void Event_StopAnim( int channel, int frames );
 void Event_PlayAnim( int channel, const char *name );
 void Event_PlayCycle( int channel, const char *name );
 void Event_IdleAnim( int channel, const char *name );
 void Event_SetSyncedAnimWeight( int channel, int anim, float weight );
 void Event_OverrideAnim( int channel );
 void Event_EnableAnim( int channel, int blendFrames );
 void Event_SetBlendFrames( int channel, int blendFrames );
 void Event_GetBlendFrames( int channel );
 void Event_AnimState( int channel, const char *name, int blendFrames );
 void Event_GetAnimState( int channel );
 void Event_InAnimState( int channel, const char *name );
 void Event_FinishAction( const char *name );
 void Event_AnimDone( int channel, int blendFrames );
 void Event_HasAnim( int channel, const char *name );
 void Event_CheckAnim( int channel, const char *animname );
 void Event_ChooseAnim( int channel, const char *animname );
 void Event_AnimLength( int channel, const char *animname );
 void Event_AnimDistance( int channel, const char *animname );
 void Event_HasEnemies( void );
 void Event_NextEnemy( idEntity *ent );
 void Event_ClosestEnemyToPoint( const idVec3 &pos );
 void Event_StopSound( int channel, int netsync );
 void Event_SetNextState( const char *name );
 void Event_SetState( const char *name );
 void Event_GetState( void );
 void Event_GetHead( void );
};
# 723 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Projectile.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Projectile.h"
extern const idEventDef EV_Explode;

class idProjectile : public idEntity {
public :
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idProjectile> eventCallbacks[];

       idProjectile();
 virtual ~idProjectile();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Create( idEntity *owner, const idVec3 &start, const idVec3 &dir );
 virtual void Launch( const idVec3 &start, const idVec3 &dir, const idVec3 &pushVelocity, const float timeSinceFire = 0.0f, const float launchPower = 1.0f, const float dmgPower = 1.0f );
 virtual void FreeLightDef( void );

 idEntity * GetOwner( void ) const;

 virtual void Think( void );
 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );
 virtual bool Collide( const trace_t &collision, const idVec3 &velocity );
 virtual void Explode( const trace_t &collision, idEntity *ignore );
 void Fizzle( void );

 static idVec3 GetVelocity( const idDict *projectile );
 static idVec3 GetGravity( const idDict *projectile );

 enum {
  EVENT_DAMAGE_EFFECT = idEntity::EVENT_MAXEVENTS,
  EVENT_MAXEVENTS
 };

 static void DefaultDamageEffect( idEntity *soundEnt, const idDict &projectileDef, const trace_t &collision, const idVec3 &velocity );
 static bool ClientPredictionCollide( idEntity *soundEnt, const idDict &projectileDef, const trace_t &collision, const idVec3 &velocity, bool addDamageEffect );
 virtual void ClientPredictionThink( void );
 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );
 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );

protected:
 idEntityPtr<idEntity> owner;

 struct projectileFlags_s {
  bool detonate_on_world : 1;
  bool detonate_on_actor : 1;
  bool randomShaderSpin : 1;
  bool isTracer : 1;
  bool noSplashDamage : 1;
 } projectileFlags;

 float thrust;
 int thrust_end;
 float damagePower;

 renderLight_t renderLight;
 qhandle_t lightDefHandle;
 idVec3 lightOffset;
 int lightStartTime;
 int lightEndTime;
 idVec3 lightColor;

 idForce_Constant thruster;
 idPhysics_RigidBody physicsObj;

 const idDeclParticle * smokeFly;
 int smokeFlyTime;

 typedef enum {

  SPAWNED = 0,
  CREATED = 1,
  LAUNCHED = 2,
  FIZZLED = 3,
  EXPLODED = 4
 } projectileState_t;

 projectileState_t state;

private:
 bool netSyncPhysics;

 void AddDefaultDamageEffect( const trace_t &collision, const idVec3 &velocity );

 void Event_Explode( void );
 void Event_Fizzle( void );
 void Event_RadiusDamage( idEntity *ignore );
 void Event_Touch( idEntity *other, trace_t *trace );
 void Event_GetProjectileState( void );
};

class idGuidedProjectile : public idProjectile {
public :
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idGuidedProjectile> eventCallbacks[];

       idGuidedProjectile( void );
       ~idGuidedProjectile( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 virtual void Think( void );
 virtual void Launch( const idVec3 &start, const idVec3 &dir, const idVec3 &pushVelocity, const float timeSinceFire = 0.0f, const float launchPower = 1.0f, const float dmgPower = 1.0f );

protected:
 float speed;
 idEntityPtr<idEntity> enemy;
 virtual void GetSeekPos( idVec3 &out );

private:
 idAngles rndScale;
 idAngles rndAng;
 idAngles angles;
 int rndUpdateTime;
 float turn_max;
 float clamp_dist;
 bool burstMode;
 bool unGuided;
 float burstDist;
 float burstVelocity;
};

class idSoulCubeMissile : public idGuidedProjectile {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idSoulCubeMissile> eventCallbacks[];
 ~idSoulCubeMissile();
 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 virtual void Think( void );
 virtual void Launch( const idVec3 &start, const idVec3 &dir, const idVec3 &pushVelocity, const float timeSinceFire = 0.0f, const float power = 1.0f, const float dmgPower = 1.0f );

protected:
 virtual void GetSeekPos( idVec3 &out );
 void ReturnToOwner( void );
 void KillTarget( const idVec3 &dir );

private:
 idVec3 startingVelocity;
 idVec3 endingVelocity;
 float accelTime;
 int launchTime;
 bool killPhase;
 bool returnPhase;
 idVec3 destOrg;
 idVec3 orbitOrg;
 int orbitTime;
 int smokeKillTime;
 const idDeclParticle * smokeKill;
};

struct beamTarget_t {
 idEntityPtr<idEntity> target;
 renderEntity_t renderEntity;
 qhandle_t modelDefHandle;
};

class idBFGProjectile : public idProjectile {
public :
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idBFGProjectile> eventCallbacks[];

       idBFGProjectile();
       ~idBFGProjectile();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 virtual void Think( void );
 virtual void Launch( const idVec3 &start, const idVec3 &dir, const idVec3 &pushVelocity, const float timeSinceFire = 0.0f, const float launchPower = 1.0f, const float dmgPower = 1.0f );
 virtual void Explode( const trace_t &collision, idEntity *ignore );

private:
 idList<beamTarget_t> beamTargets;
 renderEntity_t secondModel;
 qhandle_t secondModelDefHandle;
 int nextDamageTime;
 idStr damageFreq;

 void FreeBeams();
 void Event_RemoveBeams();
 void ApplyDamage();
};
# 235 "d:/Data/Nintendo/DoomGX/src/game/Projectile.h"
class idDebris : public idEntity {
public :
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idDebris> eventCallbacks[];

       idDebris();
       ~idDebris();


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

 void Create( idEntity *owner, const idVec3 &start, const idMat3 &axis );
 void Launch( void );
 void Think( void );
 void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );
 void Explode( void );
 void Fizzle( void );
 virtual bool Collide( const trace_t &collision, const idVec3 &velocity );


private:
 idEntityPtr<idEntity> owner;
 idPhysics_RigidBody physicsObj;
 const idDeclParticle * smokeFly;
 int smokeFlyTime;
 const idSoundShader * sndBounce;


 void Event_Explode( void );
 void Event_Fizzle( void );
};
# 724 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Weapon.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Weapon.h"
typedef enum {
 WP_READY,
 WP_OUTOFAMMO,
 WP_RELOAD,
 WP_HOLSTERED,
 WP_RISING,
 WP_LOWERING
} weaponStatus_t;

typedef int ammo_t;
static const int AMMO_NUMTYPES = 16;

class idPlayer;

static const int LIGHTID_WORLD_MUZZLE_FLASH = 1;
static const int LIGHTID_VIEW_MUZZLE_FLASH = 100;

class idMoveableItem;

class idWeapon : public idAnimatedEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idWeapon> eventCallbacks[];

       idWeapon();
 virtual ~idWeapon();


 void Spawn( void );
 void SetOwner( idPlayer *owner );
 idPlayer* GetOwner( void );
 virtual bool ShouldConstructScriptObjectAtSpawn( void ) const;

 static void CacheWeapon( const char *weaponName );


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );


 void Clear( void );
 void GetWeaponDef( const char *objectname, int ammoinclip );
 bool IsLinked( void );
 bool IsWorldModelReady( void );


 const char * Icon( void ) const;
 void UpdateGUI( void );

 virtual void SetModel( const char *modelname );
 bool GetGlobalJointTransform( bool viewModel, const jointHandle_t jointHandle, idVec3 &offset, idMat3 &axis );
 void SetPushVelocity( const idVec3 &pushVelocity );
 bool UpdateSkin( void );


 void Think( void );
 void Raise( void );
 void PutAway( void );
 void Reload( void );
 void LowerWeapon( void );
 void RaiseWeapon( void );
 void HideWeapon( void );
 void ShowWeapon( void );
 void HideWorldModel( void );
 void ShowWorldModel( void );
 void OwnerDied( void );
 void BeginAttack( void );
 void EndAttack( void );
 bool IsReady( void ) const;
 bool IsReloading( void ) const;
 bool IsHolstered( void ) const;
 bool ShowCrosshair( void ) const;
 idEntity * DropItem( const idVec3 &velocity, int activateDelay, int removeDelay, bool died );
 bool CanDrop( void ) const;
 void WeaponStolen( void );


 virtual idThread * ConstructScriptObject( void );
 virtual void DeconstructScriptObject( void );
 void SetState( const char *statename, int blendFrames );
 void UpdateScript( void );
 void EnterCinematic( void );
 void ExitCinematic( void );
 void NetCatchup( void );


 void PresentWeapon( bool showViewModel );
 int GetZoomFov( void );
 void GetWeaponAngleOffsets( int *average, float *scale, float *max );
 void GetWeaponTimeOffsets( float *time, float *scale );
 bool BloodSplat( float size );


 static ammo_t GetAmmoNumForName( const char *ammoname );
 static const char *GetAmmoNameForNum( ammo_t ammonum );
 static const char *GetAmmoPickupNameForNum( ammo_t ammonum );
 ammo_t GetAmmoType( void ) const;
 int AmmoAvailable( void ) const;
 int AmmoInClip( void ) const;
 void ResetAmmoClip( void );
 int ClipSize( void ) const;
 int LowAmmo( void ) const;
 int AmmoRequired( void ) const;

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

 enum {
  EVENT_RELOAD = idEntity::EVENT_MAXEVENTS,
  EVENT_ENDRELOAD,
  EVENT_CHANGESKIN,
  EVENT_MAXEVENTS
 };
 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );

 virtual void ClientPredictionThink( void );

private:

 idScriptBool WEAPON_ATTACK;
 idScriptBool WEAPON_RELOAD;
 idScriptBool WEAPON_NETRELOAD;
 idScriptBool WEAPON_NETENDRELOAD;
 idScriptBool WEAPON_NETFIRING;
 idScriptBool WEAPON_RAISEWEAPON;
 idScriptBool WEAPON_LOWERWEAPON;
 weaponStatus_t status;
 idThread * thread;
 idStr state;
 idStr idealState;
 int animBlendFrames;
 int animDoneTime;
 bool isLinked;


 idEntity *projectileEnt;

 idPlayer * owner;
 idEntityPtr<idAnimatedEntity> worldModel;


 int hideTime;
 float hideDistance;
 int hideStartTime;
 float hideStart;
 float hideEnd;
 float hideOffset;
 bool hide;
 bool disabled;


 int berserk;


 idVec3 playerViewOrigin;
 idMat3 playerViewAxis;


 idVec3 viewWeaponOrigin;
 idMat3 viewWeaponAxis;


 idVec3 muzzleOrigin;
 idMat3 muzzleAxis;

 idVec3 pushVelocity;




 const idDeclEntityDef * weaponDef;
 const idDeclEntityDef * meleeDef;
 idDict projectileDict;
 float meleeDistance;
 idStr meleeDefName;
 idDict brassDict;
 int brassDelay;
 idStr icon;


 renderLight_t guiLight;
 int guiLightHandle;


 renderLight_t muzzleFlash;
 int muzzleFlashHandle;

 renderLight_t worldMuzzleFlash;
 int worldMuzzleFlashHandle;

 idVec3 flashColor;
 int muzzleFlashEnd;
 int flashTime;
 bool lightOn;
 bool silent_fire;
 bool allowDrop;


 bool hasBloodSplat;


 int kick_endtime;
 int muzzle_kick_time;
 int muzzle_kick_maxtime;
 idAngles muzzle_kick_angles;
 idVec3 muzzle_kick_offset;


 ammo_t ammoType;
 int ammoRequired;
 int clipSize;
 int ammoClip;
 int lowAmmo;
 bool powerAmmo;


 bool isFiring;


    int zoomFov;


 jointHandle_t barrelJointView;
 jointHandle_t flashJointView;
 jointHandle_t ejectJointView;
 jointHandle_t guiLightJointView;
 jointHandle_t ventLightJointView;

 jointHandle_t flashJointWorld;
 jointHandle_t barrelJointWorld;
 jointHandle_t ejectJointWorld;


 const idSoundShader * sndHum;


 const idDeclParticle * weaponSmoke;
 int weaponSmokeStartTime;
 bool continuousSmoke;
 const idDeclParticle * strikeSmoke;
 int strikeSmokeStartTime;
 idVec3 strikePos;
 idMat3 strikeAxis;
 int nextStrikeFx;


 bool nozzleFx;

 int nozzleFxFade;
 int lastAttack;
 renderLight_t nozzleGlow;
 int nozzleGlowHandle;

 idVec3 nozzleGlowColor;
 const idMaterial * nozzleGlowShader;
 float nozzleGlowRadius;


 int weaponAngleOffsetAverages;
 float weaponAngleOffsetScale;
 float weaponAngleOffsetMax;
 float weaponOffsetTime;
 float weaponOffsetScale;


 void AlertMonsters( void );


 void InitWorldModel( const idDeclEntityDef *def );
 void MuzzleFlashLight( void );
 void MuzzleRise( idVec3 &origin, idMat3 &axis );
 void UpdateNozzleFx( void );
 void UpdateFlashPosition( void );


 void Event_Clear( void );
 void Event_GetOwner( void );
 void Event_WeaponState( const char *statename, int blendFrames );
 void Event_SetWeaponStatus( float newStatus );
 void Event_WeaponReady( void );
 void Event_WeaponOutOfAmmo( void );
 void Event_WeaponReloading( void );
 void Event_WeaponHolstered( void );
 void Event_WeaponRising( void );
 void Event_WeaponLowering( void );
 void Event_UseAmmo( int amount );
 void Event_AddToClip( int amount );
 void Event_AmmoInClip( void );
 void Event_AmmoAvailable( void );
 void Event_TotalAmmoCount( void );
 void Event_ClipSize( void );
 void Event_PlayAnim( int channel, const char *animname );
 void Event_PlayCycle( int channel, const char *animname );
 void Event_AnimDone( int channel, int blendFrames );
 void Event_SetBlendFrames( int channel, int blendFrames );
 void Event_GetBlendFrames( int channel );
 void Event_Next( void );
 void Event_SetSkin( const char *skinname );
 void Event_Flashlight( int enable );
 void Event_GetLightParm( int parmnum );
 void Event_SetLightParm( int parmnum, float value );
 void Event_SetLightParms( float parm0, float parm1, float parm2, float parm3 );
 void Event_LaunchProjectiles( int num_projectiles, float spread, float fuseOffset, float launchPower, float dmgPower );
 void Event_CreateProjectile( void );
 void Event_EjectBrass( void );
 void Event_Melee( void );
 void Event_GetWorldModel( void );
 void Event_AllowDrop( int allow );
 void Event_AutoReload( void );
 void Event_NetReload( void );
 void Event_IsInvisible( void );
 void Event_NetEndReload( void );
};

inline bool idWeapon::IsLinked( void ) {
 return isLinked;
}

inline bool idWeapon::IsWorldModelReady( void ) {
 return ( worldModel.GetEntity() != __null );
}

inline idPlayer* idWeapon::GetOwner( void ) {
 return owner;
}
# 725 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Light.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Light.h"
extern const idEventDef EV_Light_GetLightParm;
extern const idEventDef EV_Light_SetLightParm;
extern const idEventDef EV_Light_SetLightParms;

class idLight : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idLight> eventCallbacks[];

     idLight();
     ~idLight();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void UpdateChangeableSpawnArgs( const idDict *source );
 virtual void Think( void );
 virtual void FreeLightDef( void );
 virtual bool GetPhysicsToSoundTransform( idVec3 &origin, idMat3 &axis );
 void Present( void );

 void SaveState( idDict *args );
 virtual void SetColor( float red, float green, float blue );
 virtual void SetColor( const idVec4 &color );
 virtual void GetColor( idVec3 &out ) const;
 virtual void GetColor( idVec4 &out ) const;
 const idVec3 & GetBaseColor( void ) const { return baseColor; }
 void SetShader( const char *shadername );
 void SetLightParm( int parmnum, float value );
 void SetLightParms( float parm0, float parm1, float parm2, float parm3 );
 void SetRadiusXYZ( float x, float y, float z );
 void SetRadius( float radius );
 void On( void );
 void Off( void );
 void Fade( const idVec4 &to, float fadeTime );
 void FadeOut( float time );
 void FadeIn( float time );
 void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );
 void BecomeBroken( idEntity *activator );
 qhandle_t GetLightDefHandle( void ) const { return lightDefHandle; }
 void SetLightParent( idEntity *lparent ) { lightParent = lparent; }
 void SetLightLevel( void );

 virtual void ShowEditingDialog( void );

 enum {
  EVENT_BECOMEBROKEN = idEntity::EVENT_MAXEVENTS,
  EVENT_MAXEVENTS
 };

 virtual void ClientPredictionThink( void );
 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );
 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );

private:
 renderLight_t renderLight;
 idVec3 localLightOrigin;
 idMat3 localLightAxis;
 qhandle_t lightDefHandle;
 idStr brokenModel;
 int levels;
 int currentLevel;
 idVec3 baseColor;
 bool breakOnTrigger;
 int count;
 int triggercount;
 idEntity * lightParent;
 idVec4 fadeFrom;
 idVec4 fadeTo;
 int fadeStart;
 int fadeEnd;
 bool soundWasPlaying;

private:
 void PresentLightDefChange( void );
 void PresentModelDefChange( void );

 void Event_SetShader( const char *shadername );
 void Event_GetLightParm( int parmnum );
 void Event_SetLightParm( int parmnum, float value );
 void Event_SetLightParms( float parm0, float parm1, float parm2, float parm3 );
 void Event_SetRadiusXYZ( float x, float y, float z );
 void Event_SetRadius( float radius );
 void Event_Hide( void );
 void Event_Show( void );
 void Event_On( void );
 void Event_Off( void );
 void Event_ToggleOnOff( idEntity *activator );
 void Event_SetSoundHandles( void );
 void Event_FadeOut( float time );
 void Event_FadeIn( float time );
};
# 726 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/WorldSpawn.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/WorldSpawn.h"
class idWorldspawn : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idWorldspawn> eventCallbacks[];

     ~idWorldspawn();

 void Spawn( void );

 void Save( idRestoreGame *savefile );
 void Restore( idRestoreGame *savefile );

private:
 void Event_Remove( void );
};
# 727 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Item.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/Item.h"
class idItem : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idItem> eventCallbacks[];

       idItem();
 virtual ~idItem();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 void GetAttributes( idDict &attributes );
 virtual bool GiveToPlayer( idPlayer *player );
 virtual bool Pickup( idPlayer *player );
 virtual void Think( void );
 virtual void Present();

 enum {
  EVENT_PICKUP = idEntity::EVENT_MAXEVENTS,
  EVENT_RESPAWN,
  EVENT_RESPAWNFX,
  EVENT_MAXEVENTS
 };

 virtual void ClientPredictionThink( void );
 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );


 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

private:
 idVec3 orgOrigin;
 bool spin;
 bool pulse;
 bool canPickUp;


 int itemShellHandle;
 const idMaterial * shellMaterial;


 mutable bool inView;
 mutable int inViewTime;
 mutable int lastCycle;
 mutable int lastRenderViewTime;

 bool UpdateRenderEntity( renderEntity_s *renderEntity, const renderView_t *renderView ) const;
 static bool ModelCallback( renderEntity_s *renderEntity, const renderView_t *renderView );

 void Event_DropToFloor( void );
 void Event_Touch( idEntity *other, trace_t *trace );
 void Event_Trigger( idEntity *activator );
 void Event_Respawn( void );
 void Event_RespawnFx( void );
};

class idItemPowerup : public idItem {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idItemPowerup> eventCallbacks[];

       idItemPowerup();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn();
 virtual bool GiveToPlayer( idPlayer *player );

private:
 int time;
 int type;
};

class idObjective : public idItem {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idObjective> eventCallbacks[];

       idObjective();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn();

private:
 idVec3 playerPos;

 void Event_Trigger( idEntity *activator );
 void Event_HideObjective( idEntity *e );
 void Event_GetPlayerPos();
 void Event_CamShot();
};

class idVideoCDItem : public idItem {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idVideoCDItem> eventCallbacks[];

 void Spawn();
 virtual bool GiveToPlayer( idPlayer *player );
};

class idPDAItem : public idItem {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPDAItem> eventCallbacks[];

 virtual bool GiveToPlayer( idPlayer *player );
};

class idMoveableItem : public idItem {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idMoveableItem> eventCallbacks[];

       idMoveableItem();
 virtual ~idMoveableItem();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 virtual void Think( void );
 virtual bool Pickup( idPlayer *player );

 static void DropItems( idAnimatedEntity *ent, const char *type, idList<idEntity *> *list );
 static idEntity * DropItem( const char *classname, const idVec3 &origin, const idMat3 &axis, const idVec3 &velocity, int activateDelay, int removeDelay );

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

private:
 idPhysics_RigidBody physicsObj;
 idClipModel * trigger;
 const idDeclParticle * smoke;
 int smokeTime;

 void Gib( const idVec3 &dir, const char *damageDefName );

 void Event_DropToFloor( void );
 void Event_Gib( const char *damageDefName );
};

class idMoveablePDAItem : public idMoveableItem {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idMoveablePDAItem> eventCallbacks[];

 virtual bool GiveToPlayer( idPlayer *player );
};
# 197 "d:/Data/Nintendo/DoomGX/src/game/Item.h"
class idItemRemover : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idItemRemover> eventCallbacks[];

 void Spawn();
 void RemoveItem( idPlayer *player );

private:
 void Event_Trigger( idEntity *activator );
};

class idObjectiveComplete : public idItemRemover {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idObjectiveComplete> eventCallbacks[];

       idObjectiveComplete();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn();

private:
 idVec3 playerPos;

 void Event_Trigger( idEntity *activator );
 void Event_HideObjective( idEntity *e );
 void Event_GetPlayerPos();
};
# 728 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/PlayerView.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/PlayerView.h"
typedef struct {
 const idMaterial * material;
 float x, y, w, h;
 float s1, t1, s2, t2;
 int finishTime;
 int startFadeTime;
 float driftAmount;
} screenBlob_t;



class idPlayerView {
public:
      idPlayerView();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void SetPlayerEntity( class idPlayer *playerEnt );

 void ClearEffects( void );

 void DamageImpulse( idVec3 localKickDir, const idDict *damageDef );

 void WeaponFireFeedback( const idDict *weaponDef );

 idAngles AngleOffset( void ) const;

 idMat3 ShakeAxis( void ) const;

 void CalculateShake( void );



 void RenderPlayerView( idUserInterface *hud );

 void Fade( idVec4 color, int time );

 void Flash( idVec4 color, int time );

 void AddBloodSpray( float duration );


 void EnableBFGVision( bool b ) { bfgVision = b; };

private:
 void SingleView( idUserInterface *hud, const renderView_t *view );
 void DoubleVision( idUserInterface *hud, const renderView_t *view, int offset );
 void BerserkVision( idUserInterface *hud, const renderView_t *view );
 void InfluenceVision( idUserInterface *hud, const renderView_t *view );
 void ScreenFade();

 screenBlob_t * GetScreenBlob();

 screenBlob_t screenBlobs[8];

 int dvFinishTime;
 const idMaterial * dvMaterial;

 int kickFinishTime;
 idAngles kickAngles;

 bool bfgVision;

 const idMaterial * tunnelMaterial;
 const idMaterial * armorMaterial;
 const idMaterial * berserkMaterial;
 const idMaterial * irGogglesMaterial;
 const idMaterial * bloodSprayMaterial;
 const idMaterial * bfgMaterial;
 const idMaterial * lagoMaterial;
 float lastDamageTime;

 idVec4 fadeColor;
 idVec4 fadeToColor;
 idVec4 fadeFromColor;
 float fadeRate;
 int fadeTime;

 idAngles shakeAng;

 idPlayer * player;
 renderView_t view;
};
# 729 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/PlayerIcon.h" 1
# 32 "d:/Data/Nintendo/DoomGX/src/game/PlayerIcon.h"
typedef enum {
 ICON_LAG,
 ICON_CHAT,
 ICON_NONE
} playerIconType_t;

class idPlayerIcon {
public:

public:
 idPlayerIcon();
 ~idPlayerIcon();

 void Draw( idPlayer *player, jointHandle_t joint );
 void Draw( idPlayer *player, const idVec3 &origin );

public:
 playerIconType_t iconType;
 renderEntity_t renderEnt;
 qhandle_t iconHandle;

public:
 void FreeIcon( void );
 bool CreateIcon( idPlayer* player, playerIconType_t type, const char *mtr, const idVec3 &origin, const idMat3 &axis );
 bool CreateIcon( idPlayer* player, playerIconType_t type, const idVec3 &origin, const idMat3 &axis );
 void UpdateIcon( idPlayer* player, const idVec3 &origin, const idMat3 &axis );

};
# 730 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Player.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Player.h"
extern const idEventDef EV_Player_GetButtons;
extern const idEventDef EV_Player_GetMove;
extern const idEventDef EV_Player_GetViewAngles;
extern const idEventDef EV_Player_EnableWeapon;
extern const idEventDef EV_Player_DisableWeapon;
extern const idEventDef EV_Player_ExitTeleporter;
extern const idEventDef EV_Player_SelectWeapon;
extern const idEventDef EV_SpectatorTouch;

const float THIRD_PERSON_FOCUS_DISTANCE = 512.0f;
const int LAND_DEFLECT_TIME = 150;
const int LAND_RETURN_TIME = 300;
const int FOCUS_TIME = 300;
const int FOCUS_GUI_TIME = 500;

const int MAX_WEAPONS = 16;

const int DEAD_HEARTRATE = 0;
const int LOWHEALTH_HEARTRATE_ADJ = 20;
const int DYING_HEARTRATE = 30;
const int BASE_HEARTRATE = 70;
const int ZEROSTAMINA_HEARTRATE = 115;
const int MAX_HEARTRATE = 130;
const int ZERO_VOLUME = -40;
const int DMG_VOLUME = 5;
const int DEATH_VOLUME = 15;

const int SAVING_THROW_TIME = 5000;

const int ASYNC_PLAYER_INV_AMMO_BITS = idMath::BitsForInteger( 999 );
const int ASYNC_PLAYER_INV_CLIP_BITS = -7;

struct idItemInfo {
 idStr name;
 idStr icon;
};

struct idObjectiveInfo {
 idStr title;
 idStr text;
 idStr screenshot;
};

struct idLevelTriggerInfo {
 idStr levelName;
 idStr triggerName;
};


enum {
 BERSERK = 0,
 INVISIBILITY,
 MEGAHEALTH,
 ADRENALINE,
 MAX_POWERUPS
};


enum {
 SPEED = 0,
 PROJECTILE_DAMAGE,
 MELEE_DAMAGE,
 MELEE_DISTANCE
};


enum {
 INFLUENCE_NONE = 0,
 INFLUENCE_LEVEL1,
 INFLUENCE_LEVEL2,
 INFLUENCE_LEVEL3,
};

class idInventory {
public:
 int maxHealth;
 int weapons;
 int powerups;
 int armor;
 int maxarmor;
 int ammo[ AMMO_NUMTYPES ];
 int clip[ MAX_WEAPONS ];
 int powerupEndTime[ MAX_POWERUPS ];


 int ammoPredictTime;

 int deplete_armor;
 float deplete_rate;
 int deplete_ammount;
 int nextArmorDepleteTime;

 int pdasViewed[4];

 int selPDA;
 int selEMail;
 int selVideo;
 int selAudio;
 bool pdaOpened;
 bool turkeyScore;
 idList<idDict *> items;
 idStrList pdas;
 idStrList pdaSecurity;
 idStrList videos;
 idStrList emails;

 bool ammoPulse;
 bool weaponPulse;
 bool armorPulse;
 int lastGiveTime;

 idList<idLevelTriggerInfo> levelTriggers;

       idInventory() { Clear(); }
       ~idInventory() { Clear(); }


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Clear( void );
 void GivePowerUp( idPlayer *player, int powerup, int msec );
 void ClearPowerUps( void );
 void GetPersistantData( idDict &dict );
 void RestoreInventory( idPlayer *owner, const idDict &dict );
 bool Give( idPlayer *owner, const idDict &spawnArgs, const char *statname, const char *value, int *idealWeapon, bool updateHud );
 void Drop( const idDict &spawnArgs, const char *weapon_classname, int weapon_index );
 ammo_t AmmoIndexForAmmoClass( const char *ammo_classname ) const;
 int MaxAmmoForAmmoClass( idPlayer *owner, const char *ammo_classname ) const;
 int WeaponIndexForAmmoClass( const idDict & spawnArgs, const char *ammo_classname ) const;
 ammo_t AmmoIndexForWeaponClass( const char *weapon_classname, int *ammoRequired );
 const char * AmmoPickupNameForIndex( ammo_t ammonum ) const;
 void AddPickupName( const char *name, const char *icon );

 int HasAmmo( ammo_t type, int amount );
 bool UseAmmo( ammo_t type, int amount );
 int HasAmmo( const char *weapon_classname );

 void UpdateArmor( void );

 int nextItemPickup;
 int nextItemNum;
 int onePickupTime;
 idList<idItemInfo> pickupItemNames;
 idList<idObjectiveInfo> objectiveNames;
};

typedef struct {
 int time;
 idVec3 dir;
} loggedAccel_t;

typedef struct {
 int areaNum;
 idVec3 pos;
} aasLocation_t;

class idPlayer : public idActor {
public:
 enum {
  EVENT_IMPULSE = idEntity::EVENT_MAXEVENTS,
  EVENT_EXIT_TELEPORTER,
  EVENT_ABORT_TELEPORTER,
  EVENT_POWERUP,
  EVENT_SPECTATE,
  EVENT_MAXEVENTS
 };

 usercmd_t usercmd;

 class idPlayerView playerView;

 bool noclip;
 bool godmode;

 bool spawnAnglesSet;
 idAngles spawnAngles;
 idAngles viewAngles;
 idAngles cmdAngles;

 int buttonMask;
 int oldButtons;
 int oldFlags;

 int lastHitTime;
 int lastSndHitTime;
 int lastSavingThrowTime;

 idScriptBool AI_FORWARD;
 idScriptBool AI_BACKWARD;
 idScriptBool AI_STRAFE_LEFT;
 idScriptBool AI_STRAFE_RIGHT;
 idScriptBool AI_ATTACK_HELD;
 idScriptBool AI_WEAPON_FIRED;
 idScriptBool AI_JUMP;
 idScriptBool AI_CROUCH;
 idScriptBool AI_ONGROUND;
 idScriptBool AI_ONLADDER;
 idScriptBool AI_DEAD;
 idScriptBool AI_RUN;
 idScriptBool AI_PAIN;
 idScriptBool AI_HARDLANDING;
 idScriptBool AI_SOFTLANDING;
 idScriptBool AI_RELOAD;
 idScriptBool AI_TELEPORT;
 idScriptBool AI_TURN_LEFT;
 idScriptBool AI_TURN_RIGHT;


 idInventory inventory;

 idEntityPtr<idWeapon> weapon;
 idUserInterface * hud;
 idUserInterface * objectiveSystem;
 bool objectiveSystemOpen;

 int weapon_soulcube;
 int weapon_pda;
 int weapon_fists;

 int heartRate;
 idInterpolate<float> heartInfo;
 int lastHeartAdjust;
 int lastHeartBeat;
 int lastDmgTime;
 int deathClearContentsTime;
 bool doingDeathSkin;
 int lastArmorPulse;
 float stamina;
 float healthPool;
 int nextHealthPulse;
 bool healthPulse;
 bool healthTake;
 int nextHealthTake;


 bool hiddenWeapon;
 idEntityPtr<idProjectile> soulCubeProjectile;


 static idVec3 colorBarTable[ 5 ];
 int spectator;
 idVec3 colorBar;
 int colorBarIndex;
 bool scoreBoardOpen;
 bool forceScoreBoard;
 bool forceRespawn;
 bool spectating;
 int lastSpectateTeleport;
 bool lastHitToggle;
 bool forcedReady;
 bool wantSpectate;
 bool weaponGone;
 bool useInitialSpawns;
 int latchedTeam;
 int tourneyRank;
 int tourneyLine;
 int spawnedTime;

 idEntityPtr<idEntity> teleportEntity;
 int teleportKiller;
 bool lastManOver;
 bool lastManPlayAgain;
 bool lastManPresent;
 bool isLagged;
 bool isChatting;


 int minRespawnTime;
 int maxRespawnTime;



 idVec3 firstPersonViewOrigin;
 idMat3 firstPersonViewAxis;

 idDragEntity dragEntity;

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPlayer> eventCallbacks[];

       idPlayer();
 virtual ~idPlayer();

 void Spawn( void );
 void Think( void );


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Hide( void );
 virtual void Show( void );

 void Init( void );
 void PrepareForRestart( void );
 virtual void Restart( void );
 void LinkScriptVariables( void );
 void SetupWeaponEntity( void );
 void SelectInitialSpawnPoint( idVec3 &origin, idAngles &angles );
 void SpawnFromSpawnSpot( void );
 void SpawnToPoint( const idVec3 &spawn_origin, const idAngles &spawn_angles );
 void SetClipModel( void );

 void SavePersistantInfo( void );
 void RestorePersistantInfo( void );
 void SetLevelTrigger( const char *levelName, const char *triggerName );

 bool UserInfoChanged( bool canModify );
 idDict * GetUserInfo( void );
 bool BalanceTDM( void );

 void CacheWeapons( void );

 void EnterCinematic( void );
 void ExitCinematic( void );
 bool HandleESC( void );
 bool SkipCinematic( void );

 void UpdateConditions( void );
 void SetViewAngles( const idAngles &angles );


 void UpdateDeltaViewAngles( const idAngles &angles );

 virtual bool Collide( const trace_t &collision, const idVec3 &velocity );

 virtual void GetAASLocation( idAAS *aas, idVec3 &pos, int &areaNum ) const;
 virtual void GetAIAimTargets( const idVec3 &lastSightPos, idVec3 &headPos, idVec3 &chestPos );
 virtual void DamageFeedback( idEntity *victim, idEntity *inflictor, int &damage );
 void CalcDamagePoints( idEntity *inflictor, idEntity *attacker, const idDict *damageDef,
          const float damageScale, const int location, int *health, int *armor );
 virtual void Damage( idEntity *inflictor, idEntity *attacker, const idVec3 &dir, const char *damageDefName, const float damageScale, const int location );


 virtual void Teleport( const idVec3 &origin, const idAngles &angles, idEntity *destination );

 void Kill( bool delayRespawn, bool nodamage );
 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );
 void StartFxOnBone(const char *fx, const char *bone);

 renderView_t * GetRenderView( void );
 void CalculateRenderView( void );
 void CalculateFirstPersonView( void );

 void DrawHUD( idUserInterface *hud );

 void WeaponFireFeedback( const idDict *weaponDef );

 float DefaultFov( void ) const;
 float CalcFov( bool honorZoom );
 void CalculateViewWeaponPos( idVec3 &origin, idMat3 &axis );
 idVec3 GetEyePosition( void ) const;
 void GetViewPos( idVec3 &origin, idMat3 &axis ) const;
 void OffsetThirdPersonView( float angle, float range, float height, bool clip );

 bool Give( const char *statname, const char *value );
 bool GiveItem( idItem *item );
 void GiveItem( const char *name );
 void GiveHealthPool( float amt );

 bool GiveInventoryItem( idDict *item );
 void RemoveInventoryItem( idDict *item );
 bool GiveInventoryItem( const char *name );
 void RemoveInventoryItem( const char *name );
 idDict * FindInventoryItem( const char *name );

 void GivePDA( const char *pdaName, idDict *item );
 void GiveVideo( const char *videoName, idDict *item );
 void GiveEmail( const char *emailName );
 void GiveSecurity( const char *security );
 void GiveObjective( const char *title, const char *text, const char *screenshot );
 void CompleteObjective( const char *title );

 bool GivePowerUp( int powerup, int time );
 void ClearPowerUps( void );
 bool PowerUpActive( int powerup ) const;
 float PowerUpModifier( int type );

 int SlotForWeapon( const char *weaponName );
 void Reload( void );
 void NextWeapon( void );
 void NextBestWeapon( void );
 void PrevWeapon( void );
 void SelectWeapon( int num, bool force );
 void DropWeapon( bool died ) ;
 void StealWeapon( idPlayer *player );
 void AddProjectilesFired( int count );
 void AddProjectileHits( int count );
 void SetLastHitTime( int time );
 void LowerWeapon( void );
 void RaiseWeapon( void );
 void WeaponLoweringCallback( void );
 void WeaponRisingCallback( void );
 void RemoveWeapon( const char *weap );
 bool CanShowWeaponViewmodel( void ) const;

 void AddAIKill( void );
 void SetSoulCubeProjectile( idProjectile *projectile );

 void AdjustHeartRate( int target, float timeInSecs, float delay, bool force );
 void SetCurrentHeartRate( void );
 int GetBaseHeartRate( void );
 void UpdateAir( void );

 virtual bool HandleSingleGuiCommand( idEntity *entityGui, idLexer *src );
 bool GuiActive( void ) { return focusGUIent != __null; }

 void PerformImpulse( int impulse );
 void Spectate( bool spectate );
 void TogglePDA( void );
 void ToggleScoreboard( void );
 void RouteGuiMouse( idUserInterface *gui );
 void UpdateHud( void );
 const idDeclPDA * GetPDA( void ) const;
 const idDeclVideo * GetVideo( int index );
 void SetInfluenceFov( float fov );
 void SetInfluenceView( const char *mtr, const char *skinname, float radius, idEntity *ent );
 void SetInfluenceLevel( int level );
 int GetInfluenceLevel( void ) { return influenceActive; };
 void SetPrivateCameraView( idCamera *camView );
 idCamera * GetPrivateCameraView( void ) const { return privateCameraView; }
 void StartFxFov( float duration );
 void UpdateHudWeapon( bool flashWeapon = true );
 void UpdateHudStats( idUserInterface *hud );
 void UpdateHudAmmo( idUserInterface *hud );
 void Event_StopAudioLog( void );
 void StartAudioLog( void );
 void StopAudioLog( void );
 void ShowTip( const char *title, const char *tip, bool autoHide );
 void HideTip( void );
 bool IsTipVisible( void ) { return tipUp; };
 void ShowObjective( const char *obj );
 void HideObjective( void );

 virtual void ClientPredictionThink( void );
 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );
 void WritePlayerStateToSnapshot( idBitMsgDelta &msg ) const;
 void ReadPlayerStateFromSnapshot( const idBitMsgDelta &msg );

 virtual bool ServerReceiveEvent( int event, int time, const idBitMsg &msg );

 virtual bool GetPhysicsToVisualTransform( idVec3 &origin, idMat3 &axis );
 virtual bool GetPhysicsToSoundTransform( idVec3 &origin, idMat3 &axis );

 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );
 bool IsReady( void );
 bool IsRespawning( void );
 bool IsInTeleport( void );

 idEntity *GetInfluenceEntity( void ) { return influenceEntity; };
 const idMaterial *GetInfluenceMaterial( void ) { return influenceMaterial; };
 float GetInfluenceRadius( void ) { return influenceRadius; };


 void ServerSpectate( bool spectate );

 idPhysics *GetPlayerPhysics( void );
 void TeleportDeath( int killer );
 void SetLeader( bool lead );
 bool IsLeader( void );

 void UpdateSkinSetup( bool restart );

 bool OnLadder( void ) const;

 virtual void UpdatePlayerIcons( void );
 virtual void DrawPlayerIcons( void );
 virtual void HidePlayerIcons( void );
 bool NeedsIcon( void );

 bool SelfSmooth( void );
 void SetSelfSmooth( bool b );

private:
 jointHandle_t hipJoint;
 jointHandle_t chestJoint;
 jointHandle_t headJoint;

 idPhysics_Player physicsObj;

 idList<aasLocation_t> aasLocation;

 int bobFoot;
 float bobFrac;
 float bobfracsin;
 int bobCycle;
 float xyspeed;
 int stepUpTime;
 float stepUpDelta;
 float idealLegsYaw;
 float legsYaw;
 bool legsForward;
 float oldViewYaw;
 idAngles viewBobAngles;
 idVec3 viewBob;
 int landChange;
 int landTime;

 int currentWeapon;
 int idealWeapon;
 int previousWeapon;
 int weaponSwitchTime;
 bool weaponEnabled;
 bool showWeaponViewModel;

 const idDeclSkin * skin;
 const idDeclSkin * powerUpSkin;
 idStr baseSkinName;

 int numProjectilesFired;
 int numProjectileHits;

 bool airless;
 int airTics;
 int lastAirDamage;

 bool gibDeath;
 bool gibsLaunched;
 idVec3 gibsDir;

 idInterpolate<float> zoomFov;
 idInterpolate<float> centerView;
 bool fxFov;

 float influenceFov;
 int influenceActive;
 idEntity * influenceEntity;
 const idMaterial * influenceMaterial;
 float influenceRadius;
 const idDeclSkin * influenceSkin;

 idCamera * privateCameraView;

 static const int NUM_LOGGED_VIEW_ANGLES = 64;
 idAngles loggedViewAngles[NUM_LOGGED_VIEW_ANGLES];
 static const int NUM_LOGGED_ACCELS = 16;
 loggedAccel_t loggedAccel[NUM_LOGGED_ACCELS];
 int currentLoggedAccel;


 idEntity * focusGUIent;
 idUserInterface * focusUI;
 idAI * focusCharacter;
 int talkCursor;
 int focusTime;
 idAFEntity_Vehicle * focusVehicle;
 idUserInterface * cursor;


 int oldMouseX;
 int oldMouseY;

 idStr pdaAudio;
 idStr pdaVideo;
 idStr pdaVideoWave;

 bool tipUp;
 bool objectiveUp;

 int lastDamageDef;
 idVec3 lastDamageDir;
 int lastDamageLocation;
 int smoothedFrame;
 bool smoothedOriginUpdated;
 idVec3 smoothedOrigin;
 idAngles smoothedAngles;


 bool ready;
 bool respawning;
 bool leader;
 int lastSpectateChange;
 int lastTeleFX;
 unsigned int lastSnapshotSequence;
 bool weaponCatchup;
 int MPAim;
 int lastMPAim;
 int lastMPAimTime;
 int MPAimFadeTime;
 bool MPAimHighlight;
 bool isTelefragged;

 idPlayerIcon playerIcon;

 bool selfSmooth;

 void LookAtKiller( idEntity *inflictor, idEntity *attacker );

 void StopFiring( void );
 void FireWeapon( void );
 void Weapon_Combat( void );
 void Weapon_NPC( void );
 void Weapon_GUI( void );
 void UpdateWeapon( void );
 void UpdateSpectating( void );
 void SpectateFreeFly( bool force );
 void SpectateCycle( void );
 idAngles GunTurningOffset( void );
 idVec3 GunAcceleratingOffset( void );

 void UseObjects( void );
 void CrashLand( const idVec3 &oldOrigin, const idVec3 &oldVelocity );
 void BobCycle( const idVec3 &pushVelocity );
 void UpdateViewAngles( void );
 void EvaluateControls( void );
 void AdjustSpeed( void );
 void AdjustBodyAngles( void );
 void InitAASLocation( void );
 void SetAASLocation( void );
 void Move( void );
 void UpdatePowerUps( void );
 void UpdateDeathSkin( bool state_hitch );
 void ClearPowerup( int i );
 void SetSpectateOrigin( void );

 void ClearFocus( void );
 void UpdateFocus( void );
 void UpdateLocation( void );
 idUserInterface * ActiveGui( void );
 void UpdatePDAInfo( bool updatePDASel );
 int AddGuiPDAData( const declType_t dataType, const char *listName, const idDeclPDA *src, idUserInterface *gui );
 void ExtractEmailInfo( const idStr &email, const char *scan, idStr &out );
 void UpdateObjectiveInfo( void );

 void UseVehicle( void );

 void Event_GetButtons( void );
 void Event_GetMove( void );
 void Event_GetViewAngles( void );
 void Event_StopFxFov( void );
 void Event_EnableWeapon( void );
 void Event_DisableWeapon( void );
 void Event_GetCurrentWeapon( void );
 void Event_GetPreviousWeapon( void );
 void Event_SelectWeapon( const char *weaponName );
 void Event_GetWeaponEntity( void );
 void Event_OpenPDA( void );
 void Event_PDAAvailable( void );
 void Event_InPDA( void );
 void Event_ExitTeleporter( void );
 void Event_HideTip( void );
 void Event_LevelTrigger( void );
 void Event_Gibbed( void );
 void Event_GetIdealWeapon( void );
};

inline bool idPlayer::IsReady( void ) {
 return ready || forcedReady;
}

inline bool idPlayer::IsRespawning( void ) {
 return respawning;
}

inline idPhysics* idPlayer::GetPlayerPhysics( void ) {
 return &physicsObj;
}

inline bool idPlayer::IsInTeleport( void ) {
 return ( teleportEntity.GetEntity() != __null );
}

inline void idPlayer::SetLeader( bool lead ) {
 leader = lead;
}

inline bool idPlayer::IsLeader( void ) {
 return leader;
}

inline bool idPlayer::SelfSmooth( void ) {
 return selfSmooth;
}

inline void idPlayer::SetSelfSmooth( bool b ) {
 selfSmooth = b;
}
# 731 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Mover.h" 1
# 32 "d:/Data/Nintendo/DoomGX/src/game/Mover.h"
extern const idEventDef EV_TeamBlocked;
extern const idEventDef EV_PartBlocked;
extern const idEventDef EV_ReachedPos;
extern const idEventDef EV_ReachedAng;
# 45 "d:/Data/Nintendo/DoomGX/src/game/Mover.h"
class idMover : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idMover> eventCallbacks[];

       idMover( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

 virtual void Hide( void );
 virtual void Show( void );

 void SetPortalState( bool open );

protected:
 typedef enum {
  ACCELERATION_STAGE,
  LINEAR_STAGE,
  DECELERATION_STAGE,
  FINISHED_STAGE
 } moveStage_t;

 typedef enum {
  MOVER_NONE,
  MOVER_ROTATING,
  MOVER_MOVING,
  MOVER_SPLINE
 } moverCommand_t;




 typedef enum {
  DIR_UP = -1,
  DIR_DOWN = -2,
  DIR_LEFT = -3,
  DIR_RIGHT = -4,
  DIR_FORWARD = -5,
  DIR_BACK = -6,
  DIR_REL_UP = -7,
  DIR_REL_DOWN = -8,
  DIR_REL_LEFT = -9,
  DIR_REL_RIGHT = -10,
  DIR_REL_FORWARD = -11,
  DIR_REL_BACK = -12
 } moverDir_t;

 typedef struct {
  moveStage_t stage;
  int acceleration;
  int movetime;
  int deceleration;
  idVec3 dir;
 } moveState_t;

 typedef struct {
  moveStage_t stage;
  int acceleration;
  int movetime;
  int deceleration;
  idAngles rot;
 } rotationState_t;

 idPhysics_Parametric physicsObj;

 void Event_OpenPortal( void );
 void Event_ClosePortal( void );
 void Event_PartBlocked( idEntity *blockingEntity );

 void MoveToPos( const idVec3 &pos);
 void UpdateMoveSound( moveStage_t stage );
 void UpdateRotationSound( moveStage_t stage );
 void SetGuiStates( const char *state );
 void FindGuiTargets( void );
 void SetGuiState( const char *key, const char *val ) const;

 virtual void DoneMoving( void );
 virtual void DoneRotating( void );
 virtual void BeginMove( idThread *thread = __null );
 virtual void BeginRotation( idThread *thread, bool stopwhendone );
 moveState_t move;

private:
 rotationState_t rot;

 int move_thread;
 int rotate_thread;
 idAngles dest_angles;
 idAngles angle_delta;
 idVec3 dest_position;
 idVec3 move_delta;
 float move_speed;
 int move_time;
 int deceltime;
 int acceltime;
 bool stopRotation;
 bool useSplineAngles;
 idEntityPtr<idEntity> splineEnt;
 moverCommand_t lastCommand;
 float damage;

 qhandle_t areaPortal;

 idList< idEntityPtr<idEntity> > guiTargets;

 void VectorForDir( float dir, idVec3 &vec );
 idCurve_Spline<idVec3> *GetSpline( idEntity *splineEntity ) const;

 void Event_SetCallback( void );
 void Event_TeamBlocked( idEntity *blockedPart, idEntity *blockingEntity );
 void Event_StopMoving( void );
 void Event_StopRotating( void );
 void Event_UpdateMove( void );
 void Event_UpdateRotation( void );
 void Event_SetMoveSpeed( float speed );
 void Event_SetMoveTime( float time );
 void Event_SetDecelerationTime( float time );
 void Event_SetAccellerationTime( float time );
 void Event_MoveTo( idEntity *ent );
 void Event_MoveToPos( idVec3 &pos );
 void Event_MoveDir( float angle, float distance );
 void Event_MoveAccelerateTo( float speed, float time );
 void Event_MoveDecelerateTo( float speed, float time );
 void Event_RotateDownTo( int axis, float angle );
 void Event_RotateUpTo( int axis, float angle );
 void Event_RotateTo( idAngles &angles );
 void Event_Rotate( idAngles &angles );
 void Event_RotateOnce( idAngles &angles );
 void Event_Bob( float speed, float phase, idVec3 &depth );
 void Event_Sway( float speed, float phase, idAngles &depth );
 void Event_SetAccelSound( const char *sound );
 void Event_SetDecelSound( const char *sound );
 void Event_SetMoveSound( const char *sound );
 void Event_FindGuiTargets( void );
 void Event_InitGuiTargets( void );
 void Event_EnableSplineAngles( void );
 void Event_DisableSplineAngles( void );
 void Event_RemoveInitialSplineAngles( void );
 void Event_StartSpline( idEntity *splineEntity );
 void Event_StopSpline( void );
 void Event_Activate( idEntity *activator );
 void Event_PostRestore( int start, int total, int accel, int decel, int useSplineAng );
 void Event_IsMoving( void );
 void Event_IsRotating( void );
};

class idSplinePath : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idSplinePath> eventCallbacks[];

       idSplinePath();

 void Spawn( void );
};


struct floorInfo_s {
 idVec3 pos;
 idStr door;
 int floor;
};

class idElevator : public idMover {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idElevator> eventCallbacks[];

       idElevator( void );

 void Spawn();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual bool HandleSingleGuiCommand( idEntity *entityGui, idLexer *src );
 void Event_GotoFloor( int floor );
 floorInfo_s * GetFloorInfo( int floor );

protected:
 virtual void DoneMoving( void );
 virtual void BeginMove( idThread *thread = __null );
 void SpawnTrigger( const idVec3 &pos );
 void GetLocalTriggerPosition();
 void Event_Touch( idEntity *other, trace_t *trace );

private:
 typedef enum {
  INIT,
  IDLE,
  WAITING_ON_DOORS
 } elevatorState_t;

 elevatorState_t state;
 idList<floorInfo_s> floorInfo;
 int currentFloor;
 int pendingFloor;
 int lastFloor;
 bool controlsDisabled;
 float returnTime;
 int returnFloor;
 int lastTouchTime;

 class idDoor * GetDoor( const char *name );
 void Think( void );
 void OpenInnerDoor( void );
 void OpenFloorDoor( int floor );
 void CloseAllDoors( void );
 void DisableAllDoors( void );
 void EnableProperDoors( void );

 void Event_TeamBlocked( idEntity *blockedEntity, idEntity *blockingEntity );
 void Event_Activate( idEntity *activator );
 void Event_PostFloorArrival();

};
# 276 "d:/Data/Nintendo/DoomGX/src/game/Mover.h"
typedef enum {
 MOVER_POS1,
 MOVER_POS2,
 MOVER_1TO2,
 MOVER_2TO1
} moverState_t;

class idMover_Binary : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idMover_Binary> eventCallbacks[];

       idMover_Binary();
       ~idMover_Binary();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void PreBind( void );
 virtual void PostBind( void );

 void Enable( bool b );
 void InitSpeed( idVec3 &mpos1, idVec3 &mpos2, float mspeed, float maccelTime, float mdecelTime );
 void InitTime( idVec3 &mpos1, idVec3 &mpos2, float mtime, float maccelTime, float mdecelTime );
 void GotoPosition1( void );
 void GotoPosition2( void );
 void Use_BinaryMover( idEntity *activator );
 void SetGuiStates( const char *state );
 void UpdateBuddies( int val );
 idMover_Binary * GetActivateChain( void ) const { return activateChain; }
 idMover_Binary * GetMoveMaster( void ) const { return moveMaster; }
 void BindTeam( idEntity *bindTo );
 void SetBlocked( bool b );
 bool IsBlocked( void );
 idEntity * GetActivator( void ) const;

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

 void SetPortalState( bool open );

protected:
 idVec3 pos1;
 idVec3 pos2;
 moverState_t moverState;
 idMover_Binary * moveMaster;
 idMover_Binary * activateChain;
 int soundPos1;
 int sound1to2;
 int sound2to1;
 int soundPos2;
 int soundLoop;
 float wait;
 float damage;
 int duration;
 int accelTime;
 int decelTime;
 idEntityPtr<idEntity> activatedBy;
 int stateStartTime;
 idStr team;
 bool enabled;
 int move_thread;
 int updateStatus;
 idStrList buddies;
 idPhysics_Parametric physicsObj;
 qhandle_t areaPortal;
 bool blocked;
 idList< idEntityPtr<idEntity> > guiTargets;

 void MatchActivateTeam( moverState_t newstate, int time );
 void JoinActivateTeam( idMover_Binary *master );

 void UpdateMoverSound( moverState_t state );
 void SetMoverState( moverState_t newstate, int time );
 moverState_t GetMoverState( void ) const { return moverState; }
 void FindGuiTargets( void );
 void SetGuiState( const char *key, const char *val ) const;

 void Event_SetCallback( void );
 void Event_ReturnToPos1( void );
 void Event_Use_BinaryMover( idEntity *activator );
 void Event_Reached_BinaryMover( void );
 void Event_MatchActivateTeam( moverState_t newstate, int time );
 void Event_Enable( void );
 void Event_Disable( void );
 void Event_OpenPortal( void );
 void Event_ClosePortal( void );
 void Event_FindGuiTargets( void );
 void Event_InitGuiTargets( void );

 static void GetMovedir( float dir, idVec3 &movedir );
};

class idDoor : public idMover_Binary {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idDoor> eventCallbacks[];

       idDoor( void );
       ~idDoor( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );
 virtual void PreBind( void );
 virtual void PostBind( void );
 virtual void Hide( void );
 virtual void Show( void );

 bool IsOpen( void );
 bool IsNoTouch( void );
 int IsLocked( void );
 void Lock( int f );
 void Use( idEntity *other, idEntity *activator );
 void Close( void );
 void Open( void );
 void SetCompanion( idDoor *door );

private:
 float triggersize;
 bool crusher;
 bool noTouch;
 bool aas_area_closed;
 idStr buddyStr;
 idClipModel * trigger;
 idClipModel * sndTrigger;
 int nextSndTriggerTime;
 idVec3 localTriggerOrigin;
 idMat3 localTriggerAxis;
 idStr requires;
 int removeItem;
 idStr syncLock;
 int normalAxisIndex;
 idDoor * companionDoor;

 void SetAASAreaState( bool closed );

 void GetLocalTriggerPosition( const idClipModel *trigger );
 void CalcTriggerBounds( float size, idBounds &bounds );

 void Event_Reached_BinaryMover( void );
 void Event_TeamBlocked( idEntity *blockedEntity, idEntity *blockingEntity );
 void Event_PartBlocked( idEntity *blockingEntity );
 void Event_Touch( idEntity *other, trace_t *trace );
 void Event_Activate( idEntity *activator );
 void Event_StartOpen( void );
 void Event_SpawnDoorTrigger( void );
 void Event_SpawnSoundTrigger( void );
 void Event_Close( void );
 void Event_Open( void );
 void Event_Lock( int f );
 void Event_IsOpen( void );
 void Event_Locked( void );
 void Event_SpectatorTouch( idEntity *other, trace_t *trace );
 void Event_OpenPortal( void );
 void Event_ClosePortal( void );
};

class idPlat : public idMover_Binary {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPlat> eventCallbacks[];

       idPlat( void );
       ~idPlat( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );
 virtual void PreBind( void );
 virtual void PostBind( void );

private:
 idClipModel * trigger;
 idVec3 localTriggerOrigin;
 idMat3 localTriggerAxis;

 void GetLocalTriggerPosition( const idClipModel *trigger );
 void SpawnPlatTrigger( idVec3 &pos );

 void Event_TeamBlocked( idEntity *blockedEntity, idEntity *blockingEntity );
 void Event_PartBlocked( idEntity *blockingEntity );
 void Event_Touch( idEntity *other, trace_t *trace );
};
# 475 "d:/Data/Nintendo/DoomGX/src/game/Mover.h"
class idMover_Periodic : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idMover_Periodic> eventCallbacks[];

       idMover_Periodic( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

protected:
 idPhysics_Parametric physicsObj;
 float damage;

 void Event_TeamBlocked( idEntity *blockedEntity, idEntity *blockingEntity );
 void Event_PartBlocked( idEntity *blockingEntity );
};

class idRotater : public idMover_Periodic {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idRotater> eventCallbacks[];

       idRotater( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 idEntityPtr<idEntity> activatedBy;

 void Event_Activate( idEntity *activator );
};

class idBobber : public idMover_Periodic {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idBobber> eventCallbacks[];

       idBobber( void );

 void Spawn( void );

private:
};

class idPendulum : public idMover_Periodic {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idPendulum> eventCallbacks[];

       idPendulum( void );

 void Spawn( void );

private:
};

class idRiser : public idMover_Periodic {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idRiser> eventCallbacks[];

 idRiser( void );

 void Spawn( void );

private:
 void Event_Activate( idEntity *activator );
};
# 732 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Camera.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/Camera.h"
class idCamera : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idCamera> eventCallbacks[];

 void Spawn( void );
 virtual void GetViewParms( renderView_t *view ) = 0;
 virtual renderView_t * GetRenderView();
 virtual void Stop( void ){} ;
};
# 59 "d:/Data/Nintendo/DoomGX/src/game/Camera.h"
class idCameraView : public idCamera {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idCameraView> eventCallbacks[];
       idCameraView();


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( );
 virtual void GetViewParms( renderView_t *view );
 virtual void Stop( void );

protected:
 void Event_Activate( idEntity *activator );
 void Event_SetAttachments();
 void SetAttachment( idEntity **e, const char *p );
 float fov;
 idEntity *attachedTo;
 idEntity *attachedView;
};
# 91 "d:/Data/Nintendo/DoomGX/src/game/Camera.h"
typedef struct {
 idCQuat q;
 idVec3 t;
 float fov;
} cameraFrame_t;

class idCameraAnim : public idCamera {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idCameraAnim> eventCallbacks[];

       idCameraAnim();
       ~idCameraAnim();


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 virtual void GetViewParms( renderView_t *view );

private:
 int threadNum;
 idVec3 offset;
 int frameRate;
 int starttime;
 int cycle;
 idList<int> cameraCuts;
 idList<cameraFrame_t> camera;
 idEntityPtr<idEntity> activator;

 void Start( void );
 void Stop( void );
 void Think( void );

 void LoadAnim( void );
 void Event_Start( void );
 void Event_Stop( void );
 void Event_SetCallback( void );
 void Event_Activate( idEntity *activator );
};
# 733 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Moveable.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Moveable.h"
extern const idEventDef EV_BecomeNonSolid;
extern const idEventDef EV_IsAtRest;

class idMoveable : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idMoveable> eventCallbacks[];

       idMoveable( void );
       ~idMoveable( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

 virtual void Hide( void );
 virtual void Show( void );

 bool AllowStep( void ) const;
 void EnableDamage( bool enable, float duration );
 virtual bool Collide( const trace_t &collision, const idVec3 &velocity );
 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );
 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );

protected:
 idPhysics_RigidBody physicsObj;
 idStr brokenModel;
 idStr damage;
 idStr fxCollide;
 int nextCollideFxTime;
 float minDamageVelocity;
 float maxDamageVelocity;
 idCurve_Spline<idVec3> *initialSpline;
 idVec3 initialSplineDir;
 bool explode;
 bool unbindOnDeath;
 bool allowStep;
 bool canDamage;
 int nextDamageTime;
 int nextSoundTime;

 const idMaterial * GetRenderModelMaterial( void ) const;
 void BecomeNonSolid( void );
 void InitInitialSpline( int startTime );
 bool FollowInitialSplinePath( void );

 void Event_Activate( idEntity *activator );
 void Event_BecomeNonSolid( void );
 void Event_SetOwnerFromSpawnArgs( void );
 void Event_IsAtRest( void );
 void Event_EnableDamage( float enable );
};
# 106 "d:/Data/Nintendo/DoomGX/src/game/Moveable.h"
class idBarrel : public idMoveable {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idBarrel> eventCallbacks[];
       idBarrel();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void BarrelThink( void );
 virtual void Think( void );
 virtual bool GetPhysicsToVisualTransform( idVec3 &origin, idMat3 &axis );
 virtual void ClientPredictionThink( void );

private:
 float radius;
 int barrelAxis;
 idVec3 lastOrigin;
 idMat3 lastAxis;
 float additionalRotation;
 idMat3 additionalAxis;
};
# 142 "d:/Data/Nintendo/DoomGX/src/game/Moveable.h"
class idExplodingBarrel : public idBarrel {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idExplodingBarrel> eventCallbacks[];

       idExplodingBarrel();
       ~idExplodingBarrel();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );
 virtual void Damage( idEntity *inflictor, idEntity *attacker, const idVec3 &dir,
        const char *damageDefName, const float damageScale, const int location );
 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );
 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );

 enum {
  EVENT_EXPLODE = idEntity::EVENT_MAXEVENTS,
  EVENT_MAXEVENTS
 };

private:
 typedef enum {
  NORMAL = 0,
  BURNING,
  BURNEXPIRED,
  EXPLODING
 } explode_state_t;
 explode_state_t state;

 idVec3 spawnOrigin;
 idMat3 spawnAxis;
 qhandle_t particleModelDefHandle;
 qhandle_t lightDefHandle;
 renderEntity_t particleRenderEntity;
 renderLight_t light;
 int particleTime;
 int lightTime;
 float time;

 void AddParticles( const char *name, bool burn );
 void AddLight( const char *name , bool burn );
 void ExplodingEffects( void );

 void Event_Activate( idEntity *activator );
 void Event_Respawn();
 void Event_Explode();
 void Event_TriggerTargets();
};
# 734 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Target.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget> eventCallbacks[];
};
# 55 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_Remove : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_Remove> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 72 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_Show : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_Show> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 89 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_Damage : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_Damage> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 106 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SessionCommand : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SessionCommand> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 123 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_EndLevel : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_EndLevel> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );

};
# 141 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_WaitForButton : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_WaitForButton> eventCallbacks[];

 void Think( void );

private:
 void Event_Activate( idEntity *activator );
};
# 159 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SetGlobalShaderTime : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SetGlobalShaderTime> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 176 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SetShaderParm : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SetShaderParm> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 193 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SetShaderTime : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SetShaderTime> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 209 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_FadeEntity : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_FadeEntity> eventCallbacks[];

      idTarget_FadeEntity( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Think( void );

private:
 idVec4 fadeFrom;
 int fadeStart;
 int fadeEnd;

 void Event_Activate( idEntity *activator );
};
# 236 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_LightFadeIn : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_LightFadeIn> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 252 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_LightFadeOut : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_LightFadeOut> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 268 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_Give : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_Give> eventCallbacks[];

 void Spawn( void );

private:
 void Event_Activate( idEntity *activator );
};
# 287 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_GiveEmail : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_GiveEmail> eventCallbacks[];

 void Spawn( void );

private:
 void Event_Activate( idEntity *activator );
};
# 305 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SetModel : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SetModel> eventCallbacks[];

 void Spawn( void );

private:
 void Event_Activate( idEntity *activator );
};
# 324 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SetInfluence : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SetInfluence> eventCallbacks[];

      idTarget_SetInfluence( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

private:
 void Event_Activate( idEntity *activator );
 void Event_RestoreInfluence();
 void Event_GatherEntities();
 void Event_Flash( float flash, int out );
 void Event_ClearFlash( float flash );
 void Think( void );

 idList<int> lightList;
 idList<int> guiList;
 idList<int> soundList;
 idList<int> genericList;
 float flashIn;
 float flashOut;
 float delay;
 idStr flashInSound;
 idStr flashOutSound;
 idEntity * switchToCamera;
 idInterpolate<float>fovSetting;
 bool soundFaded;
 bool restoreOnTrigger;
};
# 367 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SetKeyVal : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SetKeyVal> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 384 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SetFov : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SetFov> eventCallbacks[];

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Think( void );

private:
 idInterpolate<int> fovSetting;

 void Event_Activate( idEntity *activator );
};
# 408 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_SetPrimaryObjective : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_SetPrimaryObjective> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 424 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_LockDoor: public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_LockDoor> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 440 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_CallObjectFunction : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_CallObjectFunction> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 457 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_EnableLevelWeapons : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_EnableLevelWeapons> eventCallbacks[];

private:
 void Event_Activate( idEntity *activator );
};
# 474 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_Tip : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_Tip> eventCallbacks[];

      idTarget_Tip( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 idVec3 playerPos;

 void Event_Activate( idEntity *activator );
 void Event_TipOff( void );
 void Event_GetPlayerPos( void );
};
# 500 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_GiveSecurity : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_GiveSecurity> eventCallbacks[];
private:
 void Event_Activate( idEntity *activator );
};
# 515 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_RemoveWeapons : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_RemoveWeapons> eventCallbacks[];
private:
 void Event_Activate( idEntity *activator );
};
# 530 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_LevelTrigger : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_LevelTrigger> eventCallbacks[];
private:
 void Event_Activate( idEntity *activator );
};
# 544 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_EnableStamina : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_EnableStamina> eventCallbacks[];
private:
 void Event_Activate( idEntity *activator );
};
# 558 "d:/Data/Nintendo/DoomGX/src/game/Target.h"
class idTarget_FadeSoundClass : public idTarget {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTarget_FadeSoundClass> eventCallbacks[];
private:
 void Event_Activate( idEntity *activator );
 void Event_RestoreVolume();
};
# 735 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h" 1
# 32 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
extern const idEventDef EV_Enable;
extern const idEventDef EV_Disable;
# 43 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
class idTrigger : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTrigger> eventCallbacks[];

 static void DrawDebugInfo( void );

      idTrigger();
 void Spawn( void );

 const function_t * GetScriptFunction( void ) const;

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Enable( void );
 virtual void Disable( void );

protected:
 void CallScript( void ) const;

 void Event_Enable( void );
 void Event_Disable( void );

 const function_t * scriptFunction;
};
# 78 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
class idTrigger_Multi : public idTrigger {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTrigger_Multi> eventCallbacks[];

      idTrigger_Multi( void );

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

private:
 float wait;
 float random;
 float delay;
 float random_delay;
 int nextTriggerTime;
 idStr requires;
 int removeItem;
 bool touchClient;
 bool touchOther;
 bool triggerFirst;
 bool triggerWithSelf;

 bool CheckFacing( idEntity *activator );
 void TriggerAction( idEntity *activator );
 void Event_TriggerAction( idEntity *activator );
 void Event_Trigger( idEntity *activator );
 void Event_Touch( idEntity *other, trace_t *trace );
};
# 118 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
class idTrigger_EntityName : public idTrigger {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTrigger_EntityName> eventCallbacks[];

      idTrigger_EntityName( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

private:
 float wait;
 float random;
 float delay;
 float random_delay;
 int nextTriggerTime;
 bool triggerFirst;
 idStr entityName;

 void TriggerAction( idEntity *activator );
 void Event_TriggerAction( idEntity *activator );
 void Event_Trigger( idEntity *activator );
 void Event_Touch( idEntity *other, trace_t *trace );
};
# 152 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
class idTrigger_Timer : public idTrigger {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTrigger_Timer> eventCallbacks[];

      idTrigger_Timer( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

 virtual void Enable( void );
 virtual void Disable( void );

private:
 float random;
 float wait;
 bool on;
 float delay;
 idStr onName;
 idStr offName;

 void Event_Timer( void );
 void Event_Use( idEntity *activator );
};
# 187 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
class idTrigger_Count : public idTrigger {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTrigger_Count> eventCallbacks[];

      idTrigger_Count( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

private:
 int goal;
 int count;
 float delay;

 void Event_Trigger( idEntity *activator );
 void Event_TriggerAction( idEntity *activator );
};
# 216 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
class idTrigger_Hurt : public idTrigger {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTrigger_Hurt> eventCallbacks[];

      idTrigger_Hurt( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

private:
 bool on;
 float delay;
 int nextTime;

 void Event_Touch( idEntity *other, trace_t *trace );
 void Event_Toggle( idEntity *activator );
};
# 245 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
class idTrigger_Fade : public idTrigger {
public:

 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTrigger_Fade> eventCallbacks[];

private:
 void Event_Trigger( idEntity *activator );
};
# 263 "d:/Data/Nintendo/DoomGX/src/game/Trigger.h"
class idTrigger_Touch : public idTrigger {
public:

 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTrigger_Touch> eventCallbacks[];

      idTrigger_Touch( void );

 void Spawn( void );
 virtual void Think( void );

 void Save( idSaveGame *savefile );
 void Restore( idRestoreGame *savefile );

 virtual void Enable( void );
 virtual void Disable( void );

 void TouchEntities( void );

private:
 idClipModel * clipModel;

 void Event_Trigger( idEntity *activator );
};
# 736 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Sound.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Sound.h"
class idSound : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idSound> eventCallbacks[];

     idSound( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void UpdateChangeableSpawnArgs( const idDict *source );

 void Spawn( void );

 void ToggleOnOff( idEntity *other, idEntity *activator );
 void Think( void );
 void SetSound( const char *sound, int channel = SND_CHANNEL_ANY );

 virtual void ShowEditingDialog( void );

private:
 float lastSoundVol;
 float soundVol;
 float random;
 float wait;
 bool timerOn;
 idVec3 shakeTranslate;
 idAngles shakeRotate;
 int playingUntilTime;

 void Event_Trigger( idEntity *activator );
 void Event_Timer( void );
 void Event_On( void );
 void Event_Off( void );
 void DoSound( bool play );
};
# 737 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/Fx.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/Fx.h"
typedef struct {
 renderLight_t renderLight;
 qhandle_t lightDefHandle;
 renderEntity_t renderEntity;
 int modelDefHandle;
 float delay;
 int particleSystem;
 int start;
 bool soundStarted;
 bool shakeStarted;
 bool decalDropped;
 bool launched;
} idFXLocalAction;

class idEntityFx : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idEntityFx> eventCallbacks[];

       idEntityFx();
 virtual ~idEntityFx();

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think();
 void Setup( const char *fx );
 void Run( int time );
 void Start( int time );
 void Stop( void );
 const int Duration( void );
 const char * EffectName( void );
 const char * Joint( void );
 const bool Done();

 virtual void WriteToSnapshot( idBitMsgDelta &msg ) const;
 virtual void ReadFromSnapshot( const idBitMsgDelta &msg );
 virtual void ClientPredictionThink( void );

 static idEntityFx * StartFx( const char *fx, const idVec3 *useOrigin, const idMat3 *useAxis, idEntity *ent, bool bind );

protected:
 void Event_Trigger( idEntity *activator );
 void Event_ClearFx( void );

 void CleanUp( void );
 void CleanUpSingleAction( const idFXSingleAction& fxaction, idFXLocalAction& laction );
 void ApplyFade( const idFXSingleAction& fxaction, idFXLocalAction& laction, const int time, const int actualStart );

 int started;
 int nextTriggerTime;
 const idDeclFX * fxEffect;
 idList<idFXLocalAction> actions;
 idStr systemName;
};

class idTeleporter : public idEntityFx {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTeleporter> eventCallbacks[];

private:

 void Event_DoAction( idEntity *activator );
};
# 738 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/SecurityCamera.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/game/SecurityCamera.h"
class idSecurityCamera : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idSecurityCamera> eventCallbacks[];

 void Spawn( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 virtual void Think( void );

 virtual renderView_t * GetRenderView();
 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );
 virtual bool Pain( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );
 virtual void Present( void );


private:

 enum { SCANNING, LOSINGINTEREST, ALERT, ACTIVATED };

 float angle;
 float sweepAngle;
 int modelAxis;
 bool flipAxis;
 float scanDist;
 float scanFov;

 float sweepStart;
 float sweepEnd;
 bool negativeSweep;
 bool sweeping;
 int alertMode;
 float stopSweeping;
 float scanFovCos;

 idVec3 viewOffset;

 int pvsArea;
 idPhysics_RigidBody physicsObj;
 idTraceModel trm;

 void StartSweep( void );
 bool CanSeePlayer( void );
 void SetAlertMode( int status );
 void DrawFov( void );
 const idVec3 GetAxis( void ) const;
 float SweepSpeed( void ) const;

 void Event_ReverseSweep( void );
 void Event_ContinueSweep( void );
 void Event_Pause( void );
 void Event_Alert( void );
 void Event_AddLight( void );
};
# 739 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/BrittleFracture.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/game/BrittleFracture.h"
typedef struct shard_s {
 idClipModel * clipModel;
 idFixedWinding winding;
 idList<idFixedWinding *> decals;
 idList<bool> edgeHasNeighbour;
 idList<struct shard_s *> neighbours;
 idPhysics_RigidBody physicsObj;
 int droppedTime;
 bool atEdge;
 int islandNum;
} shard_t;


class idBrittleFracture : public idEntity {

public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idBrittleFracture> eventCallbacks[];

        idBrittleFracture( void );
 virtual ~idBrittleFracture( void );

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

 virtual void Present( void );
 virtual void Think( void );
 virtual void ApplyImpulse( idEntity *ent, int id, const idVec3 &point, const idVec3 &impulse );
 virtual void AddForce( idEntity *ent, int id, const idVec3 &point, const idVec3 &force );
 virtual void AddDamageEffect( const trace_t &collision, const idVec3 &velocity, const char *damageDefName );
 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );

 void ProjectDecal( const idVec3 &point, const idVec3 &dir, const int time, const char *damageDefName );
 bool IsBroken( void ) const;

 enum {
  EVENT_PROJECT_DECAL = idEntity::EVENT_MAXEVENTS,
  EVENT_SHATTER,
  EVENT_MAXEVENTS
 };

 virtual void ClientPredictionThink( void );
 virtual bool ClientReceiveEvent( int event, int time, const idBitMsg &msg );

private:

 const idMaterial * material;
 const idMaterial * decalMaterial;
 float decalSize;
 float maxShardArea;
 float maxShatterRadius;
 float minShatterRadius;
 float linearVelocityScale;
 float angularVelocityScale;
 float shardMass;
 float density;
 float friction;
 float bouncyness;
 idStr fxFracture;


 idPhysics_StaticMulti physicsObj;
 idList<shard_t *> shards;
 idBounds bounds;
 bool disableFracture;


 mutable int lastRenderEntityUpdate;
 mutable bool changed;

 bool UpdateRenderEntity( renderEntity_s *renderEntity, const renderView_t *renderView ) const;
 static bool ModelCallback( renderEntity_s *renderEntity, const renderView_t *renderView );

 void AddShard( idClipModel *clipModel, idFixedWinding &w );
 void RemoveShard( int index );
 void DropShard( shard_t *shard, const idVec3 &point, const idVec3 &dir, const float impulse, const int time );
 void Shatter( const idVec3 &point, const idVec3 &impulse, const int time );
 void DropFloatingIslands( const idVec3 &point, const idVec3 &impulse, const int time );
 void Break( void );
 void Fracture_r( idFixedWinding &w );
 void CreateFractures( const idRenderModel *renderModel );
 void FindNeighbours( void );

 void Event_Activate( idEntity *activator );
 void Event_Touch( idEntity *other, trace_t *trace );
};
# 740 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/ai/AI.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/ai/AI.h"
const float SQUARE_ROOT_OF_2 = 1.414213562f;
const float AI_TURN_PREDICTION = 0.2f;
const float AI_TURN_SCALE = 60.0f;
const float AI_SEEK_PREDICTION = 0.3f;
const float AI_FLY_DAMPENING = 0.15f;
const float AI_HEARING_RANGE = 2048.0f;
const int DEFAULT_FLY_OFFSET = 68;







typedef enum {
 MOVETYPE_DEAD,
 MOVETYPE_ANIM,
 MOVETYPE_SLIDE,
 MOVETYPE_FLY,
 MOVETYPE_STATIC,
 NUM_MOVETYPES
} moveType_t;

typedef enum {
 MOVE_NONE,
 MOVE_FACE_ENEMY,
 MOVE_FACE_ENTITY,


 NUM_NONMOVING_COMMANDS,

 MOVE_TO_ENEMY = NUM_NONMOVING_COMMANDS,
 MOVE_TO_ENEMYHEIGHT,
 MOVE_TO_ENTITY,
 MOVE_OUT_OF_RANGE,
 MOVE_TO_ATTACK_POSITION,
 MOVE_TO_COVER,
 MOVE_TO_POSITION,
 MOVE_TO_POSITION_DIRECT,
 MOVE_SLIDE_TO_POSITION,
 MOVE_WANDER,
 NUM_MOVE_COMMANDS
} moveCommand_t;

typedef enum {
 TALK_NEVER,
 TALK_DEAD,
 TALK_OK,
 TALK_BUSY,
 NUM_TALK_STATES
} talkState_t;





typedef enum {
 MOVE_STATUS_DONE,
 MOVE_STATUS_MOVING,
 MOVE_STATUS_WAITING,
 MOVE_STATUS_DEST_NOT_FOUND,
 MOVE_STATUS_DEST_UNREACHABLE,
 MOVE_STATUS_BLOCKED_BY_WALL,
 MOVE_STATUS_BLOCKED_BY_OBJECT,
 MOVE_STATUS_BLOCKED_BY_ENEMY,
 MOVE_STATUS_BLOCKED_BY_MONSTER
} moveStatus_t;




typedef struct obstaclePath_s {
 idVec3 seekPos;
 idEntity * firstObstacle;
 idVec3 startPosOutsideObstacles;
 idEntity * startPosObstacle;
 idVec3 seekPosOutsideObstacles;
 idEntity * seekPosObstacle;
} obstaclePath_t;


typedef enum {
 SE_BLOCKED = ( 1 << ( 0 ) ),
 SE_ENTER_LEDGE_AREA = ( 1 << ( 1 ) ),
 SE_ENTER_OBSTACLE = ( 1 << ( 2 ) ),
 SE_FALL = ( 1 << ( 3 ) ),
 SE_LAND = ( 1 << ( 4 ) )
} stopEvent_t;

typedef struct predictedPath_s {
 idVec3 endPos;
 idVec3 endVelocity;
 idVec3 endNormal;
 int endTime;
 int endEvent;
 const idEntity * blockingEntity;
} predictedPath_t;




extern const idEventDef AI_BeginAttack;
extern const idEventDef AI_EndAttack;
extern const idEventDef AI_MuzzleFlash;
extern const idEventDef AI_CreateMissile;
extern const idEventDef AI_AttackMissile;
extern const idEventDef AI_FireMissileAtTarget;
extern const idEventDef AI_AttackMelee;
extern const idEventDef AI_DirectDamage;
extern const idEventDef AI_JumpFrame;
extern const idEventDef AI_EnableClip;
extern const idEventDef AI_DisableClip;
extern const idEventDef AI_EnableGravity;
extern const idEventDef AI_DisableGravity;
extern const idEventDef AI_TriggerParticles;
extern const idEventDef AI_RandomPath;

class idPathCorner;

typedef struct particleEmitter_s {
 particleEmitter_s() {
  particle = __null;
  time = 0;
  joint = INVALID_JOINT;
 };
 const idDeclParticle *particle;
 int time;
 jointHandle_t joint;
} particleEmitter_t;

class idMoveState {
public:
       idMoveState();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 moveType_t moveType;
 moveCommand_t moveCommand;
 moveStatus_t moveStatus;
 idVec3 moveDest;
 idVec3 moveDir;
 idEntityPtr<idEntity> goalEntity;
 idVec3 goalEntityOrigin;
 int toAreaNum;
 int startTime;
 int duration;
 float speed;
 float range;
 float wanderYaw;
 int nextWanderTime;
 int blockTime;
 idEntityPtr<idEntity> obstacle;
 idVec3 lastMoveOrigin;
 int lastMoveTime;
 int anim;
};

class idAASFindCover : public idAASCallback {
public:
      idAASFindCover( const idVec3 &hideFromPos );
      ~idAASFindCover();

 virtual bool TestArea( const idAAS *aas, int areaNum );

private:
 pvsHandle_t hidePVS;
 int PVSAreas[ idEntity::MAX_PVS_AREAS ];
};

class idAASFindAreaOutOfRange : public idAASCallback {
public:
      idAASFindAreaOutOfRange( const idVec3 &targetPos, float maxDist );

 virtual bool TestArea( const idAAS *aas, int areaNum );

private:
 idVec3 targetPos;
 float maxDistSqr;
};

class idAASFindAttackPosition : public idAASCallback {
public:
      idAASFindAttackPosition( const idAI *self, const idMat3 &gravityAxis, idEntity *target, const idVec3 &targetPos, const idVec3 &fireOffset );
      ~idAASFindAttackPosition();

 virtual bool TestArea( const idAAS *aas, int areaNum );

private:
 const idAI *self;
 idEntity *target;
 idBounds excludeBounds;
 idVec3 targetPos;
 idVec3 fireOffset;
 idMat3 gravityAxis;
 pvsHandle_t targetPVS;
 int PVSAreas[ idEntity::MAX_PVS_AREAS ];
};

class idAI : public idActor {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idAI> eventCallbacks[];

       idAI();
       ~idAI();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 void HeardSound( idEntity *ent, const char *action );
 idActor *GetEnemy( void ) const;
 void TalkTo( idActor *actor );
 talkState_t GetTalkState( void ) const;

 bool GetAimDir( const idVec3 &firePos, idEntity *aimAtEnt, const idEntity *ignore, idVec3 &aimDir ) const;

 void TouchedByFlashlight( idActor *flashlight_owner );


 static void List_f( const idCmdArgs &args );


 static bool FindPathAroundObstacles( const idPhysics *physics, const idAAS *aas, const idEntity *ignore, const idVec3 &startPos, const idVec3 &seekPos, obstaclePath_t &path );

 static void FreeObstacleAvoidanceNodes( void );

 static bool PredictPath( const idEntity *ent, const idAAS *aas, const idVec3 &start, const idVec3 &velocity, int totalTime, int frameTime, int stopEvent, predictedPath_t &path );

 static bool TestTrajectory( const idVec3 &start, const idVec3 &end, float zVel, float gravity, float time, float max_height, const idClipModel *clip, int clipmask, const idEntity *ignore, const idEntity *targetEntity, int drawtime );

 static bool PredictTrajectory( const idVec3 &firePos, const idVec3 &target, float projectileSpeed, const idVec3 &projGravity, const idClipModel *clip, int clipmask, float max_height, const idEntity *ignore, const idEntity *targetEntity, int drawtime, idVec3 &aimDir );

protected:

 idAAS * aas;
 int travelFlags;

 idMoveState move;
 idMoveState savedMove;

 float kickForce;
 bool ignore_obstacles;
 float blockedRadius;
 int blockedMoveTime;
 int blockedAttackTime;


 float ideal_yaw;
 float current_yaw;
 float turnRate;
 float turnVel;
 float anim_turn_yaw;
 float anim_turn_amount;
 float anim_turn_angles;


 idPhysics_Monster physicsObj;


 jointHandle_t flyTiltJoint;
 float fly_speed;
 float fly_bob_strength;
 float fly_bob_vert;
 float fly_bob_horz;
 int fly_offset;
 float fly_seek_scale;
 float fly_roll_scale;
 float fly_roll_max;
 float fly_roll;
 float fly_pitch_scale;
 float fly_pitch_max;
 float fly_pitch;

 bool allowMove;
 bool allowHiddenMovement;
 bool disableGravity;
 bool af_push_moveables;


 bool lastHitCheckResult;
 int lastHitCheckTime;
 int lastAttackTime;
 float melee_range;
 float projectile_height_to_distance_ratio;
 idList<idVec3> missileLaunchOffset;

 const idDict * projectileDef;
 mutable idClipModel *projectileClipModel;
 float projectileRadius;
 float projectileSpeed;
 idVec3 projectileVelocity;
 idVec3 projectileGravity;
 idEntityPtr<idProjectile> projectile;
 idStr attack;


 const idSoundShader *chat_snd;
 int chat_min;
 int chat_max;
 int chat_time;
 talkState_t talk_state;
 idEntityPtr<idActor> talkTarget;


 int num_cinematics;
 int current_cinematic;

 bool allowJointMod;
 idEntityPtr<idEntity> focusEntity;
 idVec3 currentFocusPos;
 int focusTime;
 int alignHeadTime;
 int forceAlignHeadTime;
 idAngles eyeAng;
 idAngles lookAng;
 idAngles destLookAng;
 idAngles lookMin;
 idAngles lookMax;
 idList<jointHandle_t> lookJoints;
 idList<idAngles> lookJointAngles;
 float eyeVerticalOffset;
 float eyeHorizontalOffset;
 float eyeFocusRate;
 float headFocusRate;
 int focusAlignTime;


 float shrivel_rate;
 int shrivel_start;

 bool restartParticles;
 bool useBoneAxis;
 idList<particleEmitter_t> particles;

 renderLight_t worldMuzzleFlash;
 int worldMuzzleFlashHandle;
 jointHandle_t flashJointWorld;
 int muzzleFlashEnd;
 int flashTime;


 idAngles eyeMin;
 idAngles eyeMax;
 jointHandle_t focusJoint;
 jointHandle_t orientationJoint;


 idEntityPtr<idActor> enemy;
 idVec3 lastVisibleEnemyPos;
 idVec3 lastVisibleEnemyEyeOffset;
 idVec3 lastVisibleReachableEnemyPos;
 idVec3 lastReachableEnemyPos;
 bool wakeOnFlashlight;


 idScriptBool AI_TALK;
 idScriptBool AI_DAMAGE;
 idScriptBool AI_PAIN;
 idScriptFloat AI_SPECIAL_DAMAGE;
 idScriptBool AI_DEAD;
 idScriptBool AI_ENEMY_VISIBLE;
 idScriptBool AI_ENEMY_IN_FOV;
 idScriptBool AI_ENEMY_DEAD;
 idScriptBool AI_MOVE_DONE;
 idScriptBool AI_ONGROUND;
 idScriptBool AI_ACTIVATED;
 idScriptBool AI_FORWARD;
 idScriptBool AI_JUMP;
 idScriptBool AI_ENEMY_REACHABLE;
 idScriptBool AI_BLOCKED;
 idScriptBool AI_OBSTACLE_IN_PATH;
 idScriptBool AI_DEST_UNREACHABLE;
 idScriptBool AI_HIT_ENEMY;
 idScriptBool AI_PUSHED;




 void SetAAS( void );
 virtual void DormantBegin( void );
 virtual void DormantEnd( void );
 void Think( void );
 void Activate( idEntity *activator );
 int ReactionTo( const idEntity *ent );
 bool CheckForEnemy( void );
 void EnemyDead( void );
 virtual bool CanPlayChatterSounds( void ) const;
 void SetChatSound( void );
 void PlayChatter( void );
 virtual void Hide( void );
 virtual void Show( void );
 idVec3 FirstVisiblePointOnPath( const idVec3 origin, const idVec3 &target, int travelFlags ) const;
 void CalculateAttackOffsets( void );
 void PlayCinematic( void );


 virtual void ApplyImpulse( idEntity *ent, int id, const idVec3 &point, const idVec3 &impulse );
 void GetMoveDelta( const idMat3 &oldaxis, const idMat3 &axis, idVec3 &delta );
 void CheckObstacleAvoidance( const idVec3 &goalPos, idVec3 &newPos );
 void DeadMove( void );
 void AnimMove( void );
 void SlideMove( void );
 void AdjustFlyingAngles( void );
 void AddFlyBob( idVec3 &vel );
 void AdjustFlyHeight( idVec3 &vel, const idVec3 &goalPos );
 void FlySeekGoal( idVec3 &vel, idVec3 &goalPos );
 void AdjustFlySpeed( idVec3 &vel );
 void FlyTurn( void );
 void FlyMove( void );
 void StaticMove( void );


 virtual bool Pain( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );
 virtual void Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location );


 void KickObstacles( const idVec3 &dir, float force, idEntity *alwaysKick );
 bool ReachedPos( const idVec3 &pos, const moveCommand_t moveCommand ) const;
 float TravelDistance( const idVec3 &start, const idVec3 &end ) const;
 int PointReachableAreaNum( const idVec3 &pos, const float boundsScale = 2.0f ) const;
 bool PathToGoal( aasPath_t &path, int areaNum, const idVec3 &origin, int goalAreaNum, const idVec3 &goalOrigin ) const;
 void DrawRoute( void ) const;
 bool GetMovePos( idVec3 &seekPos );
 bool MoveDone( void ) const;
 bool EntityCanSeePos( idActor *actor, const idVec3 &actorOrigin, const idVec3 &pos );
 void BlockedFailSafe( void );


 void StopMove( moveStatus_t status );
 bool FaceEnemy( void );
 bool FaceEntity( idEntity *ent );
 bool DirectMoveToPosition( const idVec3 &pos );
 bool MoveToEnemyHeight( void );
 bool MoveOutOfRange( idEntity *entity, float range );
 bool MoveToAttackPosition( idEntity *ent, int attack_anim );
 bool MoveToEnemy( void );
 bool MoveToEntity( idEntity *ent );
 bool MoveToPosition( const idVec3 &pos );
 bool MoveToCover( idEntity *entity, const idVec3 &pos );
 bool SlideToPosition( const idVec3 &pos, float time );
 bool WanderAround( void );
 bool StepDirection( float dir );
 bool NewWanderDir( const idVec3 &dest );


 const idDeclParticle *SpawnParticlesOnJoint( particleEmitter_t &pe, const char *particleName, const char *jointName );
 void SpawnParticles( const char *keyName );
 bool ParticlesActive( void );


 bool FacingIdeal( void );
 void Turn( void );
 bool TurnToward( float yaw );
 bool TurnToward( const idVec3 &pos );


 void ClearEnemy( void );
 bool EnemyPositionValid( void ) const;
 void SetEnemyPosition( void );
 void UpdateEnemyPosition( void );
 void SetEnemy( idActor *newEnemy );


 void CreateProjectileClipModel( void ) const;
 idProjectile *CreateProjectile( const idVec3 &pos, const idVec3 &dir );
 void RemoveProjectile( void );
 idProjectile *LaunchProjectile( const char *jointname, idEntity *target, bool clampToAttackCone );
 virtual void DamageFeedback( idEntity *victim, idEntity *inflictor, int &damage );
 void DirectDamage( const char *meleeDefName, idEntity *ent );
 bool TestMelee( void ) const;
 bool AttackMelee( const char *meleeDefName );
 void BeginAttack( const char *name );
 void EndAttack( void );
 void PushWithAF( void );


 void GetMuzzle( const char *jointname, idVec3 &muzzle, idMat3 &axis );
 void InitMuzzleFlash( void );
 void TriggerWeaponEffects( const idVec3 &muzzle );
 void UpdateMuzzleFlash( void );
 virtual bool UpdateAnimationControllers( void );
 void UpdateParticles( void );
 void TriggerParticles( const char *jointName );


 void LinkScriptVariables( void );
 void UpdateAIScript( void );




 void Event_Activate( idEntity *activator );
 void Event_Touch( idEntity *other, trace_t *trace );
 void Event_FindEnemy( int useFOV );
 void Event_FindEnemyAI( int useFOV );
 void Event_FindEnemyInCombatNodes( void );
 void Event_ClosestReachableEnemyOfEntity( idEntity *team_mate );
 void Event_HeardSound( int ignore_team );
 void Event_SetEnemy( idEntity *ent );
 void Event_ClearEnemy( void );
 void Event_MuzzleFlash( const char *jointname );
 void Event_CreateMissile( const char *jointname );
 void Event_AttackMissile( const char *jointname );
 void Event_FireMissileAtTarget( const char *jointname, const char *targetname );
 void Event_LaunchMissile( const idVec3 &muzzle, const idAngles &ang );
 void Event_AttackMelee( const char *meleeDefName );
 void Event_DirectDamage( idEntity *damageTarget, const char *damageDefName );
 void Event_RadiusDamageFromJoint( const char *jointname, const char *damageDefName );
 void Event_BeginAttack( const char *name );
 void Event_EndAttack( void );
 void Event_MeleeAttackToJoint( const char *jointname, const char *meleeDefName );
 void Event_RandomPath( void );
 void Event_CanBecomeSolid( void );
 void Event_BecomeSolid( void );
 void Event_BecomeNonSolid( void );
 void Event_BecomeRagdoll( void );
 void Event_StopRagdoll( void );
 void Event_SetHealth( float newHealth );
 void Event_GetHealth( void );
 void Event_AllowDamage( void );
 void Event_IgnoreDamage( void );
 void Event_GetCurrentYaw( void );
 void Event_TurnTo( float angle );
 void Event_TurnToPos( const idVec3 &pos );
 void Event_TurnToEntity( idEntity *ent );
 void Event_MoveStatus( void );
 void Event_StopMove( void );
 void Event_MoveToCover( void );
 void Event_MoveToEnemy( void );
 void Event_MoveToEnemyHeight( void );
 void Event_MoveOutOfRange( idEntity *entity, float range );
 void Event_MoveToAttackPosition( idEntity *entity, const char *attack_anim );
 void Event_MoveToEntity( idEntity *ent );
 void Event_MoveToPosition( const idVec3 &pos );
 void Event_SlideTo( const idVec3 &pos, float time );
 void Event_Wander( void );
 void Event_FacingIdeal( void );
 void Event_FaceEnemy( void );
 void Event_FaceEntity( idEntity *ent );
 void Event_WaitAction( const char *waitForState );
 void Event_GetCombatNode( void );
 void Event_EnemyInCombatCone( idEntity *ent, int use_current_enemy_location );
 void Event_WaitMove( void );
 void Event_GetJumpVelocity( const idVec3 &pos, float speed, float max_height );
 void Event_EntityInAttackCone( idEntity *ent );
 void Event_CanSeeEntity( idEntity *ent );
 void Event_SetTalkTarget( idEntity *target );
 void Event_GetTalkTarget( void );
 void Event_SetTalkState( int state );
 void Event_EnemyRange( void );
 void Event_EnemyRange2D( void );
 void Event_GetEnemy( void );
 void Event_GetEnemyPos( void );
 void Event_GetEnemyEyePos( void );
 void Event_PredictEnemyPos( float time );
 void Event_CanHitEnemy( void );
 void Event_CanHitEnemyFromAnim( const char *animname );
 void Event_CanHitEnemyFromJoint( const char *jointname );
 void Event_EnemyPositionValid( void );
 void Event_ChargeAttack( const char *damageDef );
 void Event_TestChargeAttack( void );
 void Event_TestAnimMoveTowardEnemy( const char *animname );
 void Event_TestAnimMove( const char *animname );
 void Event_TestMoveToPosition( const idVec3 &position );
 void Event_TestMeleeAttack( void );
 void Event_TestAnimAttack( const char *animname );
 void Event_Shrivel( float shirvel_time );
 void Event_Burn( void );
 void Event_PreBurn( void );
 void Event_ClearBurn( void );
 void Event_SetSmokeVisibility( int num, int on );
 void Event_NumSmokeEmitters( void );
 void Event_StopThinking( void );
 void Event_GetTurnDelta( void );
 void Event_GetMoveType( void );
 void Event_SetMoveType( int moveType );
 void Event_SaveMove( void );
 void Event_RestoreMove( void );
 void Event_AllowMovement( float flag );
 void Event_JumpFrame( void );
 void Event_EnableClip( void );
 void Event_DisableClip( void );
 void Event_EnableGravity( void );
 void Event_DisableGravity( void );
 void Event_EnableAFPush( void );
 void Event_DisableAFPush( void );
 void Event_SetFlySpeed( float speed );
 void Event_SetFlyOffset( int offset );
 void Event_ClearFlyOffset( void );
 void Event_GetClosestHiddenTarget( const char *type );
 void Event_GetRandomTarget( const char *type );
 void Event_TravelDistanceToPoint( const idVec3 &pos );
 void Event_TravelDistanceToEntity( idEntity *ent );
 void Event_TravelDistanceBetweenPoints( const idVec3 &source, const idVec3 &dest );
 void Event_TravelDistanceBetweenEntities( idEntity *source, idEntity *dest );
 void Event_LookAtEntity( idEntity *ent, float duration );
 void Event_LookAtEnemy( float duration );
 void Event_SetJointMod( int allowJointMod );
 void Event_ThrowMoveable( void );
 void Event_ThrowAF( void );
 void Event_SetAngles( idAngles const &ang );
 void Event_GetAngles( void );
 void Event_RealKill( void );
 void Event_Kill( void );
 void Event_WakeOnFlashlight( int enable );
 void Event_LocateEnemy( void );
 void Event_KickObstacles( idEntity *kickEnt, float force );
 void Event_GetObstacle( void );
 void Event_PushPointIntoAAS( const idVec3 &pos );
 void Event_GetTurnRate( void );
 void Event_SetTurnRate( float rate );
 void Event_AnimTurn( float angles );
 void Event_AllowHiddenMovement( int enable );
 void Event_TriggerParticles( const char *jointName );
 void Event_FindActorsInBounds( const idVec3 &mins, const idVec3 &maxs );
 void Event_CanReachPosition( const idVec3 &pos );
 void Event_CanReachEntity( idEntity *ent );
 void Event_CanReachEnemy( void );
 void Event_GetReachableEntityPosition( idEntity *ent );
};

class idCombatNode : public idEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idCombatNode> eventCallbacks[];

      idCombatNode();

 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void Spawn( void );
 bool IsDisabled( void ) const;
 bool EntityInView( idActor *actor, const idVec3 &pos );
 static void DrawDebugInfo( void );

private:
 float min_dist;
 float max_dist;
 float cone_dist;
 float min_height;
 float max_height;
 idVec3 cone_left;
 idVec3 cone_right;
 idVec3 offset;
 bool disabled;

 void Event_Activate( idEntity *activator );
 void Event_MarkUsed( void );
};
# 742 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim_Testmodel.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/game/anim/Anim_Testmodel.h"
class idTestModel : public idAnimatedEntity {
public:
 public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idTestModel> eventCallbacks[];

       idTestModel();
       ~idTestModel();

 void Save( idSaveGame *savefile );
 void Restore( idRestoreGame *savefile );

 void Spawn( void );

 virtual bool ShouldConstructScriptObjectAtSpawn( void ) const;

 void NextAnim( const idCmdArgs &args );
 void PrevAnim( const idCmdArgs &args );
 void NextFrame( const idCmdArgs &args );
 void PrevFrame( const idCmdArgs &args );
 void TestAnim( const idCmdArgs &args );
 void BlendAnim( const idCmdArgs &args );

 static void KeepTestModel_f( const idCmdArgs &args );
 static void TestModel_f( const idCmdArgs &args );
 static void ArgCompletion_TestModel( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void TestSkin_f( const idCmdArgs &args );
 static void TestShaderParm_f( const idCmdArgs &args );
 static void TestParticleStopTime_f( const idCmdArgs &args );
 static void TestAnim_f( const idCmdArgs &args );
 static void ArgCompletion_TestAnim( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void TestBlend_f( const idCmdArgs &args );
 static void TestModelNextAnim_f( const idCmdArgs &args );
 static void TestModelPrevAnim_f( const idCmdArgs &args );
 static void TestModelNextFrame_f( const idCmdArgs &args );
 static void TestModelPrevFrame_f( const idCmdArgs &args );

private:
 idEntityPtr<idEntity> head;
 idAnimator *headAnimator;
 idAnim customAnim;
 idPhysics_Parametric physicsObj;
 idStr animname;
 int anim;
 int headAnim;
 int mode;
 int frame;
 int starttime;
 int animtime;

 idList<copyJoints_t> copyJoints;

 virtual void Think( void );

 void Event_Footstep( void );
};
# 743 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2

# 1 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Compiler.h" 1
# 31 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Compiler.h"
const char * const RESULT_STRING = "<RESULT>";

typedef struct opcode_s {
 char *name;
 char *opname;
 int priority;
 bool rightAssociative;
 idVarDef *type_a;
 idVarDef *type_b;
 idVarDef *type_c;
} opcode_t;





enum {
 OP_RETURN,

 OP_UINC_F,
 OP_UINCP_F,
 OP_UDEC_F,
 OP_UDECP_F,
 OP_COMP_F,

 OP_MUL_F,
 OP_MUL_V,
 OP_MUL_FV,
 OP_MUL_VF,
 OP_DIV_F,
 OP_MOD_F,
 OP_ADD_F,
 OP_ADD_V,
 OP_ADD_S,
 OP_ADD_FS,
 OP_ADD_SF,
 OP_ADD_VS,
 OP_ADD_SV,
 OP_SUB_F,
 OP_SUB_V,

 OP_EQ_F,
 OP_EQ_V,
 OP_EQ_S,
 OP_EQ_E,
 OP_EQ_EO,
 OP_EQ_OE,
 OP_EQ_OO,

 OP_NE_F,
 OP_NE_V,
 OP_NE_S,
 OP_NE_E,
 OP_NE_EO,
 OP_NE_OE,
 OP_NE_OO,

 OP_LE,
 OP_GE,
 OP_LT,
 OP_GT,

 OP_INDIRECT_F,
 OP_INDIRECT_V,
 OP_INDIRECT_S,
 OP_INDIRECT_ENT,
 OP_INDIRECT_BOOL,
 OP_INDIRECT_OBJ,

 OP_ADDRESS,

 OP_EVENTCALL,
 OP_OBJECTCALL,
 OP_SYSCALL,

 OP_STORE_F,
 OP_STORE_V,
 OP_STORE_S,
 OP_STORE_ENT,
 OP_STORE_BOOL,
 OP_STORE_OBJENT,
 OP_STORE_OBJ,
 OP_STORE_ENTOBJ,

 OP_STORE_FTOS,
 OP_STORE_BTOS,
 OP_STORE_VTOS,
 OP_STORE_FTOBOOL,
 OP_STORE_BOOLTOF,

 OP_STOREP_F,
 OP_STOREP_V,
 OP_STOREP_S,
 OP_STOREP_ENT,
 OP_STOREP_FLD,
 OP_STOREP_BOOL,
 OP_STOREP_OBJ,
 OP_STOREP_OBJENT,

 OP_STOREP_FTOS,
 OP_STOREP_BTOS,
 OP_STOREP_VTOS,
 OP_STOREP_FTOBOOL,
 OP_STOREP_BOOLTOF,

 OP_UMUL_F,
 OP_UMUL_V,
 OP_UDIV_F,
 OP_UDIV_V,
 OP_UMOD_F,
 OP_UADD_F,
 OP_UADD_V,
 OP_USUB_F,
 OP_USUB_V,
 OP_UAND_F,
 OP_UOR_F,

 OP_NOT_BOOL,
 OP_NOT_F,
 OP_NOT_V,
 OP_NOT_S,
 OP_NOT_ENT,

 OP_NEG_F,
 OP_NEG_V,

 OP_INT_F,
 OP_IF,
 OP_IFNOT,

 OP_CALL,
 OP_THREAD,
 OP_OBJTHREAD,

 OP_PUSH_F,
 OP_PUSH_V,
 OP_PUSH_S,
 OP_PUSH_ENT,
 OP_PUSH_OBJ,
 OP_PUSH_OBJENT,
 OP_PUSH_FTOS,
 OP_PUSH_BTOF,
 OP_PUSH_FTOB,
 OP_PUSH_VTOS,
 OP_PUSH_BTOS,

 OP_GOTO,

 OP_AND,
 OP_AND_BOOLF,
 OP_AND_FBOOL,
 OP_AND_BOOLBOOL,
 OP_OR,
 OP_OR_BOOLF,
 OP_OR_FBOOL,
 OP_OR_BOOLBOOL,

 OP_BITAND,
 OP_BITOR,

 OP_BREAK,
 OP_CONTINUE,

 NUM_OPCODES
};

class idCompiler {
private:
 static bool punctuationValid[ 256 ];
 static char *punctuation[];

 idParser parser;
 idParser *parserPtr;
 idToken token;

 idTypeDef *immediateType;
 eval_t immediate;

 bool eof;
 bool console;
 bool callthread;
 int braceDepth;
 int loopDepth;
 int currentLineNumber;
 int currentFileNumber;
 int errorCount;

 idVarDef *scope;
 const idVarDef *basetype;

 float Divide( float numerator, float denominator );
 void Error( const char *error, ... ) const __attribute__((format(printf,2,3)));
 void Warning( const char *message, ... ) const __attribute__((format(printf,2,3)));
 idVarDef *OptimizeOpcode( const opcode_t *op, idVarDef *var_a, idVarDef *var_b );
 idVarDef *EmitOpcode( const opcode_t *op, idVarDef *var_a, idVarDef *var_b );
 idVarDef *EmitOpcode( int op, idVarDef *var_a, idVarDef *var_b );
 bool EmitPush( idVarDef *expression, const idTypeDef *funcArg );
 void NextToken( void );
 void ExpectToken( const char *string );
 bool CheckToken( const char *string );
 void ParseName( idStr &name );
 void SkipOutOfFunction( void );
 void SkipToSemicolon( void );
 idTypeDef *CheckType( void );
 idTypeDef *ParseType( void );
 idVarDef *FindImmediate( const idTypeDef *type, const eval_t *eval, const char *string ) const;
 idVarDef *GetImmediate( idTypeDef *type, const eval_t *eval, const char *string );
 idVarDef *VirtualFunctionConstant( idVarDef *func );
 idVarDef *SizeConstant( int size );
 idVarDef *JumpConstant( int value );
 idVarDef *JumpDef( int jumpfrom, int jumpto );
 idVarDef *JumpTo( int jumpto );
 idVarDef *JumpFrom( int jumpfrom );
 idVarDef *ParseImmediate( void );
 idVarDef *EmitFunctionParms( int op, idVarDef *func, int startarg, int startsize, idVarDef *object );
 idVarDef *ParseFunctionCall( idVarDef *func );
 idVarDef *ParseObjectCall( idVarDef *object, idVarDef *func );
 idVarDef *ParseEventCall( idVarDef *object, idVarDef *func );
 idVarDef *ParseSysObjectCall( idVarDef *func );
 idVarDef *LookupDef( const char *name, const idVarDef *baseobj );
 idVarDef *ParseValue( void );
 idVarDef *GetTerm( void );
 bool TypeMatches( etype_t type1, etype_t type2 ) const;
 idVarDef *GetExpression( int priority );
 idTypeDef *GetTypeForEventArg( char argType );
 void PatchLoop( int start, int continuePos );
 void ParseReturnStatement( void );
 void ParseWhileStatement( void );
 void ParseForStatement( void );
 void ParseDoWhileStatement( void );
 void ParseIfStatement( void );
 void ParseStatement( void );
 void ParseObjectDef( const char *objname );
 idTypeDef *ParseFunction( idTypeDef *returnType, const char *name );
 void ParseFunctionDef( idTypeDef *returnType, const char *name );
 void ParseVariableDef( idTypeDef *type, const char *name );
 void ParseEventDef( idTypeDef *type, const char *name );
 void ParseDefs( void );
 void ParseNamespace( idVarDef *newScope );

public :
 static opcode_t opcodes[];

     idCompiler();
 void CompileFile( const char *text, const char *filename, bool console );
};
# 745 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Interpreter.h" 1
# 35 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Interpreter.h"
typedef struct prstack_s {
 int s;
 const function_t *f;
 int stackbase;
} prstack_t;

class idInterpreter {
private:
 prstack_t callStack[ 64 ];
 int callStackDepth;
 int maxStackDepth;

 byte localstack[ 6144 ];
 int localstackUsed;
 int localstackBase;
 int maxLocalstackUsed;

 const function_t *currentFunction;
 int instructionPointer;

 int popParms;
 const idEventDef *multiFrameEvent;
 idEntity *eventEntity;

 idThread *thread;

 void PopParms( int numParms );
 void PushString( const char *string );
 void Push( int value );
 const char *FloatToString( float value );
 void AppendString( idVarDef *def, const char *from );
 void SetString( idVarDef *def, const char *from );
 const char *GetString( idVarDef *def );
 varEval_t GetVariable( idVarDef *def );
 idEntity *GetEntity( int entnum ) const;
 idScriptObject *GetScriptObject( int entnum ) const;
 void NextInstruction( int position );

 void LeaveFunction( idVarDef *returnDef );
 void CallEvent( const function_t *func, int argsize );
 void CallSysEvent( const function_t *func, int argsize );

public:
 bool doneProcessing;
 bool threadDying;
 bool terminateOnExit;
 bool debug;

      idInterpreter();


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void SetThread( idThread *pThread );

 void StackTrace( void ) const;

 int CurrentLine( void ) const;
 const char *CurrentFile( void ) const;

 void Error( char *fmt, ... ) const __attribute__((format(printf,2,3)));
 void Warning( char *fmt, ... ) const __attribute__((format(printf,2,3)));
 void DisplayInfo( void ) const;

 bool BeginMultiFrameEvent( idEntity *ent, const idEventDef *event );
 void EndMultiFrameEvent( idEntity *ent, const idEventDef *event );
 bool MultiFrameEventInProgress( void ) const;

 void ThreadCall( idInterpreter *source, const function_t *func, int args );
 void EnterFunction( const function_t *func, bool clearStack );
 void EnterObjectFunction( idEntity *self, const function_t *func, bool clearStack );

 bool Execute( void );
 void Reset( void );

 bool GetRegisterValue( const char *name, idStr &out, int scopeDepth );
 int GetCallstackDepth( void ) const;
 const prstack_t *GetCallstack( void ) const;
 const function_t *GetCurrentFunction( void ) const;
 idThread *GetThread( void ) const;

};






inline void idInterpreter::PopParms( int numParms ) {

 if ( localstackUsed < numParms ) {
  Error( "locals stack underflow\n" );
 }

 localstackUsed -= numParms;
}






inline void idInterpreter::Push( int value ) {
 if ( localstackUsed + sizeof( int ) > 6144 ) {
  Error( "Push: locals stack overflow\n" );
 }
 *( int * )&localstack[ localstackUsed ] = value;
 localstackUsed += sizeof( int );
}






inline void idInterpreter::PushString( const char *string ) {
 if ( localstackUsed + 128 > 6144 ) {
  Error( "PushString: locals stack overflow\n" );
 }
 idStr::Copynz( ( char * )&localstack[ localstackUsed ], string, 128 );
 localstackUsed += 128;
}






inline const char *idInterpreter::FloatToString( float value ) {
 static char text[ 32 ];

 if ( value == ( float )( int )value ) {
  sprintf( text, "%d", ( int )value );
 } else {
  sprintf( text, "%f", value );
 }
 return text;
}






inline void idInterpreter::AppendString( idVarDef *def, const char *from ) {
 if ( def->initialized == idVarDef::stackVariable ) {
  idStr::Append( ( char * )&localstack[ localstackBase + def->value.stackOffset ], 128, from );
 } else {
  idStr::Append( def->value.stringPtr, 128, from );
 }
}






inline void idInterpreter::SetString( idVarDef *def, const char *from ) {
 if ( def->initialized == idVarDef::stackVariable ) {
  idStr::Copynz( ( char * )&localstack[ localstackBase + def->value.stackOffset ], from, 128 );
 } else {
  idStr::Copynz( def->value.stringPtr, from, 128 );
 }
}






inline const char *idInterpreter::GetString( idVarDef *def ) {
 if ( def->initialized == idVarDef::stackVariable ) {
  return ( char * )&localstack[ localstackBase + def->value.stackOffset ];
 } else {
  return def->value.stringPtr;
 }
}






inline varEval_t idInterpreter::GetVariable( idVarDef *def ) {
 if ( def->initialized == idVarDef::stackVariable ) {
  varEval_t val;
  val.intPtr = ( int * )&localstack[ localstackBase + def->value.stackOffset ];
  return val;
 } else {
  return def->value;
 }
}






inline idEntity *idInterpreter::GetEntity( int entnum ) const{
 ((void)0);
 if ( ( entnum > 0 ) && ( entnum <= (1<<12) ) ) {
  return gameLocal.entities[ entnum - 1 ];
 }
 return __null;
}






inline idScriptObject *idInterpreter::GetScriptObject( int entnum ) const {
 idEntity *ent;

 ((void)0);
 if ( ( entnum > 0 ) && ( entnum <= (1<<12) ) ) {
  ent = gameLocal.entities[ entnum - 1 ];
  if ( ent && ent->scriptObject.data ) {
   return &ent->scriptObject;
  }
 }
 return __null;
}






inline void idInterpreter::NextInstruction( int position ) {


 instructionPointer = position - 1;
}
# 746 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Thread.h" 1
# 32 "d:/Data/Nintendo/DoomGX/src/game/script/Script_Thread.h"
extern const idEventDef EV_Thread_Execute;
extern const idEventDef EV_Thread_SetCallback;
extern const idEventDef EV_Thread_TerminateThread;
extern const idEventDef EV_Thread_Pause;
extern const idEventDef EV_Thread_Wait;
extern const idEventDef EV_Thread_WaitFrame;
extern const idEventDef EV_Thread_WaitFor;
extern const idEventDef EV_Thread_WaitForThread;
extern const idEventDef EV_Thread_Print;
extern const idEventDef EV_Thread_PrintLn;
extern const idEventDef EV_Thread_Say;
extern const idEventDef EV_Thread_Assert;
extern const idEventDef EV_Thread_Trigger;
extern const idEventDef EV_Thread_SetCvar;
extern const idEventDef EV_Thread_GetCvar;
extern const idEventDef EV_Thread_Random;
extern const idEventDef EV_Thread_GetTime;
extern const idEventDef EV_Thread_KillThread;
extern const idEventDef EV_Thread_SetThreadName;
extern const idEventDef EV_Thread_GetEntity;
extern const idEventDef EV_Thread_Spawn;
extern const idEventDef EV_Thread_SetSpawnArg;
extern const idEventDef EV_Thread_SpawnString;
extern const idEventDef EV_Thread_SpawnFloat;
extern const idEventDef EV_Thread_SpawnVector;
extern const idEventDef EV_Thread_AngToForward;
extern const idEventDef EV_Thread_AngToRight;
extern const idEventDef EV_Thread_AngToUp;
extern const idEventDef EV_Thread_Sine;
extern const idEventDef EV_Thread_Cosine;
extern const idEventDef EV_Thread_Normalize;
extern const idEventDef EV_Thread_VecLength;
extern const idEventDef EV_Thread_VecDotProduct;
extern const idEventDef EV_Thread_VecCrossProduct;
extern const idEventDef EV_Thread_OnSignal;
extern const idEventDef EV_Thread_ClearSignal;
extern const idEventDef EV_Thread_SetCamera;
extern const idEventDef EV_Thread_FirstPerson;
extern const idEventDef EV_Thread_TraceFraction;
extern const idEventDef EV_Thread_TracePos;
extern const idEventDef EV_Thread_FadeIn;
extern const idEventDef EV_Thread_FadeOut;
extern const idEventDef EV_Thread_FadeTo;
extern const idEventDef EV_Thread_Restart;

class idThread : public idClass {
private:
 static idThread *currentThread;

 idThread *waitingForThread;
 int waitingFor;
 int waitingUntil;
 idInterpreter interpreter;

 idDict spawnArgs;

 int threadNum;
 idStr threadName;

 int lastExecuteTime;
 int creationTime;

 bool manualControl;

 static int threadIndex;
 static idList<idThread *> threadList;

 static trace_t trace;

 void Init( void );
 void Pause( void );

 void Event_Execute( void );
 void Event_SetThreadName( const char *name );




 void Event_TerminateThread( int num );
 void Event_Pause( void );
 void Event_Wait( float time );
 void Event_WaitFrame( void );
 void Event_WaitFor( idEntity *ent );
 void Event_WaitForThread( int num );
 void Event_Print( const char *text );
 void Event_PrintLn( const char *text );
 void Event_Say( const char *text );
 void Event_Assert( float value );
 void Event_Trigger( idEntity *ent );
 void Event_SetCvar( const char *name, const char *value ) const;
 void Event_GetCvar( const char *name ) const;
 void Event_Random( float range ) const;
 void Event_GetTime( void );
 void Event_KillThread( const char *name );
 void Event_GetEntity( const char *name );
 void Event_Spawn( const char *classname );
 void Event_CopySpawnArgs( idEntity *ent );
 void Event_SetSpawnArg( const char *key, const char *value );
 void Event_SpawnString( const char *key, const char *defaultvalue );
 void Event_SpawnFloat( const char *key, float defaultvalue );
 void Event_SpawnVector( const char *key, idVec3 &defaultvalue );
 void Event_ClearPersistantArgs( void );
 void Event_SetPersistantArg( const char *key, const char *value );
 void Event_GetPersistantString( const char *key );
 void Event_GetPersistantFloat( const char *key );
 void Event_GetPersistantVector( const char *key );
 void Event_AngToForward( idAngles &ang );
 void Event_AngToRight( idAngles &ang );
 void Event_AngToUp( idAngles &ang );
 void Event_GetSine( float angle );
 void Event_GetCosine( float angle );
 void Event_GetSquareRoot( float theSquare );
 void Event_VecNormalize( idVec3 &vec );
 void Event_VecLength( idVec3 &vec );
 void Event_VecDotProduct( idVec3 &vec1, idVec3 &vec2 );
 void Event_VecCrossProduct( idVec3 &vec1, idVec3 &vec2 );
 void Event_VecToAngles( idVec3 &vec );
 void Event_OnSignal( int signal, idEntity *ent, const char *func );
 void Event_ClearSignalThread( int signal, idEntity *ent );
 void Event_SetCamera( idEntity *ent );
 void Event_FirstPerson( void );
 void Event_Trace( const idVec3 &start, const idVec3 &end, const idVec3 &mins, const idVec3 &maxs, int contents_mask, idEntity *passEntity );
 void Event_TracePoint( const idVec3 &start, const idVec3 &end, int contents_mask, idEntity *passEntity );
 void Event_GetTraceFraction( void );
 void Event_GetTraceEndPos( void );
 void Event_GetTraceNormal( void );
 void Event_GetTraceEntity( void );
 void Event_GetTraceJoint( void );
 void Event_GetTraceBody( void );
 void Event_FadeIn( idVec3 &color, float time );
 void Event_FadeOut( idVec3 &color, float time );
 void Event_FadeTo( idVec3 &color, float alpha, float time );
 void Event_SetShaderParm( int parmnum, float value );
 void Event_StartMusic( const char *name );
 void Event_Warning( const char *text );
 void Event_Error( const char *text );
 void Event_StrLen( const char *string );
 void Event_StrLeft( const char *string, int num );
 void Event_StrRight( const char *string, int num );
 void Event_StrSkip( const char *string, int num );
 void Event_StrMid( const char *string, int start, int num );
 void Event_StrToFloat( const char *string );
 void Event_RadiusDamage( const idVec3 &origin, idEntity *inflictor, idEntity *attacker, idEntity *ignore, const char *damageDefName, float dmgPower );
 void Event_IsClient( void );
 void Event_IsMultiplayer( void );
 void Event_GetFrameTime( void );
 void Event_GetTicsPerSecond( void );
 void Event_CacheSoundShader( const char *soundName );
 void Event_DebugLine( const idVec3 &color, const idVec3 &start, const idVec3 &end, const float lifetime );
 void Event_DebugArrow( const idVec3 &color, const idVec3 &start, const idVec3 &end, const int size, const float lifetime );
 void Event_DebugCircle( const idVec3 &color, const idVec3 &origin, const idVec3 &dir, const float radius, const int numSteps, const float lifetime );
 void Event_DebugBounds( const idVec3 &color, const idVec3 &mins, const idVec3 &maxs, const float lifetime );
 void Event_DrawText( const char *text, const idVec3 &origin, float scale, const idVec3 &color, const int align, const float lifetime );
 void Event_InfluenceActive( void );

public:
        public: static idTypeInfo Type; static idClass *CreateInstance( void ); virtual idTypeInfo *GetType( void ) const; static idEventFunc<idThread> eventCallbacks[];

        idThread();
        idThread( idEntity *self, const function_t *func );
        idThread( const function_t *func );
        idThread( idInterpreter *source, const function_t *func, int args );
        idThread( idInterpreter *source, idEntity *self, const function_t *func, int args );

 virtual ~idThread();


 void ManualDelete( void );


 void Save( idSaveGame *savefile ) const;
 void Restore( idRestoreGame *savefile );

 void EnableDebugInfo( void ) { interpreter.debug = true; };
 void DisableDebugInfo( void ) { interpreter.debug = false; };

 void WaitMS( int time );
 void WaitSec( float time );
 void WaitFrame( void );


 void CallFunction( const function_t *func, bool clearStack );


 void CallFunction( idEntity *obj, const function_t *func, bool clearStack );

 void DisplayInfo();
 static idThread *GetThread( int num );
 static void ListThreads_f( const idCmdArgs &args );
 static void Restart( void );
 static void ObjectMoveDone( int threadnum, idEntity *obj );

 static idList<idThread*>& GetThreads ( void );

 bool IsDoneProcessing ( void );
 bool IsDying ( void );

 void End( void );
 static void KillThread( const char *name );
 static void KillThread( int num );
 bool Execute( void );
 void ManualControl( void ) { manualControl = true; CancelEvents( &EV_Thread_Execute ); };
 void DoneProcessing( void ) { interpreter.doneProcessing = true; };
 void ContinueProcessing( void ) { interpreter.doneProcessing = false; };
 bool ThreadDying( void ) { return interpreter.threadDying; };
 void EndThread( void ) { interpreter.threadDying = true; };
 bool IsWaiting( void );
 void ClearWaitFor( void );
 bool IsWaitingFor( idEntity *obj );
 void ObjectMoveDone( idEntity *obj );
 void ThreadCallback( idThread *thread );
 void DelayedStart( int delay );
 bool Start( void );
 idThread *WaitingOnThread( void );
 void SetThreadNum( int num );
 int GetThreadNum( void );
 void SetThreadName( const char *name );
 const char *GetThreadName( void );

 void Error( const char *fmt, ... ) const __attribute__((format(printf,2,3)));
 void Warning( const char *fmt, ... ) const __attribute__((format(printf,2,3)));

 static idThread *CurrentThread( void );
 static int CurrentThreadNum( void );
 static bool BeginMultiFrameEvent( idEntity *ent, const idEventDef *event );
 static void EndMultiFrameEvent( idEntity *ent, const idEventDef *event );

 static void ReturnString( const char *text );
 static void ReturnFloat( float value );
 static void ReturnInt( int value );
 static void ReturnVector( idVec3 const &vec );
 static void ReturnEntity( idEntity *ent );
};






inline idThread *idThread::WaitingOnThread( void ) {
 return waitingForThread;
}






inline void idThread::SetThreadNum( int num ) {
 threadNum = num;
}






inline int idThread::GetThreadNum( void ) {
 return threadNum;
}






inline const char *idThread::GetThreadName( void ) {
 return threadName.c_str();
}






inline idList<idThread*>& idThread::GetThreads ( void ) {
 return threadList;
}






inline bool idThread::IsDoneProcessing ( void ) {
 return interpreter.doneProcessing;
}






inline bool idThread::IsDying ( void ) {
 return interpreter.threadDying;
}
# 747 "d:/Data/Nintendo/DoomGX/src/game/Game_local.h" 2
# 33 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp" 2
# 43 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
const idEventDef EV_PostSpawn( "<postspawn>", __null );
const idEventDef EV_FindTargets( "<findTargets>", __null );
const idEventDef EV_Touch( "<touch>", "et" );
const idEventDef EV_GetName( "getName", __null, 's' );
const idEventDef EV_SetName( "setName", "s" );
const idEventDef EV_Activate( "activate", "e" );
const idEventDef EV_ActivateTargets( "activateTargets", "e" );
const idEventDef EV_NumTargets( "numTargets", __null, 'f' );
const idEventDef EV_GetTarget( "getTarget", "f", 'e' );
const idEventDef EV_RandomTarget( "randomTarget", "s", 'e' );
const idEventDef EV_Bind( "bind", "e" );
const idEventDef EV_BindPosition( "bindPosition", "e" );
const idEventDef EV_BindToJoint( "bindToJoint", "esf" );
const idEventDef EV_Unbind( "unbind", __null );
const idEventDef EV_RemoveBinds( "removeBinds" );
const idEventDef EV_SpawnBind( "<spawnbind>", __null );
const idEventDef EV_SetOwner( "setOwner", "e" );
const idEventDef EV_SetModel( "setModel", "s" );
const idEventDef EV_SetSkin( "setSkin", "s" );
const idEventDef EV_GetWorldOrigin( "getWorldOrigin", __null, 'v' );
const idEventDef EV_SetWorldOrigin( "setWorldOrigin", "v" );
const idEventDef EV_GetOrigin( "getOrigin", __null, 'v' );
const idEventDef EV_SetOrigin( "setOrigin", "v" );
const idEventDef EV_GetAngles( "getAngles", __null, 'v' );
const idEventDef EV_SetAngles( "setAngles", "v" );
const idEventDef EV_GetLinearVelocity( "getLinearVelocity", __null, 'v' );
const idEventDef EV_SetLinearVelocity( "setLinearVelocity", "v" );
const idEventDef EV_GetAngularVelocity( "getAngularVelocity", __null, 'v' );
const idEventDef EV_SetAngularVelocity( "setAngularVelocity", "v" );
const idEventDef EV_GetSize( "getSize", __null, 'v' );
const idEventDef EV_SetSize( "setSize", "vv" );
const idEventDef EV_GetMins( "getMins", __null, 'v' );
const idEventDef EV_GetMaxs( "getMaxs", __null, 'v' );
const idEventDef EV_IsHidden( "isHidden", __null, 'd' );
const idEventDef EV_Hide( "hide", __null );
const idEventDef EV_Show( "show", __null );
const idEventDef EV_Touches( "touches", "E", 'd' );
const idEventDef EV_ClearSignal( "clearSignal", "d" );
const idEventDef EV_GetShaderParm( "getShaderParm", "d", 'f' );
const idEventDef EV_SetShaderParm( "setShaderParm", "df" );
const idEventDef EV_SetShaderParms( "setShaderParms", "ffff" );
const idEventDef EV_SetColor( "setColor", "fff" );
const idEventDef EV_GetColor( "getColor", __null, 'v' );
const idEventDef EV_CacheSoundShader( "cacheSoundShader", "s" );
const idEventDef EV_StartSoundShader( "startSoundShader", "sd", 'f' );
const idEventDef EV_StartSound( "startSound", "sdd", 'f' );
const idEventDef EV_StopSound( "stopSound", "dd" );
const idEventDef EV_FadeSound( "fadeSound", "dff" );
const idEventDef EV_SetGuiParm( "setGuiParm", "ss" );
const idEventDef EV_SetGuiFloat( "setGuiFloat", "sf" );
const idEventDef EV_GetNextKey( "getNextKey", "ss", 's' );
const idEventDef EV_SetKey( "setKey", "ss" );
const idEventDef EV_GetKey( "getKey", "s", 's' );
const idEventDef EV_GetIntKey( "getIntKey", "s", 'f' );
const idEventDef EV_GetFloatKey( "getFloatKey", "s", 'f' );
const idEventDef EV_GetVectorKey( "getVectorKey", "s", 'v' );
const idEventDef EV_GetEntityKey( "getEntityKey", "s", 'e' );
const idEventDef EV_RestorePosition( "restorePosition" );
const idEventDef EV_UpdateCameraTarget( "<updateCameraTarget>", __null );
const idEventDef EV_DistanceTo( "distanceTo", "E", 'f' );
const idEventDef EV_DistanceToPoint( "distanceToPoint", "v", 'f' );
const idEventDef EV_StartFx( "startFx", "s" );
const idEventDef EV_HasFunction( "hasFunction", "s", 'd' );
const idEventDef EV_CallFunction( "callFunction", "s" );
const idEventDef EV_SetNeverDormant( "setNeverDormant", "d" );

idTypeInfo idEntity::Type( "idEntity", "idClass", ( idEventFunc<idClass> * )idEntity::eventCallbacks, idEntity::CreateInstance, ( void ( idClass::* )( void ) )&idEntity::Spawn, ( void ( idClass::* )( idSaveGame * ) const )&idEntity::Save, ( void ( idClass::* )( idRestoreGame * ) )&idEntity::Restore ); idClass *idEntity::CreateInstance( void ) { gameLocal.Error( "Cannot instanciate abstract class %s.", "idEntity" ); return __null; } idTypeInfo *idEntity::GetType( void ) const { return &( idEntity::Type ); } idEventFunc<idEntity> idEntity::eventCallbacks[] = {
 { &( EV_GetName ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetName ) },
 { &( EV_SetName ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetName ) },
 { &( EV_FindTargets ), ( void ( idClass::* )( void ) )( &idEntity::Event_FindTargets ) },
 { &( EV_ActivateTargets ), ( void ( idClass::* )( void ) )( &idEntity::Event_ActivateTargets ) },
 { &( EV_NumTargets ), ( void ( idClass::* )( void ) )( &idEntity::Event_NumTargets ) },
 { &( EV_GetTarget ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetTarget ) },
 { &( EV_RandomTarget ), ( void ( idClass::* )( void ) )( &idEntity::Event_RandomTarget ) },
 { &( EV_BindToJoint ), ( void ( idClass::* )( void ) )( &idEntity::Event_BindToJoint ) },
 { &( EV_RemoveBinds ), ( void ( idClass::* )( void ) )( &idEntity::Event_RemoveBinds ) },
 { &( EV_Bind ), ( void ( idClass::* )( void ) )( &idEntity::Event_Bind ) },
 { &( EV_BindPosition ), ( void ( idClass::* )( void ) )( &idEntity::Event_BindPosition ) },
 { &( EV_Unbind ), ( void ( idClass::* )( void ) )( &idEntity::Event_Unbind ) },
 { &( EV_SpawnBind ), ( void ( idClass::* )( void ) )( &idEntity::Event_SpawnBind ) },
 { &( EV_SetOwner ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetOwner ) },
 { &( EV_SetModel ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetModel ) },
 { &( EV_SetSkin ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetSkin ) },
 { &( EV_GetShaderParm ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetShaderParm ) },
 { &( EV_SetShaderParm ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetShaderParm ) },
 { &( EV_SetShaderParms ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetShaderParms ) },
 { &( EV_SetColor ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetColor ) },
 { &( EV_GetColor ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetColor ) },
 { &( EV_IsHidden ), ( void ( idClass::* )( void ) )( &idEntity::Event_IsHidden ) },
 { &( EV_Hide ), ( void ( idClass::* )( void ) )( &idEntity::Event_Hide ) },
 { &( EV_Show ), ( void ( idClass::* )( void ) )( &idEntity::Event_Show ) },
 { &( EV_CacheSoundShader ), ( void ( idClass::* )( void ) )( &idEntity::Event_CacheSoundShader ) },
 { &( EV_StartSoundShader ), ( void ( idClass::* )( void ) )( &idEntity::Event_StartSoundShader ) },
 { &( EV_StartSound ), ( void ( idClass::* )( void ) )( &idEntity::Event_StartSound ) },
 { &( EV_StopSound ), ( void ( idClass::* )( void ) )( &idEntity::Event_StopSound ) },
 { &( EV_FadeSound ), ( void ( idClass::* )( void ) )( &idEntity::Event_FadeSound ) },
 { &( EV_GetWorldOrigin ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetWorldOrigin ) },
 { &( EV_SetWorldOrigin ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetWorldOrigin ) },
 { &( EV_GetOrigin ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetOrigin ) },
 { &( EV_SetOrigin ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetOrigin ) },
 { &( EV_GetAngles ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetAngles ) },
 { &( EV_SetAngles ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetAngles ) },
 { &( EV_GetLinearVelocity ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetLinearVelocity ) },
 { &( EV_SetLinearVelocity ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetLinearVelocity ) },
 { &( EV_GetAngularVelocity ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetAngularVelocity ) },
 { &( EV_SetAngularVelocity ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetAngularVelocity ) },
 { &( EV_GetSize ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetSize ) },
 { &( EV_SetSize ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetSize ) },
 { &( EV_GetMins ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetMins ) },
 { &( EV_GetMaxs ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetMaxs ) },
 { &( EV_Touches ), ( void ( idClass::* )( void ) )( &idEntity::Event_Touches ) },
 { &( EV_SetGuiParm ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetGuiParm ) },
 { &( EV_SetGuiFloat ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetGuiFloat ) },
 { &( EV_GetNextKey ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetNextKey ) },
 { &( EV_SetKey ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetKey ) },
 { &( EV_GetKey ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetKey ) },
 { &( EV_GetIntKey ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetIntKey ) },
 { &( EV_GetFloatKey ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetFloatKey ) },
 { &( EV_GetVectorKey ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetVectorKey ) },
 { &( EV_GetEntityKey ), ( void ( idClass::* )( void ) )( &idEntity::Event_GetEntityKey ) },
 { &( EV_RestorePosition ), ( void ( idClass::* )( void ) )( &idEntity::Event_RestorePosition ) },
 { &( EV_UpdateCameraTarget ), ( void ( idClass::* )( void ) )( &idEntity::Event_UpdateCameraTarget ) },
 { &( EV_DistanceTo ), ( void ( idClass::* )( void ) )( &idEntity::Event_DistanceTo ) },
 { &( EV_DistanceToPoint ), ( void ( idClass::* )( void ) )( &idEntity::Event_DistanceToPoint ) },
 { &( EV_StartFx ), ( void ( idClass::* )( void ) )( &idEntity::Event_StartFx ) },
 { &( EV_Thread_WaitFrame ), ( void ( idClass::* )( void ) )( &idEntity::Event_WaitFrame ) },
 { &( EV_Thread_Wait ), ( void ( idClass::* )( void ) )( &idEntity::Event_Wait ) },
 { &( EV_HasFunction ), ( void ( idClass::* )( void ) )( &idEntity::Event_HasFunction ) },
 { &( EV_CallFunction ), ( void ( idClass::* )( void ) )( &idEntity::Event_CallFunction ) },
 { &( EV_SetNeverDormant ), ( void ( idClass::* )( void ) )( &idEntity::Event_SetNeverDormant ) },
{ __null, __null } };






void UpdateGuiParms( idUserInterface *gui, const idDict *args ) {
 if ( gui == __null || args == __null ) {
  return;
 }
 const idKeyValue *kv = args->MatchPrefix( "gui_parm", __null );
 while( kv ) {
  gui->SetStateString( kv->GetKey(), kv->GetValue() );
  kv = args->MatchPrefix( "gui_parm", kv );
 }
 gui->SetStateBool( "noninteractive", args->GetBool( "gui_noninteractive" ) ) ;
 gui->StateChanged( gameLocal.time );
}






void AddRenderGui( const char *name, idUserInterface **gui, const idDict *args ) {
 const idKeyValue *kv = args->MatchPrefix( "gui_parm", __null );
 *gui = uiManager->FindGui( name, true, ( kv != __null ) );
 UpdateGuiParms( *gui, args );
}
# 213 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idGameEdit::ParseSpawnArgsToRenderEntity( const idDict *args, renderEntity_t *renderEntity ) {
 int i;
 const char *temp;
 idVec3 color;
 float angle;
 const idDeclModelDef *modelDef;

 memset( renderEntity, 0, sizeof( *renderEntity ) );

 temp = args->GetString( "model" );

 modelDef = __null;
 if ( temp[0] != '\0' ) {
  modelDef = static_cast<const idDeclModelDef *>( declManager->FindType( DECL_MODELDEF, temp, false ) );
  if ( modelDef ) {
   renderEntity->hModel = modelDef->ModelHandle();
  }
  if ( !renderEntity->hModel ) {
   renderEntity->hModel = renderModelManager->FindModel( temp );
  }
 }
 if ( renderEntity->hModel ) {
  renderEntity->bounds = renderEntity->hModel->Bounds( renderEntity );
 } else {
  renderEntity->bounds.Zero();
 }

 temp = args->GetString( "skin" );
 if ( temp[0] != '\0' ) {
  renderEntity->customSkin = declManager->FindSkin( temp );
 } else if ( modelDef ) {
  renderEntity->customSkin = modelDef->GetDefaultSkin();
 }

 temp = args->GetString( "shader" );
 if ( temp[0] != '\0' ) {
  renderEntity->customShader = declManager->FindMaterial( temp );
 }

 args->GetVector( "origin", "0 0 0", renderEntity->origin );


 if ( !args->GetMatrix( "rotation", "1 0 0 0 1 0 0 0 1", renderEntity->axis ) ) {
  angle = args->GetFloat( "angle" );
  if ( angle != 0.0f ) {
   renderEntity->axis = idAngles( 0.0f, angle, 0.0f ).ToMat3();
  } else {
   renderEntity->axis.Identity();
  }
 }

 renderEntity->referenceSound = __null;


 args->GetVector( "_color", "1 1 1", color );
 renderEntity->shaderParms[ SHADERPARM_RED ] = color[0];
 renderEntity->shaderParms[ SHADERPARM_GREEN ] = color[1];
 renderEntity->shaderParms[ SHADERPARM_BLUE ] = color[2];
 renderEntity->shaderParms[ 3 ] = args->GetFloat( "shaderParm3", "1" );
 renderEntity->shaderParms[ 4 ] = args->GetFloat( "shaderParm4", "0" );
 renderEntity->shaderParms[ 5 ] = args->GetFloat( "shaderParm5", "0" );
 renderEntity->shaderParms[ 6 ] = args->GetFloat( "shaderParm6", "0" );
 renderEntity->shaderParms[ 7 ] = args->GetFloat( "shaderParm7", "0" );
 renderEntity->shaderParms[ 8 ] = args->GetFloat( "shaderParm8", "0" );
 renderEntity->shaderParms[ 9 ] = args->GetFloat( "shaderParm9", "0" );
 renderEntity->shaderParms[ 10 ] = args->GetFloat( "shaderParm10", "0" );
 renderEntity->shaderParms[ 11 ] = args->GetFloat( "shaderParm11", "0" );


 renderEntity->noDynamicInteractions = args->GetBool( "noDynamicInteractions" );


 renderEntity->noShadow = args->GetBool( "noshadows" );


 renderEntity->noSelfShadow = args->GetBool( "noselfshadows" );


 for( i = 0; i < MAX_RENDERENTITY_GUI; i++ ) {
  temp = args->GetString( i == 0 ? "gui" : va( "gui%d", i + 1 ) );
  if ( temp[ 0 ] != '\0' ) {
   AddRenderGui( temp, &renderEntity->gui[ i ], args );
  }
 }
}
# 308 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idGameEdit::ParseSpawnArgsToRefSound( const idDict *args, refSound_t *refSound ) {
 const char *temp;

 memset( refSound, 0, sizeof( *refSound ) );

 refSound->parms.minDistance = args->GetFloat( "s_mindistance" );
 refSound->parms.maxDistance = args->GetFloat( "s_maxdistance" );
 refSound->parms.volume = args->GetFloat( "s_volume" );
 refSound->parms.shakes = args->GetFloat( "s_shakes" );

 args->GetVector( "origin", "0 0 0", refSound->origin );

 refSound->referenceSound = __null;




 refSound->diversity = args->GetFloat( "s_diversity", "-1" );
 refSound->waitfortrigger = args->GetBool( "s_waitfortrigger" );

 if ( args->GetBool( "s_omni" ) ) {
  refSound->parms.soundShaderFlags |= SSF_OMNIDIRECTIONAL;
 }
 if ( args->GetBool( "s_looping" ) ) {
  refSound->parms.soundShaderFlags |= SSF_LOOPING;
 }
 if ( args->GetBool( "s_occlusion" ) ) {
  refSound->parms.soundShaderFlags |= SSF_NO_OCCLUSION;
 }
 if ( args->GetBool( "s_global" ) ) {
  refSound->parms.soundShaderFlags |= SSF_GLOBAL;
 }
 if ( args->GetBool( "s_unclamped" ) ) {
  refSound->parms.soundShaderFlags |= SSF_UNCLAMPED;
 }
 refSound->parms.soundClass = args->GetInt( "s_soundClass" );

 temp = args->GetString( "s_shader" );
 if ( temp[0] != '\0' ) {

 }
}
# 361 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::UpdateChangeableSpawnArgs( const idDict *source ) {
 int i;
 const char *target;

 if ( !source ) {
  source = &spawnArgs;
 }
 cameraTarget = __null;
 target = source->GetString( "cameraTarget" );
 if ( target && target[0] ) {

  PostEventMS( &EV_UpdateCameraTarget, 0 );
 }

 for ( i = 0; i < MAX_RENDERENTITY_GUI; i++ ) {
  UpdateGuiParms( renderEntity.gui[ i ], source );
 }
}






idEntity::idEntity() {

    Sys_DebugPrintf("idEntity::idEntity() size %d\r\n", sizeof(*this));



 entityNumber = ((1<<12)-1);
 entityDefNumber = -1;

 spawnNode.SetOwner( this );
 activeNode.SetOwner( this );

 snapshotNode.SetOwner( this );
 snapshotSequence = -1;
 snapshotBits = 0;

 thinkFlags = 0;
 dormantStart = 0;
 cinematic = false;
 renderView = __null;
 cameraTarget = __null;
 health = 0;

 physics = __null;
 bindMaster = __null;
 bindJoint = INVALID_JOINT;
 bindBody = -1;
 teamMaster = __null;
 teamChain = __null;
 signals = __null;

 memset( PVSAreas, 0, sizeof( PVSAreas ) );
 numPVSAreas = -1;

 memset( &fl, 0, sizeof( fl ) );
 fl.neverDormant = true;

 memset( &renderEntity, 0, sizeof( renderEntity ) );
 modelDefHandle = -1;
 memset( &refSound, 0, sizeof( refSound ) );

 mpGUIState = -1;
}






void idEntity::FixupLocalizedStrings() {
 for ( int i = 0; i < spawnArgs.GetNumKeyVals(); i++ ) {
  const idKeyValue *kv = spawnArgs.GetKeyVal( i );
  if ( idStr::Cmpn( kv->GetValue(), "#str_", 5 ) == 0 ){
   spawnArgs.Set( kv->GetKey(), common->GetLanguageDict()->GetString( kv->GetValue() ) );
  }
 }
}






void idEntity::Spawn( void ) {
 int i;
 const char *temp;
 idVec3 origin;
 idMat3 axis;
 const idKeyValue *networkSync;
 const char *classname;
 const char *scriptObjectName;
Sys_Printf(">>> TRACE_CLIPMODEL idEntity::Spawn %p %s\r\n", this, this->GetName());
Sys_PrintBacktrace();

 gameLocal.RegisterEntity( this );

 spawnArgs.GetString( "classname", __null, &classname );
 const idDeclEntityDef *def = gameLocal.FindEntityDef( classname, false );
 if ( def ) {
  entityDefNumber = def->Index();
 }

 FixupLocalizedStrings();


 gameEdit->ParseSpawnArgsToRenderEntity( &spawnArgs, &renderEntity );

 renderEntity.entityNum = entityNumber;


 dormantStart = gameLocal.time - DELAY_DORMANT_TIME + gameLocal.msec * 5;

 origin = renderEntity.origin;
 axis = renderEntity.axis;


 gameEdit->ParseSpawnArgsToRefSound( &spawnArgs, &refSound );



 refSound.listenerId = entityNumber + 1;

 cameraTarget = __null;
 temp = spawnArgs.GetString( "cameraTarget" );
 if ( temp && temp[0] ) {

  PostEventMS( &EV_UpdateCameraTarget, 0 );
 }

 for ( i = 0; i < MAX_RENDERENTITY_GUI; i++ ) {
  UpdateGuiParms( renderEntity.gui[ i ], &spawnArgs );
 }

 fl.solidForTeam = spawnArgs.GetBool( "solidForTeam", "0" );
 fl.neverDormant = spawnArgs.GetBool( "neverDormant", "0" );
 fl.hidden = spawnArgs.GetBool( "hide", "0" );
 if ( fl.hidden ) {

  PostEventMS( &EV_Hide, 0 );
 }
 cinematic = spawnArgs.GetBool( "cinematic", "0" );

 networkSync = spawnArgs.FindKey( "networkSync" );
 if ( networkSync ) {
  fl.networkSync = ( atoi( networkSync->GetValue() ) != 0 );
 }
# 522 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
 temp = spawnArgs.GetString( "name", va( "%s_%s_%d", GetClassname(), spawnArgs.GetString( "classname" ), entityNumber ) );
 SetName( temp );


 if ( spawnArgs.MatchPrefix( "target" ) || spawnArgs.MatchPrefix( "guiTarget" ) ) {
  if ( gameLocal.GameState() == GAMESTATE_STARTUP ) {
   PostEventMS( &EV_FindTargets, 0 );
  } else {

   FindTargets();
  }
 }

 health = spawnArgs.GetInt( "health" );

 InitDefaultPhysics( origin, axis );

 SetOrigin( origin );
 SetAxis( axis );

 temp = spawnArgs.GetString( "model" );
 if ( temp && *temp ) {
  SetModel( temp );
 }

 if ( spawnArgs.GetString( "bind", "", &temp ) ) {
  PostEventMS( &EV_SpawnBind, 0 );
 }


 if ( refSound.shader && !refSound.waitfortrigger ) {
  StartSoundShader( refSound.shader, SND_CHANNEL_ANY, 0, false, __null );
 }


 if ( ShouldConstructScriptObjectAtSpawn() && spawnArgs.GetString( "scriptobject", __null, &scriptObjectName ) ) {
  if ( !scriptObject.SetType( scriptObjectName ) ) {
   gameLocal.Error( "Script object '%s' not found on entity '%s'.", scriptObjectName, name.c_str() );
  }

  ConstructScriptObject();
 }
}






idEntity::~idEntity( void ) {

 if ( gameLocal.GameState() != GAMESTATE_SHUTDOWN && !gameLocal.isClient && fl.networkSync && entityNumber >= 4 ) {
  idBitMsg msg;
  byte msgBuf[ MAX_GAME_MESSAGE_SIZE ];

  msg.Init( msgBuf, sizeof( msgBuf ) );
  msg.WriteByte( GAME_RELIABLE_MESSAGE_DELETE_ENT );
  msg.WriteBits( gameLocal.GetSpawnId( this ), 32 );
  networkSystem->ServerSendReliableMessage( -1, msg );
 }

 DeconstructScriptObject();
 scriptObject.Free();

 if ( thinkFlags ) {
  BecomeInactive( thinkFlags );
 }
 activeNode.Remove();

 Signal( SIG_REMOVED );



 SetPhysics( __null );


 RemoveBinds();


 Unbind();
 QuitTeam();

 gameLocal.RemoveEntityFromHash( name.c_str(), this );

 delete renderView;
 renderView = __null;

 delete signals;
 signals = __null;

 FreeModelDef();
 FreeSoundEmitter( false );

 gameLocal.UnregisterEntity( this );
}






void idEntity::Save( idSaveGame *savefile ) const {
 int i, j;

 savefile->WriteInt( entityNumber );
 savefile->WriteInt( entityDefNumber );



 savefile->WriteInt( snapshotSequence );
 savefile->WriteInt( snapshotBits );

 savefile->WriteDict( &spawnArgs );
 savefile->WriteString( name );
 scriptObject.Save( savefile );

 savefile->WriteInt( thinkFlags );
 savefile->WriteInt( dormantStart );
 savefile->WriteBool( cinematic );

 savefile->WriteObject( cameraTarget );

 savefile->WriteInt( health );

 savefile->WriteInt( targets.Num() );
 for( i = 0; i < targets.Num(); i++ ) {
  targets[ i ].Save( savefile );
 }

 entityFlags_s flags = fl;
 LittleBitField( &flags, sizeof( flags ) );
 savefile->Write( &flags, sizeof( flags ) );

 savefile->WriteRenderEntity( renderEntity );
 savefile->WriteInt( modelDefHandle );
 savefile->WriteRefSound( refSound );

 savefile->WriteObject( bindMaster );
 savefile->WriteJoint( bindJoint );
 savefile->WriteInt( bindBody );
 savefile->WriteObject( teamMaster );
 savefile->WriteObject( teamChain );

 savefile->WriteStaticObject( defaultPhysicsObj );

 savefile->WriteInt( numPVSAreas );
 for( i = 0; i < MAX_PVS_AREAS; i++ ) {
  savefile->WriteInt( PVSAreas[ i ] );
 }

 if ( !signals ) {
  savefile->WriteBool( false );
 } else {
  savefile->WriteBool( true );
  for( i = 0; i < NUM_SIGNALS; i++ ) {
   savefile->WriteInt( signals->signal[ i ].Num() );
   for( j = 0; j < signals->signal[ i ].Num(); j++ ) {
    savefile->WriteInt( signals->signal[ i ][ j ].threadnum );
    savefile->WriteString( signals->signal[ i ][ j ].function->Name() );
   }
  }
 }

 savefile->WriteInt( mpGUIState );
}






void idEntity::Restore( idRestoreGame *savefile ) {
 int i, j;
 int num;
 idStr funcname;

 savefile->ReadInt( entityNumber );
 savefile->ReadInt( entityDefNumber );



 savefile->ReadInt( snapshotSequence );
 savefile->ReadInt( snapshotBits );

 savefile->ReadDict( &spawnArgs );
 savefile->ReadString( name );
 SetName( name );

 scriptObject.Restore( savefile );

 savefile->ReadInt( thinkFlags );
 savefile->ReadInt( dormantStart );
 savefile->ReadBool( cinematic );

 savefile->ReadObject( reinterpret_cast<idClass *&>( cameraTarget ) );

 savefile->ReadInt( health );

 targets.Clear();
 savefile->ReadInt( num );
 targets.SetNum( num );
 for( i = 0; i < num; i++ ) {
  targets[ i ].Restore( savefile );
 }

 savefile->Read( &fl, sizeof( fl ) );
 LittleBitField( &fl, sizeof( fl ) );

 savefile->ReadRenderEntity( renderEntity );
 savefile->ReadInt( modelDefHandle );
 savefile->ReadRefSound( refSound );

 savefile->ReadObject( reinterpret_cast<idClass *&>( bindMaster ) );
 savefile->ReadJoint( bindJoint );
 savefile->ReadInt( bindBody );
 savefile->ReadObject( reinterpret_cast<idClass *&>( teamMaster ) );
 savefile->ReadObject( reinterpret_cast<idClass *&>( teamChain ) );

 savefile->ReadStaticObject( defaultPhysicsObj );
 RestorePhysics( &defaultPhysicsObj );

 savefile->ReadInt( numPVSAreas );
 for( i = 0; i < MAX_PVS_AREAS; i++ ) {
  savefile->ReadInt( PVSAreas[ i ] );
 }

 bool readsignals;
 savefile->ReadBool( readsignals );
 if ( readsignals ) {
  signals = new signalList_t;
  for( i = 0; i < NUM_SIGNALS; i++ ) {
   savefile->ReadInt( num );
   signals->signal[ i ].SetNum( num );
   for( j = 0; j < num; j++ ) {
    savefile->ReadInt( signals->signal[ i ][ j ].threadnum );
    savefile->ReadString( funcname );
    signals->signal[ i ][ j ].function = gameLocal.program.FindFunction( funcname );
    if ( !signals->signal[ i ][ j ].function ) {
     savefile->Error( "Function '%s' not found", funcname.c_str() );
    }
   }
  }
 }

 savefile->ReadInt( mpGUIState );


 if ( modelDefHandle != -1 ) {
  modelDefHandle = gameRenderWorld->AddEntityDef( &renderEntity );
 }
}






const char * idEntity::GetEntityDefName( void ) const {
 if ( entityDefNumber < 0 ) {
  return "*unknown*";
 }
 return declManager->DeclByIndex( DECL_ENTITYDEF, entityDefNumber, false )->GetName();
}






void idEntity::SetName( const char *newname ) {
 if ( name.Length() ) {
  gameLocal.RemoveEntityFromHash( name.c_str(), this );
  gameLocal.program.SetEntity( name, __null );
 }

 name = newname;
 if ( name.Length() ) {
  if ( ( name == "NULL" ) || ( name == "null_entity" ) ) {
   gameLocal.Error( "Cannot name entity '%s'.  '%s' is reserved for script.", name.c_str(), name.c_str() );
  }
  gameLocal.AddEntityToHash( name.c_str(), this );
  gameLocal.program.SetEntity( name, this );
 }
}






const char * idEntity::GetName( void ) const {
 return name.c_str();
}
# 828 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::Think( void ) {
 RunPhysics();
 Present();
}
# 841 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::DoDormantTests( void ) {

 if ( fl.neverDormant ) {
  return false;
 }


 if ( !gameLocal.InPlayerConnectedArea( this ) ) {
  if ( dormantStart == 0 ) {
   dormantStart = gameLocal.time;
  }
  if ( gameLocal.time - dormantStart < DELAY_DORMANT_TIME ) {

   return false;
  }
  return true;
 } else {


  if ( !fl.hasAwakened ) {
   if ( !gameLocal.InPlayerPVS( this ) ) {
    return true;
   }
  }


  dormantStart = 0;
  fl.hasAwakened = true;
  return false;
 }

 return false;
}
# 883 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::CheckDormant( void ) {
 bool dormant;

 dormant = DoDormantTests();
 if ( dormant && !fl.isDormant ) {
  fl.isDormant = true;
  DormantBegin();
 } else if ( !dormant && fl.isDormant ) {
  fl.isDormant = false;
  DormantEnd();
 }

 return dormant;
}
# 905 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::DormantBegin( void ) {
}
# 915 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::DormantEnd( void ) {
}






bool idEntity::IsActive( void ) const {
 return activeNode.InList();
}






void idEntity::BecomeActive( int flags ) {
 if ( ( flags & TH_PHYSICS ) ) {

  if ( teamMaster && teamMaster != this ) {
   teamMaster->BecomeActive( TH_PHYSICS );
  } else if ( !( thinkFlags & TH_PHYSICS ) ) {

   if ( physics->IsType( idPhysics_Parametric::Type ) || physics->IsType( idPhysics_Actor::Type ) ) {
    gameLocal.sortPushers = true;
   }
  }
 }

 int oldFlags = thinkFlags;
 thinkFlags |= flags;
 if ( thinkFlags ) {
  if ( !IsActive() ) {
   activeNode.AddToEnd( gameLocal.activeEntities );
  } else if ( !oldFlags ) {

   gameLocal.numEntitiesToDeactivate--;
  }
 }
}






void idEntity::BecomeInactive( int flags ) {
 if ( ( flags & TH_PHYSICS ) ) {

  if ( teamMaster == this ) {
   for ( idEntity *ent = teamMaster->teamChain; ent; ent = ent->teamChain ) {
    if ( ( ent->thinkFlags & TH_PHYSICS ) || ( ( ent->bindMaster == this ) && ( ent->bindJoint != INVALID_JOINT ) ) ) {
     flags &= ~TH_PHYSICS;
     break;
    }
   }
  }
 }

 if ( thinkFlags ) {
  thinkFlags &= ~flags;
  if ( !thinkFlags && IsActive() ) {
   gameLocal.numEntitiesToDeactivate++;
  }
 }

 if ( ( flags & TH_PHYSICS ) ) {

  if ( teamMaster && teamMaster != this ) {

   if ( teamMaster->IsAtRest() ) {
    teamMaster->BecomeInactive( TH_PHYSICS );
   }
  }
 }
}
# 1004 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::SetShaderParm( int parmnum, float value ) {
 if ( ( parmnum < 0 ) || ( parmnum >= MAX_ENTITY_SHADER_PARMS ) ) {
  gameLocal.Warning( "shader parm index (%d) out of range", parmnum );
  return;
 }

 renderEntity.shaderParms[ parmnum ] = value;
 UpdateVisuals();
}






void idEntity::SetColor( float red, float green, float blue ) {
 renderEntity.shaderParms[ SHADERPARM_RED ] = red;
 renderEntity.shaderParms[ SHADERPARM_GREEN ] = green;
 renderEntity.shaderParms[ SHADERPARM_BLUE ] = blue;
 UpdateVisuals();
}






void idEntity::SetColor( const idVec3 &color ) {
 SetColor( color[ 0 ], color[ 1 ], color[ 2 ] );
 UpdateVisuals();
}






void idEntity::GetColor( idVec3 &out ) const {
 out[ 0 ] = renderEntity.shaderParms[ SHADERPARM_RED ];
 out[ 1 ] = renderEntity.shaderParms[ SHADERPARM_GREEN ];
 out[ 2 ] = renderEntity.shaderParms[ SHADERPARM_BLUE ];
}






void idEntity::SetColor( const idVec4 &color ) {
 renderEntity.shaderParms[ SHADERPARM_RED ] = color[ 0 ];
 renderEntity.shaderParms[ SHADERPARM_GREEN ] = color[ 1 ];
 renderEntity.shaderParms[ SHADERPARM_BLUE ] = color[ 2 ];
 renderEntity.shaderParms[ SHADERPARM_ALPHA ] = color[ 3 ];
 UpdateVisuals();
}






void idEntity::GetColor( idVec4 &out ) const {
 out[ 0 ] = renderEntity.shaderParms[ SHADERPARM_RED ];
 out[ 1 ] = renderEntity.shaderParms[ SHADERPARM_GREEN ];
 out[ 2 ] = renderEntity.shaderParms[ SHADERPARM_BLUE ];
 out[ 3 ] = renderEntity.shaderParms[ SHADERPARM_ALPHA ];
}






bool idEntity::UpdateAnimationControllers( void ) {

 return false;
}






void idEntity::SetModel( const char *modelname ) {
 ((void)0);

 FreeModelDef();

 renderEntity.hModel = renderModelManager->FindModel( modelname );

 if ( renderEntity.hModel ) {
  renderEntity.hModel->Reset();
 }

 renderEntity.callback = __null;
 renderEntity.numJoints = 0;
 renderEntity.joints = __null;
 if ( renderEntity.hModel ) {
  renderEntity.bounds = renderEntity.hModel->Bounds( &renderEntity );
 } else {
  renderEntity.bounds.Zero();
 }

 UpdateVisuals();
}






void idEntity::SetSkin( const idDeclSkin *skin ) {
 renderEntity.customSkin = skin;
 UpdateVisuals();
}






const idDeclSkin *idEntity::GetSkin( void ) const {
 return renderEntity.customSkin;
}






void idEntity::FreeModelDef( void ) {
 if ( modelDefHandle != -1 ) {
  gameRenderWorld->FreeEntityDef( modelDefHandle );
  modelDefHandle = -1;
 }
}






void idEntity::FreeLightDef( void ) {
}






bool idEntity::IsHidden( void ) const {
 return fl.hidden;
}






void idEntity::Hide( void ) {
 if ( !IsHidden() ) {
  fl.hidden = true;
  FreeModelDef();
  UpdateVisuals();
 }
}






void idEntity::Show( void ) {
 if ( IsHidden() ) {
  fl.hidden = false;
  UpdateVisuals();
 }
}






void idEntity::UpdateModelTransform( void ) {
 idVec3 origin;
 idMat3 axis;

 if ( GetPhysicsToVisualTransform( origin, axis ) ) {
  renderEntity.axis = axis * GetPhysics()->GetAxis();
  renderEntity.origin = GetPhysics()->GetOrigin() + origin * renderEntity.axis;
 } else {
  renderEntity.axis = GetPhysics()->GetAxis();
  renderEntity.origin = GetPhysics()->GetOrigin();
 }
}






void idEntity::UpdateModel( void ) {
 UpdateModelTransform();


 idAnimator *animator = GetAnimator();
 if ( animator && animator->ModelHandle() ) {

  renderEntity.callback = idEntity::ModelCallback;
 }


 ClearPVSAreas();


 BecomeActive( TH_UPDATEVISUALS );
}






void idEntity::UpdateVisuals( void ) {
 UpdateModel();
 UpdateSound();
}






void idEntity::UpdatePVSAreas( void ) {
 int localNumPVSAreas, localPVSAreas[32];
 idBounds modelAbsBounds;
 int i;

 modelAbsBounds.FromTransformedBounds( renderEntity.bounds, renderEntity.origin, renderEntity.axis );
 localNumPVSAreas = gameLocal.pvs.GetPVSAreas( modelAbsBounds, localPVSAreas, sizeof( localPVSAreas ) / sizeof( localPVSAreas[0] ) );



 if ( localNumPVSAreas > MAX_PVS_AREAS ) {
  localNumPVSAreas = gameLocal.pvs.GetPVSAreas( idBounds( modelAbsBounds.GetCenter() ).Expand( 64.0f ), localPVSAreas, sizeof( localPVSAreas ) / sizeof( localPVSAreas[0] ) );
 }

 for ( numPVSAreas = 0; numPVSAreas < MAX_PVS_AREAS && numPVSAreas < localNumPVSAreas; numPVSAreas++ ) {
  PVSAreas[numPVSAreas] = localPVSAreas[numPVSAreas];
 }

 for( i = numPVSAreas; i < MAX_PVS_AREAS; i++ ) {
  PVSAreas[ i ] = 0;
 }
}






void idEntity::UpdatePVSAreas( const idVec3 &pos ) {
 int i;

 numPVSAreas = gameLocal.pvs.GetPVSAreas( idBounds( pos ), PVSAreas, MAX_PVS_AREAS );
 i = numPVSAreas;
 while ( i < MAX_PVS_AREAS ) {
  PVSAreas[ i++ ] = 0;
 }
}






int idEntity::GetNumPVSAreas( void ) {
 if ( numPVSAreas < 0 ) {
  UpdatePVSAreas();
 }
 return numPVSAreas;
}






const int *idEntity::GetPVSAreas( void ) {
 if ( numPVSAreas < 0 ) {
  UpdatePVSAreas();
 }
 return PVSAreas;
}






void idEntity::ClearPVSAreas( void ) {
 numPVSAreas = -1;
}
# 1316 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::PhysicsTeamInPVS( pvsHandle_t pvsHandle ) {
 idEntity *part;

 if ( teamMaster ) {
  for ( part = teamMaster; part; part = part->teamChain ) {
   if ( gameLocal.pvs.InCurrentPVS( pvsHandle, part->GetPVSAreas(), part->GetNumPVSAreas() ) ) {
    return true;
   }
  }
 } else {
  return gameLocal.pvs.InCurrentPVS( pvsHandle, GetPVSAreas(), GetNumPVSAreas() );
 }
 return false;
}






void idEntity::ProjectOverlay( const idVec3 &origin, const idVec3 &dir, float size, const char *material ) {
 float s, c;
 idMat3 axis, axistemp;
 idVec3 localOrigin, localAxis[2];
 idPlane localPlane[2];


 if ( modelDefHandle < 0 ) {
  return;
 }


 if ( renderEntity.hModel->IsDynamicModel() != DM_CACHED ) {
  return;
 }

 idMath::SinCos16( gameLocal.random.RandomFloat() * idMath::TWO_PI, s, c );

 axis[2] = -dir;
 axis[2].NormalVectors( axistemp[0], axistemp[1] );
 axis[0] = axistemp[ 0 ] * c + axistemp[ 1 ] * -s;
 axis[1] = axistemp[ 0 ] * -s + axistemp[ 1 ] * -c;

 renderEntity.axis.ProjectVector( origin - renderEntity.origin, localOrigin );
 renderEntity.axis.ProjectVector( axis[0], localAxis[0] );
 renderEntity.axis.ProjectVector( axis[1], localAxis[1] );

 size = 1.0f / size;
 localAxis[0] *= size;
 localAxis[1] *= size;

 localPlane[0] = localAxis[0];
 localPlane[0][3] = -( localOrigin * localAxis[0] ) + 0.5f;

 localPlane[1] = localAxis[1];
 localPlane[1][3] = -( localOrigin * localAxis[1] ) + 0.5f;

 const idMaterial *mtr = declManager->FindMaterial( material );


 gameRenderWorld->ProjectOverlay( modelDefHandle, localPlane, mtr );


 UpdateVisuals();
}
# 1389 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::Present( void ) {

 if ( !gameLocal.isNewFrame ) {
  return;
 }


 if ( !( thinkFlags & TH_UPDATEVISUALS ) ) {
  return;
 }
 BecomeInactive( TH_UPDATEVISUALS );


 if ( cameraTarget && gameLocal.InPlayerPVS( this ) ) {
  renderEntity.remoteRenderView = cameraTarget->GetRenderView();
 }


 if ( !renderEntity.hModel || IsHidden() ) {
  return;
 }


 if ( modelDefHandle == -1 ) {
  modelDefHandle = gameRenderWorld->AddEntityDef( &renderEntity );
 } else {
  gameRenderWorld->UpdateEntityDef( modelDefHandle, &renderEntity );
 }
}






renderEntity_t *idEntity::GetRenderEntity( void ) {
 return &renderEntity;
}






int idEntity::GetModelDefHandle( void ) {
 return modelDefHandle;
}






bool idEntity::UpdateRenderEntity( renderEntity_s *renderEntity, const renderView_t *renderView ) {
 if ( gameLocal.inCinematic && gameLocal.skipCinematic ) {
  return false;
 }

 idAnimator *animator = GetAnimator();
 if ( animator ) {
  return animator->CreateFrame( gameLocal.time, false );
 }

 return false;
}
# 1462 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::ModelCallback( renderEntity_s *renderEntity, const renderView_t *renderView ) {
 idEntity *ent;

 ent = gameLocal.entities[ renderEntity->entityNum ];
 if ( !ent ) {
  gameLocal.Error( "idEntity::ModelCallback: callback with NULL game entity" );
 }

 return ent->UpdateRenderEntity( renderEntity, renderView );
}
# 1480 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
idAnimator *idEntity::GetAnimator( void ) {
 return __null;
}
# 1491 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
renderView_t *idEntity::GetRenderView( void ) {
 if ( !renderView ) {
  renderView = new renderView_t;
 }
 memset( renderView, 0, sizeof( *renderView ) );

 renderView->vieworg = GetPhysics()->GetOrigin();
 renderView->fov_x = 120;
 renderView->fov_y = 120;
 renderView->viewaxis = GetPhysics()->GetAxis();


 for( int i = 0; i < MAX_GLOBAL_SHADER_PARMS; i++ ) {
  renderView->shaderParms[ i ] = gameLocal.globalShaderParms[ i ];
 }

 renderView->globalMaterial = gameLocal.GetGlobalMaterial();

 renderView->time = gameLocal.time;

 return renderView;
}
# 1527 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::CanPlayChatterSounds( void ) const {
 return true;
}






bool idEntity::StartSound( const char *soundName, const s_channelType channel, int soundShaderFlags, bool broadcast, int *length ) {
 const idSoundShader *shader;
 const char *sound;

 if ( length ) {
  *length = 0;
 }



 ((void)0);

 if ( !spawnArgs.GetString( soundName, "", &sound ) ) {
  return false;
 }

 if ( sound[0] == '\0' ) {
  return false;
 }

 if ( !gameLocal.isNewFrame ) {

  return true;
 }


return true;
}






bool idEntity::StartSoundShader( const idSoundShader *shader, const s_channelType channel, int soundShaderFlags, bool broadcast, int *length ) {
 float diversity;
 int len;

 if ( length ) {
  *length = 0;
 }

 if ( !shader ) {
  return false;
 }

 if ( !gameLocal.isNewFrame ) {
  return true;
 }

 if ( gameLocal.isServer && broadcast ) {
  idBitMsg msg;
  byte msgBuf[MAX_EVENT_PARAM_SIZE];

  msg.Init( msgBuf, sizeof( msgBuf ) );
  msg.BeginWriting();
  msg.WriteLong( gameLocal.ServerRemapDecl( -1, DECL_SOUND, shader->Index() ) );
  msg.WriteByte( channel );
  ServerSendEvent( EVENT_STARTSOUNDSHADER, &msg, false, -1 );
 }


 if ( refSound.diversity < 0.0f ) {
  diversity = gameLocal.random.RandomFloat();
 } else {
  diversity = refSound.diversity;
 }


 if ( !refSound.referenceSound ) {
  refSound.referenceSound = gameSoundWorld->AllocSoundEmitter();
 }

 UpdateSound();

 len = refSound.referenceSound->StartSound( shader, channel, diversity, soundShaderFlags );
 if ( length ) {
  *length = len;
 }


 renderEntity.referenceSound = refSound.referenceSound;

 return true;
}






void idEntity::StopSound( const s_channelType channel, bool broadcast ) {
 if ( !gameLocal.isNewFrame ) {
  return;
 }

 if ( gameLocal.isServer && broadcast ) {
  idBitMsg msg;
  byte msgBuf[MAX_EVENT_PARAM_SIZE];

  msg.Init( msgBuf, sizeof( msgBuf ) );
  msg.BeginWriting();
  msg.WriteByte( channel );
  ServerSendEvent( EVENT_STOPSOUNDSHADER, &msg, false, -1 );
 }

 if ( refSound.referenceSound ) {
  refSound.referenceSound->StopSound( channel );
 }
}
# 1654 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::SetSoundVolume( float volume ) {
 refSound.parms.volume = volume;
}






void idEntity::UpdateSound( void ) {
 if ( refSound.referenceSound ) {
  idVec3 origin;
  idMat3 axis;

  if ( GetPhysicsToSoundTransform( origin, axis ) ) {
   refSound.origin = GetPhysics()->GetOrigin() + origin * axis;
  } else {
   refSound.origin = GetPhysics()->GetOrigin();
  }

  refSound.referenceSound->UpdateEmitter( refSound.origin, refSound.listenerId, &refSound.parms );
 }
}






int idEntity::GetListenerId( void ) const {
 return refSound.listenerId;
}






idSoundEmitter *idEntity::GetSoundEmitter( void ) const {
 return refSound.referenceSound;
}






void idEntity::FreeSoundEmitter( bool immediate ) {
 if ( refSound.referenceSound ) {
  refSound.referenceSound->Free( immediate );
  refSound.referenceSound = __null;
 }
}
# 1719 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::PreBind( void ) {
}






void idEntity::PostBind( void ) {
}






void idEntity::PreUnbind( void ) {
}






void idEntity::PostUnbind( void ) {
}






bool idEntity::InitBind( idEntity *master ) {

 if ( master == this ) {
  gameLocal.Error( "Tried to bind an object to itself." );
  return false;
 }

 if ( this == gameLocal.world ) {
  gameLocal.Error( "Tried to bind world to another entity" );
  return false;
 }


 Unbind();


 if ( master && IsType( idAFEntity_Base::Type ) ) {
  static_cast<idAFEntity_Base *>(this)->AddBindConstraints();
 }

 if ( !master || master == gameLocal.world ) {

  return false;
 }

 return true;
}






void idEntity::FinishBind( void ) {


 physics->SetMaster( bindMaster, fl.bindOrientated );






 JoinTeam( bindMaster );


 cinematic = bindMaster->cinematic;


 teamMaster->BecomeActive( TH_PHYSICS );
}
# 1810 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::Bind( idEntity *master, bool orientated ) {

 if ( !InitBind( master ) ) {
  return;
 }

 PreBind();

 bindJoint = INVALID_JOINT;
 bindBody = -1;
 bindMaster = master;
 fl.bindOrientated = orientated;

 FinishBind();

 PostBind( );
}
# 1835 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::BindToJoint( idEntity *master, const char *jointname, bool orientated ) {
 jointHandle_t jointnum;
 idAnimator *masterAnimator;

 if ( !InitBind( master ) ) {
  return;
 }

 masterAnimator = master->GetAnimator();
 if ( !masterAnimator ) {
  gameLocal.Warning( "idEntity::BindToJoint: entity '%s' cannot support skeletal models.", master->GetName() );
  return;
 }

 jointnum = masterAnimator->GetJointHandle( jointname );
 if ( jointnum == INVALID_JOINT ) {
  gameLocal.Warning( "idEntity::BindToJoint: joint '%s' not found on entity '%s'.", jointname, master->GetName() );
 }

 PreBind();

 bindJoint = jointnum;
 bindBody = -1;
 bindMaster = master;
 fl.bindOrientated = orientated;

 FinishBind();

 PostBind();
}
# 1873 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::BindToJoint( idEntity *master, jointHandle_t jointnum, bool orientated ) {

 if ( !InitBind( master ) ) {
  return;
 }

 PreBind();

 bindJoint = jointnum;
 bindBody = -1;
 bindMaster = master;
 fl.bindOrientated = orientated;

 FinishBind();

 PostBind();
}
# 1898 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::BindToBody( idEntity *master, int bodyId, bool orientated ) {

 if ( !InitBind( master ) ) {
  return;
 }

 if ( bodyId < 0 ) {
  gameLocal.Warning( "idEntity::BindToBody: body '%d' not found.", bodyId );
 }

 PreBind();

 bindJoint = INVALID_JOINT;
 bindBody = bodyId;
 bindMaster = master;
 fl.bindOrientated = orientated;

 FinishBind();

 PostBind();
}






void idEntity::Unbind( void ) {
 idEntity * prev;
 idEntity * next;
 idEntity * last;
 idEntity * ent;


 if ( IsType( idAFEntity_Base::Type ) ) {
  static_cast<idAFEntity_Base *>(this)->RemoveBindConstraints();
 }

 if ( !bindMaster ) {
  return;
 }

 if ( !teamMaster ) {

  bindMaster = __null;
  return;
 }

 PreUnbind();

 if ( physics ) {
  physics->SetMaster( __null, fl.bindOrientated );
 }




 prev = teamMaster;
 for( ent = teamMaster->teamChain; ent && ( ent != this ); ent = ent->teamChain ) {
  prev = ent;
 }

 ((void)0);



 last = this;
 for( next = teamChain; next != __null; next = next->teamChain ) {
  if ( !next->IsBoundTo( this ) ) {
   break;
  }


  next->teamMaster = this;
  last = next;
 }


 last->teamChain = __null;



 if ( teamMaster != this ) {
  prev->teamChain = next;
  if ( !next && ( teamMaster == prev ) ) {
   prev->teamMaster = __null;
  }
 } else if ( next ) {


  for( ent = next; ent->teamChain != __null; ent = ent->teamChain ) {
   ent->teamMaster = next;
  }
  next->teamMaster = next;
 }


 if ( teamChain ) {

  teamMaster = this;
 } else {

  teamMaster = __null;
 }

 bindJoint = INVALID_JOINT;
 bindBody = -1;
 bindMaster = __null;

 PostUnbind();
}






void idEntity::RemoveBinds( void ) {
 idEntity *ent;
 idEntity *next;

 for( ent = teamChain; ent != __null; ent = next ) {
  next = ent->teamChain;
  if ( ent->bindMaster == this ) {
   ent->Unbind();
   ent->PostEventMS( &EV_Remove, 0 );
   next = teamChain;
  }
 }
}






bool idEntity::IsBound( void ) const {
 if ( bindMaster ) {
  return true;
 }
 return false;
}






bool idEntity::IsBoundTo( idEntity *master ) const {
 idEntity *ent;

 if ( !bindMaster ) {
  return false;
 }

 for ( ent = bindMaster; ent != __null; ent = ent->bindMaster ) {
  if ( ent == master ) {
   return true;
  }
 }

 return false;
}






idEntity *idEntity::GetBindMaster( void ) const {
 return bindMaster;
}






jointHandle_t idEntity::GetBindJoint( void ) const {
 return bindJoint;
}






int idEntity::GetBindBody( void ) const {
 return bindBody;
}






idEntity *idEntity::GetTeamMaster( void ) const {
 return teamMaster;
}






idEntity *idEntity::GetNextTeamEntity( void ) const {
 return teamChain;
}






void idEntity::ConvertLocalToWorldTransform( idVec3 &offset, idMat3 &axis ) {
 UpdateModelTransform();

 offset = renderEntity.origin + offset * renderEntity.axis;
 axis *= renderEntity.axis;
}
# 2130 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
idVec3 idEntity::GetLocalVector( const idVec3 &vec ) const {
 idVec3 pos;

 if ( !bindMaster ) {
  return vec;
 }

 idVec3 masterOrigin;
 idMat3 masterAxis;

 GetMasterPosition( masterOrigin, masterAxis );
 masterAxis.ProjectVector( vec, pos );

 return pos;
}
# 2154 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
idVec3 idEntity::GetLocalCoordinates( const idVec3 &vec ) const {
 idVec3 pos;

 if ( !bindMaster ) {
  return vec;
 }

 idVec3 masterOrigin;
 idMat3 masterAxis;

 GetMasterPosition( masterOrigin, masterAxis );
 masterAxis.ProjectVector( vec - masterOrigin, pos );

 return pos;
}
# 2181 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
idVec3 idEntity::GetWorldVector( const idVec3 &vec ) const {
 idVec3 pos;

 if ( !bindMaster ) {
  return vec;
 }

 idVec3 masterOrigin;
 idMat3 masterAxis;

 GetMasterPosition( masterOrigin, masterAxis );
 masterAxis.UnprojectVector( vec, pos );

 return pos;
}
# 2205 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
idVec3 idEntity::GetWorldCoordinates( const idVec3 &vec ) const {
 idVec3 pos;

 if ( !bindMaster ) {
  return vec;
 }

 idVec3 masterOrigin;
 idMat3 masterAxis;

 GetMasterPosition( masterOrigin, masterAxis );
 masterAxis.UnprojectVector( vec, pos );
 pos += masterOrigin;

 return pos;
}






bool idEntity::GetMasterPosition( idVec3 &masterOrigin, idMat3 &masterAxis ) const {
 idVec3 localOrigin;
 idMat3 localAxis;
 idAnimator *masterAnimator;

 if ( bindMaster ) {

  if ( bindJoint != INVALID_JOINT ) {
   masterAnimator = bindMaster->GetAnimator();
   if ( !masterAnimator ) {
    masterOrigin = vec3_origin;
    masterAxis = mat3_identity;
    return false;
   } else {
    masterAnimator->GetJointTransform( bindJoint, gameLocal.time, masterOrigin, masterAxis );
    masterAxis *= bindMaster->renderEntity.axis;
    masterOrigin = bindMaster->renderEntity.origin + masterOrigin * bindMaster->renderEntity.axis;
   }
  } else if ( bindBody >= 0 && bindMaster->GetPhysics() ) {
   masterOrigin = bindMaster->GetPhysics()->GetOrigin( bindBody );
   masterAxis = bindMaster->GetPhysics()->GetAxis( bindBody );
  } else {
   masterOrigin = bindMaster->renderEntity.origin;
   masterAxis = bindMaster->renderEntity.axis;
  }
  return true;
 } else {
  masterOrigin = vec3_origin;
  masterAxis = mat3_identity;
  return false;
 }
}






void idEntity::GetWorldVelocities( idVec3 &linearVelocity, idVec3 &angularVelocity ) const {

 linearVelocity = physics->GetLinearVelocity();
 angularVelocity = physics->GetAngularVelocity();

 if ( bindMaster ) {
  idVec3 masterOrigin, masterLinearVelocity, masterAngularVelocity;
  idMat3 masterAxis;


  GetMasterPosition( masterOrigin, masterAxis );


  bindMaster->GetWorldVelocities( masterLinearVelocity, masterAngularVelocity );


  linearVelocity = linearVelocity * masterAxis + masterLinearVelocity +
        masterAngularVelocity.Cross( GetPhysics()->GetOrigin() - masterOrigin );
 }
}






void idEntity::JoinTeam( idEntity *teammember ) {
 idEntity *ent;
 idEntity *master;
 idEntity *prev;
 idEntity *next;


 if ( teamMaster && ( teamMaster != this ) ) {
  QuitTeam();
 }

 ((void)0);

 if ( teammember == this ) {
  teamMaster = this;
  return;
 }


 master = teammember->teamMaster;
 if ( !master ) {

  master = teammember;
  teammember->teamMaster = teammember;
  teammember->teamChain = this;


  for( ent = teamChain; ent != __null; ent = ent->teamChain ) {
   ent->teamMaster = master;
  }
 } else {

  prev = teammember;
  next = teammember->teamChain;
  if ( bindMaster ) {


   while( next && next->IsBoundTo( teammember ) ) {
    prev = next;
    next = next->teamChain;
   }
  } else {

   while( next ) {
    prev = next;
    next = next->teamChain;
   }
  }



  for( ent = this; ent->teamChain != __null; ent = ent->teamChain ) {
   ent->teamChain->teamMaster = master;
  }

     prev->teamChain = this;
  ent->teamChain = next;
 }

 teamMaster = master;


 gameLocal.sortTeamMasters = true;
}






void idEntity::QuitTeam( void ) {
 idEntity *ent;

 if ( !teamMaster ) {
  return;
 }


 if ( teamMaster == this ) {

  if ( !teamChain->teamChain ) {

   teamChain->teamMaster = __null;
  } else {

   for( ent = teamChain; ent; ent = ent->teamChain ) {
    ent->teamMaster = teamChain;
   }
  }
 } else {
  ((void)0);
  ((void)0);


  ent = teamMaster;
  while( ent->teamChain != this ) {
   ((void)0);
   ent = ent->teamChain;
  }


  ent->teamChain = teamChain;


  if ( !teamMaster->teamChain ) {
   teamMaster->teamMaster = __null;
  }
 }

 teamMaster = __null;
 teamChain = __null;
}
# 2415 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::InitDefaultPhysics( const idVec3 &origin, const idMat3 &axis ) {
 const char *temp;
 idClipModel *clipModel = __null;


 if ( spawnArgs.GetString( "clipmodel", "", &temp ) ) {
  if ( idClipModel::CheckModel( temp ) ) {
   clipModel = new idClipModel( temp );
  }
 }

 if ( !spawnArgs.GetBool( "noclipmodel", "0" ) ) {


  if ( !clipModel ) {
   idVec3 size;
   idBounds bounds;
   bool setClipModel = false;

   if ( spawnArgs.GetVector( "mins", __null, bounds[0] ) &&
    spawnArgs.GetVector( "maxs", __null, bounds[1] ) ) {
    setClipModel = true;
    if ( bounds[0][0] > bounds[1][0] || bounds[0][1] > bounds[1][1] || bounds[0][2] > bounds[1][2] ) {
     gameLocal.Error( "Invalid bounds '%s'-'%s' on entity '%s'", bounds[0].ToString(), bounds[1].ToString(), name.c_str() );
    }
   } else if ( spawnArgs.GetVector( "size", __null, size ) ) {
    if ( ( size.x < 0.0f ) || ( size.y < 0.0f ) || ( size.z < 0.0f ) ) {
     gameLocal.Error( "Invalid size '%s' on entity '%s'", size.ToString(), name.c_str() );
    }
    bounds[0].Set( size.x * -0.5f, size.y * -0.5f, 0.0f );
    bounds[1].Set( size.x * 0.5f, size.y * 0.5f, size.z );
    setClipModel = true;
   }

   if ( setClipModel ) {
    int numSides;
    idTraceModel trm;

    if ( spawnArgs.GetInt( "cylinder", "0", numSides ) && numSides > 0 ) {
     trm.SetupCylinder( bounds, numSides < 3 ? 3 : numSides );
    } else if ( spawnArgs.GetInt( "cone", "0", numSides ) && numSides > 0 ) {
     trm.SetupCone( bounds, numSides < 3 ? 3 : numSides );
    } else {
     trm.SetupBox( bounds );
    }
    clipModel = new idClipModel( trm );
   }
  }


  if ( !clipModel ) {
   temp = spawnArgs.GetString( "model" );
   if ( ( temp != __null ) && ( *temp != 0 ) ) {
    if ( idClipModel::CheckModel( temp ) ) {
     clipModel = new idClipModel( temp );
    }
   }
  }
 }

 defaultPhysicsObj.SetSelf( this );
 defaultPhysicsObj.SetClipModel( clipModel, 1.0f );
 defaultPhysicsObj.SetOrigin( origin );
 defaultPhysicsObj.SetAxis( axis );

 physics = &defaultPhysicsObj;
}






void idEntity::SetPhysics( idPhysics *phys ) {

 if ( physics ) {
  physics->ClearContacts();
 }

 if ( phys != __null ) {
  defaultPhysicsObj.SetClipModel( __null, 1.0f );
  physics = phys;
  physics->Activate();
 } else {
  physics = &defaultPhysicsObj;
 }
 physics->UpdateTime( gameLocal.time );
 physics->SetMaster( bindMaster, fl.bindOrientated );
}






void idEntity::RestorePhysics( idPhysics *phys ) {
 ((void)0);

 physics = phys;
}






idPhysics *idEntity::GetPhysics( void ) const {
 return physics;
}






bool idEntity::RunPhysics( void ) {
 int i, reachedTime, startTime, endTime;
 idEntity * part, *blockedPart, *blockingEntity;
 trace_t results;
 bool moved;


 if ( !( thinkFlags & TH_PHYSICS ) ) {

  if ( UpdateAnimationControllers() ) {
   BecomeActive( TH_ANIMATE );
  }
  return false;
 }


 if ( teamMaster && teamMaster != this ) {
  return false;
 }

 startTime = gameLocal.previousTime;
 endTime = gameLocal.time;

 gameLocal.push.InitSavingPushedEntityPositions();
 blockedPart = __null;


 for ( part = this; part != __null; part = part->teamChain ) {
  if ( part->physics ) {
   if ( !part->fl.solidForTeam ) {
    part->physics->DisableClip();
   }
   part->physics->SaveState();
  }
 }


 for ( part = this; part != __null; part = part->teamChain ) {

  if ( part->physics ) {


   moved = part->physics->Evaluate( endTime - startTime, endTime );


   blockingEntity = part->physics->GetBlockingEntity();
   if ( blockingEntity ) {
    blockedPart = part;
    break;
   }


   if ( moved || part->fl.forcePhysicsUpdate ) {
    part->UpdateFromPhysics( false );
   }



   if ( part->UpdateAnimationControllers() ) {
    part->BecomeActive( TH_ANIMATE );
   }
  }
 }


 for ( part = this; part != __null; part = part->teamChain ) {
  if ( part->physics ) {
   if ( !part->fl.solidForTeam ) {
    part->physics->EnableClip();
   }
  }
 }


 if ( blockedPart ) {

  for ( part = this; part != blockedPart; part = part->teamChain ) {

   if ( part->physics ) {


    part->physics->RestoreState();


    part->UpdateFromPhysics( true );
   }
  }
  for ( part = this; part != __null; part = part->teamChain ) {
   if ( part->physics ) {

    part->physics->UpdateTime( endTime );
   }
  }


  gameLocal.push.RestorePushedEntityPositions();

  if ( gameLocal.isClient ) {
   return false;
  }


  Signal( SIG_BLOCKED );
  ProcessEvent( &EV_TeamBlocked, blockedPart, blockingEntity );

  blockedPart->ProcessEvent( &EV_PartBlocked, blockingEntity );
  return false;
 }


 for ( i = 0; i < gameLocal.push.GetNumPushedEntities(); i++ ) {
  idEntity *ent = gameLocal.push.GetPushedEntity( i );
  ent->physics->SetPushed( endTime - startTime );
 }

 if ( gameLocal.isClient ) {
  return true;
 }


 for ( part = this; part != __null; part = part->teamChain ) {

  if ( part->physics ) {

   reachedTime = part->physics->GetLinearEndTime();
   if ( startTime < reachedTime && endTime >= reachedTime ) {
    part->ProcessEvent( &EV_ReachedPos );
   }
   reachedTime = part->physics->GetAngularEndTime();
   if ( startTime < reachedTime && endTime >= reachedTime ) {
    part->ProcessEvent( &EV_ReachedAng );
   }
  }
 }

 return true;
}






void idEntity::UpdateFromPhysics( bool moveBack ) {

 if ( IsType( idActor::Type ) ) {
  idActor *actor = static_cast<idActor *>( this );


  if ( GetBindMaster() ) {
   idAngles delta = actor->GetDeltaViewAngles();
   if ( moveBack ) {
    delta.yaw -= static_cast<idPhysics_Actor *>(physics)->GetMasterDeltaYaw();
   } else {
    delta.yaw += static_cast<idPhysics_Actor *>(physics)->GetMasterDeltaYaw();
   }
   actor->SetDeltaViewAngles( delta );
  }
 }

 UpdateVisuals();
}






void idEntity::SetOrigin( const idVec3 &org ) {

 GetPhysics()->SetOrigin( org );

 UpdateVisuals();
}






void idEntity::SetAxis( const idMat3 &axis ) {

 if ( GetPhysics()->IsType( idPhysics_Actor::Type ) ) {
  static_cast<idActor *>(this)->viewAxis = axis;
 } else {
  GetPhysics()->SetAxis( axis );
 }

 UpdateVisuals();
}






void idEntity::SetAngles( const idAngles &ang ) {
 SetAxis( ang.ToMat3() );
}






bool idEntity::GetFloorPos( float max_dist, idVec3 &floorpos ) const {
 trace_t result;

 if ( !GetPhysics()->HasGroundContacts() ) {
  GetPhysics()->ClipTranslation( result, GetPhysics()->GetGravityNormal() * max_dist, __null );
  if ( result.fraction < 1.0f ) {
   floorpos = result.endpos;
   return true;
  } else {
   floorpos = GetPhysics()->GetOrigin();
   return false;
  }
 } else {
  floorpos = GetPhysics()->GetOrigin();
  return true;
 }
}






bool idEntity::GetPhysicsToVisualTransform( idVec3 &origin, idMat3 &axis ) {
 return false;
}






bool idEntity::GetPhysicsToSoundTransform( idVec3 &origin, idMat3 &axis ) {

 if ( GetPhysics()->GetNumClipModels() > 0 ) {
  origin = GetPhysics()->GetBounds().GetCenter();
  axis.Identity();
  return true;
 }
 return false;
}






bool idEntity::Collide( const trace_t &collision, const idVec3 &velocity ) {

 return false;
}






void idEntity::GetImpactInfo( idEntity *ent, int id, const idVec3 &point, impactInfo_t *info ) {
 GetPhysics()->GetImpactInfo( id, point, info );
}






void idEntity::ApplyImpulse( idEntity *ent, int id, const idVec3 &point, const idVec3 &impulse ) {
 GetPhysics()->ApplyImpulse( id, point, impulse );
}






void idEntity::AddForce( idEntity *ent, int id, const idVec3 &point, const idVec3 &force ) {
 GetPhysics()->AddForce( id, point, force );
}






void idEntity::ActivatePhysics( idEntity *ent ) {
 GetPhysics()->Activate();
}






bool idEntity::IsAtRest( void ) const {
 return GetPhysics()->IsAtRest();
}






int idEntity::GetRestStartTime( void ) const {
 return GetPhysics()->GetRestStartTime();
}






void idEntity::AddContactEntity( idEntity *ent ) {
 GetPhysics()->AddContactEntity( ent );
}






void idEntity::RemoveContactEntity( idEntity *ent ) {
 GetPhysics()->RemoveContactEntity( ent );
}
# 2875 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::CanDamage( const idVec3 &origin, idVec3 &damagePoint ) const {
 idVec3 dest;
 trace_t tr;
 idVec3 midpoint;



 midpoint = ( GetPhysics()->GetAbsBounds()[0] + GetPhysics()->GetAbsBounds()[1] ) * 0.5;

 dest = midpoint;
 gameLocal.clip.TracePoint( tr, origin, dest, (CONTENTS_SOLID), __null );
 if ( tr.fraction == 1.0 || ( gameLocal.GetTraceEntity( tr ) == this ) ) {
  damagePoint = tr.endpos;
  return true;
 }


 dest = midpoint;
 dest[0] += 15.0;
 dest[1] += 15.0;
 gameLocal.clip.TracePoint( tr, origin, dest, (CONTENTS_SOLID), __null );
 if ( tr.fraction == 1.0 || ( gameLocal.GetTraceEntity( tr ) == this ) ) {
  damagePoint = tr.endpos;
  return true;
 }

 dest = midpoint;
 dest[0] += 15.0;
 dest[1] -= 15.0;
 gameLocal.clip.TracePoint( tr, origin, dest, (CONTENTS_SOLID), __null );
 if ( tr.fraction == 1.0 || ( gameLocal.GetTraceEntity( tr ) == this ) ) {
  damagePoint = tr.endpos;
  return true;
 }

 dest = midpoint;
 dest[0] -= 15.0;
 dest[1] += 15.0;
 gameLocal.clip.TracePoint( tr, origin, dest, (CONTENTS_SOLID), __null );
 if ( tr.fraction == 1.0 || ( gameLocal.GetTraceEntity( tr ) == this ) ) {
  damagePoint = tr.endpos;
  return true;
 }

 dest = midpoint;
 dest[0] -= 15.0;
 dest[1] -= 15.0;
 gameLocal.clip.TracePoint( tr, origin, dest, (CONTENTS_SOLID), __null );
 if ( tr.fraction == 1.0 || ( gameLocal.GetTraceEntity( tr ) == this ) ) {
  damagePoint = tr.endpos;
  return true;
 }

 dest = midpoint;
 dest[2] += 15.0;
 gameLocal.clip.TracePoint( tr, origin, dest, (CONTENTS_SOLID), __null );
 if ( tr.fraction == 1.0 || ( gameLocal.GetTraceEntity( tr ) == this ) ) {
  damagePoint = tr.endpos;
  return true;
 }

 dest = midpoint;
 dest[2] -= 15.0;
 gameLocal.clip.TracePoint( tr, origin, dest, (CONTENTS_SOLID), __null );
 if ( tr.fraction == 1.0 || ( gameLocal.GetTraceEntity( tr ) == this ) ) {
  damagePoint = tr.endpos;
  return true;
 }

 return false;
}
# 2954 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::DamageFeedback( idEntity *victim, idEntity *inflictor, int &damage ) {

}
# 2975 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::Damage( idEntity *inflictor, idEntity *attacker, const idVec3 &dir,
       const char *damageDefName, const float damageScale, const int location ) {
 if ( !fl.takedamage ) {
  return;
 }

 if ( !inflictor ) {
  inflictor = gameLocal.world;
 }

 if ( !attacker ) {
  attacker = gameLocal.world;
 }

 const idDict *damageDef = gameLocal.FindEntityDefDict( damageDefName );
 if ( !damageDef ) {
  gameLocal.Error( "Unknown damageDef '%s'\n", damageDefName );
 }

 int damage = damageDef->GetInt( "damage" );


 attacker->DamageFeedback( this, inflictor, damage );
 if ( damage ) {

  health -= damage;
  if ( health <= 0 ) {
   if ( health < -999 ) {
    health = -999;
   }

   Killed( inflictor, attacker, damage, dir, location );
  } else {
   Pain( inflictor, attacker, damage, dir, location );
  }
 }
}






void idEntity::AddDamageEffect( const trace_t &collision, const idVec3 &velocity, const char *damageDefName ) {
 const char *sound, *decal, *key;

 const idDeclEntityDef *def = gameLocal.FindEntityDef( damageDefName, false );
 if ( def == __null ) {
  return;
 }

 const char *materialType = gameLocal.sufaceTypeNames[ collision.c.material->GetSurfaceType() ];


 key = va( "snd_%s", materialType );
 sound = spawnArgs.GetString( key );
 if ( *sound == '\0' ) {
  sound = def->dict.GetString( key );
 }
 if ( *sound != '\0' ) {

 }

 if ( g_decals.GetBool() ) {

  key = va( "mtr_wound_%s", materialType );
  decal = spawnArgs.RandomPrefix( key, gameLocal.random );
  if ( *decal == '\0' ) {
   decal = def->dict.RandomPrefix( key, gameLocal.random );
  }
  if ( *decal != '\0' ) {
   idVec3 dir = velocity;
   dir.Normalize();
   ProjectOverlay( collision.c.point, dir, 20.0f, decal );
  }
 }
}
# 3061 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::Pain( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location ) {
 return false;
}
# 3073 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::Killed( idEntity *inflictor, idEntity *attacker, int damage, const idVec3 &dir, int location ) {
}
# 3091 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::ShouldConstructScriptObjectAtSpawn( void ) const {
 return true;
}
# 3103 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
idThread *idEntity::ConstructScriptObject( void ) {
 idThread *thread;
 const function_t *constructor;


 scriptObject.ClearObject();


 constructor = scriptObject.GetConstructor();
 if ( constructor ) {

  thread = new idThread();
  thread->SetThreadName( name.c_str() );
  thread->CallFunction( this, constructor, true );
  thread->DelayedStart( 0 );
 } else {
  thread = __null;
 }


 scriptObject.ClearObject();

 return thread;
}
# 3137 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::DeconstructScriptObject( void ) {
 idThread *thread;
 const function_t *destructor;


 if ( gameLocal.GameState() == GAMESTATE_SHUTDOWN ) {
  return;
 }


 destructor = scriptObject.GetDestructor();
 if ( destructor ) {

  thread = new idThread();
  thread->SetThreadName( name.c_str() );
  thread->CallFunction( this, destructor, true );
  thread->Execute();
  delete thread;
 }
}






bool idEntity::HasSignal( signalNum_t signalnum ) const {
 if ( !signals ) {
  return false;
 }
 ((void)0);
 return ( signals->signal[ signalnum ].Num() > 0 );
}






void idEntity::SetSignal( signalNum_t signalnum, idThread *thread, const function_t *function ) {
 int i;
 int num;
 signal_t sig;
 int threadnum;

 ((void)0);

 if ( !signals ) {
  signals = new signalList_t;
 }

 ((void)0);
 threadnum = thread->GetThreadNum();

 num = signals->signal[ signalnum ].Num();
 for( i = 0; i < num; i++ ) {
  if ( signals->signal[ signalnum ][ i ].threadnum == threadnum ) {
   signals->signal[ signalnum ][ i ].function = function;
   return;
  }
 }

 if ( num >= 16 ) {
  thread->Error( "Exceeded maximum number of signals per object" );
 }

 sig.threadnum = threadnum;
 sig.function = function;
 signals->signal[ signalnum ].Append( sig );
}






void idEntity::ClearSignal( idThread *thread, signalNum_t signalnum ) {
 ((void)0);
 if ( ( signalnum < 0 ) || ( signalnum >= NUM_SIGNALS ) ) {
  gameLocal.Error( "Signal out of range" );
 }

 if ( !signals ) {
  return;
 }

 signals->signal[ signalnum ].Clear();
}






void idEntity::ClearSignalThread( signalNum_t signalnum, idThread *thread ) {
 int i;
 int num;
 int threadnum;

 ((void)0);

 if ( ( signalnum < 0 ) || ( signalnum >= NUM_SIGNALS ) ) {
  gameLocal.Error( "Signal out of range" );
 }

 if ( !signals ) {
  return;
 }

 threadnum = thread->GetThreadNum();

 num = signals->signal[ signalnum ].Num();
 for( i = 0; i < num; i++ ) {
  if ( signals->signal[ signalnum ][ i ].threadnum == threadnum ) {
   signals->signal[ signalnum ].RemoveIndex( i );
   return;
  }
 }
}






void idEntity::Signal( signalNum_t signalnum ) {
 int i;
 int num;
 signal_t sigs[ 16 ];
 idThread *thread;

 ((void)0);

 if ( !signals ) {
  return;
 }





 num = signals->signal[ signalnum ].Num();
 for( i = 0; i < num; i++ ) {
  sigs[ i ] = signals->signal[ signalnum ][ i ];
 }


 signals->signal[ signalnum ].Clear();

 for( i = 0; i < num; i++ ) {
  thread = idThread::GetThread( sigs[ i ].threadnum );
  if ( thread ) {
   thread->CallFunction( this, sigs[ i ].function, true );
   thread->Execute();
  }
 }
}






void idEntity::SignalEvent( idThread *thread, signalNum_t signalnum ) {
 if ( ( signalnum < 0 ) || ( signalnum >= NUM_SIGNALS ) ) {
  gameLocal.Error( "Signal out of range" );
 }

 if ( !signals ) {
  return;
 }

 Signal( signalnum );
}
# 3324 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::TriggerGuis( void ) {
 int i;
 for ( i = 0; i < MAX_RENDERENTITY_GUI; i++ ) {
  if ( renderEntity.gui[ i ] ) {
   renderEntity.gui[ i ]->Trigger( gameLocal.time );
  }
 }
}






bool idEntity::HandleGuiCommands( idEntity *entityGui, const char *cmds ) {
 idEntity *targetEnt;
 bool ret = false;
 if ( entityGui && cmds && *cmds ) {
  idLexer src;
  idToken token, token2, token3, token4;
  src.LoadMemory( cmds, strlen( cmds ), "guiCommands" );
  while( 1 ) {

   if ( !src.ReadToken( &token ) ) {
    return ret;
   }

   if ( token == ";" ) {
    continue;
   }

   if ( token.Icmp( "activate" ) == 0 ) {
    bool targets = true;
    if ( src.ReadToken( &token2 ) ) {
     if ( token2 == ";" ) {
      src.UnreadToken( &token2 );
     } else {
      targets = false;
     }
    }

    if ( targets ) {
     entityGui->ActivateTargets( this );
    } else {
     idEntity *ent = gameLocal.FindEntity( token2 );
     if ( ent ) {
      ent->Signal( SIG_TRIGGER );
      ent->PostEventMS( &EV_Activate, 0, this );
     }
    }

    entityGui->renderEntity.shaderParms[ SHADERPARM_MODE ] = 1.0f;
    continue;
   }


   if ( token.Icmp( "runScript" ) == 0 ) {
    if ( src.ReadToken( &token2 ) ) {
     while( src.CheckTokenString( "::" ) ) {
      idToken token3;
      if ( !src.ReadToken( &token3 ) ) {
       gameLocal.Error( "Expecting function name following '::' in gui for entity '%s'", entityGui->name.c_str() );
      }
      token2 += "::" + token3;
     }
     const function_t *func = gameLocal.program.FindFunction( token2 );
     if ( !func ) {
      gameLocal.Error( "Can't find function '%s' for gui in entity '%s'", token2.c_str(), entityGui->name.c_str() );
     } else {
      idThread *thread = new idThread( func );
      thread->DelayedStart( 0 );
     }
    }
    continue;
   }

   if ( token.Icmp("play") == 0 ) {
    if ( src.ReadToken( &token2 ) ) {


    }
    continue;
   }

   if ( token.Icmp( "setkeyval" ) == 0 ) {
    if ( src.ReadToken( &token2 ) && src.ReadToken(&token3) && src.ReadToken( &token4 ) ) {
     idEntity *ent = gameLocal.FindEntity( token2 );
     if ( ent ) {
      ent->spawnArgs.Set( token3, token4 );
      ent->UpdateChangeableSpawnArgs( __null );
      ent->UpdateVisuals();
     }
    }
    continue;
   }

   if ( token.Icmp( "setshaderparm" ) == 0 ) {
    if ( src.ReadToken( &token2 ) && src.ReadToken(&token3) ) {
     entityGui->SetShaderParm( atoi( token2 ), atof( token3 ) );
     entityGui->UpdateVisuals();
    }
    continue;
   }

   if ( token.Icmp("close") == 0 ) {
    ret = true;
    continue;
   }

   if ( !token.Icmp( "turkeyscore" ) ) {
    if ( src.ReadToken( &token2 ) && entityGui->renderEntity.gui[0] ) {
     int score = entityGui->renderEntity.gui[0]->State().GetInt( "score" );
     score += atoi( token2 );
     entityGui->renderEntity.gui[0]->SetStateInt( "score", score );
     if ( gameLocal.GetLocalPlayer() && score >= 25000 && !gameLocal.GetLocalPlayer()->inventory.turkeyScore ) {
      gameLocal.GetLocalPlayer()->GiveEmail( "highScore" );
      gameLocal.GetLocalPlayer()->inventory.turkeyScore = true;
     }
    }
    continue;
   }



   if ( !token.Icmp( "print" ) ) {
    idStr msg;
    while ( src.ReadToken( &token2 ) ) {
     if ( token2 == ";" ) {
      src.UnreadToken( &token2 );
      break;
     }
     msg += token2.c_str();
    }
    common->Printf( "ent gui 0x%x '%s': %s\n", entityNumber, name.c_str(), msg.c_str() );
    continue;
   }


   src.UnreadToken(&token);
   if ( !HandleSingleGuiCommand( entityGui, &src ) ) {


    if ( entityGui->HandleSingleGuiCommand( entityGui, &src ) ) {
     continue;
    }

    int c = entityGui->targets.Num();
    int i;
    for ( i = 0; i < c; i++) {
     targetEnt = entityGui->targets[ i ].GetEntity();
     if ( targetEnt && targetEnt->HandleSingleGuiCommand( entityGui, &src ) ) {
      break;
     }
    }

    if ( i == c ) {

     common->DPrintf( "idEntity::HandleGuiCommands: '%s' not handled\n", token.c_str() );
     src.ReadToken( &token );
    }
   }

  }
 }
 return ret;
}






bool idEntity::HandleSingleGuiCommand( idEntity *entityGui, idLexer *src ) {
 return false;
}
# 3515 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::FindTargets( void ) {
 int i;


 gameLocal.GetTargets( spawnArgs, targets, "target" );


 for( i = 0; i < targets.Num(); i++ ) {
  if ( targets[ i ].GetEntity() == this ) {
   gameLocal.Error( "Entity '%s' is targeting itself", name.c_str() );
  }
 }
}






void idEntity::RemoveNullTargets( void ) {
 int i;

 for( i = targets.Num() - 1; i >= 0; i-- ) {
  if ( !targets[ i ].GetEntity() ) {
   targets.RemoveIndex( i );
  }
 }
}
# 3551 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::ActivateTargets( idEntity *activator ) const {
 idEntity *ent;
 int i, j;

 for( i = 0; i < targets.Num(); i++ ) {
  ent = targets[ i ].GetEntity();
  if ( !ent ) {
   continue;
  }
  if ( ent->RespondsTo( EV_Activate ) || ent->HasSignal( SIG_TRIGGER ) ) {
   ent->Signal( SIG_TRIGGER );
   ent->ProcessEvent( &EV_Activate, activator );
  }
  for ( j = 0; j < MAX_RENDERENTITY_GUI; j++ ) {
   if ( ent->renderEntity.gui[ j ] ) {
    ent->renderEntity.gui[ j ]->Trigger( gameLocal.time );
   }
  }
 }
}
# 3583 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::Teleport( const idVec3 &origin, const idAngles &angles, idEntity *destination ) {
 GetPhysics()->SetOrigin( origin );
 GetPhysics()->SetAxis( angles.ToMat3() );

 UpdateVisuals();
}
# 3597 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
bool idEntity::TouchTriggers( void ) const {
 int i, numClipModels, numEntities;
 idClipModel * cm;
 idClipModel * clipModels[ (1<<12) ];
 idEntity * ent;
 trace_t trace;

 memset( &trace, 0, sizeof( trace ) );
 trace.endpos = GetPhysics()->GetOrigin();
 trace.endAxis = GetPhysics()->GetAxis();

 numClipModels = gameLocal.clip.ClipModelsTouchingBounds( GetPhysics()->GetAbsBounds(), CONTENTS_TRIGGER, clipModels, (1<<12) );
 numEntities = 0;

 for ( i = 0; i < numClipModels; i++ ) {
  cm = clipModels[ i ];


  if ( cm->GetOwner() == this ) {
   continue;
  }

  ent = cm->GetEntity();

  if ( !ent->RespondsTo( EV_Touch ) && !ent->HasSignal( SIG_TOUCH ) ) {
   continue;
  }

  if ( !GetPhysics()->ClipContents( cm ) ) {
   continue;
  }

  numEntities++;

  trace.c.contents = cm->GetContents();
  trace.c.entityNum = cm->GetEntity()->entityNumber;
  trace.c.id = cm->GetId();

  ent->Signal( SIG_TOUCH );
  ent->ProcessEvent( &EV_Touch, this, &trace );

  if ( !gameLocal.entities[ entityNumber ] ) {
   gameLocal.Printf( "entity was removed while touching triggers\n" );
   return true;
  }
 }

 return ( numEntities != 0 );
}






idCurve_Spline<idVec3> *idEntity::GetSpline( void ) const {
 int i, numPoints, t;
 const idKeyValue *kv;
 idLexer lex;
 idVec3 v;
 idCurve_Spline<idVec3> *spline;
 const char *curveTag = "curve_";

 kv = spawnArgs.MatchPrefix( curveTag );
 if ( !kv ) {
  return __null;
 }

 idStr str = kv->GetKey().Right( kv->GetKey().Length() - strlen( curveTag ) );
 if ( str.Icmp( "CatmullRomSpline" ) == 0 ) {
  spline = new idCurve_CatmullRomSpline<idVec3>();
 } else if ( str.Icmp( "nubs" ) == 0 ) {
  spline = new idCurve_NonUniformBSpline<idVec3>();
 } else if ( str.Icmp( "nurbs" ) == 0 ) {
  spline = new idCurve_NURBS<idVec3>();
 } else {
  spline = new idCurve_BSpline<idVec3>();
 }

 spline->SetBoundaryType( idCurve_Spline<idVec3>::BT_CLAMPED );

 lex.LoadMemory( kv->GetValue(), kv->GetValue().Length(), curveTag );
 numPoints = lex.ParseInt();
 lex.ExpectTokenString( "(" );
 for ( t = i = 0; i < numPoints; i++, t += 100 ) {
  v.x = lex.ParseFloat();
  v.y = lex.ParseFloat();
  v.z = lex.ParseFloat();
  spline->AddValue( t, v );
 }
 lex.ExpectTokenString( ")" );

 return spline;
}






void idEntity::ShowEditingDialog( void ) {
}
# 3711 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::Event_GetName( void ) {
 idThread::ReturnString( name.c_str() );
}






void idEntity::Event_SetName( const char *newname ) {
 SetName( newname );
}






void idEntity::Event_FindTargets( void ) {
 FindTargets();
}
# 3741 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::Event_ActivateTargets( idEntity *activator ) {
 ActivateTargets( activator );
}






void idEntity::Event_NumTargets( void ) {
 idThread::ReturnFloat( targets.Num() );
}






void idEntity::Event_GetTarget( float index ) {
 int i;

 i = ( int )index;
 if ( ( i < 0 ) || i >= targets.Num() ) {
  idThread::ReturnEntity( __null );
 } else {
  idThread::ReturnEntity( targets[ i ].GetEntity() );
 }
}






void idEntity::Event_RandomTarget( const char *ignore ) {
 int num;
 idEntity *ent;
 int i;
 int ignoreNum;

 RemoveNullTargets();
 if ( !targets.Num() ) {
  idThread::ReturnEntity( __null );
  return;
 }

 ignoreNum = -1;
 if ( ignore && ( ignore[ 0 ] != 0 ) && ( targets.Num() > 1 ) ) {
  for( i = 0; i < targets.Num(); i++ ) {
   ent = targets[ i ].GetEntity();
   if ( ent && ( ent->name == ignore ) ) {
    ignoreNum = i;
    break;
   }
  }
 }

 if ( ignoreNum >= 0 ) {
  num = gameLocal.random.RandomInt( targets.Num() - 1 );
  if ( num >= ignoreNum ) {
   num++;
  }
 } else {
  num = gameLocal.random.RandomInt( targets.Num() );
 }

 ent = targets[ num ].GetEntity();
 idThread::ReturnEntity( ent );
}






void idEntity::Event_BindToJoint( idEntity *master, const char *jointname, float orientated ) {
 BindToJoint( master, jointname, ( orientated != 0.0f ) );
}






void idEntity::Event_RemoveBinds( void ) {
 RemoveBinds();
}






void idEntity::Event_Bind( idEntity *master ) {
 Bind( master, true );
}






void idEntity::Event_BindPosition( idEntity *master ) {
 Bind( master, false );
}






void idEntity::Event_Unbind( void ) {
 Unbind();
}






void idEntity::Event_SpawnBind( void ) {
 idEntity *parent;
 const char *bind, *joint, *bindanim;
 jointHandle_t bindJoint;
 bool bindOrientated;
 int id;
 const idAnim *anim;
 int animNum;
 idAnimator *parentAnimator;

 if ( spawnArgs.GetString( "bind", "", &bind ) ) {
  if ( idStr::Icmp( bind, "worldspawn" ) == 0 ) {

   parent = gameLocal.world;
  } else {
   parent = gameLocal.FindEntity( bind );
  }
  bindOrientated = spawnArgs.GetBool( "bindOrientated", "1" );
  if ( parent ) {

   if ( spawnArgs.GetString( "bindToJoint", "", &joint ) && *joint ) {
    parentAnimator = parent->GetAnimator();
    if ( !parentAnimator ) {
     gameLocal.Error( "Cannot bind to joint '%s' on '%s'.  Entity does not support skeletal models.", joint, name.c_str() );
    }
    bindJoint = parentAnimator->GetJointHandle( joint );
    if ( bindJoint == INVALID_JOINT ) {
     gameLocal.Error( "Joint '%s' not found for bind on '%s'", joint, name.c_str() );
    }


    if ( ( parent->spawnArgs.GetString( "bindanim", "", &bindanim ) || parent->spawnArgs.GetString( "anim", "", &bindanim ) ) && *bindanim ) {
     animNum = parentAnimator->GetAnim( bindanim );
     if ( !animNum ) {
      gameLocal.Error( "Anim '%s' not found for bind on '%s'", bindanim, name.c_str() );
     }
     anim = parentAnimator->GetAnim( animNum );
     if ( !anim ) {
      gameLocal.Error( "Anim '%s' not found for bind on '%s'", bindanim, name.c_str() );
     }


     parent->UpdateModelTransform();


     parentAnimator->CreateFrame( gameLocal.time, true );
     idJointMat *frame = parent->renderEntity.joints;
     gameEdit->ANIM_CreateAnimFrame( parentAnimator->ModelHandle(), anim->MD5Anim( 0 ), parent->renderEntity.numJoints, frame, 0, parentAnimator->ModelDef()->GetVisualOffset(), parentAnimator->RemoveOrigin() );
     BindToJoint( parent, joint, bindOrientated );
     parentAnimator->ForceUpdate();
    } else {
     BindToJoint( parent, joint, bindOrientated );
    }
   }

   else if ( spawnArgs.GetInt( "bindToBody", "0", id ) ) {
    BindToBody( parent, id, bindOrientated );
   }

   else {
    Bind( parent, bindOrientated );
   }
  }
 }
}






void idEntity::Event_SetOwner( idEntity *owner ) {
 int i;

 for ( i = 0; i < GetPhysics()->GetNumClipModels(); i++ ) {
  GetPhysics()->GetClipModel( i )->SetOwner( owner );
 }
}






void idEntity::Event_SetModel( const char *modelname ) {
 SetModel( modelname );
}






void idEntity::Event_SetSkin( const char *skinname ) {
 renderEntity.customSkin = declManager->FindSkin( skinname );
 UpdateVisuals();
}






void idEntity::Event_GetShaderParm( int parmnum ) {
 if ( ( parmnum < 0 ) || ( parmnum >= MAX_ENTITY_SHADER_PARMS ) ) {
  gameLocal.Error( "shader parm index (%d) out of range", parmnum );
 }

 idThread::ReturnFloat( renderEntity.shaderParms[ parmnum ] );
}






void idEntity::Event_SetShaderParm( int parmnum, float value ) {
 SetShaderParm( parmnum, value );
}






void idEntity::Event_SetShaderParms( float parm0, float parm1, float parm2, float parm3 ) {
 renderEntity.shaderParms[ SHADERPARM_RED ] = parm0;
 renderEntity.shaderParms[ SHADERPARM_GREEN ] = parm1;
 renderEntity.shaderParms[ SHADERPARM_BLUE ] = parm2;
 renderEntity.shaderParms[ SHADERPARM_ALPHA ] = parm3;
 UpdateVisuals();
}







void idEntity::Event_SetColor( float red, float green, float blue ) {
 SetColor( red, green, blue );
}






void idEntity::Event_GetColor( void ) {
 idVec3 out;

 GetColor( out );
 idThread::ReturnVector( out );
}






void idEntity::Event_IsHidden( void ) {
 idThread::ReturnInt( fl.hidden );
}






void idEntity::Event_Hide( void ) {
 Hide();
}






void idEntity::Event_Show( void ) {
 Show();
}






void idEntity::Event_CacheSoundShader( const char *soundName ) {

}






void idEntity::Event_StartSoundShader( const char *soundName, int channel ) {
 int length;



}






void idEntity::Event_StopSound( int channel, int netSync ) {
 StopSound( channel, ( netSync != 0 ) );
}






void idEntity::Event_StartSound( const char *soundName, int channel, int netSync ) {
 int time;

 StartSound( soundName, ( s_channelType )channel, 0, ( netSync != 0 ), &time );
 idThread::ReturnFloat( ( (time) * idMath::M_MS2SEC ) );
}






void idEntity::Event_FadeSound( int channel, float to, float over ) {
 if ( refSound.referenceSound ) {

 }
}






void idEntity::Event_GetWorldOrigin( void ) {
 idThread::ReturnVector( GetPhysics()->GetOrigin() );
}






void idEntity::Event_SetWorldOrigin( idVec3 const &org ) {
 idVec3 neworg = GetLocalCoordinates( org );
 SetOrigin( neworg );
}






void idEntity::Event_SetOrigin( idVec3 const &org ) {
 SetOrigin( org );
}






void idEntity::Event_GetOrigin( void ) {
 idThread::ReturnVector( GetLocalCoordinates( GetPhysics()->GetOrigin() ) );
}






void idEntity::Event_SetAngles( idAngles const &ang ) {
 SetAngles( ang );
}






void idEntity::Event_GetAngles( void ) {
 idAngles ang = GetPhysics()->GetAxis().ToAngles();
 idThread::ReturnVector( idVec3( ang[0], ang[1], ang[2] ) );
}






void idEntity::Event_SetLinearVelocity( const idVec3 &velocity ) {
 GetPhysics()->SetLinearVelocity( velocity );
}






void idEntity::Event_GetLinearVelocity( void ) {
 idThread::ReturnVector( GetPhysics()->GetLinearVelocity() );
}






void idEntity::Event_SetAngularVelocity( const idVec3 &velocity ) {
 GetPhysics()->SetAngularVelocity( velocity );
}






void idEntity::Event_GetAngularVelocity( void ) {
 idThread::ReturnVector( GetPhysics()->GetAngularVelocity() );
}






void idEntity::Event_SetSize( idVec3 const &mins, idVec3 const &maxs ) {
 GetPhysics()->SetClipBox( idBounds( mins, maxs ), 1.0f );
}






void idEntity::Event_GetSize( void ) {
 idBounds bounds;

 bounds = GetPhysics()->GetBounds();
 idThread::ReturnVector( bounds[1] - bounds[0] );
}






void idEntity::Event_GetMins( void ) {
 idThread::ReturnVector( GetPhysics()->GetBounds()[0] );
}






void idEntity::Event_GetMaxs( void ) {
 idThread::ReturnVector( GetPhysics()->GetBounds()[1] );
}






void idEntity::Event_Touches( idEntity *ent ) {
 if ( !ent ) {
  idThread::ReturnInt( false );
  return;
 }

 const idBounds &myBounds = GetPhysics()->GetAbsBounds();
 const idBounds &entBounds = ent->GetPhysics()->GetAbsBounds();

 idThread::ReturnInt( myBounds.IntersectsBounds( entBounds ) );
}






void idEntity::Event_SetGuiParm( const char *key, const char *val ) {
 for ( int i = 0; i < MAX_RENDERENTITY_GUI; i++ ) {
  if ( renderEntity.gui[ i ] ) {
   if ( idStr::Icmpn( key, "gui_", 4 ) == 0 ) {
    spawnArgs.Set( key, val );
   }
   renderEntity.gui[ i ]->SetStateString( key, val );
   renderEntity.gui[ i ]->StateChanged( gameLocal.time );
  }
 }
}






void idEntity::Event_SetGuiFloat( const char *key, float f ) {
 for ( int i = 0; i < MAX_RENDERENTITY_GUI; i++ ) {
  if ( renderEntity.gui[ i ] ) {
   renderEntity.gui[ i ]->SetStateString( key, va( "%f", f ) );
   renderEntity.gui[ i ]->StateChanged( gameLocal.time );
  }
 }
}






void idEntity::Event_GetNextKey( const char *prefix, const char *lastMatch ) {
 const idKeyValue *kv;
 const idKeyValue *previous;

 if ( *lastMatch ) {
  previous = spawnArgs.FindKey( lastMatch );
 } else {
  previous = __null;
 }

 kv = spawnArgs.MatchPrefix( prefix, previous );
 if ( !kv ) {
  idThread::ReturnString( "" );
 } else {
  idThread::ReturnString( kv->GetKey() );
 }
}






void idEntity::Event_SetKey( const char *key, const char *value ) {
 spawnArgs.Set( key, value );
}






void idEntity::Event_GetKey( const char *key ) {
 const char *value;

 spawnArgs.GetString( key, "", &value );
 idThread::ReturnString( value );
}






void idEntity::Event_GetIntKey( const char *key ) {
 int value;

 spawnArgs.GetInt( key, "0", value );


 idThread::ReturnFloat( value );
}






void idEntity::Event_GetFloatKey( const char *key ) {
 float value;

 spawnArgs.GetFloat( key, "0", value );
 idThread::ReturnFloat( value );
}






void idEntity::Event_GetVectorKey( const char *key ) {
 idVec3 value;

 spawnArgs.GetVector( key, "0 0 0", value );
 idThread::ReturnVector( value );
}






void idEntity::Event_GetEntityKey( const char *key ) {
 idEntity *ent;
 const char *entname;

 if ( !spawnArgs.GetString( key, __null, &entname ) ) {
  idThread::ReturnEntity( __null );
  return;
 }

 ent = gameLocal.FindEntity( entname );
 if ( !ent ) {
  gameLocal.Warning( "Couldn't find entity '%s' specified in '%s' key in entity '%s'", entname, key, name.c_str() );
 }

 idThread::ReturnEntity( ent );
}






void idEntity::Event_RestorePosition( void ) {
 idVec3 org;
 idAngles angles;
 idMat3 axis;
 idEntity * part;

 spawnArgs.GetVector( "origin", "0 0 0", org );


 if ( spawnArgs.GetMatrix( "rotation", "1 0 0 0 1 0 0 0 1", axis ) ) {
  angles = axis.ToAngles();
 } else {
     angles[ 0 ] = 0;
     angles[ 1 ] = spawnArgs.GetFloat( "angle" );
     angles[ 2 ] = 0;
 }

 Teleport( org, angles, __null );

 for ( part = teamChain; part != __null; part = part->teamChain ) {
  if ( part->bindMaster != this ) {
   continue;
  }
  if ( part->GetPhysics()->IsType( idPhysics_Parametric::Type ) ) {
   if ( static_cast<idPhysics_Parametric *>(part->GetPhysics())->IsPusher() ) {
    gameLocal.Warning( "teleported '%s' which has the pushing mover '%s' bound to it\n", GetName(), part->GetName() );
   }
  } else if ( part->GetPhysics()->IsType( idPhysics_AF::Type ) ) {
   gameLocal.Warning( "teleported '%s' which has the articulated figure '%s' bound to it\n", GetName(), part->GetName() );
  }
 }
}






void idEntity::Event_UpdateCameraTarget( void ) {
 const char *target;
 const idKeyValue *kv;
 idVec3 dir;

 target = spawnArgs.GetString( "cameraTarget" );

 cameraTarget = gameLocal.FindEntity( target );

 if ( cameraTarget ) {
  kv = cameraTarget->spawnArgs.MatchPrefix( "target", __null );
  while( kv ) {
   idEntity *ent = gameLocal.FindEntity( kv->GetValue() );
   if ( ent && idStr::Icmp( ent->GetEntityDefName(), "target_null" ) == 0) {
    dir = ent->GetPhysics()->GetOrigin() - cameraTarget->GetPhysics()->GetOrigin();
    dir.Normalize();
    cameraTarget->SetAxis( dir.ToMat3() );
    SetAxis(dir.ToMat3());
    break;
   }
   kv = cameraTarget->spawnArgs.MatchPrefix( "target", kv );
  }
 }
 UpdateVisuals();
}






void idEntity::Event_DistanceTo( idEntity *ent ) {
 if ( !ent ) {

  idThread::ReturnFloat( ( ( 128 * 1024 ) - ( -128 * 1024 ) ) );
 } else {
  float dist = ( GetPhysics()->GetOrigin() - ent->GetPhysics()->GetOrigin() ).LengthFast();
  idThread::ReturnFloat( dist );
 }
}






void idEntity::Event_DistanceToPoint( const idVec3 &point ) {
 float dist = ( GetPhysics()->GetOrigin() - point ).LengthFast();
 idThread::ReturnFloat( dist );
}






void idEntity::Event_StartFx( const char *fx ) {
 idEntityFx::StartFx( fx, __null, __null, this, true );
}






void idEntity::Event_WaitFrame( void ) {
 idThread *thread;

 thread = idThread::CurrentThread();
 if ( thread ) {
  thread->WaitFrame();
 }
}






void idEntity::Event_Wait( float time ) {
 idThread *thread = idThread::CurrentThread();

 if ( !thread ) {
  gameLocal.Error( "Event 'wait' called from outside thread" );
 }

 thread->WaitSec( time );
}






void idEntity::Event_HasFunction( const char *name ) {
 const function_t *func;

 func = scriptObject.GetFunction( name );
 if ( func ) {
  idThread::ReturnInt( true );
 } else {
  idThread::ReturnInt( false );
 }
}






void idEntity::Event_CallFunction( const char *funcname ) {
 const function_t *func;
 idThread *thread;

 thread = idThread::CurrentThread();
 if ( !thread ) {
  gameLocal.Error( "Event 'callFunction' called from outside thread" );
 }

 func = scriptObject.GetFunction( funcname );
 if ( !func ) {
  gameLocal.Error( "Unknown function '%s' in '%s'", funcname, scriptObject.GetTypeName() );
 }

 if ( func->type->NumParameters() != 1 ) {
  gameLocal.Error( "Function '%s' has the wrong number of parameters for 'callFunction'", funcname );
 }
 if ( !scriptObject.GetTypeDef()->Inherits( func->type->GetParmType( 0 ) ) ) {
  gameLocal.Error( "Function '%s' is the wrong type for 'callFunction'", funcname );
 }


 thread->CallFunction( this, func, false );
}






void idEntity::Event_SetNeverDormant( int enable ) {
 fl.neverDormant = ( enable != 0 );
 dormantStart = 0;
}
# 4578 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::ClientPredictionThink( void ) {
 RunPhysics();
 Present();
}






void idEntity::WriteBindToSnapshot( idBitMsgDelta &msg ) const {
 int bindInfo;

 if ( bindMaster ) {
  bindInfo = bindMaster->entityNumber;
  bindInfo |= ( fl.bindOrientated & 1 ) << 12;
  if ( bindJoint != INVALID_JOINT ) {
   bindInfo |= 1 << ( 12 + 1 );
   bindInfo |= bindJoint << ( 3 + 12 );
  } else if ( bindBody != -1 ) {
   bindInfo |= 2 << ( 12 + 1 );
   bindInfo |= bindBody << ( 3 + 12 );
  }
 } else {
  bindInfo = ((1<<12)-1);
 }
 msg.WriteBits( bindInfo, 12 + 3 + 9 );
}






void idEntity::ReadBindFromSnapshot( const idBitMsgDelta &msg ) {
 int bindInfo, bindEntityNum, bindPos;
 bool bindOrientated;
 idEntity *master;

 bindInfo = msg.ReadBits( 12 + 3 + 9 );
 bindEntityNum = bindInfo & ( ( 1 << 12 ) - 1 );

 if ( bindEntityNum != ((1<<12)-1) ) {
  master = gameLocal.entities[ bindEntityNum ];

  bindOrientated = ( bindInfo >> 12 ) & 1;
  bindPos = ( bindInfo >> ( 12 + 3 ) );
  switch( ( bindInfo >> ( 12 + 1 ) ) & 3 ) {
   case 1: {
    BindToJoint( master, (jointHandle_t) bindPos, bindOrientated );
    break;
   }
   case 2: {
    BindToBody( master, bindPos, bindOrientated );
    break;
   }
   default: {
    Bind( master, bindOrientated );
    break;
   }
  }
 } else if ( bindMaster ) {
  Unbind();
 }
}






void idEntity::WriteColorToSnapshot( idBitMsgDelta &msg ) const {
 idVec4 color;

 color[0] = renderEntity.shaderParms[ SHADERPARM_RED ];
 color[1] = renderEntity.shaderParms[ SHADERPARM_GREEN ];
 color[2] = renderEntity.shaderParms[ SHADERPARM_BLUE ];
 color[3] = renderEntity.shaderParms[ SHADERPARM_ALPHA ];
 msg.WriteLong( PackColor( color ) );
}






void idEntity::ReadColorFromSnapshot( const idBitMsgDelta &msg ) {
 idVec4 color;

 UnpackColor( msg.ReadLong(), color );
 renderEntity.shaderParms[ SHADERPARM_RED ] = color[0];
 renderEntity.shaderParms[ SHADERPARM_GREEN ] = color[1];
 renderEntity.shaderParms[ SHADERPARM_BLUE ] = color[2];
 renderEntity.shaderParms[ SHADERPARM_ALPHA ] = color[3];
}






void idEntity::WriteGUIToSnapshot( idBitMsgDelta &msg ) const {

 if ( renderEntity.gui[ 0 ] ) {
  msg.WriteByte( renderEntity.gui[ 0 ]->State().GetInt( "networkState" ) );
 } else {
  msg.WriteByte( 0 );
 }
}






void idEntity::ReadGUIFromSnapshot( const idBitMsgDelta &msg ) {
 int state;
 idUserInterface *gui;
 state = msg.ReadByte( );
 gui = renderEntity.gui[ 0 ];
 if ( gui && state != mpGUIState ) {
  mpGUIState = state;
  gui->SetStateInt( "networkState", state );
  gui->HandleNamedEvent( "networkState" );
 }
}






void idEntity::WriteToSnapshot( idBitMsgDelta &msg ) const {
}






void idEntity::ReadFromSnapshot( const idBitMsgDelta &msg ) {
}
# 4729 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idEntity::ServerSendEvent( int eventId, const idBitMsg *msg, bool saveEvent, int excludeClient ) const {
 idBitMsg outMsg;
 byte msgBuf[MAX_GAME_MESSAGE_SIZE];

 if ( !gameLocal.isServer ) {
  return;
 }


 if ( !gameLocal.isNewFrame ) {
  return;
 }

 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.BeginWriting();
 outMsg.WriteByte( GAME_RELIABLE_MESSAGE_EVENT );
 outMsg.WriteBits( gameLocal.GetSpawnId( this ), 32 );
 outMsg.WriteByte( eventId );
 outMsg.WriteLong( gameLocal.time );
 if ( msg ) {
  outMsg.WriteBits( msg->GetSize(), idMath::BitsForInteger( MAX_EVENT_PARAM_SIZE ) );
  outMsg.WriteData( msg->GetData(), msg->GetSize() );
 } else {
  outMsg.WriteBits( 0, idMath::BitsForInteger( MAX_EVENT_PARAM_SIZE ) );
 }

 if ( excludeClient != -1 ) {
  networkSystem->ServerSendReliableMessageExcluding( excludeClient, outMsg );
 } else {
  networkSystem->ServerSendReliableMessage( -1, outMsg );
 }

 if ( saveEvent ) {
  gameLocal.SaveEntityNetworkEvent( this, eventId, msg );
 }
}






void idEntity::ClientSendEvent( int eventId, const idBitMsg *msg ) const {
 idBitMsg outMsg;
 byte msgBuf[MAX_GAME_MESSAGE_SIZE];

 if ( !gameLocal.isClient ) {
  return;
 }


 if ( !gameLocal.isNewFrame ) {
  return;
 }

 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.BeginWriting();
 outMsg.WriteByte( GAME_RELIABLE_MESSAGE_EVENT );
 outMsg.WriteBits( gameLocal.GetSpawnId( this ), 32 );
 outMsg.WriteByte( eventId );
 outMsg.WriteLong( gameLocal.time );
 if ( msg ) {
  outMsg.WriteBits( msg->GetSize(), idMath::BitsForInteger( MAX_EVENT_PARAM_SIZE ) );
  outMsg.WriteData( msg->GetData(), msg->GetSize() );
 } else {
  outMsg.WriteBits( 0, idMath::BitsForInteger( MAX_EVENT_PARAM_SIZE ) );
 }

 networkSystem->ClientSendReliableMessage( outMsg );
}






bool idEntity::ServerReceiveEvent( int event, int time, const idBitMsg &msg ) {
 switch( event ) {
  case 0: {
  }
  default: {
   return false;
  }
 }
}






bool idEntity::ClientReceiveEvent( int event, int time, const idBitMsg &msg ) {
 int index;
 const idSoundShader *shader;
 s_channelType channel;

 switch( event ) {
  case EVENT_STARTSOUNDSHADER: {

   ((void)0);
   if ( time < gameLocal.realClientTime - 1000 ) {

    common->DPrintf( "ent 0x%x: start sound shader too old (%d ms)\n", entityNumber, gameLocal.realClientTime - time );
    return true;
   }
   index = gameLocal.ClientRemapDecl( DECL_SOUND, msg.ReadLong() );
   if ( index >= 0 && index < declManager->GetNumDecls( DECL_SOUND ) ) {

    channel = (s_channelType)msg.ReadByte();

   }
   return true;
  }
  case EVENT_STOPSOUNDSHADER: {

   ((void)0);
   channel = (s_channelType)msg.ReadByte();
   StopSound( channel, false );
   return true;
  }
  default: {
   return false;
  }
 }
 return false;
}
# 4864 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
const idEventDef EV_GetJointHandle( "getJointHandle", "s", 'd' );
const idEventDef EV_ClearAllJoints( "clearAllJoints" );
const idEventDef EV_ClearJoint( "clearJoint", "d" );
const idEventDef EV_SetJointPos( "setJointPos", "ddv" );
const idEventDef EV_SetJointAngle( "setJointAngle", "ddv" );
const idEventDef EV_GetJointPos( "getJointPos", "d", 'v' );
const idEventDef EV_GetJointAngle( "getJointAngle", "d", 'v' );

idTypeInfo idAnimatedEntity::Type( "idAnimatedEntity", "idEntity", ( idEventFunc<idClass> * )idAnimatedEntity::eventCallbacks, idAnimatedEntity::CreateInstance, ( void ( idClass::* )( void ) )&idAnimatedEntity::Spawn, ( void ( idClass::* )( idSaveGame * ) const )&idAnimatedEntity::Save, ( void ( idClass::* )( idRestoreGame * ) )&idAnimatedEntity::Restore ); idClass *idAnimatedEntity::CreateInstance( void ) { try { idAnimatedEntity *ptr = new idAnimatedEntity; ptr->FindUninitializedMemory(); return ptr; } catch( idAllocError & ) { return __null; } } idTypeInfo *idAnimatedEntity::GetType( void ) const { return &( idAnimatedEntity::Type ); } idEventFunc<idAnimatedEntity> idAnimatedEntity::eventCallbacks[] = {
 { &( EV_GetJointHandle ), ( void ( idClass::* )( void ) )( &idAnimatedEntity::Event_GetJointHandle ) },
 { &( EV_ClearAllJoints ), ( void ( idClass::* )( void ) )( &idAnimatedEntity::Event_ClearAllJoints ) },
 { &( EV_ClearJoint ), ( void ( idClass::* )( void ) )( &idAnimatedEntity::Event_ClearJoint ) },
 { &( EV_SetJointPos ), ( void ( idClass::* )( void ) )( &idAnimatedEntity::Event_SetJointPos ) },
 { &( EV_SetJointAngle ), ( void ( idClass::* )( void ) )( &idAnimatedEntity::Event_SetJointAngle ) },
 { &( EV_GetJointPos ), ( void ( idClass::* )( void ) )( &idAnimatedEntity::Event_GetJointPos ) },
 { &( EV_GetJointAngle ), ( void ( idClass::* )( void ) )( &idAnimatedEntity::Event_GetJointAngle ) },
{ __null, __null } };






idAnimatedEntity::idAnimatedEntity() {

    Sys_DebugPrintf("idAnimatedEntity::idAnimatedEntity() size %d\r\n", sizeof(*this));


 animator.SetEntity( this );
 damageEffects = __null;
}






idAnimatedEntity::~idAnimatedEntity() {
 damageEffect_t *de;

 for ( de = damageEffects; de; de = damageEffects ) {
  damageEffects = de->next;
  delete de;
 }
}
# 4917 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Save( idSaveGame *savefile ) const {
 animator.Save( savefile );



}
# 4931 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Restore( idRestoreGame *savefile ) {
 animator.Restore( savefile );


 if ( animator.ModelHandle() ) {

  renderEntity.callback = idEntity::ModelCallback;
  animator.GetJoints( &renderEntity.numJoints, &renderEntity.joints );
  animator.GetBounds( gameLocal.time, renderEntity.bounds );
  if ( modelDefHandle != -1 ) {
   gameRenderWorld->UpdateEntityDef( modelDefHandle, &renderEntity );
  }
 }
}






void idAnimatedEntity::ClientPredictionThink( void ) {
 RunPhysics();
 UpdateAnimation();
 Present();
}






void idAnimatedEntity::Think( void ) {
 RunPhysics();
 UpdateAnimation();
 Present();
 UpdateDamageEffects();
}






void idAnimatedEntity::UpdateAnimation( void ) {

 if ( !( thinkFlags & TH_ANIMATE ) ) {
  return;
 }


 if ( !animator.ModelHandle() ) {

  return;
 }


 if ( !fl.hidden ) {
  animator.ServiceAnims( gameLocal.previousTime, gameLocal.time );
 }


 if ( !animator.FrameHasChanged( gameLocal.time ) ) {

  return;
 }


 animator.GetBounds( gameLocal.time, renderEntity.bounds );
 if ( renderEntity.bounds.IsCleared() && !fl.hidden ) {
  gameLocal.DPrintf( "%d: inside out bounds\n", gameLocal.time );
 }


 UpdateVisuals();


 animator.ClearForceUpdate();
}






idAnimator *idAnimatedEntity::GetAnimator( void ) {
 return &animator;
}






void idAnimatedEntity::SetModel( const char *modelname ) {
 FreeModelDef();

 renderEntity.hModel = animator.SetModel( modelname );
 if ( !renderEntity.hModel ) {
  idEntity::SetModel( modelname );
  return;
 }

 if ( !renderEntity.customSkin ) {
  renderEntity.customSkin = animator.ModelDef()->GetDefaultSkin();
 }


 renderEntity.callback = idEntity::ModelCallback;
 animator.GetJoints( &renderEntity.numJoints, &renderEntity.joints );
 animator.GetBounds( gameLocal.time, renderEntity.bounds );

 UpdateVisuals();
}






bool idAnimatedEntity::GetJointWorldTransform( jointHandle_t jointHandle, int currentTime, idVec3 &offset, idMat3 &axis ) {
 if ( !animator.GetJointTransform( jointHandle, currentTime, offset, axis ) ) {
  return false;
 }

 ConvertLocalToWorldTransform( offset, axis );
 return true;
}






bool idAnimatedEntity::GetJointTransformForAnim( jointHandle_t jointHandle, int animNum, int frameTime, idVec3 &offset, idMat3 &axis ) const {
 const idAnim *anim;
 int numJoints;
 idJointMat *frame;

 anim = animator.GetAnim( animNum );
 if ( !anim ) {
  ((void)0);
  return false;
 }

 numJoints = animator.NumJoints();
 if ( ( jointHandle < 0 ) || ( jointHandle >= numJoints ) ) {
  ((void)0);
  return false;
 }

 frame = ( idJointMat * )((void *)((((int)__builtin_alloca((numJoints * sizeof( idJointMat ))+15)) + 15) & ~15));
 gameEdit->ANIM_CreateAnimFrame( animator.ModelHandle(), anim->MD5Anim( 0 ), renderEntity.numJoints, frame, frameTime, animator.ModelDef()->GetVisualOffset(), animator.RemoveOrigin() );

 offset = frame[ jointHandle ].ToVec3();
 axis = frame[ jointHandle ].ToMat3();

 return true;
}
# 5097 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::AddDamageEffect( const trace_t &collision, const idVec3 &velocity, const char *damageDefName ) {
 jointHandle_t jointNum;
 idVec3 origin, dir, localDir, localOrigin, localNormal;
 idMat3 axis;

 if ( !g_bloodEffects.GetBool() || renderEntity.joints == __null ) {
  return;
 }

 const idDeclEntityDef *def = gameLocal.FindEntityDef( damageDefName, false );
 if ( def == __null ) {
  return;
 }

 jointNum = ( ( collision.c.id ) >= 0 ? INVALID_JOINT : ((jointHandle_t) ( -1 - collision.c.id )) );
 if ( jointNum == INVALID_JOINT ) {
  return;
 }

 dir = velocity;
 dir.Normalize();

 axis = renderEntity.joints[jointNum].ToMat3() * renderEntity.axis;
 origin = renderEntity.origin + renderEntity.joints[jointNum].ToVec3() * renderEntity.axis;

 localOrigin = ( collision.c.point - origin ) * axis.Transpose();
 localNormal = collision.c.normal * axis.Transpose();
 localDir = dir * axis.Transpose();

 AddLocalDamageEffect( jointNum, localOrigin, localNormal, localDir, def, collision.c.material );

 if ( gameLocal.isServer ) {
  idBitMsg msg;
  byte msgBuf[MAX_EVENT_PARAM_SIZE];

  msg.Init( msgBuf, sizeof( msgBuf ) );
  msg.BeginWriting();
  msg.WriteShort( (int)jointNum );
  msg.WriteFloat( localOrigin[0] );
  msg.WriteFloat( localOrigin[1] );
  msg.WriteFloat( localOrigin[2] );
  msg.WriteDir( localNormal, 24 );
  msg.WriteDir( localDir, 24 );
  msg.WriteLong( gameLocal.ServerRemapDecl( -1, DECL_ENTITYDEF, def->Index() ) );
  msg.WriteLong( gameLocal.ServerRemapDecl( -1, DECL_MATERIAL, collision.c.material->Index() ) );
  ServerSendEvent( EVENT_ADD_DAMAGE_EFFECT, &msg, false, -1 );
 }
}






int idAnimatedEntity::GetDefaultSurfaceType( void ) const {
 return SURFTYPE_METAL;
}






void idAnimatedEntity::AddLocalDamageEffect( jointHandle_t jointNum, const idVec3 &localOrigin, const idVec3 &localNormal, const idVec3 &localDir, const idDeclEntityDef *def, const idMaterial *collisionMaterial ) {
 const char *sound, *splat, *decal, *bleed, *key;
 damageEffect_t *de;
 idVec3 origin, dir;
 idMat3 axis;

 axis = renderEntity.joints[jointNum].ToMat3() * renderEntity.axis;
 origin = renderEntity.origin + renderEntity.joints[jointNum].ToVec3() * renderEntity.axis;

 origin = origin + localOrigin * axis;
 dir = localDir * axis;

 int type = collisionMaterial->GetSurfaceType();
 if ( type == SURFTYPE_NONE ) {
  type = GetDefaultSurfaceType();
 }

 const char *materialType = gameLocal.sufaceTypeNames[ type ];


 key = va( "snd_%s", materialType );
 sound = spawnArgs.GetString( key );
 if ( *sound == '\0' ) {
  sound = def->dict.GetString( key );
 }
 if ( *sound != '\0' ) {

 }


 key = va( "mtr_splat_%s", materialType );
 splat = spawnArgs.RandomPrefix( key, gameLocal.random );
 if ( *splat == '\0' ) {
  splat = def->dict.RandomPrefix( key, gameLocal.random );
 }
 if ( *splat != '\0' ) {
  gameLocal.BloodSplat( origin, dir, 64.0f, splat );
 }


 if ( !( IsType( idPlayer::Type ) && !gameLocal.isMultiplayer ) ) {

  key = va( "mtr_wound_%s", materialType );
  decal = spawnArgs.RandomPrefix( key, gameLocal.random );
  if ( *decal == '\0' ) {
   decal = def->dict.RandomPrefix( key, gameLocal.random );
  }
  if ( *decal != '\0' ) {
   ProjectOverlay( origin, dir, 20.0f, decal );
  }
 }


 key = va( "smoke_wound_%s", materialType );
 bleed = spawnArgs.GetString( key );
 if ( *bleed == '\0' ) {
  bleed = def->dict.GetString( key );
 }
 if ( *bleed != '\0' ) {
  de = new damageEffect_t;
  de->next = this->damageEffects;
  this->damageEffects = de;

  de->jointNum = jointNum;
  de->localOrigin = localOrigin;
  de->localNormal = localNormal;
  de->type = static_cast<const idDeclParticle *>( declManager->FindType( DECL_PARTICLE, bleed ) );
  de->time = gameLocal.time;
 }
}






void idAnimatedEntity::UpdateDamageEffects( void ) {
 damageEffect_t *de, **prev;


 prev = &this->damageEffects;
 while ( *prev ) {
  de = *prev;
  if ( de->time == 0 ) {
   *prev = de->next;
   delete de;
  } else {
   prev = &de->next;
  }
 }

 if ( !g_bloodEffects.GetBool() ) {
  return;
 }


 for ( de = this->damageEffects; de; de = de->next ) {
  idVec3 origin, start;
  idMat3 axis;

  animator.GetJointTransform( de->jointNum, gameLocal.time, origin, axis );
  axis *= renderEntity.axis;
  origin = renderEntity.origin + origin * renderEntity.axis;
  start = origin + de->localOrigin * axis;
  if ( !gameLocal.smokeParticles->EmitSmoke( de->type, de->time, gameLocal.random.CRandomFloat(), start, axis ) ) {
   de->time = 0;
  }
 }
}






bool idAnimatedEntity::ClientReceiveEvent( int event, int time, const idBitMsg &msg ) {
 int damageDefIndex;
 int materialIndex;
 jointHandle_t jointNum;
 idVec3 localOrigin, localNormal, localDir;

 switch( event ) {
  case EVENT_ADD_DAMAGE_EFFECT: {
   jointNum = (jointHandle_t) msg.ReadShort();
   localOrigin[0] = msg.ReadFloat();
   localOrigin[1] = msg.ReadFloat();
   localOrigin[2] = msg.ReadFloat();
   localNormal = msg.ReadDir( 24 );
   localDir = msg.ReadDir( 24 );
   damageDefIndex = gameLocal.ClientRemapDecl( DECL_ENTITYDEF, msg.ReadLong() );
   materialIndex = gameLocal.ClientRemapDecl( DECL_MATERIAL, msg.ReadLong() );
   const idDeclEntityDef *damageDef = static_cast<const idDeclEntityDef *>( declManager->DeclByIndex( DECL_ENTITYDEF, damageDefIndex ) );
   const idMaterial *collisionMaterial = static_cast<const idMaterial *>( declManager->DeclByIndex( DECL_MATERIAL, materialIndex ) );
   AddLocalDamageEffect( jointNum, localOrigin, localNormal, localDir, damageDef, collisionMaterial );
   return true;
  }
  default: {
   return idEntity::ClientReceiveEvent( event, time, msg );
  }
 }
 return false;
}
# 5310 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Event_GetJointHandle( const char *jointname ) {
 jointHandle_t joint;

 joint = animator.GetJointHandle( jointname );
 idThread::ReturnInt( joint );
}
# 5324 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Event_ClearAllJoints( void ) {
 animator.ClearAllJoints();
}
# 5335 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Event_ClearJoint( jointHandle_t jointnum ) {
 animator.ClearJoint( jointnum );
}
# 5346 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Event_SetJointPos( jointHandle_t jointnum, jointModTransform_t transform_type, const idVec3 &pos ) {
 animator.SetJointPos( jointnum, transform_type, pos );
}
# 5357 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Event_SetJointAngle( jointHandle_t jointnum, jointModTransform_t transform_type, const idAngles &angles ) {
 idMat3 mat;

 mat = angles.ToMat3();
 animator.SetJointAxis( jointnum, transform_type, mat );
}
# 5371 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Event_GetJointPos( jointHandle_t jointnum ) {
 idVec3 offset;
 idMat3 axis;

 if ( !GetJointWorldTransform( jointnum, gameLocal.time, offset, axis ) ) {
  gameLocal.Warning( "Joint # %d out of range on entity '%s'", jointnum, name.c_str() );
 }

 idThread::ReturnVector( offset );
}
# 5389 "d:/Data/Nintendo/DoomGX/src/game/Entity.cpp"
void idAnimatedEntity::Event_GetJointAngle( jointHandle_t jointnum ) {
 idVec3 offset;
 idMat3 axis;

 if ( !GetJointWorldTransform( jointnum, gameLocal.time, offset, axis ) ) {
  gameLocal.Warning( "Joint # %d out of range on entity '%s'", jointnum, name.c_str() );
 }

 idAngles ang = axis.ToAngles();
 idVec3 vec( ang[ 0 ], ang[ 1 ], ang[ 2 ] );
 idThread::ReturnVector( vec );
}
