# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/AsyncServer.cpp"
# 1 "d:\\Data\\Nintendo\\DoomGX\\build//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/AsyncServer.cpp"
# 29 "d:/Data/Nintendo/DoomGX/src/framework/async/AsyncServer.cpp"
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 1
# 96 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h"
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 1 3
# 29 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 1 3
# 15 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/newlib.h" 1 3
# 16 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 1 3



# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/ieeefp.h" 1 3
# 5 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 1 3
# 25 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 3
extern "C" {
# 209 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/features.h" 3
}
# 6 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/config.h" 2 3
# 17 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 2 3
# 30 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3




# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 212 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef unsigned int size_t;
# 35 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 1 3 4
# 40 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 38 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3







# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 1 3
# 9 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
extern "C" {



# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/_ansi.h" 1 3
# 14 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 1 3
# 12 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_types.h" 1 3






# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 1 3
# 9 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
extern "C" {
# 26 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 118 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_default_types.h" 3
}
# 8 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/_types.h" 2 3


typedef long long _fpos_t;


typedef long long _off_t;
# 13 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 47 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/lock.h" 3
extern int __libc_lock_init(int*,int);
extern int __libc_lock_close(int*);
extern int __libc_lock_acquire(int*);
extern int __libc_lock_try_acquire(int*);
extern int __libc_lock_release(int*);
# 14 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3
# 24 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
typedef short __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;
# 56 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 353 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 169 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                     ;
  int (* _write) (struct _reent *, void *, const char *, int)
                            ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _fpos_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 273 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 305 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 580 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 818 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr __attribute__((__section__(".sdata")));
extern struct _reent *const _global_impure_ptr __attribute__((__section__(".sdata")));

void _reclaim_reent (struct _reent *);
# 841 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/reent.h" 3
}
# 46 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 1 3
# 69 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 150 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 70 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/types.h" 1 3
# 19 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 2 3
# 92 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;



typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;



typedef unsigned long clock_t;




typedef long time_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;
typedef char * caddr_t;






typedef unsigned int ino_t;
# 163 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;





typedef int pid_t;







typedef long key_t;

typedef _ssize_t ssize_t;
# 196 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 223 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 254 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;

typedef __uint32_t fsblkcnt_t;
typedef __uint32_t fsfilcnt_t;
# 47 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3

extern "C" {

typedef __FILE FILE;




typedef _fpos_t fpos_t;





# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 1 3
# 9 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 3
     extern void __flockfile(FILE *fp);
# 18 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/stdio.h" 3
     extern void __funlockfile(FILE *fp);
# 62 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 2 3
# 171 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *, const char *, FILE *);
void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);
int fprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int printf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int scanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int sscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int vfprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int vsprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int fgetc (FILE *);
char * fgets (char *, int, FILE *);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *, size_t _size, size_t _n, FILE *);
size_t fwrite (const void * , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *, fpos_t *);

int fseek (FILE *, off_t, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *_name, const char *_type);
int sprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int remove (const char *);
int rename (const char *, const char *);






int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);




int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * asnprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int asprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int fcloseall (void);
int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int snprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vfscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsnprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
# 313 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE * fdopen (int, const char *);

int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 338 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
int dprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

FILE * fmemopen (void *, size_t, const char *);


FILE * open_memstream (char **, size_t *);



int vdprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;







int _asiprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
char * _asnprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _asprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _diprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _dprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *, int, FILE *);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
FILE * _fmemopen_r (struct _reent *, void *, size_t, const char *);
FILE * _fopen_r (struct _reent *, const char *, const char *);
FILE * _freopen_r (struct _reent *, const char *, const char *, FILE *);
int _fprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *, FILE *);
size_t _fread_r (struct _reent *, void *, size_t _size, size_t _n, FILE *);
int _fscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _fseek_r (struct _reent *, FILE *, off_t, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * , size_t _size, size_t _n, FILE *);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new)
                                          ;
int _scanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int _siprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _snprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _sprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _sscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vfprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _vscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsnprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 515 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 535 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
FILE *funopen (const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))



                                   ;
FILE *_funopen_r (struct _reent *, const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))



                                   ;







typedef ssize_t cookie_read_function_t(void *__cookie, char *__buf, size_t __n);
typedef ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
     size_t __n);




typedef int cookie_seek_function_t(void *__cookie, off_t *__off, int __whence);

typedef int cookie_close_function_t(void *__cookie);
typedef struct
{


  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
FILE *fopencookie (void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
FILE *_fopencookie_r (struct _reent *, void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
# 683 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdio.h" 3
}
# 97 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 1 3
# 15 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 16 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/stdlib.h" 1 3
# 19 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3

# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/alloca.h" 1 3
# 21 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 2 3






extern "C" {

typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;


typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;
# 58 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
int __locale_mb_cur_max (void);



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);

float atoff (const char *__nptr);

int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *))



                                                         ;
void * calloc (size_t __nmemb, size_t __size) __attribute__ ((nothrow));
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) __attribute__ ((nothrow));
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);

extern char *suboptarg;
int getsubopt (char **, char * const *, char **);

long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) __attribute__ ((nothrow));
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);


char * mkdtemp (char *);
int mkostemp (char *, int);
int mkostemps (char *, int, int);
int mkstemp (char *);
int mkstemps (char *, int);
char * mktemp (char *) __attribute__ ((__warning__ ("the use of `mktemp' is dangerous; use `mkstemp' instead")));

char * _mkdtemp_r (struct _reent *, char *);
int _mkostemp_r (struct _reent *, char *, int);
int _mkostemps_r (struct _reent *, char *, int, int);
int _mkstemp_r (struct _reent *, char *);
int _mkstemps_r (struct _reent *, char *, int);
char * _mktemp_r (struct _reent *, char *) __attribute__ ((__warning__ ("the use of `mktemp' is dangerous; use `mkstemp' instead")));

void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size) __attribute__ ((nothrow));

void * reallocf (void * __r, size_t __size);

void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);


long a64l (const char *__input);
char * l64a (long __input);
char * _l64a_r (struct _reent *,long __input);
int on_exit (void (*__func)(int, void *),void * __arg);
void _Exit (int __status) __attribute__ ((noreturn));
int putenv (char *__string);
int _putenv_r (struct _reent *, char *__string);
void * _reallocf_r (struct _reent *, void *, size_t);
int setenv (const char *__string, const char *__value, int __overwrite);
int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);

char * gcvt (double,int,char *);
char * gcvtf (float,int,char *);
char * fcvt (double,int,int *,int *);
char * fcvtf (float,int,int *,int *);
char * ecvt (double,int,int *,int *);
char * ecvtbuf (double, int, int*, int*, char *);
char * fcvtbuf (double, int, int*, int*, char *);
char * ecvtf (float,int,int *,int *);
char * dtoa (double, int, int, int *, int*, char**);
int rand_r (unsigned *__seed);

double drand48 (void);
double _drand48_r (struct _reent *);
double erand48 (unsigned short [3]);
double _erand48_r (struct _reent *, unsigned short [3]);
long jrand48 (unsigned short [3]);
long _jrand48_r (struct _reent *, unsigned short [3]);
void lcong48 (unsigned short [7]);
void _lcong48_r (struct _reent *, unsigned short [7]);
long lrand48 (void);
long _lrand48_r (struct _reent *);
long mrand48 (void);
long _mrand48_r (struct _reent *);
long nrand48 (unsigned short [3]);
long _nrand48_r (struct _reent *, unsigned short [3]);
unsigned short *
       seed48 (unsigned short [3]);
unsigned short *
       _seed48_r (struct _reent *, unsigned short [3]);
void srand48 (long);
void _srand48_r (struct _reent *, long);
long long atoll (const char *__nptr);
long long _atoll_r (struct _reent *, const char *__nptr);
long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *__n, char **__end_PTR, int __base);
long long _strtoll_r (struct _reent *, const char *__n, char **__end_PTR, int __base);
unsigned long long strtoull (const char *__n, char **__end_PTR, int __base);
unsigned long long _strtoull_r (struct _reent *, const char *__n, char **__end_PTR, int __base);


void cfree (void *);
int unsetenv (const char *__string);
int _unsetenv_r (struct _reent *, const char *__string);
# 206 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) __attribute__ ((nothrow));
void * _calloc_r (struct _reent *, size_t, size_t) __attribute__ ((nothrow));
void _free_r (struct _reent *, void *) __attribute__ ((nothrow));
void * _realloc_r (struct _reent *, void *, size_t) __attribute__ ((nothrow));
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);



extern long double strtold (const char *, char **);
extern long double wcstold (const wchar_t *, wchar_t **);


}
# 98 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 1 3 4
# 102 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 99 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 1 3
# 12 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/cdefs.h" 1 3
# 13 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 16 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3





extern "C" {

void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *, const void *, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *, const char *);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *, const char *, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);


char *strtok (char *, const char *);


size_t strxfrm (char *, const char *, size_t);


char *strtok_r (char *, const char *, char **);

int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
int ffs (int);
char *index (const char *, int);
void * memccpy (void *, const void *, int, size_t);
void * mempcpy (void *, const void *, size_t);
void * memmem (const void *, size_t, const void *, size_t);
char *rindex (const char *, int);
char *stpcpy (char *, const char *);
char *stpncpy (char *, const char *, size_t);
int strcasecmp (const char *, const char *);
char *strcasestr (const char *, const char *);
char *strchrnul (const char *, int);
char *strdup (const char *);
char *_strdup_r (struct _reent *, const char *);
char *strndup (const char *, size_t);
char *_strndup_r (struct _reent *, const char *, size_t);
# 79 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
int strerror_r (int, char *, size_t) __asm__ ("" "__xpg_strerror_r");





size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
int strncasecmp (const char *, const char *, size_t);
size_t strnlen (const char *, size_t);
char *strsep (char **, const char *);
char *strlwr (char *);
char *strupr (char *);

char *strsignal (int __signo);






char * _strerror_r (struct _reent *, int, int, int *);
# 132 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/string.h" 1 3
# 133 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/string.h" 2 3

}
# 100 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/assert.h" 1 3





extern "C" {
# 39 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/assert.h" 3
void __assert (const char *, int, const char *) __attribute__ ((__noreturn__))
                                 ;
void __assert_func (const char *, int, const char *, const char *) __attribute__ ((__noreturn__))
                                 ;


}
# 101 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 1 3
# 18 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/machine/time.h" 1 3
# 19 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3
# 27 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 28 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 2 3



extern "C" {

struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
};

clock_t clock (void);
double difftime (time_t _time2, time_t _time1);
time_t mktime (struct tm *_timeptr);
time_t time (time_t *_timer);

char *asctime (const struct tm *_tblock);
char *ctime (const time_t *_time);
struct tm *gmtime (const time_t *_timer);
struct tm *localtime (const time_t *_timer);

size_t strftime (char *_s, size_t _maxsize, const char *_fmt, const struct tm *_t);

char *asctime_r (const struct tm *, char *);
char *ctime_r (const time_t *, char *);
struct tm *gmtime_r (const time_t *, struct tm *);
struct tm *localtime_r (const time_t *, struct tm *);

}


extern "C" {



char *strptime (const char *, const char *, struct tm *);
void tzset (void);
void _tzset_r (struct _reent *);

typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  long offset;
} __tzrule_type;

typedef struct __tzinfo_struct
{
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo (void);
# 118 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
extern long _timezone;
extern int _daylight;
extern char *_tzname[2];
# 129 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
}
# 195 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
extern "C" {
# 273 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/time.h" 3
}
# 102 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 1 3





extern "C" {

int isalnum (int __c);
int isalpha (int __c);
int iscntrl (int __c);
int isdigit (int __c);
int isgraph (int __c);
int islower (int __c);
int isprint (int __c);
int ispunct (int __c);
int isspace (int __c);
int isupper (int __c);
int isxdigit (int __c);
int tolower (int __c);
int toupper (int __c);


int isblank (int __c);



int isascii (int __c);
int toascii (int __c);
# 45 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 3
extern char *__ctype_ptr__;
# 109 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/ctype.h" 3
extern const char _ctype_[];

}
# 103 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 1 3
# 34 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
       
# 35 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3

# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 1 3
# 35 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
       
# 36 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3

#pragma GCC visibility push(default)

# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 1 3
# 153 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 3
namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;




}
# 393 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/os_defines.h" 1 3
# 394 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 2 3


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/cpu_defines.h" 1 3
# 397 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/powerpc-eabi/bits/c++config.h" 2 3
# 40 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 2 3

extern "C++" {

namespace std
{
# 61 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 118 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 143 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
# 37 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 2 3





#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 83 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name[0] == '*' ? __name + 1 : __name; }
# 118 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
    bool before(const type_info& __arg) const
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 139 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
# 155 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/typeinfo" 3
    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 104 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/errno.h" 1 3




typedef int error_t;



# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/errno.h" 1 3






extern "C" {







extern int *__errno (void);




extern const char * const _sys_errlist[];
extern int _sys_nerr;
# 190 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/sys/errno.h" 3
}
# 10 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/errno.h" 2 3
# 105 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 1 3
# 9 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern "C" {




union __dmath
{
  double d;
  __ULong i[2];
};

union __fmath
{
  float f;
  __ULong i[1];
};


union __ldmath
{
  long double ld;
  __ULong i[4];
};
# 111 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double atan (double);
extern double cos (double);
extern double sin (double);
extern double tan (double);
extern double tanh (double);
extern double frexp (double, int *);
extern double modf (double, double *);
extern double ceil (double);
extern double fabs (double);
extern double floor (double);






extern double acos (double);
extern double asin (double);
extern double atan2 (double, double);
extern double cosh (double);
extern double sinh (double);
extern double exp (double);
extern double ldexp (double, int);
extern double log (double);
extern double log10 (double);
extern double pow (double, double);
extern double sqrt (double);
extern double fmod (double, double);
# 148 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 175 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern int __isinff (float x);
extern int __isinfd (double x);
extern int __isnanf (float x);
extern int __isnand (double x);
extern int __fpclassifyf (float x);
extern int __fpclassifyd (double x);
extern int __signbitf (float x);
extern int __signbitd (double x);
# 235 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double infinity (void);
extern double nan (const char *);
extern int finite (double);
extern double copysign (double, double);
extern double logb (double);
extern int ilogb (double);

extern double asinh (double);
extern double cbrt (double);
extern double nextafter (double, double);
extern double rint (double);
extern double scalbn (double, int);

extern double exp2 (double);
extern double scalbln (double, long int);
extern double tgamma (double);
extern double nearbyint (double);
extern long int lrint (double);
extern long long int llrint (double);
extern double round (double);
extern long int lround (double);
extern long long int llround (double);
extern double trunc (double);
extern double remquo (double, double, int *);
extern double fdim (double, double);
extern double fmax (double, double);
extern double fmin (double, double);
extern double fma (double, double, double);


extern double log1p (double);
extern double expm1 (double);



extern double acosh (double);
extern double atanh (double);
extern double remainder (double, double);
extern double gamma (double);
extern double lgamma (double);
extern double erf (double);
extern double erfc (double);
extern double log2 (double);





extern double hypot (double, double);






extern float atanf (float);
extern float cosf (float);
extern float sinf (float);
extern float tanf (float);
extern float tanhf (float);
extern float frexpf (float, int *);
extern float modff (float, float *);
extern float ceilf (float);
extern float fabsf (float);
extern float floorf (float);


extern float acosf (float);
extern float asinf (float);
extern float atan2f (float, float);
extern float coshf (float);
extern float sinhf (float);
extern float expf (float);
extern float ldexpf (float, int);
extern float logf (float);
extern float log10f (float);
extern float powf (float, float);
extern float sqrtf (float);
extern float fmodf (float, float);




extern float exp2f (float);
extern float scalblnf (float, long int);
extern float tgammaf (float);
extern float nearbyintf (float);
extern long int lrintf (float);
extern long long llrintf (float);
extern float roundf (float);
extern long int lroundf (float);
extern long long int llroundf (float);
extern float truncf (float);
extern float remquof (float, float, int *);
extern float fdimf (float, float);
extern float fmaxf (float, float);
extern float fminf (float, float);
extern float fmaf (float, float, float);

extern float infinityf (void);
extern float nanf (const char *);
extern int finitef (float);
extern float copysignf (float, float);
extern float logbf (float);
extern int ilogbf (float);

extern float asinhf (float);
extern float cbrtf (float);
extern float nextafterf (float, float);
extern float rintf (float);
extern float scalbnf (float, int);
extern float log1pf (float);
extern float expm1f (float);


extern float acoshf (float);
extern float atanhf (float);
extern float remainderf (float, float);
extern float gammaf (float);
extern float lgammaf (float);
extern float erff (float);
extern float erfcf (float);
extern float log2f (float);



extern float hypotf (float, float);






extern long double atanl (long double);
extern long double cosl (long double);
extern long double sinl (long double);
extern long double tanl (long double);
extern long double tanhl (long double);
extern long double frexpl (long double value, int *);
extern long double modfl (long double, long double *);
extern long double ceill (long double);
extern long double fabsl (long double);
extern long double floorl (long double);
extern long double log1pl (long double);
extern long double expm1l (long double);




extern long double acosl (long double);
extern long double asinl (long double);
extern long double atan2l (long double, long double);
extern long double coshl (long double);
extern long double sinhl (long double);
extern long double expl (long double);
extern long double ldexpl (long double, int);
extern long double logl (long double);
extern long double log10l (long double);
extern long double powl (long double, long double);
extern long double sqrtl (long double);
extern long double fmodl (long double, long double);
extern long double hypotl (long double, long double);


extern long double copysignl (long double, long double);
extern long double nanl (const char *);
extern int ilogbl (long double);
extern long double asinhl (long double);
extern long double cbrtl (long double);
extern long double nextafterl (long double, long double);
extern long double rintl (long double);
extern long double scalbnl (long double, int);
extern long double exp2l (long double);
extern long double scalblnl (long double, long);
extern long double tgammal (long double);
extern long double nearbyintl (long double);
extern long int lrintl (long double);
extern long long int llrintl (long double);
extern long double roundl (long double);
extern long lroundl (long double);
extern long long int llroundl (long double);
extern long double truncl (long double);
extern long double remquol (long double, long double, int *);
extern long double fdiml (long double, long double);
extern long double fmaxl (long double, long double);
extern long double fminl (long double, long double);
extern long double fmal (long double, long double, long double);

extern long double acoshl (long double);
extern long double atanhl (long double);
extern long double remainderl (long double, long double);
extern long double lgammal (long double);
extern long double erfl (long double);
extern long double erfcl (long double);
# 443 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern double drem (double, double);
extern void sincos (double, double *, double *);
extern double gamma_r (double, int *);
extern double lgamma_r (double, int *);

extern double y0 (double);
extern double y1 (double);
extern double yn (int, double);
extern double j0 (double);
extern double j1 (double);
extern double jn (int, double);

extern float dremf (float, float);
extern void sincosf (float, float *, float *);
extern float gammaf_r (float, int *);
extern float lgammaf_r (float, int *);

extern float y0f (float);
extern float y1f (float);
extern float ynf (int, float);
extern float j0f (float);
extern float j1f (float);
extern float jnf (int, float);



extern double exp10 (double);


extern double pow10 (double);


extern float exp10f (float);


extern float pow10f (float);
# 488 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
extern int *__signgam (void);
# 497 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
struct __exception



{
  int type;
  char *name;
  double arg1;
  double arg2;
  double retval;
  int err;
};


extern int matherr (struct __exception *e);
# 554 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
enum __fdlibm_version
{
  __fdlibm_ieee = -1,
  __fdlibm_svid,
  __fdlibm_xopen,
  __fdlibm_posix
};




extern enum __fdlibm_version __fdlib_version;
# 574 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/math.h" 3
}
# 106 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2




# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sys/sys_public.h" 1
# 174 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sys/sys_public.h"
typedef enum {
 CPUID_NONE = 0x00000,
 CPUID_UNSUPPORTED = 0x00001,
 CPUID_GENERIC = 0x00002,
 CPUID_INTEL = 0x00004,
 CPUID_AMD = 0x00008,
 CPUID_MMX = 0x00010,
 CPUID_3DNOW = 0x00020,
 CPUID_SSE = 0x00040,
 CPUID_SSE2 = 0x00080,
 CPUID_SSE3 = 0x00100,
 CPUID_ALTIVEC = 0x00200,
 CPUID_HTT = 0x01000,
 CPUID_CMOV = 0x02000,
 CPUID_FTZ = 0x04000,
 CPUID_DAZ = 0x08000
} cpuid_t;

typedef enum {
 FPU_EXCEPTION_INVALID_OPERATION = 1,
 FPU_EXCEPTION_DENORMALIZED_OPERAND = 2,
 FPU_EXCEPTION_DIVIDE_BY_ZERO = 4,
 FPU_EXCEPTION_NUMERIC_OVERFLOW = 8,
 FPU_EXCEPTION_NUMERIC_UNDERFLOW = 16,
 FPU_EXCEPTION_INEXACT_RESULT = 32
} fpuExceptions_t;

typedef enum {
 FPU_PRECISION_SINGLE = 0,
 FPU_PRECISION_DOUBLE = 1,
 FPU_PRECISION_DOUBLE_EXTENDED = 2
} fpuPrecision_t;

typedef enum {
 FPU_ROUNDING_TO_NEAREST = 0,
 FPU_ROUNDING_DOWN = 1,
 FPU_ROUNDING_UP = 2,
 FPU_ROUNDING_TO_ZERO = 3
} fpuRounding_t;

typedef enum {
 AXIS_SIDE,
 AXIS_FORWARD,
 AXIS_UP,
 AXIS_ROLL,
 AXIS_YAW,
 AXIS_PITCH,
 MAX_JOYSTICK_AXIS
} joystickAxis_t;

typedef enum {
 SE_NONE,
 SE_KEY,
 SE_CHAR,
 SE_MOUSE,
 SE_JOYSTICK_AXIS,
 SE_CONSOLE
} sysEventType_t;

typedef enum {
 M_ACTION1,
 M_ACTION2,
 M_ACTION3,
 M_ACTION4,
 M_ACTION5,
 M_ACTION6,
 M_ACTION7,
 M_ACTION8,
 M_DELTAX,
 M_DELTAY,
 M_DELTAZ
} sys_mEvents;
# 258 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sys/sys_public.h"
typedef struct {
    int evTime;
    sysEventType_t evType;
    int evValue;
    int evValue2;
    int evPtrLength;
    void *evPtr;
} sysEvent_t;


typedef struct sysMemoryStats_s {
 int memoryLoad;
 int totalPhysical;
 int availPhysical;
 int totalPageFile;
 int availPageFile;
 int totalVirtual;
 int availVirtual;
 int availExtendedVirtual;
} sysMemoryStats_t;

typedef unsigned long address_t;

template<class type> class idList;


void Sys_Init( void );
void Sys_Shutdown( void );
void Sys_Error( const char *error, ...);
void Sys_Quit( void );

bool Sys_AlreadyRunning( void );


char * Sys_GetClipboardData( void );
void Sys_SetClipboardData( const char *string );



void Sys_Printf( const char *msg, ... )__attribute__((format(printf,1,2)));


void Sys_DebugPrintf( const char *fmt, ... )__attribute__((format(printf,1,2)));
void Sys_DebugVPrintf( const char *fmt, va_list arg );






void Sys_Sleep( int msec );



int Sys_Milliseconds( void );


double Sys_GetClockTicks( void );
double Sys_ClockTicksPerSecond( void );


cpuid_t Sys_GetProcessorId( void );
const char * Sys_GetProcessorString( void );


bool Sys_FPU_StackIsEmpty( void );


void Sys_FPU_ClearStack( void );


const char * Sys_FPU_GetState( void );


void Sys_FPU_EnableExceptions( int exceptions );


void Sys_FPU_SetPrecision( int precision );


void Sys_FPU_SetRounding( int rounding );


void Sys_FPU_SetFTZ( bool enable );


void Sys_FPU_SetDAZ( bool enable );


int Sys_GetSystemRam( void );


int Sys_GetVideoRam( void );


int Sys_GetDriveFreeSpace( const char *path );


void Sys_GetCurrentMemoryStatus( sysMemoryStats_t &stats );
void Sys_GetExeLaunchMemoryStatus( sysMemoryStats_t &stats );


bool Sys_LockMemory( void *ptr, int bytes );
bool Sys_UnlockMemory( void *ptr, int bytes );


void Sys_SetPhysicalWorkMemory( int minBytes, int maxBytes );


void Sys_GetCallStack( address_t *callStack, const int callStackSize );
const char * Sys_GetCallStackStr( const address_t *callStack, const int callStackSize );
const char * Sys_GetCallStackCurStr( int depth );
const char * Sys_GetCallStackCurAddressStr( int depth );
void Sys_ShutdownSymbols( void );


int Sys_DLL_Load( const char *dllName );
void * Sys_DLL_GetProcAddress( int dllHandle, const char *procName );
void Sys_DLL_Unload( int dllHandle );


void Sys_GenerateEvents( void );
sysEvent_t Sys_GetEvent( void );
void Sys_ClearEvents( void );



void Sys_InitInput( void );
void Sys_ShutdownInput( void );
void Sys_InitScanTable( void );
const unsigned char *Sys_GetScanTable( void );
unsigned char Sys_GetConsoleKey( bool shifted );



unsigned char Sys_MapCharForKey( int key );


int Sys_PollKeyboardInputEvents( void );
int Sys_ReturnKeyboardInputEvent( const int n, int &ch, bool &state );
void Sys_EndKeyboardInputEvents( void );


int Sys_PollMouseInputEvents( void );
int Sys_ReturnMouseInputEvent( const int n, int &action, int &value );
void Sys_EndMouseInputEvents( void );




void Sys_GrabMouseCursor( bool grabIt );

void Sys_ShowWindow( bool show );
bool Sys_IsWindowVisible( void );
void Sys_ShowConsole( int visLevel, bool quitOnClose );


void Sys_Mkdir( const char *path );
time_t Sys_FileTimeStamp( FILE *fp );

const char * Sys_TimeStampToStr( time_t timeStamp );
const char * Sys_DefaultCDPath( void );
const char * Sys_DefaultBasePath( void );
const char * Sys_DefaultSavePath( void );
const char * Sys_EXEPath( void );



int Sys_ListFiles( const char *directory, const char *extension, idList<class idStr> &list );


void Sys_SetFatalError( const char *error );


void Sys_DoPreferences( void );

void Sys_Printf (char const *fmt, ...);
void Sys_PrintBacktrace(void);
# 445 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sys/sys_public.h"
typedef enum {
 NA_BAD,
 NA_LOOPBACK,
 NA_BROADCAST,
 NA_IP
} netadrtype_t;

typedef struct {
 netadrtype_t type;
 unsigned char ip[4];
 unsigned short port;
} netadr_t;



class idPort {
public:
    idPort();
 virtual ~idPort();


 bool InitForPort( int portNumber );
 int GetPort( void ) const { return bound_to.port; }
 netadr_t GetAdr( void ) const { return bound_to; }
 void Close();

 bool GetPacket( netadr_t &from, void *data, int &size, int maxSize );
 bool GetPacketBlocking( netadr_t &from, void *data, int &size, int maxSize, int timeout );
 void SendPacket( const netadr_t to, const void *data, int size );

 int packetsRead;
 int bytesRead;

 int packetsWritten;
 int bytesWritten;

private:
 netadr_t bound_to;
 int netSocket;
};

class idTCP {
public:
    idTCP();
 virtual ~idTCP();


 bool Init( const char *host, short port );
 void Close();





 int Read( void *data, int size );
 int Write( void *data, int size );

private:
 netadr_t address;
 int fd;
};





bool Sys_StringToNetAdr( const char *s, netadr_t *a, bool doDNSResolve );
const char * Sys_NetAdrToString( const netadr_t a );
bool Sys_IsLANAddress( const netadr_t a );
bool Sys_CompareNetAdrBase( const netadr_t a, const netadr_t b );

void Sys_InitNetworking( void );
void Sys_ShutdownNetworking( void );
# 528 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sys/sys_public.h"
typedef unsigned int (*xthread_t)( void * );

typedef enum {
 THREAD_NORMAL,
 THREAD_ABOVE_NORMAL,
 THREAD_HIGHEST
} xthreadPriority;

typedef struct {
 const char * name;
 int threadHandle;
 unsigned long threadId;
} xthreadInfo;

const int MAX_THREADS = 10;
extern xthreadInfo *g_threads[MAX_THREADS];
extern int g_thread_count;

void Sys_CreateThread( xthread_t function, void *parms, xthreadPriority priority, xthreadInfo &info, const char *name, xthreadInfo *threads[MAX_THREADS], int *thread_count );
void Sys_DestroyThread( xthreadInfo& info );



const char * Sys_GetThreadName( int *index = 0 );

const int MAX_CRITICAL_SECTIONS = 4;

enum {
 CRITICAL_SECTION_ZERO = 0,
 CRITICAL_SECTION_ONE,
 CRITICAL_SECTION_TWO,
 CRITICAL_SECTION_THREE
};

void Sys_EnterCriticalSection( int index = CRITICAL_SECTION_ZERO );
void Sys_LeaveCriticalSection( int index = CRITICAL_SECTION_ZERO );

const int MAX_TRIGGER_EVENTS = 4;

enum {
 TRIGGER_EVENT_ZERO = 0,
 TRIGGER_EVENT_ONE,
 TRIGGER_EVENT_TWO,
 TRIGGER_EVENT_THREE
};

void Sys_WaitForEvent( int index = TRIGGER_EVENT_ZERO );
void Sys_TriggerEvent( int index = TRIGGER_EVENT_ZERO );
# 585 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sys/sys_public.h"
class idSys {
public:
 virtual void DebugPrintf( const char *fmt, ... )__attribute__((format(printf,2,3))) = 0;
 virtual void DebugVPrintf( const char *fmt, va_list arg ) = 0;

 virtual double GetClockTicks( void ) = 0;
 virtual double ClockTicksPerSecond( void ) = 0;
 virtual cpuid_t GetProcessorId( void ) = 0;
 virtual const char * GetProcessorString( void ) = 0;
 virtual const char * FPU_GetState( void ) = 0;
 virtual bool FPU_StackIsEmpty( void ) = 0;
 virtual void FPU_SetFTZ( bool enable ) = 0;
 virtual void FPU_SetDAZ( bool enable ) = 0;

 virtual void FPU_EnableExceptions( int exceptions ) = 0;

 virtual bool LockMemory( void *ptr, int bytes ) = 0;
 virtual bool UnlockMemory( void *ptr, int bytes ) = 0;

 virtual void GetCallStack( address_t *callStack, const int callStackSize ) = 0;
 virtual const char * GetCallStackStr( const address_t *callStack, const int callStackSize ) = 0;
 virtual const char * GetCallStackCurStr( int depth ) = 0;
 virtual void ShutdownSymbols( void ) = 0;

 virtual int DLL_Load( const char *dllName ) = 0;
 virtual void * DLL_GetProcAddress( int dllHandle, const char *procName ) = 0;
 virtual void DLL_Unload( int dllHandle ) = 0;
 virtual void DLL_GetFileName( const char *baseName, char *dllName, int maxLength ) = 0;

 virtual sysEvent_t GenerateMouseButtonEvent( int button, bool down ) = 0;
 virtual sysEvent_t GenerateMouseMoveEvent( int deltax, int deltay ) = 0;

 virtual void OpenURL( const char *url, bool quit ) = 0;
 virtual void StartProcess( const char *exePath, bool quit ) = 0;
};

extern idSys * sys;

bool Sys_LoadOpenAL( void );
void Sys_FreeOpenAL( void );
# 111 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 1
# 50 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h"
class idLib {
public:
 static class idSys * sys;
 static class idCommon * common;
 static class idCVarSystem * cvarSystem;
 static class idFileSystem * fileSystem;
 static int frameNumber;

 static void Init( void );
 static void ShutDown( void );


 static void Error( const char *fmt, ... );
 static void Warning( const char *fmt, ... );
};
# 75 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h"
typedef unsigned char byte;
typedef unsigned short word;
typedef unsigned int dword;
typedef unsigned int uint;
typedef unsigned long ulong;

typedef int qhandle_t;

class idFile;
class idVec3;
class idVec4;
# 103 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h"
extern idVec4 colorBlack;
extern idVec4 colorWhite;
extern idVec4 colorRed;
extern idVec4 colorGreen;
extern idVec4 colorBlue;
extern idVec4 colorYellow;
extern idVec4 colorMagenta;
extern idVec4 colorCyan;
extern idVec4 colorOrange;
extern idVec4 colorPurple;
extern idVec4 colorPink;
extern idVec4 colorBrown;
extern idVec4 colorLtGrey;
extern idVec4 colorMdGrey;
extern idVec4 colorDkGrey;


dword PackColor( const idVec3 &color );
void UnpackColor( const dword color, idVec3 &unpackedColor );
dword PackColor( const idVec4 &color );
void UnpackColor( const dword color, idVec4 &unpackedColor );


short BigShort( short l );
short LittleShort( short l );
int BigLong( int l );
int LittleLong( int l );
float BigFloat( float l );
float LittleFloat( float l );
void BigRevBytes( void *bp, int elsize, int elcount );
void LittleRevBytes( void *bp, int elsize, int elcount );
void LittleBitField( void *bp, int elsize );
void Swap_Init( void );

bool Swap_IsBigEndian( void );


void SixtetsForInt( byte *out, int src);
int IntForSixtets( byte *in );
# 150 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h"
class idException {
public:
 char error[1024];

 idException( const char *text = "" ) { strcpy( error, text ); }
};


template<class T> inline T Max( T x, T y ) { return ( x > y ) ? x : y; }
template<class T> inline T Min( T x, T y ) { return ( x < y ) ? x : y; }
# 170 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h"
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h"
typedef struct {
 int num;
 int minSize;
 int maxSize;
 int totalSize;
} memoryStats_t;

void Mem_Init( void );
void Mem_Shutdown( void );
void Mem_EnableLeakTest( const char *name );
void Mem_ClearFrameStats( void );
void Mem_GetFrameStats( memoryStats_t &allocs, memoryStats_t &frees );
void Mem_GetStats( memoryStats_t &stats );
void Mem_Dump_f( const class idCmdArgs &args );
void Mem_DumpCompressed_f( const class idCmdArgs &args );
void Mem_AllocDefragBlock( void );




void * Mem_Alloc( const int size );
void * Mem_ClearedAlloc( const int size );
void Mem_Free( void *ptr );
char * Mem_CopyString( const char *in );
void * Mem_Alloc16( const int size );
void Mem_Free16( void *ptr );
void * Mem_Alloc32( const int size );
void Mem_Free32( void *ptr );
# 154 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h"
template<class type, int blockSize>
class idBlockAlloc {
public:
       idBlockAlloc( void );
       ~idBlockAlloc( void );

 void Shutdown( void );

 type * Alloc( void );
 void Free( type *element );

 int GetTotalCount( void ) const { return total; }
 int GetAllocCount( void ) const { return active; }
 int GetFreeCount( void ) const { return total - active; }

private:
 typedef struct element_s {
  struct element_s * next;
  type t;
 } element_t;
 typedef struct block_s {
  element_t elements[blockSize];
  struct block_s * next;
 } block_t;

 block_t * blocks;
 element_t * free;
 int total;
 int active;
};

template<class type, int blockSize>
idBlockAlloc<type,blockSize>::idBlockAlloc( void ) {
 blocks = __null;
 free = __null;
 total = active = 0;
}

template<class type, int blockSize>
idBlockAlloc<type,blockSize>::~idBlockAlloc( void ) {
 Shutdown();
}

template<class type, int blockSize>
type *idBlockAlloc<type,blockSize>::Alloc( void ) {
# 215 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h"
 active++;
 element_t *element = new element_t;

 return &element->t;
}

template<class type, int blockSize>
void idBlockAlloc<type,blockSize>::Free( type *t ) {
 element_t *element = (element_t *)( ( (unsigned char *) t ) - ( (int) &((element_t *)0)->t ) );




 delete element;

 active--;

}

template<class type, int blockSize>
void idBlockAlloc<type,blockSize>::Shutdown( void ) {
# 245 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h"
 total = active = 0;
}
# 260 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h"
template<class type, int baseBlockSize, int minBlockSize>
class idDynamicAlloc {
public:
         idDynamicAlloc( void );
         ~idDynamicAlloc( void );

 void Init( void );
 void Shutdown( void );
 void SetFixedBlocks( int numBlocks ) {}
 void SetLockMemory( bool lock ) {}
 void FreeEmptyBaseBlocks( void ) {}

 type * Alloc( const int num );
 type * Resize( type *ptr, const int num );
 void Free( type *ptr );
 const char * CheckMemory( const type *ptr ) const;

 int GetNumBaseBlocks( void ) const { return 0; }
 int GetBaseBlockMemory( void ) const { return 0; }
 int GetNumUsedBlocks( void ) const { return numUsedBlocks; }
 int GetUsedBlockMemory( void ) const { return usedBlockMemory; }
 int GetNumFreeBlocks( void ) const { return 0; }
 int GetFreeBlockMemory( void ) const { return 0; }
 int GetNumEmptyBaseBlocks( void ) const { return 0; }

private:
 int numUsedBlocks;
 int usedBlockMemory;

 int numAllocs;
 int numResizes;
 int numFrees;

 void Clear( void );
};

template<class type, int baseBlockSize, int minBlockSize>
idDynamicAlloc<type, baseBlockSize, minBlockSize>::idDynamicAlloc( void ) {
 Clear();
}

template<class type, int baseBlockSize, int minBlockSize>
idDynamicAlloc<type, baseBlockSize, minBlockSize>::~idDynamicAlloc( void ) {
 Shutdown();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicAlloc<type, baseBlockSize, minBlockSize>::Init( void ) {
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicAlloc<type, baseBlockSize, minBlockSize>::Shutdown( void ) {
 Clear();
}

template<class type, int baseBlockSize, int minBlockSize>
type *idDynamicAlloc<type, baseBlockSize, minBlockSize>::Alloc( const int num ) {
 numAllocs++;
 if ( num <= 0 ) {
  return __null;
 }
 numUsedBlocks++;
 usedBlockMemory += num * sizeof( type );
 return Mem_Alloc16( num * sizeof( type ) );
}

template<class type, int baseBlockSize, int minBlockSize>
type *idDynamicAlloc<type, baseBlockSize, minBlockSize>::Resize( type *ptr, const int num ) {

 numResizes++;

 if ( ptr == __null ) {
  return Alloc( num );
 }

 if ( num <= 0 ) {
  Free( ptr );
  return __null;
 }

 ((void)0);
 return ptr;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicAlloc<type, baseBlockSize, minBlockSize>::Free( type *ptr ) {
 numFrees++;
 if ( ptr == __null ) {
  return;
 }
 Mem_Free16( ptr );
}

template<class type, int baseBlockSize, int minBlockSize>
const char *idDynamicAlloc<type, baseBlockSize, minBlockSize>::CheckMemory( const type *ptr ) const {
 return __null;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicAlloc<type, baseBlockSize, minBlockSize>::Clear( void ) {
 numUsedBlocks = 0;
 usedBlockMemory = 0;
 numAllocs = 0;
 numResizes = 0;
 numFrees = 0;
}
# 379 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h"
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/BTree.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/BTree.h"
template< class objType, class keyType >
class idBTreeNode {
public:
 keyType key;
 objType * object;
 idBTreeNode * parent;
 idBTreeNode * next;
 idBTreeNode * prev;
 int numChildren;
 idBTreeNode * firstChild;
 idBTreeNode * lastChild;
};


template< class objType, class keyType, int maxChildrenPerNode >
class idBTree {
public:
         idBTree( void );
         ~idBTree( void );

 void Init( void );
 void Shutdown( void );

 idBTreeNode<objType,keyType> * Add( objType *object, keyType key );
 void Remove( idBTreeNode<objType,keyType> *node );

 objType * Find( keyType key ) const;
 objType * FindSmallestLargerEqual( keyType key ) const;
 objType * FindLargestSmallerEqual( keyType key ) const;

 idBTreeNode<objType,keyType> * GetRoot( void ) const;
 int GetNodeCount( void ) const;
 idBTreeNode<objType,keyType> * GetNext( idBTreeNode<objType,keyType> *node ) const;
 idBTreeNode<objType,keyType> * GetNextLeaf( idBTreeNode<objType,keyType> *node ) const;

private:
 idBTreeNode<objType,keyType> * root;
 idBlockAlloc<idBTreeNode<objType,keyType>,128> nodeAllocator;

 idBTreeNode<objType,keyType> * AllocNode( void );
 void FreeNode( idBTreeNode<objType,keyType> *node );
 void SplitNode( idBTreeNode<objType,keyType> *node );
 idBTreeNode<objType,keyType> * MergeNodes( idBTreeNode<objType,keyType> *node1, idBTreeNode<objType,keyType> *node2 );

 void CheckTree_r( idBTreeNode<objType,keyType> *node, int &numNodes ) const;
 void CheckTree( void ) const;
};


template< class objType, class keyType, int maxChildrenPerNode >
inline idBTree<objType,keyType,maxChildrenPerNode>::idBTree( void ) {
 ((void)0);
 root = __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTree<objType,keyType,maxChildrenPerNode>::~idBTree( void ) {
 Shutdown();
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::Init( void ) {
 root = AllocNode();
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::Shutdown( void ) {
 nodeAllocator.Shutdown();
 root = __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::Add( objType *object, keyType key ) {
 idBTreeNode<objType,keyType> *node, *child, *newNode;

 if ( root->numChildren >= maxChildrenPerNode ) {
  newNode = AllocNode();
  newNode->key = root->key;
  newNode->firstChild = root;
  newNode->lastChild = root;
  newNode->numChildren = 1;
  root->parent = newNode;
  SplitNode( root );
  root = newNode;
 }

 newNode = AllocNode();
 newNode->key = key;
 newNode->object = object;

 for ( node = root; node->firstChild != __null; node = child ) {

  if ( key > node->key ) {
   node->key = key;
  }


  for( child = node->firstChild; child->next; child = child->next ) {
   if ( key <= child->key ) {
    break;
   }
  }

  if ( child->object ) {

   if ( key <= child->key ) {

    if ( child->prev ) {
     child->prev->next = newNode;
    } else {
     node->firstChild = newNode;
    }
    newNode->prev = child->prev;
    newNode->next = child;
    child->prev = newNode;
   } else {

    if ( child->next ) {
     child->next->prev = newNode;
    } else {
     node->lastChild = newNode;
    }
    newNode->prev = child;
    newNode->next = child->next;
    child->next = newNode;
   }

   newNode->parent = node;
   node->numChildren++;





   return newNode;
  }


  if ( child->numChildren >= maxChildrenPerNode ) {
   SplitNode( child );
   if ( key <= child->prev->key ) {
    child = child->prev;
   }
  }
 }


 newNode->parent = root;
 root->key = key;
 root->firstChild = newNode;
 root->lastChild = newNode;
 root->numChildren++;





 return newNode;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::Remove( idBTreeNode<objType,keyType> *node ) {
 idBTreeNode<objType,keyType> *parent;

 ((void)0);


 if ( node->prev ) {
  node->prev->next = node->next;
 } else {
  node->parent->firstChild = node->next;
 }
 if ( node->next ) {
  node->next->prev = node->prev;
 } else {
  node->parent->lastChild = node->prev;
 }
 node->parent->numChildren--;


 for ( parent = node->parent; parent != root && parent->numChildren <= 1; parent = parent->parent ) {

  if ( parent->next ) {
   parent = MergeNodes( parent, parent->next );
  } else if ( parent->prev ) {
   parent = MergeNodes( parent->prev, parent );
  }


  if ( parent->key > parent->lastChild->key ) {
   parent->key = parent->lastChild->key;
  }

  if ( parent->numChildren > maxChildrenPerNode ) {
   SplitNode( parent );
   break;
  }
 }
 for ( ; parent != __null && parent->lastChild != __null; parent = parent->parent ) {

  if ( parent->key > parent->lastChild->key ) {
   parent->key = parent->lastChild->key;
  }
 }


 FreeNode( node );


 if ( root->numChildren == 1 && root->firstChild->object == __null ) {
  idBTreeNode<objType,keyType> *oldRoot = root;
  root->firstChild->parent = __null;
  root = root->firstChild;
  FreeNode( oldRoot );
 }




}

template< class objType, class keyType, int maxChildrenPerNode >
inline objType *idBTree<objType,keyType,maxChildrenPerNode>::Find( keyType key ) const {
 idBTreeNode<objType,keyType> *node;

 for ( node = root->firstChild; node != __null; node = node->firstChild ) {
  while( node->next ) {
   if ( node->key >= key ) {
    break;
   }
   node = node->next;
  }
  if ( node->object ) {
   if ( node->key == key ) {
    return node->object;
   } else {
    return __null;
   }
  }
 }
 return __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline objType *idBTree<objType,keyType,maxChildrenPerNode>::FindSmallestLargerEqual( keyType key ) const {
 idBTreeNode<objType,keyType> *node;

 for ( node = root->firstChild; node != __null; node = node->firstChild ) {
  while( node->next ) {
   if ( node->key >= key ) {
    break;
   }
   node = node->next;
  }
  if ( node->object ) {
   if ( node->key >= key ) {
    return node->object;
   } else {
    return __null;
   }
  }
 }
 return __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline objType *idBTree<objType,keyType,maxChildrenPerNode>::FindLargestSmallerEqual( keyType key ) const {
 idBTreeNode<objType,keyType> *node;

 for ( node = root->lastChild; node != __null; node = node->lastChild ) {
  while( node->prev ) {
   if ( node->key <= key ) {
    break;
   }
   node = node->prev;
  }
  if ( node->object ) {
   if ( node->key <= key ) {
    return node->object;
   } else {
    return __null;
   }
  }
 }
 return __null;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::GetRoot( void ) const {
 return root;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline int idBTree<objType,keyType,maxChildrenPerNode>::GetNodeCount( void ) const {
 return nodeAllocator.GetAllocCount();
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::GetNext( idBTreeNode<objType,keyType> *node ) const {
 if ( node->firstChild ) {
  return node->firstChild;
 } else {
  while( node && node->next == __null ) {
   node = node->parent;
  }
  return node;
 }
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::GetNextLeaf( idBTreeNode<objType,keyType> *node ) const {
 if ( node->firstChild ) {
  while ( node->firstChild ) {
   node = node->firstChild;
  }
  return node;
 } else {
  while( node && node->next == __null ) {
   node = node->parent;
  }
  if ( node ) {
   node = node->next;
   while ( node->firstChild ) {
    node = node->firstChild;
   }
   return node;
  } else {
   return __null;
  }
 }
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::AllocNode( void ) {
 idBTreeNode<objType,keyType> *node = nodeAllocator.Alloc();
 node->key = 0;
 node->parent = __null;
 node->next = __null;
 node->prev = __null;
 node->numChildren = 0;
 node->firstChild = __null;
 node->lastChild = __null;
 node->object = __null;
 return node;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::FreeNode( idBTreeNode<objType,keyType> *node ) {
 nodeAllocator.Free( node );
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::SplitNode( idBTreeNode<objType,keyType> *node ) {
 int i;
 idBTreeNode<objType,keyType> *child, *newNode;


 newNode = AllocNode();
 newNode->parent = node->parent;


 child = node->firstChild;
 child->parent = newNode;
 for ( i = 3; i < node->numChildren; i += 2 ) {
  child = child->next;
  child->parent = newNode;
 }

 newNode->key = child->key;
 newNode->numChildren = node->numChildren / 2;
 newNode->firstChild = node->firstChild;
 newNode->lastChild = child;

 node->numChildren -= newNode->numChildren;
 node->firstChild = child->next;

 child->next->prev = __null;
 child->next = __null;


 ((void)0);

 if ( node->prev ) {
  node->prev->next = newNode;
 } else {
  node->parent->firstChild = newNode;
 }
 newNode->prev = node->prev;
 newNode->next = node;
 node->prev = newNode;

 node->parent->numChildren++;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline idBTreeNode<objType,keyType> *idBTree<objType,keyType,maxChildrenPerNode>::MergeNodes( idBTreeNode<objType,keyType> *node1, idBTreeNode<objType,keyType> *node2 ) {
 idBTreeNode<objType,keyType> *child;

 ((void)0);
 ((void)0);
 ((void)0);
 ((void)0);

 for ( child = node1->firstChild; child->next; child = child->next ) {
  child->parent = node2;
 }
 child->parent = node2;
 child->next = node2->firstChild;
 node2->firstChild->prev = child;
 node2->firstChild = node1->firstChild;
 node2->numChildren += node1->numChildren;


 if ( node1->prev ) {
  node1->prev->next = node2;
 } else {
  node1->parent->firstChild = node2;
 }
 node2->prev = node1->prev;
 node2->parent->numChildren--;

 FreeNode( node1 );

 return node2;
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::CheckTree_r( idBTreeNode<objType,keyType> *node, int &numNodes ) const {
 int numChildren;
 idBTreeNode<objType,keyType> *child;

 numNodes++;


 ((void)0);

 ((void)0);

 numChildren = 0;
 for ( child = node->firstChild; child; child = child->next ) {
  numChildren++;

  if ( child->prev == __null ) {
   ((void)0);
  } else {
   ((void)0);
  }
  if ( child->next == __null ) {
   ((void)0);
  } else {
   ((void)0);
  }

  CheckTree_r( child, numNodes );
 }

 ((void)0);
}

template< class objType, class keyType, int maxChildrenPerNode >
inline void idBTree<objType,keyType,maxChildrenPerNode>::CheckTree( void ) const {
 int numNodes = 0;
 idBTreeNode<objType,keyType> *node, *lastNode;

 CheckTree_r( root, numNodes );


 ((void)0);


 lastNode = GetNextLeaf( GetRoot() );
 if ( lastNode ) {
  for ( node = GetNextLeaf( lastNode ); node; lastNode = node, node = GetNextLeaf( node ) ) {
   ((void)0);
  }
 }
}
# 380 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h" 2



template<class type>
class idDynamicBlock {
public:
 type * GetMemory( void ) const { return (type *)( ( (byte *) this ) + sizeof( idDynamicBlock<type> ) ); }
 int GetSize( void ) const { return abs( size ); }
 void SetSize( int s, bool isBaseBlock ) { size = isBaseBlock ? -s : s; }
 bool IsBaseBlock( void ) const { return ( size < 0 ); }






 int size;
 idDynamicBlock<type> * prev;
 idDynamicBlock<type> * next;
 idBTreeNode<idDynamicBlock<type>,int> *node;
};

template<class type, int baseBlockSize, int minBlockSize>
class idDynamicBlockAlloc {
public:
         idDynamicBlockAlloc( void );
         ~idDynamicBlockAlloc( void );

 void Init( void );
 void Shutdown( void );
 void SetFixedBlocks( int numBlocks );
 void SetLockMemory( bool lock );
 void FreeEmptyBaseBlocks( void );

 type * Alloc( const int num );
 type * Resize( type *ptr, const int num );
 void Free( type *ptr );
 const char * CheckMemory( const type *ptr ) const;

 int GetNumBaseBlocks( void ) const { return numBaseBlocks; }
 int GetBaseBlockMemory( void ) const { return baseBlockMemory; }
 int GetNumUsedBlocks( void ) const { return numUsedBlocks; }
 int GetUsedBlockMemory( void ) const { return usedBlockMemory; }
 int GetNumFreeBlocks( void ) const { return numFreeBlocks; }
 int GetFreeBlockMemory( void ) const { return freeBlockMemory; }
 int GetNumEmptyBaseBlocks( void ) const;

private:
 idDynamicBlock<type> * firstBlock;
 idDynamicBlock<type> * lastBlock;
 idBTree<idDynamicBlock<type>,int,4>freeTree;
 bool allowAllocs;
 bool lockMemory;





 int numBaseBlocks;
 int baseBlockMemory;
 int numUsedBlocks;
 int usedBlockMemory;
 int numFreeBlocks;
 int freeBlockMemory;

 int numAllocs;
 int numResizes;
 int numFrees;

 void Clear( void );
 idDynamicBlock<type> * AllocInternal( const int num );
 idDynamicBlock<type> * ResizeInternal( idDynamicBlock<type> *block, const int num );
 void FreeInternal( idDynamicBlock<type> *block );
 void LinkFreeInternal( idDynamicBlock<type> *block );
 void UnlinkFreeInternal( idDynamicBlock<type> *block );
 void CheckMemory( void ) const;
};

template<class type, int baseBlockSize, int minBlockSize>
idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::idDynamicBlockAlloc( void ) {
 Clear();
}

template<class type, int baseBlockSize, int minBlockSize>
idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::~idDynamicBlockAlloc( void ) {
 Shutdown();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Init( void ) {
 freeTree.Init();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Shutdown( void ) {
 idDynamicBlock<type> *block;

 for ( block = firstBlock; block != __null; block = block->next ) {
  if ( block->node == __null ) {
   FreeInternal( block );
  }
 }

 for ( block = firstBlock; block != __null; block = firstBlock ) {
  firstBlock = block->next;
  ((void)0);
  if ( lockMemory ) {
   idLib::sys->UnlockMemory( block, block->GetSize() + (int)sizeof( idDynamicBlock<type> ) );
  }
  Mem_Free16( block );
 }

 freeTree.Shutdown();

 Clear();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::SetFixedBlocks( int numBlocks ) {
 idDynamicBlock<type> *block;

 for ( int i = numBaseBlocks; i < numBlocks; i++ ) {
  block = ( idDynamicBlock<type> * ) Mem_Alloc16( baseBlockSize );
  if ( lockMemory ) {
   idLib::sys->LockMemory( block, baseBlockSize );
  }




  block->SetSize( baseBlockSize - (int)sizeof( idDynamicBlock<type> ), true );
  block->next = __null;
  block->prev = lastBlock;
  if ( lastBlock ) {
   lastBlock->next = block;
  } else {
   firstBlock = block;
  }
  lastBlock = block;
  block->node = __null;

  FreeInternal( block );

  numBaseBlocks++;
  baseBlockMemory += baseBlockSize;
 }

 allowAllocs = false;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::SetLockMemory( bool lock ) {
 lockMemory = lock;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::FreeEmptyBaseBlocks( void ) {
 idDynamicBlock<type> *block, *next;

 for ( block = firstBlock; block != __null; block = next ) {
  next = block->next;

  if ( block->IsBaseBlock() && block->node != __null && ( next == __null || next->IsBaseBlock() ) ) {
   UnlinkFreeInternal( block );
   if ( block->prev ) {
    block->prev->next = block->next;
   } else {
    firstBlock = block->next;
   }
   if ( block->next ) {
    block->next->prev = block->prev;
   } else {
    lastBlock = block->prev;
   }
   if ( lockMemory ) {
    idLib::sys->UnlockMemory( block, block->GetSize() + (int)sizeof( idDynamicBlock<type> ) );
   }
   numBaseBlocks--;
   baseBlockMemory -= block->GetSize() + (int)sizeof( idDynamicBlock<type> );
   Mem_Free16( block );
  }
 }




}

template<class type, int baseBlockSize, int minBlockSize>
int idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::GetNumEmptyBaseBlocks( void ) const {
 int numEmptyBaseBlocks;
 idDynamicBlock<type> *block;

 numEmptyBaseBlocks = 0;
 for ( block = firstBlock; block != __null; block = block->next ) {
  if ( block->IsBaseBlock() && block->node != __null && ( block->next == __null || block->next->IsBaseBlock() ) ) {
   numEmptyBaseBlocks++;
  }
 }
 return numEmptyBaseBlocks;
}

template<class type, int baseBlockSize, int minBlockSize>
type *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Alloc( const int num ) {
 idDynamicBlock<type> *block;

 numAllocs++;

 if ( num <= 0 ) {
  return __null;
 }

 block = AllocInternal( num );
 if ( block == __null ) {
  return __null;
 }
 block = ResizeInternal( block, num );
 if ( block == __null ) {
  return __null;
 }





 numUsedBlocks++;
 usedBlockMemory += block->GetSize();

 return block->GetMemory();
}

template<class type, int baseBlockSize, int minBlockSize>
type *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Resize( type *ptr, const int num ) {

 numResizes++;

 if ( ptr == __null ) {
  return Alloc( num );
 }

 if ( num <= 0 ) {
  Free( ptr );
  return __null;
 }

 idDynamicBlock<type> *block = ( idDynamicBlock<type> * ) ( ( (byte *) ptr ) - (int)sizeof( idDynamicBlock<type> ) );

 usedBlockMemory -= block->GetSize();

 block = ResizeInternal( block, num );
 if ( block == __null ) {
  return __null;
 }





 usedBlockMemory += block->GetSize();

 return block->GetMemory();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Free( type *ptr ) {

 numFrees++;

 if ( ptr == __null ) {
  return;
 }

 idDynamicBlock<type> *block = ( idDynamicBlock<type> * ) ( ( (byte *) ptr ) - (int)sizeof( idDynamicBlock<type> ) );

 numUsedBlocks--;
 usedBlockMemory -= block->GetSize();

 FreeInternal( block );




}

template<class type, int baseBlockSize, int minBlockSize>
const char *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::CheckMemory( const type *ptr ) const {
 idDynamicBlock<type> *block;

 if ( ptr == __null ) {
  return __null;
 }

 block = ( idDynamicBlock<type> * ) ( ( (byte *) ptr ) - (int)sizeof( idDynamicBlock<type> ) );

 if ( block->node != __null ) {
  return "memory has been freed";
 }
# 701 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Heap.h"
 return __null;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::Clear( void ) {
 firstBlock = lastBlock = __null;
 allowAllocs = true;
 lockMemory = false;
 numBaseBlocks = 0;
 baseBlockMemory = 0;
 numUsedBlocks = 0;
 usedBlockMemory = 0;
 numFreeBlocks = 0;
 freeBlockMemory = 0;
 numAllocs = 0;
 numResizes = 0;
 numFrees = 0;






}

template<class type, int baseBlockSize, int minBlockSize>
idDynamicBlock<type> *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::AllocInternal( const int num ) {
 idDynamicBlock<type> *block;
 int alignedBytes = ( num * sizeof( type ) + 15 ) & ~15;

 block = freeTree.FindSmallestLargerEqual( alignedBytes );
 if ( block != __null ) {
  UnlinkFreeInternal( block );
 } else if ( allowAllocs ) {
  int allocSize = Max( baseBlockSize, alignedBytes + (int)sizeof( idDynamicBlock<type> ) );
Sys_Printf(">>> Alloc size: %d\r\n", allocSize);
  block = ( idDynamicBlock<type> * ) Mem_Alloc16( allocSize );
if (!block) {
 Sys_Error(">>> ::AllocInternal FAIL FOR ALLOCSIZE %d\r\n", allocSize);
}
  if ( lockMemory ) {
   idLib::sys->LockMemory( block, baseBlockSize );
  }




  block->SetSize( allocSize - (int)sizeof( idDynamicBlock<type> ), true );
  block->next = __null;
  block->prev = lastBlock;
  if ( lastBlock ) {
   lastBlock->next = block;
  } else {
   firstBlock = block;
  }
  lastBlock = block;
  block->node = __null;

  numBaseBlocks++;
  baseBlockMemory += allocSize;
 }

 return block;
}

template<class type, int baseBlockSize, int minBlockSize>
idDynamicBlock<type> *idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::ResizeInternal( idDynamicBlock<type> *block, const int num ) {
 int alignedBytes = ( num * sizeof( type ) + 15 ) & ~15;






 if ( alignedBytes > block->GetSize() ) {

  idDynamicBlock<type> *nextBlock = block->next;


  if ( nextBlock && !nextBlock->IsBaseBlock() && nextBlock->node != __null &&
    block->GetSize() + (int)sizeof( idDynamicBlock<type> ) + nextBlock->GetSize() >= alignedBytes ) {

   UnlinkFreeInternal( nextBlock );
   block->SetSize( block->GetSize() + (int)sizeof( idDynamicBlock<type> ) + nextBlock->GetSize(), block->IsBaseBlock() );
   block->next = nextBlock->next;
   if ( nextBlock->next ) {
    nextBlock->next->prev = block;
   } else {
    lastBlock = block;
   }
  } else {

   idDynamicBlock<type> *oldBlock = block;
   block = AllocInternal( num );
   if ( block == __null ) {
    return __null;
   }
   memcpy( block->GetMemory(), oldBlock->GetMemory(), oldBlock->GetSize() );
   FreeInternal( oldBlock );
  }
 }


 if ( block->GetSize() - alignedBytes - (int)sizeof( idDynamicBlock<type> ) < Max( minBlockSize, (int)sizeof( type ) ) ) {
  return block;
 }

 idDynamicBlock<type> *newBlock;

 newBlock = ( idDynamicBlock<type> * ) ( ( (byte *) block ) + (int)sizeof( idDynamicBlock<type> ) + alignedBytes );




 newBlock->SetSize( block->GetSize() - alignedBytes - (int)sizeof( idDynamicBlock<type> ), false );
 newBlock->next = block->next;
 newBlock->prev = block;
 if ( newBlock->next ) {
  newBlock->next->prev = newBlock;
 } else {
  lastBlock = newBlock;
 }
 newBlock->node = __null;
 block->next = newBlock;
 block->SetSize( alignedBytes, block->IsBaseBlock() );

 FreeInternal( newBlock );

 return block;
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::FreeInternal( idDynamicBlock<type> *block ) {

 ((void)0);






 idDynamicBlock<type> *nextBlock = block->next;
 if ( nextBlock && !nextBlock->IsBaseBlock() && nextBlock->node != __null ) {
  UnlinkFreeInternal( nextBlock );
  block->SetSize( block->GetSize() + (int)sizeof( idDynamicBlock<type> ) + nextBlock->GetSize(), block->IsBaseBlock() );
  block->next = nextBlock->next;
  if ( nextBlock->next ) {
   nextBlock->next->prev = block;
  } else {
   lastBlock = block;
  }
 }


 idDynamicBlock<type> *prevBlock = block->prev;
 if ( prevBlock && !block->IsBaseBlock() && prevBlock->node != __null ) {
  UnlinkFreeInternal( prevBlock );
  prevBlock->SetSize( prevBlock->GetSize() + (int)sizeof( idDynamicBlock<type> ) + block->GetSize(), prevBlock->IsBaseBlock() );
  prevBlock->next = block->next;
  if ( block->next ) {
   block->next->prev = prevBlock;
  } else {
   lastBlock = prevBlock;
  }
  LinkFreeInternal( prevBlock );
 } else {
  LinkFreeInternal( block );
 }
}

template<class type, int baseBlockSize, int minBlockSize>
inline void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::LinkFreeInternal( idDynamicBlock<type> *block ) {
 block->node = freeTree.Add( block, block->GetSize() );
 numFreeBlocks++;
 freeBlockMemory += block->GetSize();
}

template<class type, int baseBlockSize, int minBlockSize>
inline void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::UnlinkFreeInternal( idDynamicBlock<type> *block ) {
 freeTree.Remove( block->node );
 block->node = __null;
 numFreeBlocks--;
 freeBlockMemory -= block->GetSize();
}

template<class type, int baseBlockSize, int minBlockSize>
void idDynamicBlockAlloc<type, baseBlockSize, minBlockSize>::CheckMemory( void ) const {
 idDynamicBlock<type> *block;

 for ( block = firstBlock; block != __null; block = block->next ) {

  if ( block->prev == __null ) {
   ((void)0);
  } else {
   ((void)0);
  }
  if ( block->next == __null ) {
   ((void)0);
  } else {
   ((void)0);
  }
 }
}
# 171 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
typedef struct myTestNode_s {
 int symbol;
 int frequency;
 struct myTestNode_s * next;
 struct myTestNode_s * children[2];
} myTestNode_t;
# 63 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idListSortCompare( const type *a, const type *b ) {
 return *a - *b;
}







template< class type >
inline type *idListNewElement( void ) {
 return new type;
}






template< class type >
inline void idSwap( type &a, type &b ) {
 type c = a;
 a = b;
 b = c;
}

template< class type >
class idList {
public:

 typedef int cmp_t( const type *, const type * );
 typedef type new_t( void );

     idList( int newgranularity = 16 );
     idList( const idList<type> &other );
     ~idList<type>( void );

 void Clear( void );
 int Num( void ) const;
 int NumAllocated( void ) const;
 void SetGranularity( int newgranularity );
 int GetGranularity( void ) const;

 size_t Allocated( void ) const;
 size_t Size( void ) const;
 size_t MemoryUsed( void ) const;

 idList<type> & operator=( const idList<type> &other );
 const type & operator[]( int index ) const;
 type & operator[]( int index );

 void Condense( void );
 void Resize( int newsize );
 void Resize( int newsize, int newgranularity );
 void SetNum( int newnum, bool resize = true );
 void AssureSize( int newSize);
 void AssureSize( int newSize, const type &initValue );
 void AssureSizeAlloc( int newSize, new_t *allocator );

 type * Ptr( void );
 const type * Ptr( void ) const;
 type & Alloc( void );
 int Append( const type & obj );
 int Append( const idList<type> &other );
 int AddUnique( const type & obj );
 int Insert( const type & obj, int index = 0 );
 int FindIndex( const type & obj ) const;
 type * Find( type const & obj ) const;
 int FindNull( void ) const;
 int IndexOf( const type *obj ) const;
 bool RemoveIndex( int index );
 bool Remove( const type & obj );
 void Sort( cmp_t *compare = ( cmp_t * )&idListSortCompare<type> );
 void SortSubSection( int startIndex, int endIndex, cmp_t *compare = ( cmp_t * )&idListSortCompare<type> );
 void Swap( idList<type> &other );
 void DeleteContents( bool clear );

private:
 int num;
 int size;
 int granularity;
 type * list;
};






template< class type >
inline idList<type>::idList( int newgranularity ) {
 ((void)0);

 list = __null;
 granularity = newgranularity;
 Clear();
}






template< class type >
inline idList<type>::idList( const idList<type> &other ) {
 list = __null;
 *this = other;
}






template< class type >
inline idList<type>::~idList( void ) {
 Clear();
}
# 191 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Clear( void ) {
 if ( list ) {
  delete[] list;
 }

 list = __null;
 num = 0;
 size = 0;
}
# 214 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::DeleteContents( bool clear ) {
 int i;

 for( i = 0; i < num; i++ ) {
  delete list[ i ];
  list[ i ] = __null;
 }

 if ( clear ) {
  Clear();
 } else {
  memset( list, 0, size * sizeof( type ) );
 }
}
# 237 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline size_t idList<type>::Allocated( void ) const {
 return size * sizeof( type );
}
# 249 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline size_t idList<type>::Size( void ) const {
 return sizeof( idList<type> ) + Allocated();
}






template< class type >
inline size_t idList<type>::MemoryUsed( void ) const {
 return num * sizeof( *list );
}
# 272 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::Num( void ) const {
 return num;
}
# 284 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::NumAllocated( void ) const {
 return size;
}
# 296 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::SetNum( int newnum, bool resize ) {
 ((void)0);
 if ( resize || newnum > size ) {
  Resize( newnum );
 }
 num = newnum;
}
# 312 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::SetGranularity( int newgranularity ) {
 int newsize;

 ((void)0);
 granularity = newgranularity;

 if ( list ) {

  newsize = num + granularity - 1;
  newsize -= newsize % granularity;
  if ( newsize != size ) {
   Resize( newsize );
  }
 }
}
# 336 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::GetGranularity( void ) const {
 return granularity;
}
# 348 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Condense( void ) {
 if ( list ) {
  if ( num ) {
   Resize( num );
  } else {
   Clear();
  }
 }
}
# 367 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Resize( int newsize ) {
 type *temp;
 int i;

 ((void)0);


 if ( newsize <= 0 ) {
  Clear();
  return;
 }

 if ( newsize == size ) {

  return;
 }

 temp = list;
 size = newsize;
 if ( size < num ) {
  num = size;
 }


 list = new type[ size ];
 for( i = 0; i < num; i++ ) {
  list[ i ] = temp[ i ];
 }


 if ( temp ) {
  delete[] temp;
 }
}
# 411 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Resize( int newsize, int newgranularity ) {
 type *temp;
 int i;

 ((void)0);

 ((void)0);
 granularity = newgranularity;


 if ( newsize <= 0 ) {
  Clear();
  return;
 }

 temp = list;
 size = newsize;
 if ( size < num ) {
  num = size;
 }


 list = new type[ size ];
 for( i = 0; i < num; i++ ) {
  list[ i ] = temp[ i ];
 }


 if ( temp ) {
  delete[] temp;
 }
}
# 452 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::AssureSize( int newSize ) {
 int newNum = newSize;

 if ( newSize > size ) {

  if ( granularity == 0 ) {
   granularity = 16;
  }

  newSize += granularity - 1;
  newSize -= newSize % granularity;
  Resize( newSize );
 }

 num = newNum;
}
# 477 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::AssureSize( int newSize, const type &initValue ) {
 int newNum = newSize;

 if ( newSize > size ) {

  if ( granularity == 0 ) {
   granularity = 16;
  }

  newSize += granularity - 1;
  newSize -= newSize % granularity;
  num = size;
  Resize( newSize );

  for ( int i = num; i < newSize; i++ ) {
   list[i] = initValue;
  }
 }

 num = newNum;
}
# 510 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::AssureSizeAlloc( int newSize, new_t *allocator ) {
 int newNum = newSize;

 if ( newSize > size ) {

  if ( granularity == 0 ) {
   granularity = 16;
  }

  newSize += granularity - 1;
  newSize -= newSize % granularity;
  num = size;
  Resize( newSize );

  for ( int i = num; i < newSize; i++ ) {
   list[i] = (*allocator)();
  }
 }

 num = newNum;
}
# 540 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline idList<type> &idList<type>::operator=( const idList<type> &other ) {
 int i;

 Clear();

 num = other.num;
 size = other.size;
 granularity = other.granularity;

 if ( size ) {
  list = new type[ size ];
  for( i = 0; i < num; i++ ) {
   list[ i ] = other.list[ i ];
  }
 }

 return *this;
}
# 568 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline const type &idList<type>::operator[]( int index ) const {
 ((void)0);
 ((void)0);

 return list[ index ];
}
# 584 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline type &idList<type>::operator[]( int index ) {
 ((void)0);
 ((void)0);

 return list[ index ];
}
# 603 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline type *idList<type>::Ptr( void ) {
 return list;
}
# 619 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
const inline type *idList<type>::Ptr( void ) const {
 return list;
}
# 631 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline type &idList<type>::Alloc( void ) {
 if ( !list ) {
  Resize( granularity );
 }

 if ( num == size ) {
  Resize( size + granularity );
 }

 return list[ num++ ];
}
# 653 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::Append( type const & obj ) {
 if ( !list ) {
  Resize( granularity );
 }

 if ( num == size ) {
  int newsize;

  if ( granularity == 0 ) {
   granularity = 16;
  }
  newsize = size + granularity;
  Resize( newsize - newsize % granularity );
 }

 list[ num ] = obj;
 num++;

 return num - 1;
}
# 686 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::Insert( type const & obj, int index ) {
 if ( !list ) {
  Resize( granularity );
 }

 if ( num == size ) {
  int newsize;

  if ( granularity == 0 ) {
   granularity = 16;
  }
  newsize = size + granularity;
  Resize( newsize - newsize % granularity );
 }

 if ( index < 0 ) {
  index = 0;
 }
 else if ( index > num ) {
  index = num;
 }
 for ( int i = num; i > index; --i ) {
  list[i] = list[i-1];
 }
 num++;
 list[index] = obj;
 return index;
}
# 725 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::Append( const idList<type> &other ) {
 if ( !list ) {
  if ( granularity == 0 ) {
   granularity = 16;
  }
  Resize( granularity );
 }

 int n = other.Num();
 for (int i = 0; i < n; i++) {
  Append(other[i]);
 }

 return Num();
}
# 749 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::AddUnique( type const & obj ) {
 int index;

 index = FindIndex( obj );
 if ( index < 0 ) {
  index = Append( obj );
 }

 return index;
}
# 768 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::FindIndex( type const & obj ) const {
 int i;

 for( i = 0; i < num; i++ ) {
  if ( list[ i ] == obj ) {
   return i;
  }
 }


 return -1;
}
# 789 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline type *idList<type>::Find( type const & obj ) const {
 int i;

 i = FindIndex( obj );
 if ( i >= 0 ) {
  return &list[ i ];
 }

 return __null;
}
# 811 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::FindNull( void ) const {
 int i;

 for( i = 0; i < num; i++ ) {
  if ( list[ i ] == __null ) {
   return i;
  }
 }


 return -1;
}
# 835 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline int idList<type>::IndexOf( type const *objptr ) const {
 int index;

 index = objptr - list;

 ((void)0);
 ((void)0);

 return index;
}
# 856 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline bool idList<type>::RemoveIndex( int index ) {
 int i;

 ((void)0);
 ((void)0);
 ((void)0);

 if ( ( index < 0 ) || ( index >= num ) ) {
  return false;
 }

 num--;
 for( i = index; i < num; i++ ) {
  list[ i ] = list[ i + 1 ];
 }

 return true;
}
# 885 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline bool idList<type>::Remove( type const & obj ) {
 int index;

 index = FindIndex( obj );
 if ( index >= 0 ) {
  return RemoveIndex( index );
 }

 return false;
}
# 905 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Sort( cmp_t *compare ) {
 if ( !list ) {
  return;
 }
 typedef int cmp_c(const void *, const void *);

 cmp_c *vCompare = (cmp_c *)compare;
 qsort( ( void * )list, ( size_t )num, sizeof( type ), vCompare );
}
# 923 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::SortSubSection( int startIndex, int endIndex, cmp_t *compare ) {
 if ( !list ) {
  return;
 }
 if ( startIndex < 0 ) {
  startIndex = 0;
 }
 if ( endIndex >= num ) {
  endIndex = num - 1;
 }
 if ( startIndex >= endIndex ) {
  return;
 }
 typedef int cmp_c(const void *, const void *);

 cmp_c *vCompare = (cmp_c *)compare;
 qsort( ( void * )( &list[startIndex] ), ( size_t )( endIndex - startIndex + 1 ), sizeof( type ), vCompare );
}
# 950 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/List.h"
template< class type >
inline void idList<type>::Swap( idList<type> &other ) {
 idSwap( num, other.num );
 idSwap( size, other.size );
 idSwap( granularity, other.granularity );
 idSwap( list, other.list );
}
# 172 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Simd.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Simd.h"
class idSIMD {
public:
 static void Init( void );
 static void InitProcessor( const char *module, bool forceGeneric );
 static void Shutdown( void );
 static void Test_f( const class idCmdArgs &args );
};
# 66 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Simd.h"
class idVec2;
class idVec3;
class idVec4;
class idVec5;
class idVec6;
class idVecX;
class idMat2;
class idMat3;
class idMat4;
class idMat5;
class idMat6;
class idMatX;
class idPlane;
class idDrawVert;
class idJointQuat;
class idJointMat;
struct dominantTri_s;

const int MIXBUFFER_SAMPLES = 4096;

typedef enum {
 SPEAKER_LEFT = 0,
 SPEAKER_RIGHT,
 SPEAKER_CENTER,
 SPEAKER_LFE,
 SPEAKER_BACKLEFT,
 SPEAKER_BACKRIGHT
} speakerLabel;


class idSIMDProcessor {
public:
         idSIMDProcessor( void ) { cpuid = CPUID_NONE; }

 cpuid_t cpuid;

 virtual const char * GetName( void ) const = 0;

 virtual void Add( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void Add( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void Sub( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void Sub( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void Mul( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void Mul( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void Div( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void Div( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void MulAdd( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void MulAdd( float *dst, const float *src0, const float *src1, const int count ) = 0;
 virtual void MulSub( float *dst, const float constant, const float *src, const int count ) = 0;
 virtual void MulSub( float *dst, const float *src0, const float *src1, const int count ) = 0;

 virtual void Dot( float *dst, const idVec3 &constant, const idVec3 *src, const int count ) = 0;
 virtual void Dot( float *dst, const idVec3 &constant, const idPlane *src, const int count ) = 0;
 virtual void Dot( float *dst, const idVec3 &constant, const idDrawVert *src, const int count ) = 0;
 virtual void Dot( float *dst, const idPlane &constant,const idVec3 *src, const int count ) = 0;
 virtual void Dot( float *dst, const idPlane &constant,const idPlane *src, const int count ) = 0;
 virtual void Dot( float *dst, const idPlane &constant,const idDrawVert *src, const int count ) = 0;
 virtual void Dot( float *dst, const idVec3 *src0, const idVec3 *src1, const int count ) = 0;
 virtual void Dot( float &dot, const float *src1, const float *src2, const int count ) = 0;

 virtual void CmpGT( byte *dst, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpGT( byte *dst, const byte bitNum, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpGE( byte *dst, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpGE( byte *dst, const byte bitNum, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpLT( byte *dst, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpLT( byte *dst, const byte bitNum, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpLE( byte *dst, const float *src0, const float constant, const int count ) = 0;
 virtual void CmpLE( byte *dst, const byte bitNum, const float *src0, const float constant, const int count ) = 0;

 virtual void MinMax( float &min, float &max, const float *src, const int count ) = 0;
 virtual void MinMax( idVec2 &min, idVec2 &max, const idVec2 *src, const int count ) = 0;
 virtual void MinMax( idVec3 &min, idVec3 &max, const idVec3 *src, const int count ) = 0;
 virtual void MinMax( idVec3 &min, idVec3 &max, const idDrawVert *src, const int count ) = 0;
 virtual void MinMax( idVec3 &min, idVec3 &max, const idDrawVert *src, const int *indexes, const int count ) = 0;

 virtual void Clamp( float *dst, const float *src, const float min, const float max, const int count ) = 0;
 virtual void ClampMin( float *dst, const float *src, const float min, const int count ) = 0;
 virtual void ClampMax( float *dst, const float *src, const float max, const int count ) = 0;

 virtual void Memcpy( void *dst, const void *src, const int count ) = 0;
 virtual void Memset( void *dst, const int val, const int count ) = 0;


 virtual void Zero16( float *dst, const int count ) = 0;
 virtual void Negate16( float *dst, const int count ) = 0;
 virtual void Copy16( float *dst, const float *src, const int count ) = 0;
 virtual void Add16( float *dst, const float *src1, const float *src2, const int count ) = 0;
 virtual void Sub16( float *dst, const float *src1, const float *src2, const int count ) = 0;
 virtual void Mul16( float *dst, const float *src1, const float constant, const int count ) = 0;
 virtual void AddAssign16( float *dst, const float *src, const int count ) = 0;
 virtual void SubAssign16( float *dst, const float *src, const int count ) = 0;
 virtual void MulAssign16( float *dst, const float constant, const int count ) = 0;


 virtual void MatX_MultiplyVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_MultiplyAddVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_MultiplySubVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_TransposeMultiplyVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_TransposeMultiplyAddVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_TransposeMultiplySubVecX( idVecX &dst, const idMatX &mat, const idVecX &vec ) = 0;
 virtual void MatX_MultiplyMatX( idMatX &dst, const idMatX &m1, const idMatX &m2 ) = 0;
 virtual void MatX_TransposeMultiplyMatX( idMatX &dst, const idMatX &m1, const idMatX &m2 ) = 0;
 virtual void MatX_LowerTriangularSolve( const idMatX &L, float *x, const float *b, const int n, int skip = 0 ) = 0;
 virtual void MatX_LowerTriangularSolveTranspose( const idMatX &L, float *x, const float *b, const int n ) = 0;
 virtual bool MatX_LDLTFactor( idMatX &mat, idVecX &invDiag, const int n ) = 0;


 virtual void BlendJoints( idJointQuat *joints, const idJointQuat *blendJoints, const float lerp, const int *index, const int numJoints ) = 0;
 virtual void ConvertJointQuatsToJointMats( idJointMat *jointMats, const idJointQuat *jointQuats, const int numJoints ) = 0;
 virtual void ConvertJointMatsToJointQuats( idJointQuat *jointQuats, const idJointMat *jointMats, const int numJoints ) = 0;
 virtual void TransformJoints( idJointMat *jointMats, const int *parents, const int firstJoint, const int lastJoint ) = 0;
 virtual void UntransformJoints( idJointMat *jointMats, const int *parents, const int firstJoint, const int lastJoint ) = 0;
 virtual void TransformVerts( idDrawVert *verts, const int numVerts, const idJointMat *joints, const idVec4 *weights, const int *index, const int numWeights ) = 0;
 virtual void TracePointCull( byte *cullBits, byte &totalOr, const float radius, const idPlane *planes, const idDrawVert *verts, const int numVerts ) = 0;
 virtual void DecalPointCull( byte *cullBits, const idPlane *planes, const idDrawVert *verts, const int numVerts ) = 0;
 virtual void OverlayPointCull( byte *cullBits, idVec2 *texCoords, const idPlane *planes, const idDrawVert *verts, const int numVerts ) = 0;
 virtual void DeriveTriPlanes( idPlane *planes, const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) = 0;
 virtual void DeriveTangents( idPlane *planes, idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) = 0;
 virtual void DeriveUnsmoothedTangents( idDrawVert *verts, const dominantTri_s *dominantTris, const int numVerts ) = 0;
 virtual void NormalizeTangents( idDrawVert *verts, const int numVerts ) = 0;
 virtual void CreateTextureSpaceLightVectors( idVec3 *lightVectors, const idVec3 &lightOrigin, const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) = 0;
 virtual void CreateSpecularTextureCoords( idVec4 *texCoords, const idVec3 &lightOrigin, const idVec3 &viewOrigin, const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) = 0;
 virtual int CreateShadowCache( idVec4 *vertexCache, int *vertRemap, const idVec3 &lightOrigin, const idDrawVert *verts, const int numVerts ) = 0;
 virtual int CreateVertexProgramShadowCache( idVec4 *vertexCache, const idDrawVert *verts, const int numVerts ) = 0;


 virtual void UpSamplePCMTo44kHz( float *dest, const short *pcm, const int numSamples, const int kHz, const int numChannels ) = 0;
 virtual void UpSampleOGGTo44kHz( float *dest, const float * const *ogg, const int numSamples, const int kHz, const int numChannels ) = 0;
 virtual void MixSoundTwoSpeakerMono( float *mixBuffer, const float *samples, const int numSamples, const float lastV[2], const float currentV[2] ) = 0;
 virtual void MixSoundTwoSpeakerStereo( float *mixBuffer, const float *samples, const int numSamples, const float lastV[2], const float currentV[2] ) = 0;
 virtual void MixSoundSixSpeakerMono( float *mixBuffer, const float *samples, const int numSamples, const float lastV[6], const float currentV[6] ) = 0;
 virtual void MixSoundSixSpeakerStereo( float *mixBuffer, const float *samples, const int numSamples, const float lastV[6], const float currentV[6] ) = 0;
 virtual void MixedSoundToSamples( short *samples, const float *mixBuffer, const int numSamples ) = 0;
};


extern idSIMDProcessor *SIMDProcessor;
# 175 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h" 1
# 95 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h"
template<class T> inline int MaxIndex( T x, T y ) { return ( x > y ) ? 0 : 1; }
template<class T> inline int MinIndex( T x, T y ) { return ( x < y ) ? 0 : 1; }

template<class T> inline T Max3( T x, T y, T z ) { return ( x > y ) ? ( ( x > z ) ? x : z ) : ( ( y > z ) ? y : z ); }
template<class T> inline T Min3( T x, T y, T z ) { return ( x < y ) ? ( ( x < z ) ? x : z ) : ( ( y < z ) ? y : z ); }
template<class T> inline int Max3Index( T x, T y, T z ) { return ( x > y ) ? ( ( x > z ) ? 0 : 2 ) : ( ( y > z ) ? 1 : 2 ); }
template<class T> inline int Min3Index( T x, T y, T z ) { return ( x < y ) ? ( ( x < z ) ? 0 : 2 ) : ( ( y < z ) ? 1 : 2 ); }

template<class T> inline T Sign( T f ) { return ( f > 0 ) ? 1 : ( ( f < 0 ) ? -1 : 0 ); }
template<class T> inline T Square( T x ) { return x * x; }
template<class T> inline T Cube( T x ) { return x * x * x; }


class idMath {
public:

 static void Init( void );

 static float RSqrt( float x );

 static float InvSqrt( float x );
 static float InvSqrt16( float x );
 static double InvSqrt64( float x );

 static float Sqrt( float x );
 static float Sqrt16( float x );
 static double Sqrt64( float x );

 static float Sin( float a );
 static float Sin16( float a );
 static double Sin64( float a );

 static float Cos( float a );
 static float Cos16( float a );
 static double Cos64( float a );

 static void SinCos( float a, float &s, float &c );
 static void SinCos16( float a, float &s, float &c );
 static void SinCos64( float a, double &s, double &c );

 static float Tan( float a );
 static float Tan16( float a );
 static double Tan64( float a );

 static float ASin( float a );
 static float ASin16( float a );
 static double ASin64( float a );

 static float ACos( float a );
 static float ACos16( float a );
 static double ACos64( float a );

 static float ATan( float a );
 static float ATan16( float a );
 static double ATan64( float a );

 static float ATan( float y, float x );
 static float ATan16( float y, float x );
 static double ATan64( float y, float x );

 static float Pow( float x, float y );
 static float Pow16( float x, float y );
 static double Pow64( float x, float y );

 static float Exp( float f );
 static float Exp16( float f );
 static double Exp64( float f );

 static float Log( float f );
 static float Log16( float f );
 static double Log64( float f );

 static int IPow( int x, int y );
 static int ILog2( float f );
 static int ILog2( int i );

 static int BitsForFloat( float f );
 static int BitsForInteger( int i );
 static int MaskForFloatSign( float f );
 static int MaskForIntegerSign( int i );
 static int FloorPowerOfTwo( int x );
 static int CeilPowerOfTwo( int x );
 static bool IsPowerOfTwo( int x );
 static int BitCount( int x );
 static int BitReverse( int x );

 static int Abs( int x );
 static float Fabs( float f );
 static float Floor( float f );
 static float Ceil( float f );
 static float Rint( float f );
 static int Ftoi( float f );
 static int FtoiFast( float f );
 static unsigned long Ftol( float f );
 static unsigned long FtolFast( float );

 static signed char ClampChar( int i );
 static signed short ClampShort( int i );
 static int ClampInt( int min, int max, int value );
 static float ClampFloat( float min, float max, float value );

 static float AngleNormalize360( float angle );
 static float AngleNormalize180( float angle );
 static float AngleDelta( float angle1, float angle2 );

 static int FloatToBits( float f, int exponentBits, int mantissaBits );
 static float BitsToFloat( int i, int exponentBits, int mantissaBits );

 static int FloatHash( const float *array, const int numFloats );

 static const float PI;
 static const float TWO_PI;
 static const float HALF_PI;
 static const float ONEFOURTH_PI;
 static const float E;
 static const float SQRT_TWO;
 static const float SQRT_THREE;
 static const float SQRT_1OVER2;
 static const float SQRT_1OVER3;
 static const float M_DEG2RAD;
 static const float M_RAD2DEG;
 static const float M_SEC2MS;
 static const float M_MS2SEC;
 static const float INFINITY;
 static const float FLT_EPSILON;

private:
 enum {
  LOOKUP_BITS = 8,
  EXP_POS = 23,
  EXP_BIAS = 127,
  LOOKUP_POS = (EXP_POS-LOOKUP_BITS),
  SEED_POS = (EXP_POS-8),
  SQRT_TABLE_SIZE = (2<<LOOKUP_BITS),
  LOOKUP_MASK = (SQRT_TABLE_SIZE-1)
 };

 union _flint {
  dword i;
  float f;
 };

 static dword iSqrt[SQRT_TABLE_SIZE];
 static bool initialized;
};

inline float idMath::RSqrt( float x ) {

 long i;
 float y, r;

 y = x * 0.5f;
 i = *reinterpret_cast<long *>( &x );
 i = 0x5f3759df - ( i >> 1 );
 r = *reinterpret_cast<float *>( &i );
 r = r * ( 1.5f - r * r * y );
 return r;
}

inline float idMath::InvSqrt16( float x ) {

 dword a = ((union _flint*)(&x))->i;
 union _flint seed;

 ((void)0);

 double y = x * 0.5f;
 seed.i = (( ( (3*EXP_BIAS-1) - ( (a >> EXP_POS) & 0xFF) ) >> 1)<<EXP_POS) | iSqrt[(a >> (EXP_POS-LOOKUP_BITS)) & LOOKUP_MASK];
 double r = seed.f;
 r = r * ( 1.5f - r * r * y );
 return (float) r;
}

inline float idMath::InvSqrt( float x ) {

 dword a = ((union _flint*)(&x))->i;
 union _flint seed;

 ((void)0);

 double y = x * 0.5f;
 seed.i = (( ( (3*EXP_BIAS-1) - ( (a >> EXP_POS) & 0xFF) ) >> 1)<<EXP_POS) | iSqrt[(a >> (EXP_POS-LOOKUP_BITS)) & LOOKUP_MASK];
 double r = seed.f;
 r = r * ( 1.5f - r * r * y );
 r = r * ( 1.5f - r * r * y );
 return (float) r;
}

inline double idMath::InvSqrt64( float x ) {
 dword a = ((union _flint*)(&x))->i;
 union _flint seed;

 ((void)0);

 double y = x * 0.5f;
 seed.i = (( ( (3*EXP_BIAS-1) - ( (a >> EXP_POS) & 0xFF) ) >> 1)<<EXP_POS) | iSqrt[(a >> (EXP_POS-LOOKUP_BITS)) & LOOKUP_MASK];
 double r = seed.f;
 r = r * ( 1.5f - r * r * y );
 r = r * ( 1.5f - r * r * y );
 r = r * ( 1.5f - r * r * y );
 return r;
}

inline float idMath::Sqrt16( float x ) {
 return x * InvSqrt16( x );
}

inline float idMath::Sqrt( float x ) {
 return x * InvSqrt( x );
}

inline double idMath::Sqrt64( float x ) {
 return x * InvSqrt64( x );
}

inline float idMath::Sin( float a ) {
 return sinf( a );
}

inline float idMath::Sin16( float a ) {
 float s;

 if ( ( a < 0.0f ) || ( a >= TWO_PI ) ) {
  a -= floorf( a / TWO_PI ) * TWO_PI;
 }

 if ( a < PI ) {
  if ( a > HALF_PI ) {
   a = PI - a;
  }
 } else {
  if ( a > PI + HALF_PI ) {
   a = a - TWO_PI;
  } else {
   a = PI - a;
  }
 }






 s = a * a;
 return a * ( ( ( ( ( -2.39e-08f * s + 2.7526e-06f ) * s - 1.98409e-04f ) * s + 8.3333315e-03f ) * s - 1.666666664e-01f ) * s + 1.0f );
}

inline double idMath::Sin64( float a ) {
 return sin( a );
}

inline float idMath::Cos( float a ) {
 return cosf( a );
}

inline float idMath::Cos16( float a ) {
 float s, d;

 if ( ( a < 0.0f ) || ( a >= TWO_PI ) ) {
  a -= floorf( a / TWO_PI ) * TWO_PI;
 }

 if ( a < PI ) {
  if ( a > HALF_PI ) {
   a = PI - a;
   d = -1.0f;
  } else {
   d = 1.0f;
  }
 } else {
  if ( a > PI + HALF_PI ) {
   a = a - TWO_PI;
   d = 1.0f;
  } else {
   a = PI - a;
   d = -1.0f;
  }
 }
# 382 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h"
 s = a * a;
 return d * ( ( ( ( ( -2.605e-07f * s + 2.47609e-05f ) * s - 1.3888397e-03f ) * s + 4.16666418e-02f ) * s - 4.999999963e-01f ) * s + 1.0f );
}

inline double idMath::Cos64( float a ) {
 return cos( a );
}

inline void idMath::SinCos( float a, float &s, float &c ) {
# 401 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h"
 s = sinf( a );
 c = cosf( a );

}

inline void idMath::SinCos16( float a, float &s, float &c ) {
 float t, d;

 if ( ( a < 0.0f ) || ( a >= idMath::TWO_PI ) ) {
  a -= floorf( a / idMath::TWO_PI ) * idMath::TWO_PI;
 }

 if ( a < PI ) {
  if ( a > HALF_PI ) {
   a = PI - a;
   d = -1.0f;
  } else {
   d = 1.0f;
  }
 } else {
  if ( a > PI + HALF_PI ) {
   a = a - TWO_PI;
   d = 1.0f;
  } else {
   a = PI - a;
   d = -1.0f;
  }
 }
# 438 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h"
 t = a * a;
 s = a * ( ( ( ( ( -2.39e-08f * t + 2.7526e-06f ) * t - 1.98409e-04f ) * t + 8.3333315e-03f ) * t - 1.666666664e-01f ) * t + 1.0f );
 c = d * ( ( ( ( ( -2.605e-07f * t + 2.47609e-05f ) * t - 1.3888397e-03f ) * t + 4.16666418e-02f ) * t - 4.999999963e-01f ) * t + 1.0f );
}

inline void idMath::SinCos64( float a, double &s, double &c ) {
# 454 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h"
 s = sin( a );
 c = cos( a );

}

inline float idMath::Tan( float a ) {
 return tanf( a );
}

inline float idMath::Tan16( float a ) {
 float s;
 bool reciprocal;

 if ( ( a < 0.0f ) || ( a >= PI ) ) {
  a -= floorf( a / PI ) * PI;
 }

 if ( a < HALF_PI ) {
  if ( a > ONEFOURTH_PI ) {
   a = HALF_PI - a;
   reciprocal = true;
  } else {
   reciprocal = false;
  }
 } else {
  if ( a > HALF_PI + ONEFOURTH_PI ) {
   a = a - PI;
   reciprocal = false;
  } else {
   a = HALF_PI - a;
   reciprocal = true;
  }
 }
# 496 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h"
 s = a * a;
 s = a * ( ( ( ( ( ( 9.5168091e-03f * s + 2.900525e-03f ) * s + 2.45650893e-02f ) * s + 5.33740603e-02f ) * s + 1.333923995e-01f ) * s + 3.333314036e-01f ) * s + 1.0f );
 if ( reciprocal ) {
  return 1.0f / s;
 } else {
  return s;
 }
}

inline double idMath::Tan64( float a ) {
 return tan( a );
}

inline float idMath::ASin( float a ) {
 if ( a <= -1.0f ) {
  return -HALF_PI;
 }
 if ( a >= 1.0f ) {
  return HALF_PI;
 }
 return asinf( a );
}

inline float idMath::ASin16( float a ) {
 if ( ((*(const unsigned long *)&(a)) >> 31) ) {
  if ( a <= -1.0f ) {
   return -HALF_PI;
  }
  a = fabs( a );
  return ( ( ( -0.0187293f * a + 0.0742610f ) * a - 0.2121144f ) * a + 1.5707288f ) * sqrt( 1.0f - a ) - HALF_PI;
 } else {
  if ( a >= 1.0f ) {
   return HALF_PI;
  }
  return HALF_PI - ( ( ( -0.0187293f * a + 0.0742610f ) * a - 0.2121144f ) * a + 1.5707288f ) * sqrt( 1.0f - a );
 }
}

inline double idMath::ASin64( float a ) {
 if ( a <= -1.0f ) {
  return -HALF_PI;
 }
 if ( a >= 1.0f ) {
  return HALF_PI;
 }
 return asin( a );
}

inline float idMath::ACos( float a ) {
 if ( a <= -1.0f ) {
  return PI;
 }
 if ( a >= 1.0f ) {
  return 0.0f;
 }
 return acosf( a );
}

inline float idMath::ACos16( float a ) {
 if ( ((*(const unsigned long *)&(a)) >> 31) ) {
  if ( a <= -1.0f ) {
   return PI;
  }
  a = fabs( a );
  return PI - ( ( ( -0.0187293f * a + 0.0742610f ) * a - 0.2121144f ) * a + 1.5707288f ) * sqrt( 1.0f - a );
 } else {
  if ( a >= 1.0f ) {
   return 0.0f;
  }
  return ( ( ( -0.0187293f * a + 0.0742610f ) * a - 0.2121144f ) * a + 1.5707288f ) * sqrt( 1.0f - a );
 }
}

inline double idMath::ACos64( float a ) {
 if ( a <= -1.0f ) {
  return PI;
 }
 if ( a >= 1.0f ) {
  return 0.0f;
 }
 return acos( a );
}

inline float idMath::ATan( float a ) {
 return atanf( a );
}

inline float idMath::ATan16( float a ) {
 float s;

 if ( fabs( a ) > 1.0f ) {
  a = 1.0f / a;
  s = a * a;
  s = - ( ( ( ( ( ( ( ( ( 0.0028662257f * s - 0.0161657367f ) * s + 0.0429096138f ) * s - 0.0752896400f )
    * s + 0.1065626393f ) * s - 0.1420889944f ) * s + 0.1999355085f ) * s - 0.3333314528f ) * s ) + 1.0f ) * a;
  if ( ((*(const unsigned long *)&(a)) >> 31) ) {
   return s - HALF_PI;
  } else {
   return s + HALF_PI;
  }
 } else {
  s = a * a;
  return ( ( ( ( ( ( ( ( ( 0.0028662257f * s - 0.0161657367f ) * s + 0.0429096138f ) * s - 0.0752896400f )
   * s + 0.1065626393f ) * s - 0.1420889944f ) * s + 0.1999355085f ) * s - 0.3333314528f ) * s ) + 1.0f ) * a;
 }
}

inline double idMath::ATan64( float a ) {
 return atan( a );
}

inline float idMath::ATan( float y, float x ) {
 return atan2f( y, x );
}

inline float idMath::ATan16( float y, float x ) {
 float a, s;

 if ( fabs( y ) > fabs( x ) ) {
  a = x / y;
  s = a * a;
  s = - ( ( ( ( ( ( ( ( ( 0.0028662257f * s - 0.0161657367f ) * s + 0.0429096138f ) * s - 0.0752896400f )
    * s + 0.1065626393f ) * s - 0.1420889944f ) * s + 0.1999355085f ) * s - 0.3333314528f ) * s ) + 1.0f ) * a;
  if ( ((*(const unsigned long *)&(a)) >> 31) ) {
   return s - HALF_PI;
  } else {
   return s + HALF_PI;
  }
 } else {
  a = y / x;
  s = a * a;
  return ( ( ( ( ( ( ( ( ( 0.0028662257f * s - 0.0161657367f ) * s + 0.0429096138f ) * s - 0.0752896400f )
   * s + 0.1065626393f ) * s - 0.1420889944f ) * s + 0.1999355085f ) * s - 0.3333314528f ) * s ) + 1.0f ) * a;
 }
}

inline double idMath::ATan64( float y, float x ) {
 return atan2( y, x );
}

inline float idMath::Pow( float x, float y ) {
 return powf( x, y );
}

inline float idMath::Pow16( float x, float y ) {
 return Exp16( y * Log16( x ) );
}

inline double idMath::Pow64( float x, float y ) {
 return pow( x, y );
}

inline float idMath::Exp( float f ) {
 return expf( f );
}

inline float idMath::Exp16( float f ) {
 int i, s, e, m, exponent;
 float x, x2, y, p, q;

 x = f * 1.44269504088896340f;

 i = *reinterpret_cast<int *>(&x);
 s = ( i >> 31 );
 e = ( ( i >> 23 ) & ( ( 1 << 8 ) - 1 ) ) - 127;
 m = ( i & ( ( 1 << 23 ) - 1 ) ) | ( 1 << 23 );
 i = ( ( m >> ( 23 - e ) ) & ~( e >> 31 ) ) ^ s;






 exponent = ( i + 127 ) << 23;
 y = *reinterpret_cast<float *>(&exponent);
 x -= (float) i;
 if ( x >= 0.5f ) {
  x -= 0.5f;
  y *= 1.4142135623730950488f;
 }
 x2 = x * x;
 p = x * ( 7.2152891511493f + x2 * 0.0576900723731f );
 q = 20.8189237930062f + x2;
 x = y * ( q + p ) / ( q - p );
 return x;
}

inline double idMath::Exp64( float f ) {
 return exp( f );
}

inline float idMath::Log( float f ) {
 return logf( f );
}

inline float idMath::Log16( float f ) {
 int i, exponent;
 float y, y2;

 i = *reinterpret_cast<int *>(&f);
 exponent = ( ( i >> 23 ) & ( ( 1 << 8 ) - 1 ) ) - 127;
 i -= ( exponent + 1 ) << 23;
 y = *reinterpret_cast<float *>(&i);
 y *= 1.4142135623730950488f;
 y = ( y - 1.0f ) / ( y + 1.0f );
 y2 = y * y;
 y = y * ( 2.000000000046727f + y2 * ( 0.666666635059382f + y2 * ( 0.4000059794795f + y2 * ( 0.28525381498f + y2 * 0.2376245609f ) ) ) );
 y += 0.693147180559945f * ( (float)exponent + 0.5f );
 return y;
}

inline double idMath::Log64( float f ) {
 return log( f );
}

inline int idMath::IPow( int x, int y ) {
 int r; for( r = x; y > 1; y-- ) { r *= x; } return r;
}

inline int idMath::ILog2( float f ) {
 return ( ( (*reinterpret_cast<int *>(&f)) >> 23 ) & ( ( 1 << 8 ) - 1 ) ) - 127;
}

inline int idMath::ILog2( int i ) {
 return ILog2( (float)i );
}

inline int idMath::BitsForFloat( float f ) {
 return ILog2( f ) + 1;
}

inline int idMath::BitsForInteger( int i ) {
 return ILog2( (float)i ) + 1;
}

inline int idMath::MaskForFloatSign( float f ) {
 return ( (*reinterpret_cast<int *>(&f)) >> 31 );
}

inline int idMath::MaskForIntegerSign( int i ) {
 return ( i >> 31 );
}

inline int idMath::FloorPowerOfTwo( int x ) {
 return CeilPowerOfTwo( x ) >> 1;
}

inline int idMath::CeilPowerOfTwo( int x ) {
 x--;
 x |= x >> 1;
 x |= x >> 2;
 x |= x >> 4;
 x |= x >> 8;
 x |= x >> 16;
 x++;
 return x;
}

inline bool idMath::IsPowerOfTwo( int x ) {
 return ( x & ( x - 1 ) ) == 0 && x > 0;
}

inline int idMath::BitCount( int x ) {
 x -= ( ( x >> 1 ) & 0x55555555 );
 x = ( ( ( x >> 2 ) & 0x33333333 ) + ( x & 0x33333333 ) );
 x = ( ( ( x >> 4 ) + x ) & 0x0f0f0f0f );
 x += ( x >> 8 );
 return ( ( x + ( x >> 16 ) ) & 0x0000003f );
}

inline int idMath::BitReverse( int x ) {
 x = ( ( ( x >> 1 ) & 0x55555555 ) | ( ( x & 0x55555555 ) << 1 ) );
 x = ( ( ( x >> 2 ) & 0x33333333 ) | ( ( x & 0x33333333 ) << 2 ) );
 x = ( ( ( x >> 4 ) & 0x0f0f0f0f ) | ( ( x & 0x0f0f0f0f ) << 4 ) );
 x = ( ( ( x >> 8 ) & 0x00ff00ff ) | ( ( x & 0x00ff00ff ) << 8 ) );
 return ( ( x >> 16 ) | ( x << 16 ) );
}

inline int idMath::Abs( int x ) {
   int y = x >> 31;
   return ( ( x ^ y ) - y );
}

inline float idMath::Fabs( float f ) {
 int tmp = *reinterpret_cast<int *>( &f );
 tmp &= 0x7FFFFFFF;
 return *reinterpret_cast<float *>( &tmp );
}

inline float idMath::Floor( float f ) {
 return floorf( f );
}

inline float idMath::Ceil( float f ) {
 return ceilf( f );
}

inline float idMath::Rint( float f ) {
 return floorf( f + 0.5f );
}

inline int idMath::Ftoi( float f ) {
 return (int) f;
}

inline int idMath::FtoiFast( float f ) {
# 825 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h"
 return (int) f;

}

inline unsigned long idMath::Ftol( float f ) {
 return (unsigned long) f;
}

inline unsigned long idMath::FtolFast( float f ) {
# 859 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Math.h"
 return (unsigned long) f;

}

inline signed char idMath::ClampChar( int i ) {
 if ( i < -128 ) {
  return -128;
 }
 if ( i > 127 ) {
  return 127;
 }
 return i;
}

inline signed short idMath::ClampShort( int i ) {
 if ( i < -32768 ) {
  return -32768;
 }
 if ( i > 32767 ) {
  return 32767;
 }
 return i;
}

inline int idMath::ClampInt( int min, int max, int value ) {
 if ( value < min ) {
  return min;
 }
 if ( value > max ) {
  return max;
 }
 return value;
}

inline float idMath::ClampFloat( float min, float max, float value ) {
 if ( value < min ) {
  return min;
 }
 if ( value > max ) {
  return max;
 }
 return value;
}

inline float idMath::AngleNormalize360( float angle ) {
 if ( ( angle >= 360.0f ) || ( angle < 0.0f ) ) {
  angle -= floor( angle / 360.0f ) * 360.0f;
 }
 return angle;
}

inline float idMath::AngleNormalize180( float angle ) {
 angle = AngleNormalize360( angle );
 if ( angle > 180.0f ) {
  angle -= 360.0f;
 }
 return angle;
}

inline float idMath::AngleDelta( float angle1, float angle2 ) {
 return AngleNormalize180( angle1 - angle2 );
}

inline int idMath::FloatHash( const float *array, const int numFloats ) {
 int i, hash = 0;
 const int *ptr;

 ptr = reinterpret_cast<const int *>( array );
 for ( i = 0; i < numFloats; i++ ) {
  hash ^= ptr[i];
 }
 return hash;
}
# 176 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Random.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Random.h"
class idRandom {
public:
      idRandom( int seed = 0 );

 void SetSeed( int seed );
 int GetSeed( void ) const;

 int RandomInt( void );
 int RandomInt( int max );
 float RandomFloat( void );
 float CRandomFloat( void );

 static const int MAX_RAND = 0x7fff;

private:
 int seed;
};

inline idRandom::idRandom( int seed ) {
 this->seed = seed;
}

inline void idRandom::SetSeed( int seed ) {
 this->seed = seed;
}

inline int idRandom::GetSeed( void ) const {
 return seed;
}

inline int idRandom::RandomInt( void ) {
 seed = 69069 * seed + 1;
 return ( seed & idRandom::MAX_RAND );
}

inline int idRandom::RandomInt( int max ) {
 if ( max == 0 ) {
  return 0;
 }
 return RandomInt() % max;
}

inline float idRandom::RandomFloat( void ) {
 return ( RandomInt() / ( float )( idRandom::MAX_RAND + 1 ) );
}

inline float idRandom::CRandomFloat( void ) {
 return ( 2.0f * ( RandomFloat() - 0.5f ) );
}
# 99 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Random.h"
class idRandom2 {
public:
       idRandom2( unsigned long seed = 0 );

 void SetSeed( unsigned long seed );
 unsigned long GetSeed( void ) const;

 int RandomInt( void );
 int RandomInt( int max );
 float RandomFloat( void );
 float CRandomFloat( void );

 static const int MAX_RAND = 0x7fff;

private:
 unsigned long seed;

 static const unsigned long IEEE_ONE = 0x3f800000;
 static const unsigned long IEEE_MASK = 0x007fffff;
};

inline idRandom2::idRandom2( unsigned long seed ) {
 this->seed = seed;
}

inline void idRandom2::SetSeed( unsigned long seed ) {
 this->seed = seed;
}

inline unsigned long idRandom2::GetSeed( void ) const {
 return seed;
}

inline int idRandom2::RandomInt( void ) {
 seed = 1664525L * seed + 1013904223L;
 return ( (int) seed & idRandom2::MAX_RAND );
}

inline int idRandom2::RandomInt( int max ) {
 if ( max == 0 ) {
  return 0;
 }
 return ( RandomInt() >> ( 16 - idMath::BitsForInteger( max ) ) ) % max;
}

inline float idRandom2::RandomFloat( void ) {
 unsigned long i;
 seed = 1664525L * seed + 1013904223L;
 i = idRandom2::IEEE_ONE | ( seed & idRandom2::IEEE_MASK );
 return ( ( *(float *)&i ) - 1.0f );
}

inline float idRandom2::CRandomFloat( void ) {
 unsigned long i;
 seed = 1664525L * seed + 1013904223L;
 i = idRandom2::IEEE_ONE | ( seed & idRandom2::IEEE_MASK );
 return ( 2.0f * ( *(float *)&i ) - 3.0f );
}
# 177 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Complex.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Complex.h"
class idComplex {
public:
 float r;
 float i;

      idComplex( void );
      idComplex( const float r, const float i );

 void Set( const float r, const float i );
 void Zero( void );

 float operator[]( int index ) const;
 float & operator[]( int index );

 idComplex operator-() const;
 idComplex & operator=( const idComplex &a );

 idComplex operator*( const idComplex &a ) const;
 idComplex operator/( const idComplex &a ) const;
 idComplex operator+( const idComplex &a ) const;
 idComplex operator-( const idComplex &a ) const;

 idComplex & operator*=( const idComplex &a );
 idComplex & operator/=( const idComplex &a );
 idComplex & operator+=( const idComplex &a );
 idComplex & operator-=( const idComplex &a );

 idComplex operator*( const float a ) const;
 idComplex operator/( const float a ) const;
 idComplex operator+( const float a ) const;
 idComplex operator-( const float a ) const;

 idComplex & operator*=( const float a );
 idComplex & operator/=( const float a );
 idComplex & operator+=( const float a );
 idComplex & operator-=( const float a );

 friend idComplex operator*( const float a, const idComplex &b );
 friend idComplex operator/( const float a, const idComplex &b );
 friend idComplex operator+( const float a, const idComplex &b );
 friend idComplex operator-( const float a, const idComplex &b );

 bool Compare( const idComplex &a ) const;
 bool Compare( const idComplex &a, const float epsilon ) const;
 bool operator==( const idComplex &a ) const;
 bool operator!=( const idComplex &a ) const;

 idComplex Reciprocal( void ) const;
 idComplex Sqrt( void ) const;
 float Abs( void ) const;

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;
};

extern idComplex complex_origin;


inline idComplex::idComplex( void ) {
}

inline idComplex::idComplex( const float r, const float i ) {
 this->r = r;
 this->i = i;
}

inline void idComplex::Set( const float r, const float i ) {
 this->r = r;
 this->i = i;
}

inline void idComplex::Zero( void ) {
 r = i = 0.0f;
}

inline float idComplex::operator[]( int index ) const {
 ((void)0);
 return ( &r )[ index ];
}

inline float& idComplex::operator[]( int index ) {
 ((void)0);
 return ( &r )[ index ];
}

inline idComplex idComplex::operator-() const {
 return idComplex( -r, -i );
}

inline idComplex &idComplex::operator=( const idComplex &a ) {
 r = a.r;
 i = a.i;
 return *this;
}

inline idComplex idComplex::operator*( const idComplex &a ) const {
 return idComplex( r * a.r - i * a.i, i * a.r + r * a.i );
}

inline idComplex idComplex::operator/( const idComplex &a ) const {
 float s, t;
 if ( idMath::Fabs( a.r ) >= idMath::Fabs( a.i ) ) {
  s = a.i / a.r;
  t = 1.0f / ( a.r + s * a.i );
  return idComplex( ( r + s * i ) * t, ( i - s * r ) * t );
 } else {
  s = a.r / a.i;
  t = 1.0f / ( s * a.r + a.i );
  return idComplex( ( r * s + i ) * t, ( i * s - r ) * t );
 }
}

inline idComplex idComplex::operator+( const idComplex &a ) const {
 return idComplex( r + a.r, i + a.i );
}

inline idComplex idComplex::operator-( const idComplex &a ) const {
 return idComplex( r - a.r, i - a.i );
}

inline idComplex &idComplex::operator*=( const idComplex &a ) {
 *this = idComplex( r * a.r - i * a.i, i * a.r + r * a.i );
 return *this;
}

inline idComplex &idComplex::operator/=( const idComplex &a ) {
 float s, t;
 if ( idMath::Fabs( a.r ) >= idMath::Fabs( a.i ) ) {
  s = a.i / a.r;
  t = 1.0f / ( a.r + s * a.i );
  *this = idComplex( ( r + s * i ) * t, ( i - s * r ) * t );
 } else {
  s = a.r / a.i;
  t = 1.0f / ( s * a.r + a.i );
  *this = idComplex( ( r * s + i ) * t, ( i * s - r ) * t );
 }
 return *this;
}

inline idComplex &idComplex::operator+=( const idComplex &a ) {
 r += a.r;
 i += a.i;
 return *this;
}

inline idComplex &idComplex::operator-=( const idComplex &a ) {
 r -= a.r;
 i -= a.i;
 return *this;
}

inline idComplex idComplex::operator*( const float a ) const {
 return idComplex( r * a, i * a );
}

inline idComplex idComplex::operator/( const float a ) const {
 float s = 1.0f / a;
 return idComplex( r * s, i * s );
}

inline idComplex idComplex::operator+( const float a ) const {
 return idComplex( r + a, i );
}

inline idComplex idComplex::operator-( const float a ) const {
 return idComplex( r - a, i );
}

inline idComplex &idComplex::operator*=( const float a ) {
 r *= a;
 i *= a;
 return *this;
}

inline idComplex &idComplex::operator/=( const float a ) {
 float s = 1.0f / a;
 r *= s;
 i *= s;
 return *this;
}

inline idComplex &idComplex::operator+=( const float a ) {
 r += a;
 return *this;
}

inline idComplex &idComplex::operator-=( const float a ) {
 r -= a;
 return *this;
}

inline idComplex operator*( const float a, const idComplex &b ) {
 return idComplex( a * b.r, a * b.i );
}

inline idComplex operator/( const float a, const idComplex &b ) {
 float s, t;
 if ( idMath::Fabs( b.r ) >= idMath::Fabs( b.i ) ) {
  s = b.i / b.r;
  t = a / ( b.r + s * b.i );
  return idComplex( t, - s * t );
 } else {
  s = b.r / b.i;
  t = a / ( s * b.r + b.i );
  return idComplex( s * t, - t );
 }
}

inline idComplex operator+( const float a, const idComplex &b ) {
 return idComplex( a + b.r, b.i );
}

inline idComplex operator-( const float a, const idComplex &b ) {
 return idComplex( a - b.r, -b.i );
}

inline idComplex idComplex::Reciprocal( void ) const {
 float s, t;
 if ( idMath::Fabs( r ) >= idMath::Fabs( i ) ) {
  s = i / r;
  t = 1.0f / ( r + s * i );
  return idComplex( t, - s * t );
 } else {
  s = r / i;
  t = 1.0f / ( s * r + i );
  return idComplex( s * t, - t );
 }
}

inline idComplex idComplex::Sqrt( void ) const {
 float x, y, w;

 if ( r == 0.0f && i == 0.0f ) {
  return idComplex( 0.0f, 0.0f );
 }
 x = idMath::Fabs( r );
 y = idMath::Fabs( i );
 if ( x >= y ) {
  w = y / x;
  w = idMath::Sqrt( x ) * idMath::Sqrt( 0.5f * ( 1.0f + idMath::Sqrt( 1.0f + w * w ) ) );
 } else {
  w = x / y;
  w = idMath::Sqrt( y ) * idMath::Sqrt( 0.5f * ( w + idMath::Sqrt( 1.0f + w * w ) ) );
 }
 if ( w == 0.0f ) {
  return idComplex( 0.0f, 0.0f );
 }
 if ( r >= 0.0f ) {
  return idComplex( w, 0.5f * i / w );
 } else {
  return idComplex( 0.5f * y / w, ( i >= 0.0f ) ? w : -w );
 }
}

inline float idComplex::Abs( void ) const {
 float x, y, t;
 x = idMath::Fabs( r );
 y = idMath::Fabs( i );
 if ( x == 0.0f ) {
  return y;
 } else if ( y == 0.0f ) {
  return x;
 } else if ( x > y ) {
  t = y / x;
  return x * idMath::Sqrt( 1.0f + t * t );
 } else {
  t = x / y;
  return y * idMath::Sqrt( 1.0f + t * t );
 }
}

inline bool idComplex::Compare( const idComplex &a ) const {
 return ( ( r == a.r ) && ( i == a.i ) );
}

inline bool idComplex::Compare( const idComplex &a, const float epsilon ) const {
 if ( idMath::Fabs( r - a.r ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( i - a.i ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idComplex::operator==( const idComplex &a ) const {
 return Compare( a );
}

inline bool idComplex::operator!=( const idComplex &a ) const {
 return !Compare( a );
}

inline int idComplex::GetDimension( void ) const {
 return 2;
}

inline const float *idComplex::ToFloatPtr( void ) const {
 return &r;
}

inline float *idComplex::ToFloatPtr( void ) {
 return &r;
}
# 178 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Vector.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Vector.h"
class idAngles;
class idPolar3;
class idMat3;







class idVec2 {
public:
 float x;
 float y;

     idVec2( void );
     explicit idVec2( const float x, const float y );

 void Set( const float x, const float y );
 void Zero( void );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idVec2 operator-() const;
 float operator*( const idVec2 &a ) const;
 idVec2 operator*( const float a ) const;
 idVec2 operator/( const float a ) const;
 idVec2 operator+( const idVec2 &a ) const;
 idVec2 operator-( const idVec2 &a ) const;
 idVec2 & operator+=( const idVec2 &a );
 idVec2 & operator-=( const idVec2 &a );
 idVec2 & operator/=( const idVec2 &a );
 idVec2 & operator/=( const float a );
 idVec2 & operator*=( const float a );

 friend idVec2 operator*( const float a, const idVec2 b );

 bool Compare( const idVec2 &a ) const;
 bool Compare( const idVec2 &a, const float epsilon ) const;
 bool operator==( const idVec2 &a ) const;
 bool operator!=( const idVec2 &a ) const;

 float Length( void ) const;
 float LengthFast( void ) const;
 float LengthSqr( void ) const;
 float Normalize( void );
 float NormalizeFast( void );
 idVec2 & Truncate( float length );
 void Clamp( const idVec2 &min, const idVec2 &max );
 void Snap( void );
 void SnapInt( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void Lerp( const idVec2 &v1, const idVec2 &v2, const float l );
};

extern idVec2 vec2_origin;


inline idVec2::idVec2( void ) {
}

inline idVec2::idVec2( const float x, const float y ) {
 this->x = x;
 this->y = y;
}

inline void idVec2::Set( const float x, const float y ) {
 this->x = x;
 this->y = y;
}

inline void idVec2::Zero( void ) {
 x = y = 0.0f;
}

inline bool idVec2::Compare( const idVec2 &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) );
}

inline bool idVec2::Compare( const idVec2 &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idVec2::operator==( const idVec2 &a ) const {
 return Compare( a );
}

inline bool idVec2::operator!=( const idVec2 &a ) const {
 return !Compare( a );
}

inline float idVec2::operator[]( int index ) const {
 return ( &x )[ index ];
}

inline float& idVec2::operator[]( int index ) {
 return ( &x )[ index ];
}

inline float idVec2::Length( void ) const {
 return ( float )idMath::Sqrt( x * x + y * y );
}

inline float idVec2::LengthFast( void ) const {
 float sqrLength;

 sqrLength = x * x + y * y;
 return sqrLength * idMath::RSqrt( sqrLength );
}

inline float idVec2::LengthSqr( void ) const {
 return ( x * x + y * y );
}

inline float idVec2::Normalize( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y;
 invLength = idMath::InvSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 return invLength * sqrLength;
}

inline float idVec2::NormalizeFast( void ) {
 float lengthSqr, invLength;

 lengthSqr = x * x + y * y;
 invLength = idMath::RSqrt( lengthSqr );
 x *= invLength;
 y *= invLength;
 return invLength * lengthSqr;
}

inline idVec2 &idVec2::Truncate( float length ) {
 float length2;
 float ilength;

 if ( !length ) {
  Zero();
 }
 else {
  length2 = LengthSqr();
  if ( length2 > length * length ) {
   ilength = length * idMath::InvSqrt( length2 );
   x *= ilength;
   y *= ilength;
  }
 }

 return *this;
}

inline void idVec2::Clamp( const idVec2 &min, const idVec2 &max ) {
 if ( x < min.x ) {
  x = min.x;
 } else if ( x > max.x ) {
  x = max.x;
 }
 if ( y < min.y ) {
  y = min.y;
 } else if ( y > max.y ) {
  y = max.y;
 }
}

inline void idVec2::Snap( void ) {
 x = floor( x + 0.5f );
 y = floor( y + 0.5f );
}

inline void idVec2::SnapInt( void ) {
 x = float( int( x ) );
 y = float( int( y ) );
}

inline idVec2 idVec2::operator-() const {
 return idVec2( -x, -y );
}

inline idVec2 idVec2::operator-( const idVec2 &a ) const {
 return idVec2( x - a.x, y - a.y );
}

inline float idVec2::operator*( const idVec2 &a ) const {
 return x * a.x + y * a.y;
}

inline idVec2 idVec2::operator*( const float a ) const {
 return idVec2( x * a, y * a );
}

inline idVec2 idVec2::operator/( const float a ) const {
 float inva = 1.0f / a;
 return idVec2( x * inva, y * inva );
}

inline idVec2 operator*( const float a, const idVec2 b ) {
 return idVec2( b.x * a, b.y * a );
}

inline idVec2 idVec2::operator+( const idVec2 &a ) const {
 return idVec2( x + a.x, y + a.y );
}

inline idVec2 &idVec2::operator+=( const idVec2 &a ) {
 x += a.x;
 y += a.y;

 return *this;
}

inline idVec2 &idVec2::operator/=( const idVec2 &a ) {
 x /= a.x;
 y /= a.y;

 return *this;
}

inline idVec2 &idVec2::operator/=( const float a ) {
 float inva = 1.0f / a;
 x *= inva;
 y *= inva;

 return *this;
}

inline idVec2 &idVec2::operator-=( const idVec2 &a ) {
 x -= a.x;
 y -= a.y;

 return *this;
}

inline idVec2 &idVec2::operator*=( const float a ) {
 x *= a;
 y *= a;

 return *this;
}

inline int idVec2::GetDimension( void ) const {
 return 2;
}

inline const float *idVec2::ToFloatPtr( void ) const {
 return &x;
}

inline float *idVec2::ToFloatPtr( void ) {
 return &x;
}
# 316 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Vector.h"
class idVec3 {
public:
 float x;
 float y;
 float z;

     idVec3( void );
     explicit idVec3( const float x, const float y, const float z );

 void Set( const float x, const float y, const float z );
 void Zero( void );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idVec3 operator-() const;
 idVec3 & operator=( const idVec3 &a );
 float operator*( const idVec3 &a ) const;
 idVec3 operator*( const float a ) const;
 idVec3 operator/( const float a ) const;
 idVec3 operator+( const idVec3 &a ) const;
 idVec3 operator-( const idVec3 &a ) const;
 idVec3 & operator+=( const idVec3 &a );
 idVec3 & operator-=( const idVec3 &a );
 idVec3 & operator/=( const idVec3 &a );
 idVec3 & operator/=( const float a );
 idVec3 & operator*=( const float a );

 friend idVec3 operator*( const float a, const idVec3 b );

 bool Compare( const idVec3 &a ) const;
 bool Compare( const idVec3 &a, const float epsilon ) const;
 bool operator==( const idVec3 &a ) const;
 bool operator!=( const idVec3 &a ) const;

 bool FixDegenerateNormal( void );
 bool FixDenormals( void );

 idVec3 Cross( const idVec3 &a ) const;
 idVec3 & Cross( const idVec3 &a, const idVec3 &b );
 float Length( void ) const;
 float LengthSqr( void ) const;
 float LengthFast( void ) const;
 float Normalize( void );
 float NormalizeFast( void );
 idVec3 & Truncate( float length );
 void Clamp( const idVec3 &min, const idVec3 &max );
 void Snap( void );
 void SnapInt( void );

 int GetDimension( void ) const;

 float ToYaw( void ) const;
 float ToPitch( void ) const;
 idAngles ToAngles( void ) const;
 idPolar3 ToPolar( void ) const;
 idMat3 ToMat3( void ) const;
 const idVec2 & ToVec2( void ) const;
 idVec2 & ToVec2( void );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void NormalVectors( idVec3 &left, idVec3 &down ) const;
 void OrthogonalBasis( idVec3 &left, idVec3 &up ) const;

 void ProjectOntoPlane( const idVec3 &normal, const float overBounce = 1.0f );
 bool ProjectAlongPlane( const idVec3 &normal, const float epsilon, const float overBounce = 1.0f );
 void ProjectSelfOntoSphere( const float radius );

 void Lerp( const idVec3 &v1, const idVec3 &v2, const float l );
 void SLerp( const idVec3 &v1, const idVec3 &v2, const float l );
};

extern idVec3 vec3_origin;


inline idVec3::idVec3( void ) {
}

inline idVec3::idVec3( const float x, const float y, const float z ) {
 this->x = x;
 this->y = y;
 this->z = z;
}

inline float idVec3::operator[]( const int index ) const {
 return ( &x )[ index ];
}

inline float &idVec3::operator[]( const int index ) {
 return ( &x )[ index ];
}

inline void idVec3::Set( const float x, const float y, const float z ) {
 this->x = x;
 this->y = y;
 this->z = z;
}

inline void idVec3::Zero( void ) {
 x = y = z = 0.0f;
}

inline idVec3 idVec3::operator-() const {
 return idVec3( -x, -y, -z );
}

inline idVec3 &idVec3::operator=( const idVec3 &a ) {
 x = a.x;
 y = a.y;
 z = a.z;
 return *this;
}

inline idVec3 idVec3::operator-( const idVec3 &a ) const {
 return idVec3( x - a.x, y - a.y, z - a.z );
}

inline float idVec3::operator*( const idVec3 &a ) const {
 return x * a.x + y * a.y + z * a.z;
}

inline idVec3 idVec3::operator*( const float a ) const {
 return idVec3( x * a, y * a, z * a );
}

inline idVec3 idVec3::operator/( const float a ) const {
 float inva = 1.0f / a;
 return idVec3( x * inva, y * inva, z * inva );
}

inline idVec3 operator*( const float a, const idVec3 b ) {
 return idVec3( b.x * a, b.y * a, b.z * a );
}

inline idVec3 idVec3::operator+( const idVec3 &a ) const {
 return idVec3( x + a.x, y + a.y, z + a.z );
}

inline idVec3 &idVec3::operator+=( const idVec3 &a ) {
 x += a.x;
 y += a.y;
 z += a.z;

 return *this;
}

inline idVec3 &idVec3::operator/=( const idVec3 &a ) {
 x /= a.x;
 y /= a.y;
 z /= a.z;

 return *this;
}

inline idVec3 &idVec3::operator/=( const float a ) {
 float inva = 1.0f / a;
 x *= inva;
 y *= inva;
 z *= inva;

 return *this;
}

inline idVec3 &idVec3::operator-=( const idVec3 &a ) {
 x -= a.x;
 y -= a.y;
 z -= a.z;

 return *this;
}

inline idVec3 &idVec3::operator*=( const float a ) {
 x *= a;
 y *= a;
 z *= a;

 return *this;
}

inline bool idVec3::Compare( const idVec3 &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) && ( z == a.z ) );
}

inline bool idVec3::Compare( const idVec3 &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( z - a.z ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idVec3::operator==( const idVec3 &a ) const {
 return Compare( a );
}

inline bool idVec3::operator!=( const idVec3 &a ) const {
 return !Compare( a );
}

inline float idVec3::NormalizeFast( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y + z * z;
 invLength = idMath::RSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 z *= invLength;
 return invLength * sqrLength;
}

inline bool idVec3::FixDegenerateNormal( void ) {
 if ( x == 0.0f ) {
  if ( y == 0.0f ) {
   if ( z > 0.0f ) {
    if ( z != 1.0f ) {
     z = 1.0f;
     return true;
    }
   } else {
    if ( z != -1.0f ) {
     z = -1.0f;
     return true;
    }
   }
   return false;
  } else if ( z == 0.0f ) {
   if ( y > 0.0f ) {
    if ( y != 1.0f ) {
     y = 1.0f;
     return true;
    }
   } else {
    if ( y != -1.0f ) {
     y = -1.0f;
     return true;
    }
   }
   return false;
  }
 } else if ( y == 0.0f ) {
  if ( z == 0.0f ) {
   if ( x > 0.0f ) {
    if ( x != 1.0f ) {
     x = 1.0f;
     return true;
    }
   } else {
    if ( x != -1.0f ) {
     x = -1.0f;
     return true;
    }
   }
   return false;
  }
 }
 if ( idMath::Fabs( x ) == 1.0f ) {
  if ( y != 0.0f || z != 0.0f ) {
   y = z = 0.0f;
   return true;
  }
  return false;
 } else if ( idMath::Fabs( y ) == 1.0f ) {
  if ( x != 0.0f || z != 0.0f ) {
   x = z = 0.0f;
   return true;
  }
  return false;
 } else if ( idMath::Fabs( z ) == 1.0f ) {
  if ( x != 0.0f || y != 0.0f ) {
   x = y = 0.0f;
   return true;
  }
  return false;
 }
 return false;
}

inline bool idVec3::FixDenormals( void ) {
 bool denormal = false;
 if ( fabs( x ) < 1e-30f ) {
  x = 0.0f;
  denormal = true;
 }
 if ( fabs( y ) < 1e-30f ) {
  y = 0.0f;
  denormal = true;
 }
 if ( fabs( z ) < 1e-30f ) {
  z = 0.0f;
  denormal = true;
 }
 return denormal;
}

inline idVec3 idVec3::Cross( const idVec3 &a ) const {
 return idVec3( y * a.z - z * a.y, z * a.x - x * a.z, x * a.y - y * a.x );
}

inline idVec3 &idVec3::Cross( const idVec3 &a, const idVec3 &b ) {
 x = a.y * b.z - a.z * b.y;
 y = a.z * b.x - a.x * b.z;
 z = a.x * b.y - a.y * b.x;

 return *this;
}

inline float idVec3::Length( void ) const {
 return ( float )idMath::Sqrt( x * x + y * y + z * z );
}

inline float idVec3::LengthSqr( void ) const {
 return ( x * x + y * y + z * z );
}

inline float idVec3::LengthFast( void ) const {
 float sqrLength;

 sqrLength = x * x + y * y + z * z;
 return sqrLength * idMath::RSqrt( sqrLength );
}

inline float idVec3::Normalize( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y + z * z;
 invLength = idMath::InvSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 z *= invLength;
 return invLength * sqrLength;
}

inline idVec3 &idVec3::Truncate( float length ) {
 float length2;
 float ilength;

 if ( !length ) {
  Zero();
 }
 else {
  length2 = LengthSqr();
  if ( length2 > length * length ) {
   ilength = length * idMath::InvSqrt( length2 );
   x *= ilength;
   y *= ilength;
   z *= ilength;
  }
 }

 return *this;
}

inline void idVec3::Clamp( const idVec3 &min, const idVec3 &max ) {
 if ( x < min.x ) {
  x = min.x;
 } else if ( x > max.x ) {
  x = max.x;
 }
 if ( y < min.y ) {
  y = min.y;
 } else if ( y > max.y ) {
  y = max.y;
 }
 if ( z < min.z ) {
  z = min.z;
 } else if ( z > max.z ) {
  z = max.z;
 }
}

inline void idVec3::Snap( void ) {
 x = floor( x + 0.5f );
 y = floor( y + 0.5f );
 z = floor( z + 0.5f );
}

inline void idVec3::SnapInt( void ) {
 x = float( int( x ) );
 y = float( int( y ) );
 z = float( int( z ) );
}

inline int idVec3::GetDimension( void ) const {
 return 3;
}

inline const idVec2 &idVec3::ToVec2( void ) const {
 return *reinterpret_cast<const idVec2 *>(this);
}

inline idVec2 &idVec3::ToVec2( void ) {
 return *reinterpret_cast<idVec2 *>(this);
}

inline const float *idVec3::ToFloatPtr( void ) const {
 return &x;
}

inline float *idVec3::ToFloatPtr( void ) {
 return &x;
}

inline void idVec3::NormalVectors( idVec3 &left, idVec3 &down ) const {
 float d;

 d = x * x + y * y;
 if ( !d ) {
  left[0] = 1;
  left[1] = 0;
  left[2] = 0;
 } else {
  d = idMath::InvSqrt( d );
  left[0] = -y * d;
  left[1] = x * d;
  left[2] = 0;
 }
 down = left.Cross( *this );
}

inline void idVec3::OrthogonalBasis( idVec3 &left, idVec3 &up ) const {
 float l, s;

 if ( idMath::Fabs( z ) > 0.7f ) {
  l = y * y + z * z;
  s = idMath::InvSqrt( l );
  up[0] = 0;
  up[1] = z * s;
  up[2] = -y * s;
  left[0] = l * s;
  left[1] = -x * up[2];
  left[2] = x * up[1];
 }
 else {
  l = x * x + y * y;
  s = idMath::InvSqrt( l );
  left[0] = -y * s;
  left[1] = x * s;
  left[2] = 0;
  up[0] = -z * left[1];
  up[1] = z * left[0];
  up[2] = l * s;
 }
}

inline void idVec3::ProjectOntoPlane( const idVec3 &normal, const float overBounce ) {
 float backoff;

 backoff = *this * normal;

 if ( overBounce != 1.0 ) {
  if ( backoff < 0 ) {
   backoff *= overBounce;
  } else {
   backoff /= overBounce;
  }
 }

 *this -= backoff * normal;
}

inline bool idVec3::ProjectAlongPlane( const idVec3 &normal, const float epsilon, const float overBounce ) {
 idVec3 cross;
 float len;

 cross = this->Cross( normal ).Cross( (*this) );

 cross.Normalize();
 len = normal * cross;
 if ( idMath::Fabs( len ) < epsilon ) {
  return false;
 }
 cross *= overBounce * ( normal * (*this) ) / len;
 (*this) -= cross;
 return true;
}
# 808 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Vector.h"
class idVec4 {
public:
 float x;
 float y;
 float z;
 float w;

     idVec4( void );
     explicit idVec4( const float x, const float y, const float z, const float w );

 void Set( const float x, const float y, const float z, const float w );
 void Zero( void );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idVec4 operator-() const;
 float operator*( const idVec4 &a ) const;
 idVec4 operator*( const float a ) const;
 idVec4 operator/( const float a ) const;
 idVec4 operator+( const idVec4 &a ) const;
 idVec4 operator-( const idVec4 &a ) const;
 idVec4 & operator+=( const idVec4 &a );
 idVec4 & operator-=( const idVec4 &a );
 idVec4 & operator/=( const idVec4 &a );
 idVec4 & operator/=( const float a );
 idVec4 & operator*=( const float a );

 friend idVec4 operator*( const float a, const idVec4 b );

 bool Compare( const idVec4 &a ) const;
 bool Compare( const idVec4 &a, const float epsilon ) const;
 bool operator==( const idVec4 &a ) const;
 bool operator!=( const idVec4 &a ) const;

 float Length( void ) const;
 float LengthSqr( void ) const;
 float Normalize( void );
 float NormalizeFast( void );

 int GetDimension( void ) const;

 const idVec2 & ToVec2( void ) const;
 idVec2 & ToVec2( void );
 const idVec3 & ToVec3( void ) const;
 idVec3 & ToVec3( void );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void Lerp( const idVec4 &v1, const idVec4 &v2, const float l );
};

extern idVec4 vec4_origin;


inline idVec4::idVec4( void ) {
}

inline idVec4::idVec4( const float x, const float y, const float z, const float w ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->w = w;
}

inline void idVec4::Set( const float x, const float y, const float z, const float w ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->w = w;
}

inline void idVec4::Zero( void ) {
 x = y = z = w = 0.0f;
}

inline float idVec4::operator[]( int index ) const {
 return ( &x )[ index ];
}

inline float& idVec4::operator[]( int index ) {
 return ( &x )[ index ];
}

inline idVec4 idVec4::operator-() const {
 return idVec4( -x, -y, -z, -w );
}

inline idVec4 idVec4::operator-( const idVec4 &a ) const {
 return idVec4( x - a.x, y - a.y, z - a.z, w - a.w );
}

inline float idVec4::operator*( const idVec4 &a ) const {
 return x * a.x + y * a.y + z * a.z + w * a.w;
}

inline idVec4 idVec4::operator*( const float a ) const {
 return idVec4( x * a, y * a, z * a, w * a );
}

inline idVec4 idVec4::operator/( const float a ) const {
 float inva = 1.0f / a;
 return idVec4( x * inva, y * inva, z * inva, w * inva );
}

inline idVec4 operator*( const float a, const idVec4 b ) {
 return idVec4( b.x * a, b.y * a, b.z * a, b.w * a );
}

inline idVec4 idVec4::operator+( const idVec4 &a ) const {
 return idVec4( x + a.x, y + a.y, z + a.z, w + a.w );
}

inline idVec4 &idVec4::operator+=( const idVec4 &a ) {
 x += a.x;
 y += a.y;
 z += a.z;
 w += a.w;

 return *this;
}

inline idVec4 &idVec4::operator/=( const idVec4 &a ) {
 x /= a.x;
 y /= a.y;
 z /= a.z;
 w /= a.w;

 return *this;
}

inline idVec4 &idVec4::operator/=( const float a ) {
 float inva = 1.0f / a;
 x *= inva;
 y *= inva;
 z *= inva;
 w *= inva;

 return *this;
}

inline idVec4 &idVec4::operator-=( const idVec4 &a ) {
 x -= a.x;
 y -= a.y;
 z -= a.z;
 w -= a.w;

 return *this;
}

inline idVec4 &idVec4::operator*=( const float a ) {
 x *= a;
 y *= a;
 z *= a;
 w *= a;

 return *this;
}

inline bool idVec4::Compare( const idVec4 &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) && ( z == a.z ) && w == a.w );
}

inline bool idVec4::Compare( const idVec4 &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( z - a.z ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( w - a.w ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idVec4::operator==( const idVec4 &a ) const {
 return Compare( a );
}

inline bool idVec4::operator!=( const idVec4 &a ) const {
 return !Compare( a );
}

inline float idVec4::Length( void ) const {
 return ( float )idMath::Sqrt( x * x + y * y + z * z + w * w );
}

inline float idVec4::LengthSqr( void ) const {
 return ( x * x + y * y + z * z + w * w );
}

inline float idVec4::Normalize( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y + z * z + w * w;
 invLength = idMath::InvSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 z *= invLength;
 w *= invLength;
 return invLength * sqrLength;
}

inline float idVec4::NormalizeFast( void ) {
 float sqrLength, invLength;

 sqrLength = x * x + y * y + z * z + w * w;
 invLength = idMath::RSqrt( sqrLength );
 x *= invLength;
 y *= invLength;
 z *= invLength;
 w *= invLength;
 return invLength * sqrLength;
}

inline int idVec4::GetDimension( void ) const {
 return 4;
}

inline const idVec2 &idVec4::ToVec2( void ) const {
 return *reinterpret_cast<const idVec2 *>(this);
}

inline idVec2 &idVec4::ToVec2( void ) {
 return *reinterpret_cast<idVec2 *>(this);
}

inline const idVec3 &idVec4::ToVec3( void ) const {
 return *reinterpret_cast<const idVec3 *>(this);
}

inline idVec3 &idVec4::ToVec3( void ) {
 return *reinterpret_cast<idVec3 *>(this);
}

inline const float *idVec4::ToFloatPtr( void ) const {
 return &x;
}

inline float *idVec4::ToFloatPtr( void ) {
 return &x;
}
# 1066 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Vector.h"
class idVec5 {
public:
 float x;
 float y;
 float z;
 float s;
 float t;

     idVec5( void );
     explicit idVec5( const idVec3 &xyz, const idVec2 &st );
     explicit idVec5( const float x, const float y, const float z, const float s, const float t );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idVec5 & operator=( const idVec3 &a );

 int GetDimension( void ) const;

 const idVec3 & ToVec3( void ) const;
 idVec3 & ToVec3( void );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void Lerp( const idVec5 &v1, const idVec5 &v2, const float l );
};

extern idVec5 vec5_origin;


inline idVec5::idVec5( void ) {
}

inline idVec5::idVec5( const idVec3 &xyz, const idVec2 &st ) {
 x = xyz.x;
 y = xyz.y;
 z = xyz.z;
 s = st[0];
 t = st[1];
}

inline idVec5::idVec5( const float x, const float y, const float z, const float s, const float t ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->s = s;
 this->t = t;
}

inline float idVec5::operator[]( int index ) const {
 return ( &x )[ index ];
}

inline float& idVec5::operator[]( int index ) {
 return ( &x )[ index ];
}

inline idVec5 &idVec5::operator=( const idVec3 &a ) {
 x = a.x;
 y = a.y;
 z = a.z;
 s = t = 0;
 return *this;
}

inline int idVec5::GetDimension( void ) const {
 return 5;
}

inline const idVec3 &idVec5::ToVec3( void ) const {
 return *reinterpret_cast<const idVec3 *>(this);
}

inline idVec3 &idVec5::ToVec3( void ) {
 return *reinterpret_cast<idVec3 *>(this);
}

inline const float *idVec5::ToFloatPtr( void ) const {
 return &x;
}

inline float *idVec5::ToFloatPtr( void ) {
 return &x;
}
# 1158 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Vector.h"
class idVec6 {
public:
     idVec6( void );
     explicit idVec6( const float *a );
     explicit idVec6( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 );

 void Set( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 );
 void Zero( void );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idVec6 operator-() const;
 idVec6 operator*( const float a ) const;
 idVec6 operator/( const float a ) const;
 float operator*( const idVec6 &a ) const;
 idVec6 operator-( const idVec6 &a ) const;
 idVec6 operator+( const idVec6 &a ) const;
 idVec6 & operator*=( const float a );
 idVec6 & operator/=( const float a );
 idVec6 & operator+=( const idVec6 &a );
 idVec6 & operator-=( const idVec6 &a );

 friend idVec6 operator*( const float a, const idVec6 b );

 bool Compare( const idVec6 &a ) const;
 bool Compare( const idVec6 &a, const float epsilon ) const;
 bool operator==( const idVec6 &a ) const;
 bool operator!=( const idVec6 &a ) const;

 float Length( void ) const;
 float LengthSqr( void ) const;
 float Normalize( void );
 float NormalizeFast( void );

 int GetDimension( void ) const;

 const idVec3 & SubVec3( int index ) const;
 idVec3 & SubVec3( int index );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 float p[6];
};

extern idVec6 vec6_origin;

extern idVec6 vec6_infinity;

inline idVec6::idVec6( void ) {
}

inline idVec6::idVec6( const float *a ) {
 memcpy( p, a, 6 * sizeof( float ) );
}

inline idVec6::idVec6( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 ) {
 p[0] = a1;
 p[1] = a2;
 p[2] = a3;
 p[3] = a4;
 p[4] = a5;
 p[5] = a6;
}

inline idVec6 idVec6::operator-() const {
 return idVec6( -p[0], -p[1], -p[2], -p[3], -p[4], -p[5] );
}

inline float idVec6::operator[]( const int index ) const {
 return p[index];
}

inline float &idVec6::operator[]( const int index ) {
 return p[index];
}

inline idVec6 idVec6::operator*( const float a ) const {
 return idVec6( p[0]*a, p[1]*a, p[2]*a, p[3]*a, p[4]*a, p[5]*a );
}

inline float idVec6::operator*( const idVec6 &a ) const {
 return p[0] * a[0] + p[1] * a[1] + p[2] * a[2] + p[3] * a[3] + p[4] * a[4] + p[5] * a[5];
}

inline idVec6 idVec6::operator/( const float a ) const {
 float inva;

 ((void)0);
 inva = 1.0f / a;
 return idVec6( p[0]*inva, p[1]*inva, p[2]*inva, p[3]*inva, p[4]*inva, p[5]*inva );
}

inline idVec6 idVec6::operator+( const idVec6 &a ) const {
 return idVec6( p[0] + a[0], p[1] + a[1], p[2] + a[2], p[3] + a[3], p[4] + a[4], p[5] + a[5] );
}

inline idVec6 idVec6::operator-( const idVec6 &a ) const {
 return idVec6( p[0] - a[0], p[1] - a[1], p[2] - a[2], p[3] - a[3], p[4] - a[4], p[5] - a[5] );
}

inline idVec6 &idVec6::operator*=( const float a ) {
 p[0] *= a;
 p[1] *= a;
 p[2] *= a;
 p[3] *= a;
 p[4] *= a;
 p[5] *= a;
 return *this;
}

inline idVec6 &idVec6::operator/=( const float a ) {
 float inva;

 ((void)0);
 inva = 1.0f / a;
 p[0] *= inva;
 p[1] *= inva;
 p[2] *= inva;
 p[3] *= inva;
 p[4] *= inva;
 p[5] *= inva;
 return *this;
}

inline idVec6 &idVec6::operator+=( const idVec6 &a ) {
 p[0] += a[0];
 p[1] += a[1];
 p[2] += a[2];
 p[3] += a[3];
 p[4] += a[4];
 p[5] += a[5];
 return *this;
}

inline idVec6 &idVec6::operator-=( const idVec6 &a ) {
 p[0] -= a[0];
 p[1] -= a[1];
 p[2] -= a[2];
 p[3] -= a[3];
 p[4] -= a[4];
 p[5] -= a[5];
 return *this;
}

inline idVec6 operator*( const float a, const idVec6 b ) {
 return b * a;
}

inline bool idVec6::Compare( const idVec6 &a ) const {
 return ( ( p[0] == a[0] ) && ( p[1] == a[1] ) && ( p[2] == a[2] ) &&
   ( p[3] == a[3] ) && ( p[4] == a[4] ) && ( p[5] == a[5] ) );
}

inline bool idVec6::Compare( const idVec6 &a, const float epsilon ) const {
 if ( idMath::Fabs( p[0] - a[0] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[1] - a[1] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[2] - a[2] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[3] - a[3] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[4] - a[4] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[5] - a[5] ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idVec6::operator==( const idVec6 &a ) const {
 return Compare( a );
}

inline bool idVec6::operator!=( const idVec6 &a ) const {
 return !Compare( a );
}

inline void idVec6::Set( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 ) {
 p[0] = a1;
 p[1] = a2;
 p[2] = a3;
 p[3] = a4;
 p[4] = a5;
 p[5] = a6;
}

inline void idVec6::Zero( void ) {
 p[0] = p[1] = p[2] = p[3] = p[4] = p[5] = 0.0f;
}

inline float idVec6::Length( void ) const {
 return ( float )idMath::Sqrt( p[0] * p[0] + p[1] * p[1] + p[2] * p[2] + p[3] * p[3] + p[4] * p[4] + p[5] * p[5] );
}

inline float idVec6::LengthSqr( void ) const {
 return ( p[0] * p[0] + p[1] * p[1] + p[2] * p[2] + p[3] * p[3] + p[4] * p[4] + p[5] * p[5] );
}

inline float idVec6::Normalize( void ) {
 float sqrLength, invLength;

 sqrLength = p[0] * p[0] + p[1] * p[1] + p[2] * p[2] + p[3] * p[3] + p[4] * p[4] + p[5] * p[5];
 invLength = idMath::InvSqrt( sqrLength );
 p[0] *= invLength;
 p[1] *= invLength;
 p[2] *= invLength;
 p[3] *= invLength;
 p[4] *= invLength;
 p[5] *= invLength;
 return invLength * sqrLength;
}

inline float idVec6::NormalizeFast( void ) {
 float sqrLength, invLength;

 sqrLength = p[0] * p[0] + p[1] * p[1] + p[2] * p[2] + p[3] * p[3] + p[4] * p[4] + p[5] * p[5];
 invLength = idMath::RSqrt( sqrLength );
 p[0] *= invLength;
 p[1] *= invLength;
 p[2] *= invLength;
 p[3] *= invLength;
 p[4] *= invLength;
 p[5] *= invLength;
 return invLength * sqrLength;
}

inline int idVec6::GetDimension( void ) const {
 return 6;
}

inline const idVec3 &idVec6::SubVec3( int index ) const {
 return *reinterpret_cast<const idVec3 *>(p + index * 3);
}

inline idVec3 &idVec6::SubVec3( int index ) {
 return *reinterpret_cast<idVec3 *>(p + index * 3);
}

inline const float *idVec6::ToFloatPtr( void ) const {
 return p;
}

inline float *idVec6::ToFloatPtr( void ) {
 return p;
}
# 1435 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Vector.h"
class idVecX {
 friend class idMatX;

public:
     idVecX( void );
     explicit idVecX( int length );
     explicit idVecX( int length, float *data );
     ~idVecX( void );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idVecX operator-() const;
 idVecX & operator=( const idVecX &a );
 idVecX operator*( const float a ) const;
 idVecX operator/( const float a ) const;
 float operator*( const idVecX &a ) const;
 idVecX operator-( const idVecX &a ) const;
 idVecX operator+( const idVecX &a ) const;
 idVecX & operator*=( const float a );
 idVecX & operator/=( const float a );
 idVecX & operator+=( const idVecX &a );
 idVecX & operator-=( const idVecX &a );

 friend idVecX operator*( const float a, const idVecX b );

 bool Compare( const idVecX &a ) const;
 bool Compare( const idVecX &a, const float epsilon ) const;
 bool operator==( const idVecX &a ) const;
 bool operator!=( const idVecX &a ) const;

 void SetSize( int size );
 void ChangeSize( int size, bool makeZero = false );
 int GetSize( void ) const { return size; }
 void SetData( int length, float *data );
 void Zero( void );
 void Zero( int length );
 void Random( int seed, float l = 0.0f, float u = 1.0f );
 void Random( int length, int seed, float l = 0.0f, float u = 1.0f );
 void Negate( void );
 void Clamp( float min, float max );
 idVecX & SwapElements( int e1, int e2 );

 float Length( void ) const;
 float LengthSqr( void ) const;
 idVecX Normalize( void ) const;
 float NormalizeSelf( void );

 int GetDimension( void ) const;

 const idVec3 & SubVec3( int index ) const;
 idVec3 & SubVec3( int index );
 const idVec6 & SubVec6( int index ) const;
 idVec6 & SubVec6( int index );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 int size;
 int alloced;
 float * p;

 static float temp[1024 +4];
 static float * tempPtr;
 static int tempIndex;

private:
 void SetTempSize( int size );
};


inline idVecX::idVecX( void ) {
 size = alloced = 0;
 p = __null;
}

inline idVecX::idVecX( int length ) {
 size = alloced = 0;
 p = __null;
 SetSize( length );
}

inline idVecX::idVecX( int length, float *data ) {
 size = alloced = 0;
 p = __null;
 SetData( length, data );
}

inline idVecX::~idVecX( void ) {

 if ( p && ( p < idVecX::tempPtr || p >= idVecX::tempPtr + 1024 ) && alloced != -1 ) {
  Mem_Free16( p );
 }
}

inline float idVecX::operator[]( const int index ) const {
 ((void)0);
 return p[index];
}

inline float &idVecX::operator[]( const int index ) {
 ((void)0);
 return p[index];
}

inline idVecX idVecX::operator-() const {
 int i;
 idVecX m;

 m.SetTempSize( size );
 for ( i = 0; i < size; i++ ) {
  m.p[i] = -p[i];
 }
 return m;
}

inline idVecX &idVecX::operator=( const idVecX &a ) {
 SetSize( a.size );

 SIMDProcessor->Copy16( p, a.p, a.size );



 idVecX::tempIndex = 0;
 return *this;
}

inline idVecX idVecX::operator+( const idVecX &a ) const {
 idVecX m;

 ((void)0);
 m.SetTempSize( size );

 SIMDProcessor->Add16( m.p, p, a.p, size );






 return m;
}

inline idVecX idVecX::operator-( const idVecX &a ) const {
 idVecX m;

 ((void)0);
 m.SetTempSize( size );

 SIMDProcessor->Sub16( m.p, p, a.p, size );






 return m;
}

inline idVecX &idVecX::operator+=( const idVecX &a ) {
 ((void)0);

 SIMDProcessor->AddAssign16( p, a.p, size );






 idVecX::tempIndex = 0;
 return *this;
}

inline idVecX &idVecX::operator-=( const idVecX &a ) {
 ((void)0);

 SIMDProcessor->SubAssign16( p, a.p, size );






 idVecX::tempIndex = 0;
 return *this;
}

inline idVecX idVecX::operator*( const float a ) const {
 idVecX m;

 m.SetTempSize( size );

 SIMDProcessor->Mul16( m.p, p, a, size );






 return m;
}

inline idVecX &idVecX::operator*=( const float a ) {

 SIMDProcessor->MulAssign16( p, a, size );






 return *this;
}

inline idVecX idVecX::operator/( const float a ) const {
 ((void)0);
 return (*this) * ( 1.0f / a );
}

inline idVecX &idVecX::operator/=( const float a ) {
 ((void)0);
 (*this) *= ( 1.0f / a );
 return *this;
}

inline idVecX operator*( const float a, const idVecX b ) {
 return b * a;
}

inline float idVecX::operator*( const idVecX &a ) const {
 int i;
 float sum = 0.0f;

 ((void)0);
 for ( i = 0; i < size; i++ ) {
  sum += p[i] * a.p[i];
 }
 return sum;
}

inline bool idVecX::Compare( const idVecX &a ) const {
 int i;

 ((void)0);
 for ( i = 0; i < size; i++ ) {
  if ( p[i] != a.p[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idVecX::Compare( const idVecX &a, const float epsilon ) const {
 int i;

 ((void)0);
 for ( i = 0; i < size; i++ ) {
  if ( idMath::Fabs( p[i] - a.p[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idVecX::operator==( const idVecX &a ) const {
 return Compare( a );
}

inline bool idVecX::operator!=( const idVecX &a ) const {
 return !Compare( a );
}

inline void idVecX::SetSize( int newSize ) {
 int alloc = ( newSize + 3 ) & ~3;
 if ( alloc > alloced && alloced != -1 ) {
  if ( p ) {
   Mem_Free16( p );
  }
  p = (float *) Mem_Alloc16( alloc * sizeof( float ) );
  alloced = alloc;
 }
 size = newSize;
 int s = size; while( s < ( ( s + 3) & ~3 ) ) { p[s++] = 0.0f; };
}

inline void idVecX::ChangeSize( int newSize, bool makeZero ) {
 int alloc = ( newSize + 3 ) & ~3;
 if ( alloc > alloced && alloced != -1 ) {
  float *oldVec = p;
  p = (float *) Mem_Alloc16( alloc * sizeof( float ) );
  alloced = alloc;
  if ( oldVec ) {
   for ( int i = 0; i < size; i++ ) {
    p[i] = oldVec[i];
   }
   Mem_Free16( oldVec );
  }
  if ( makeZero ) {

   for ( int i = size; i < newSize; i++ ) {
    p[i] = 0.0f;
   }
  }
 }
 size = newSize;
 int s = size; while( s < ( ( s + 3) & ~3 ) ) { p[s++] = 0.0f; };
}

inline void idVecX::SetTempSize( int newSize ) {

 size = newSize;
 alloced = ( newSize + 3 ) & ~3;
 ((void)0);
 if ( idVecX::tempIndex + alloced > 1024 ) {
  idVecX::tempIndex = 0;
 }
 p = idVecX::tempPtr + idVecX::tempIndex;
 idVecX::tempIndex += alloced;
 int s = size; while( s < ( ( s + 3) & ~3 ) ) { p[s++] = 0.0f; };
}

inline void idVecX::SetData( int length, float *data ) {
 if ( p && ( p < idVecX::tempPtr || p >= idVecX::tempPtr + 1024 ) && alloced != -1 ) {
  Mem_Free16( p );
 }
 ((void)0);
 p = data;
 size = length;
 alloced = -1;
 int s = size; while( s < ( ( s + 3) & ~3 ) ) { p[s++] = 0.0f; };
}

inline void idVecX::Zero( void ) {

 SIMDProcessor->Zero16( p, size );



}

inline void idVecX::Zero( int length ) {
 SetSize( length );

 SIMDProcessor->Zero16( p, length );



}

inline void idVecX::Random( int seed, float l, float u ) {
 int i;
 float c;
 idRandom rnd( seed );

 c = u - l;
 for ( i = 0; i < size; i++ ) {
  p[i] = l + rnd.RandomFloat() * c;
 }
}

inline void idVecX::Random( int length, int seed, float l, float u ) {
 int i;
 float c;
 idRandom rnd( seed );

 SetSize( length );
 c = u - l;
 for ( i = 0; i < size; i++ ) {
  p[i] = l + rnd.RandomFloat() * c;
 }
}

inline void idVecX::Negate( void ) {

 SIMDProcessor->Negate16( p, size );






}

inline void idVecX::Clamp( float min, float max ) {
 int i;
 for ( i = 0; i < size; i++ ) {
  if ( p[i] < min ) {
   p[i] = min;
  } else if ( p[i] > max ) {
   p[i] = max;
  }
 }
}

inline idVecX &idVecX::SwapElements( int e1, int e2 ) {
 float tmp;
 tmp = p[e1];
 p[e1] = p[e2];
 p[e2] = tmp;
 return *this;
}

inline float idVecX::Length( void ) const {
 int i;
 float sum = 0.0f;

 for ( i = 0; i < size; i++ ) {
  sum += p[i] * p[i];
 }
 return idMath::Sqrt( sum );
}

inline float idVecX::LengthSqr( void ) const {
 int i;
 float sum = 0.0f;

 for ( i = 0; i < size; i++ ) {
  sum += p[i] * p[i];
 }
 return sum;
}

inline idVecX idVecX::Normalize( void ) const {
 int i;
 idVecX m;
 float invSqrt, sum = 0.0f;

 m.SetTempSize( size );
 for ( i = 0; i < size; i++ ) {
  sum += p[i] * p[i];
 }
 invSqrt = idMath::InvSqrt( sum );
 for ( i = 0; i < size; i++ ) {
  m.p[i] = p[i] * invSqrt;
 }
 return m;
}

inline float idVecX::NormalizeSelf( void ) {
 float invSqrt, sum = 0.0f;
 int i;
 for ( i = 0; i < size; i++ ) {
  sum += p[i] * p[i];
 }
 invSqrt = idMath::InvSqrt( sum );
 for ( i = 0; i < size; i++ ) {
  p[i] *= invSqrt;
 }
 return invSqrt * sum;
}

inline int idVecX::GetDimension( void ) const {
 return size;
}

inline idVec3 &idVecX::SubVec3( int index ) {
 ((void)0);
 return *reinterpret_cast<idVec3 *>(p + index * 3);
}

inline const idVec3 &idVecX::SubVec3( int index ) const {
 ((void)0);
 return *reinterpret_cast<const idVec3 *>(p + index * 3);
}

inline idVec6 &idVecX::SubVec6( int index ) {
 ((void)0);
 return *reinterpret_cast<idVec6 *>(p + index * 6);
}

inline const idVec6 &idVecX::SubVec6( int index ) const {
 ((void)0);
 return *reinterpret_cast<const idVec6 *>(p + index * 6);
}

inline const float *idVecX::ToFloatPtr( void ) const {
 return p;
}

inline float *idVecX::ToFloatPtr( void ) {
 return p;
}
# 1925 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Vector.h"
class idPolar3 {
public:
 float radius, theta, phi;

     idPolar3( void );
     explicit idPolar3( const float radius, const float theta, const float phi );

 void Set( const float radius, const float theta, const float phi );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idPolar3 operator-() const;
 idPolar3 & operator=( const idPolar3 &a );

 idVec3 ToVec3( void ) const;
};

inline idPolar3::idPolar3( void ) {
}

inline idPolar3::idPolar3( const float radius, const float theta, const float phi ) {
 ((void)0);
 this->radius = radius;
 this->theta = theta;
 this->phi = phi;
}

inline void idPolar3::Set( const float radius, const float theta, const float phi ) {
 ((void)0);
 this->radius = radius;
 this->theta = theta;
 this->phi = phi;
}

inline float idPolar3::operator[]( const int index ) const {
 return ( &radius )[ index ];
}

inline float &idPolar3::operator[]( const int index ) {
 return ( &radius )[ index ];
}

inline idPolar3 idPolar3::operator-() const {
 return idPolar3( radius, -theta, -phi );
}

inline idPolar3 &idPolar3::operator=( const idPolar3 &a ) {
 radius = a.radius;
 theta = a.theta;
 phi = a.phi;
 return *this;
}

inline idVec3 idPolar3::ToVec3( void ) const {
 float sp, cp, st, ct;
 idMath::SinCos( phi, sp, cp );
 idMath::SinCos( theta, st, ct );
  return idVec3( cp * radius * ct, cp * radius * st, radius * sp );
}
# 179 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
class idAngles;
class idQuat;
class idCQuat;
class idRotation;
class idMat4;







class idMat2 {
public:
     idMat2( void );
     explicit idMat2( const idVec2 &x, const idVec2 &y );
     explicit idMat2( const float xx, const float xy, const float yx, const float yy );
     explicit idMat2( const float src[ 2 ][ 2 ] );

 const idVec2 & operator[]( int index ) const;
 idVec2 & operator[]( int index );
 idMat2 operator-() const;
 idMat2 operator*( const float a ) const;
 idVec2 operator*( const idVec2 &vec ) const;
 idMat2 operator*( const idMat2 &a ) const;
 idMat2 operator+( const idMat2 &a ) const;
 idMat2 operator-( const idMat2 &a ) const;
 idMat2 & operator*=( const float a );
 idMat2 & operator*=( const idMat2 &a );
 idMat2 & operator+=( const idMat2 &a );
 idMat2 & operator-=( const idMat2 &a );

 friend idMat2 operator*( const float a, const idMat2 &mat );
 friend idVec2 operator*( const idVec2 &vec, const idMat2 &mat );
 friend idVec2 & operator*=( idVec2 &vec, const idMat2 &mat );

 bool Compare( const idMat2 &a ) const;
 bool Compare( const idMat2 &a, const float epsilon ) const;
 bool operator==( const idMat2 &a ) const;
 bool operator!=( const idMat2 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;

 float Trace( void ) const;
 float Determinant( void ) const;
 idMat2 Transpose( void ) const;
 idMat2 & TransposeSelf( void );
 idMat2 Inverse( void ) const;
 bool InverseSelf( void );
 idMat2 InverseFast( void ) const;
 bool InverseFastSelf( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 idVec2 mat[ 2 ];
};

extern idMat2 mat2_zero;
extern idMat2 mat2_identity;


inline idMat2::idMat2( void ) {
}

inline idMat2::idMat2( const idVec2 &x, const idVec2 &y ) {
 mat[ 0 ].x = x.x; mat[ 0 ].y = x.y;
 mat[ 1 ].x = y.x; mat[ 1 ].y = y.y;
}

inline idMat2::idMat2( const float xx, const float xy, const float yx, const float yy ) {
 mat[ 0 ].x = xx; mat[ 0 ].y = xy;
 mat[ 1 ].x = yx; mat[ 1 ].y = yy;
}

inline idMat2::idMat2( const float src[ 2 ][ 2 ] ) {
 memcpy( mat, src, 2 * 2 * sizeof( float ) );
}

inline const idVec2 &idMat2::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec2 &idMat2::operator[]( int index ) {

 return mat[ index ];
}

inline idMat2 idMat2::operator-() const {
 return idMat2( -mat[0][0], -mat[0][1],
     -mat[1][0], -mat[1][1] );
}

inline idVec2 idMat2::operator*( const idVec2 &vec ) const {
 return idVec2(
  mat[ 0 ].x * vec.x + mat[ 0 ].y * vec.y,
  mat[ 1 ].x * vec.x + mat[ 1 ].y * vec.y );
}

inline idMat2 idMat2::operator*( const idMat2 &a ) const {
 return idMat2(
  mat[0].x * a[0].x + mat[0].y * a[1].x,
  mat[0].x * a[0].y + mat[0].y * a[1].y,
  mat[1].x * a[0].x + mat[1].y * a[1].x,
  mat[1].x * a[0].y + mat[1].y * a[1].y );
}

inline idMat2 idMat2::operator*( const float a ) const {
 return idMat2(
  mat[0].x * a, mat[0].y * a,
  mat[1].x * a, mat[1].y * a );
}

inline idMat2 idMat2::operator+( const idMat2 &a ) const {
 return idMat2(
  mat[0].x + a[0].x, mat[0].y + a[0].y,
  mat[1].x + a[1].x, mat[1].y + a[1].y );
}

inline idMat2 idMat2::operator-( const idMat2 &a ) const {
 return idMat2(
  mat[0].x - a[0].x, mat[0].y - a[0].y,
  mat[1].x - a[1].x, mat[1].y - a[1].y );
}

inline idMat2 &idMat2::operator*=( const float a ) {
 mat[0].x *= a; mat[0].y *= a;
 mat[1].x *= a; mat[1].y *= a;

    return *this;
}

inline idMat2 &idMat2::operator*=( const idMat2 &a ) {
 float x, y;
 x = mat[0].x; y = mat[0].y;
 mat[0].x = x * a[0].x + y * a[1].x;
 mat[0].y = x * a[0].y + y * a[1].y;
 x = mat[1].x; y = mat[1].y;
 mat[1].x = x * a[0].x + y * a[1].x;
 mat[1].y = x * a[0].y + y * a[1].y;
 return *this;
}

inline idMat2 &idMat2::operator+=( const idMat2 &a ) {
 mat[0].x += a[0].x; mat[0].y += a[0].y;
 mat[1].x += a[1].x; mat[1].y += a[1].y;

    return *this;
}

inline idMat2 &idMat2::operator-=( const idMat2 &a ) {
 mat[0].x -= a[0].x; mat[0].y -= a[0].y;
 mat[1].x -= a[1].x; mat[1].y -= a[1].y;

    return *this;
}

inline idVec2 operator*( const idVec2 &vec, const idMat2 &mat ) {
 return mat * vec;
}

inline idMat2 operator*( const float a, idMat2 const &mat ) {
 return mat * a;
}

inline idVec2 &operator*=( idVec2 &vec, const idMat2 &mat ) {
 vec = mat * vec;
 return vec;
}

inline bool idMat2::Compare( const idMat2 &a ) const {
 if ( mat[0].Compare( a[0] ) &&
  mat[1].Compare( a[1] ) ) {
  return true;
 }
 return false;
}

inline bool idMat2::Compare( const idMat2 &a, const float epsilon ) const {
 if ( mat[0].Compare( a[0], epsilon ) &&
  mat[1].Compare( a[1], epsilon ) ) {
  return true;
 }
 return false;
}

inline bool idMat2::operator==( const idMat2 &a ) const {
 return Compare( a );
}

inline bool idMat2::operator!=( const idMat2 &a ) const {
 return !Compare( a );
}

inline void idMat2::Zero( void ) {
 mat[0].Zero();
 mat[1].Zero();
}

inline void idMat2::Identity( void ) {
 *this = mat2_identity;
}

inline bool idMat2::IsIdentity( const float epsilon ) const {
 return Compare( mat2_identity, epsilon );
}

inline bool idMat2::IsSymmetric( const float epsilon ) const {
 return ( idMath::Fabs( mat[0][1] - mat[1][0] ) < epsilon );
}

inline bool idMat2::IsDiagonal( const float epsilon ) const {
 if ( idMath::Fabs( mat[0][1] ) > epsilon ||
  idMath::Fabs( mat[1][0] ) > epsilon ) {
  return false;
 }
 return true;
}

inline float idMat2::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] );
}

inline float idMat2::Determinant( void ) const {
 return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
}

inline idMat2 idMat2::Transpose( void ) const {
 return idMat2( mat[0][0], mat[1][0],
     mat[0][1], mat[1][1] );
}

inline idMat2 &idMat2::TransposeSelf( void ) {
 float tmp;

 tmp = mat[0][1];
 mat[0][1] = mat[1][0];
 mat[1][0] = tmp;

 return *this;
}

inline idMat2 idMat2::Inverse( void ) const {
 idMat2 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat2 idMat2::InverseFast( void ) const {
 idMat2 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline int idMat2::GetDimension( void ) const {
 return 4;
}

inline const float *idMat2::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat2::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 333 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
class idMat3 {
public:
     idMat3( void );
     explicit idMat3( const idVec3 &x, const idVec3 &y, const idVec3 &z );
     explicit idMat3( const float xx, const float xy, const float xz, const float yx, const float yy, const float yz, const float zx, const float zy, const float zz );
     explicit idMat3( const float src[ 3 ][ 3 ] );

 const idVec3 & operator[]( int index ) const;
 idVec3 & operator[]( int index );
 idMat3 operator-() const;
 idMat3 operator*( const float a ) const;
 idVec3 operator*( const idVec3 &vec ) const;
 idMat3 operator*( const idMat3 &a ) const;
 idMat3 operator+( const idMat3 &a ) const;
 idMat3 operator-( const idMat3 &a ) const;
 idMat3 & operator*=( const float a );
 idMat3 & operator*=( const idMat3 &a );
 idMat3 & operator+=( const idMat3 &a );
 idMat3 & operator-=( const idMat3 &a );

 friend idMat3 operator*( const float a, const idMat3 &mat );
 friend idVec3 operator*( const idVec3 &vec, const idMat3 &mat );
 friend idVec3 & operator*=( idVec3 &vec, const idMat3 &mat );

 bool Compare( const idMat3 &a ) const;
 bool Compare( const idMat3 &a, const float epsilon ) const;
 bool operator==( const idMat3 &a ) const;
 bool operator!=( const idMat3 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;
 bool IsRotated( void ) const;

 void ProjectVector( const idVec3 &src, idVec3 &dst ) const;
 void UnprojectVector( const idVec3 &src, idVec3 &dst ) const;

 bool FixDegeneracies( void );
 bool FixDenormals( void );

 float Trace( void ) const;
 float Determinant( void ) const;
 idMat3 OrthoNormalize( void ) const;
 idMat3 & OrthoNormalizeSelf( void );
 idMat3 Transpose( void ) const;
 idMat3 & TransposeSelf( void );
 idMat3 Inverse( void ) const;
 bool InverseSelf( void );
 idMat3 InverseFast( void ) const;
 bool InverseFastSelf( void );
 idMat3 TransposeMultiply( const idMat3 &b ) const;

 idMat3 InertiaTranslate( const float mass, const idVec3 &centerOfMass, const idVec3 &translation ) const;
 idMat3 & InertiaTranslateSelf( const float mass, const idVec3 &centerOfMass, const idVec3 &translation );
 idMat3 InertiaRotate( const idMat3 &rotation ) const;
 idMat3 & InertiaRotateSelf( const idMat3 &rotation );

 int GetDimension( void ) const;

 idAngles ToAngles( void ) const;
 idQuat ToQuat( void ) const;
 idCQuat ToCQuat( void ) const;
 idRotation ToRotation( void ) const;
 idMat4 ToMat4( void ) const;
 idVec3 ToAngularVelocity( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 friend void TransposeMultiply( const idMat3 &inv, const idMat3 &b, idMat3 &dst );
 friend idMat3 SkewSymmetric( idVec3 const &src );

private:
 idVec3 mat[ 3 ];
};

extern idMat3 mat3_zero;
extern idMat3 mat3_identity;


inline idMat3::idMat3( void ) {
}

inline idMat3::idMat3( const idVec3 &x, const idVec3 &y, const idVec3 &z ) {
 mat[ 0 ].x = x.x; mat[ 0 ].y = x.y; mat[ 0 ].z = x.z;
 mat[ 1 ].x = y.x; mat[ 1 ].y = y.y; mat[ 1 ].z = y.z;
 mat[ 2 ].x = z.x; mat[ 2 ].y = z.y; mat[ 2 ].z = z.z;
}

inline idMat3::idMat3( const float xx, const float xy, const float xz, const float yx, const float yy, const float yz, const float zx, const float zy, const float zz ) {
 mat[ 0 ].x = xx; mat[ 0 ].y = xy; mat[ 0 ].z = xz;
 mat[ 1 ].x = yx; mat[ 1 ].y = yy; mat[ 1 ].z = yz;
 mat[ 2 ].x = zx; mat[ 2 ].y = zy; mat[ 2 ].z = zz;
}

inline idMat3::idMat3( const float src[ 3 ][ 3 ] ) {
 memcpy( mat, src, 3 * 3 * sizeof( float ) );
}

inline const idVec3 &idMat3::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec3 &idMat3::operator[]( int index ) {

 return mat[ index ];
}

inline idMat3 idMat3::operator-() const {
 return idMat3( -mat[0][0], -mat[0][1], -mat[0][2],
     -mat[1][0], -mat[1][1], -mat[1][2],
     -mat[2][0], -mat[2][1], -mat[2][2] );
}

inline idVec3 idMat3::operator*( const idVec3 &vec ) const {
 return idVec3(
  mat[ 0 ].x * vec.x + mat[ 1 ].x * vec.y + mat[ 2 ].x * vec.z,
  mat[ 0 ].y * vec.x + mat[ 1 ].y * vec.y + mat[ 2 ].y * vec.z,
  mat[ 0 ].z * vec.x + mat[ 1 ].z * vec.y + mat[ 2 ].z * vec.z );
}

inline idMat3 idMat3::operator*( const idMat3 &a ) const {
 int i, j;
 const float *m1Ptr, *m2Ptr;
 float *dstPtr;
 idMat3 dst;

 m1Ptr = reinterpret_cast<const float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);
 dstPtr = reinterpret_cast<float *>(&dst);

 for ( i = 0; i < 3; i++ ) {
  for ( j = 0; j < 3; j++ ) {
   *dstPtr = m1Ptr[0] * m2Ptr[ 0 * 3 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 3 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 3 + j ];
   dstPtr++;
  }
  m1Ptr += 3;
 }
 return dst;
}

inline idMat3 idMat3::operator*( const float a ) const {
 return idMat3(
  mat[0].x * a, mat[0].y * a, mat[0].z * a,
  mat[1].x * a, mat[1].y * a, mat[1].z * a,
  mat[2].x * a, mat[2].y * a, mat[2].z * a );
}

inline idMat3 idMat3::operator+( const idMat3 &a ) const {
 return idMat3(
  mat[0].x + a[0].x, mat[0].y + a[0].y, mat[0].z + a[0].z,
  mat[1].x + a[1].x, mat[1].y + a[1].y, mat[1].z + a[1].z,
  mat[2].x + a[2].x, mat[2].y + a[2].y, mat[2].z + a[2].z );
}

inline idMat3 idMat3::operator-( const idMat3 &a ) const {
 return idMat3(
  mat[0].x - a[0].x, mat[0].y - a[0].y, mat[0].z - a[0].z,
  mat[1].x - a[1].x, mat[1].y - a[1].y, mat[1].z - a[1].z,
  mat[2].x - a[2].x, mat[2].y - a[2].y, mat[2].z - a[2].z );
}

inline idMat3 &idMat3::operator*=( const float a ) {
 mat[0].x *= a; mat[0].y *= a; mat[0].z *= a;
 mat[1].x *= a; mat[1].y *= a; mat[1].z *= a;
 mat[2].x *= a; mat[2].y *= a; mat[2].z *= a;

    return *this;
}

inline idMat3 &idMat3::operator*=( const idMat3 &a ) {
 int i, j;
 const float *m2Ptr;
 float *m1Ptr, dst[3];

 m1Ptr = reinterpret_cast<float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);

 for ( i = 0; i < 3; i++ ) {
  for ( j = 0; j < 3; j++ ) {
   dst[j] = m1Ptr[0] * m2Ptr[ 0 * 3 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 3 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 3 + j ];
  }
  m1Ptr[0] = dst[0]; m1Ptr[1] = dst[1]; m1Ptr[2] = dst[2];
  m1Ptr += 3;
 }
 return *this;
}

inline idMat3 &idMat3::operator+=( const idMat3 &a ) {
 mat[0].x += a[0].x; mat[0].y += a[0].y; mat[0].z += a[0].z;
 mat[1].x += a[1].x; mat[1].y += a[1].y; mat[1].z += a[1].z;
 mat[2].x += a[2].x; mat[2].y += a[2].y; mat[2].z += a[2].z;

    return *this;
}

inline idMat3 &idMat3::operator-=( const idMat3 &a ) {
 mat[0].x -= a[0].x; mat[0].y -= a[0].y; mat[0].z -= a[0].z;
 mat[1].x -= a[1].x; mat[1].y -= a[1].y; mat[1].z -= a[1].z;
 mat[2].x -= a[2].x; mat[2].y -= a[2].y; mat[2].z -= a[2].z;

    return *this;
}

inline idVec3 operator*( const idVec3 &vec, const idMat3 &mat ) {
 return mat * vec;
}

inline idMat3 operator*( const float a, const idMat3 &mat ) {
 return mat * a;
}

inline idVec3 &operator*=( idVec3 &vec, const idMat3 &mat ) {
 float x = mat[ 0 ].x * vec.x + mat[ 1 ].x * vec.y + mat[ 2 ].x * vec.z;
 float y = mat[ 0 ].y * vec.x + mat[ 1 ].y * vec.y + mat[ 2 ].y * vec.z;
 vec.z = mat[ 0 ].z * vec.x + mat[ 1 ].z * vec.y + mat[ 2 ].z * vec.z;
 vec.x = x;
 vec.y = y;
 return vec;
}

inline bool idMat3::Compare( const idMat3 &a ) const {
 if ( mat[0].Compare( a[0] ) &&
  mat[1].Compare( a[1] ) &&
  mat[2].Compare( a[2] ) ) {
  return true;
 }
 return false;
}

inline bool idMat3::Compare( const idMat3 &a, const float epsilon ) const {
 if ( mat[0].Compare( a[0], epsilon ) &&
  mat[1].Compare( a[1], epsilon ) &&
  mat[2].Compare( a[2], epsilon ) ) {
  return true;
 }
 return false;
}

inline bool idMat3::operator==( const idMat3 &a ) const {
 return Compare( a );
}

inline bool idMat3::operator!=( const idMat3 &a ) const {
 return !Compare( a );
}

inline void idMat3::Zero( void ) {
 memset( mat, 0, sizeof( idMat3 ) );
}

inline void idMat3::Identity( void ) {
 *this = mat3_identity;
}

inline bool idMat3::IsIdentity( const float epsilon ) const {
 return Compare( mat3_identity, epsilon );
}

inline bool idMat3::IsSymmetric( const float epsilon ) const {
 if ( idMath::Fabs( mat[0][1] - mat[1][0] ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( mat[0][2] - mat[2][0] ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( mat[1][2] - mat[2][1] ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idMat3::IsDiagonal( const float epsilon ) const {
 if ( idMath::Fabs( mat[0][1] ) > epsilon ||
  idMath::Fabs( mat[0][2] ) > epsilon ||
  idMath::Fabs( mat[1][0] ) > epsilon ||
  idMath::Fabs( mat[1][2] ) > epsilon ||
  idMath::Fabs( mat[2][0] ) > epsilon ||
  idMath::Fabs( mat[2][1] ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idMat3::IsRotated( void ) const {
 return !Compare( mat3_identity );
}

inline void idMat3::ProjectVector( const idVec3 &src, idVec3 &dst ) const {
 dst.x = src * mat[ 0 ];
 dst.y = src * mat[ 1 ];
 dst.z = src * mat[ 2 ];
}

inline void idMat3::UnprojectVector( const idVec3 &src, idVec3 &dst ) const {
 dst = mat[ 0 ] * src.x + mat[ 1 ] * src.y + mat[ 2 ] * src.z;
}

inline bool idMat3::FixDegeneracies( void ) {
 bool r = mat[0].FixDegenerateNormal();
 r |= mat[1].FixDegenerateNormal();
 r |= mat[2].FixDegenerateNormal();
 return r;
}

inline bool idMat3::FixDenormals( void ) {
 bool r = mat[0].FixDenormals();
 r |= mat[1].FixDenormals();
 r |= mat[2].FixDenormals();
 return r;
}

inline float idMat3::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] + mat[2][2] );
}

inline idMat3 idMat3::OrthoNormalize( void ) const {
 idMat3 ortho;

 ortho = *this;
 ortho[ 0 ].Normalize();
 ortho[ 2 ].Cross( mat[ 0 ], mat[ 1 ] );
 ortho[ 2 ].Normalize();
 ortho[ 1 ].Cross( mat[ 2 ], mat[ 0 ] );
 ortho[ 1 ].Normalize();
 return ortho;
}

inline idMat3 &idMat3::OrthoNormalizeSelf( void ) {
 mat[ 0 ].Normalize();
 mat[ 2 ].Cross( mat[ 0 ], mat[ 1 ] );
 mat[ 2 ].Normalize();
 mat[ 1 ].Cross( mat[ 2 ], mat[ 0 ] );
 mat[ 1 ].Normalize();
 return *this;
}

inline idMat3 idMat3::Transpose( void ) const {
 return idMat3( mat[0][0], mat[1][0], mat[2][0],
     mat[0][1], mat[1][1], mat[2][1],
     mat[0][2], mat[1][2], mat[2][2] );
}

inline idMat3 &idMat3::TransposeSelf( void ) {
 float tmp0, tmp1, tmp2;

 tmp0 = mat[0][1];
 mat[0][1] = mat[1][0];
 mat[1][0] = tmp0;
 tmp1 = mat[0][2];
 mat[0][2] = mat[2][0];
 mat[2][0] = tmp1;
 tmp2 = mat[1][2];
 mat[1][2] = mat[2][1];
 mat[2][1] = tmp2;

 return *this;
}

inline idMat3 idMat3::Inverse( void ) const {
 idMat3 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat3 idMat3::InverseFast( void ) const {
 idMat3 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline idMat3 idMat3::TransposeMultiply( const idMat3 &b ) const {
 return idMat3( mat[0].x * b[0].x + mat[1].x * b[1].x + mat[2].x * b[2].x,
     mat[0].x * b[0].y + mat[1].x * b[1].y + mat[2].x * b[2].y,
     mat[0].x * b[0].z + mat[1].x * b[1].z + mat[2].x * b[2].z,
     mat[0].y * b[0].x + mat[1].y * b[1].x + mat[2].y * b[2].x,
     mat[0].y * b[0].y + mat[1].y * b[1].y + mat[2].y * b[2].y,
     mat[0].y * b[0].z + mat[1].y * b[1].z + mat[2].y * b[2].z,
     mat[0].z * b[0].x + mat[1].z * b[1].x + mat[2].z * b[2].x,
     mat[0].z * b[0].y + mat[1].z * b[1].y + mat[2].z * b[2].y,
     mat[0].z * b[0].z + mat[1].z * b[1].z + mat[2].z * b[2].z );
}

inline void TransposeMultiply( const idMat3 &transpose, const idMat3 &b, idMat3 &dst ) {
 dst[0].x = transpose[0].x * b[0].x + transpose[1].x * b[1].x + transpose[2].x * b[2].x;
 dst[0].y = transpose[0].x * b[0].y + transpose[1].x * b[1].y + transpose[2].x * b[2].y;
 dst[0].z = transpose[0].x * b[0].z + transpose[1].x * b[1].z + transpose[2].x * b[2].z;
 dst[1].x = transpose[0].y * b[0].x + transpose[1].y * b[1].x + transpose[2].y * b[2].x;
 dst[1].y = transpose[0].y * b[0].y + transpose[1].y * b[1].y + transpose[2].y * b[2].y;
 dst[1].z = transpose[0].y * b[0].z + transpose[1].y * b[1].z + transpose[2].y * b[2].z;
 dst[2].x = transpose[0].z * b[0].x + transpose[1].z * b[1].x + transpose[2].z * b[2].x;
 dst[2].y = transpose[0].z * b[0].y + transpose[1].z * b[1].y + transpose[2].z * b[2].y;
 dst[2].z = transpose[0].z * b[0].z + transpose[1].z * b[1].z + transpose[2].z * b[2].z;
}

inline idMat3 SkewSymmetric( idVec3 const &src ) {
 return idMat3( 0.0f, -src.z, src.y, src.z, 0.0f, -src.x, -src.y, src.x, 0.0f );
}

inline int idMat3::GetDimension( void ) const {
 return 9;
}

inline const float *idMat3::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat3::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 764 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
class idMat4 {
public:
     idMat4( void );
     explicit idMat4( const idVec4 &x, const idVec4 &y, const idVec4 &z, const idVec4 &w );
     explicit idMat4(const float xx, const float xy, const float xz, const float xw,
         const float yx, const float yy, const float yz, const float yw,
         const float zx, const float zy, const float zz, const float zw,
         const float wx, const float wy, const float wz, const float ww );
     explicit idMat4( const idMat3 &rotation, const idVec3 &translation );
     explicit idMat4( const float src[ 4 ][ 4 ] );

 const idVec4 & operator[]( int index ) const;
 idVec4 & operator[]( int index );
 idMat4 operator*( const float a ) const;
 idVec4 operator*( const idVec4 &vec ) const;
 idVec3 operator*( const idVec3 &vec ) const;
 idMat4 operator*( const idMat4 &a ) const;
 idMat4 operator+( const idMat4 &a ) const;
 idMat4 operator-( const idMat4 &a ) const;
 idMat4 & operator*=( const float a );
 idMat4 & operator*=( const idMat4 &a );
 idMat4 & operator+=( const idMat4 &a );
 idMat4 & operator-=( const idMat4 &a );

 friend idMat4 operator*( const float a, const idMat4 &mat );
 friend idVec4 operator*( const idVec4 &vec, const idMat4 &mat );
 friend idVec3 operator*( const idVec3 &vec, const idMat4 &mat );
 friend idVec4 & operator*=( idVec4 &vec, const idMat4 &mat );
 friend idVec3 & operator*=( idVec3 &vec, const idMat4 &mat );

 bool Compare( const idMat4 &a ) const;
 bool Compare( const idMat4 &a, const float epsilon ) const;
 bool operator==( const idMat4 &a ) const;
 bool operator!=( const idMat4 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;
 bool IsRotated( void ) const;

 void ProjectVector( const idVec4 &src, idVec4 &dst ) const;
 void UnprojectVector( const idVec4 &src, idVec4 &dst ) const;

 float Trace( void ) const;
 float Determinant( void ) const;
 idMat4 Transpose( void ) const;
 idMat4 & TransposeSelf( void );
 idMat4 Inverse( void ) const;
 bool InverseSelf( void );
 idMat4 InverseFast( void ) const;
 bool InverseFastSelf( void );
 idMat4 TransposeMultiply( const idMat4 &b ) const;

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 idVec4 mat[ 4 ];
};

extern idMat4 mat4_zero;
extern idMat4 mat4_identity;


inline idMat4::idMat4( void ) {
}

inline idMat4::idMat4( const idVec4 &x, const idVec4 &y, const idVec4 &z, const idVec4 &w ) {
 mat[ 0 ] = x;
 mat[ 1 ] = y;
 mat[ 2 ] = z;
 mat[ 3 ] = w;
}

inline idMat4::idMat4( const float xx, const float xy, const float xz, const float xw,
       const float yx, const float yy, const float yz, const float yw,
       const float zx, const float zy, const float zz, const float zw,
       const float wx, const float wy, const float wz, const float ww ) {
 mat[0][0] = xx; mat[0][1] = xy; mat[0][2] = xz; mat[0][3] = xw;
 mat[1][0] = yx; mat[1][1] = yy; mat[1][2] = yz; mat[1][3] = yw;
 mat[2][0] = zx; mat[2][1] = zy; mat[2][2] = zz; mat[2][3] = zw;
 mat[3][0] = wx; mat[3][1] = wy; mat[3][2] = wz; mat[3][3] = ww;
}

inline idMat4::idMat4( const idMat3 &rotation, const idVec3 &translation ) {

 mat[ 0 ][ 0 ] = rotation[0][0];
 mat[ 0 ][ 1 ] = rotation[1][0];
 mat[ 0 ][ 2 ] = rotation[2][0];
 mat[ 0 ][ 3 ] = translation[0];
 mat[ 1 ][ 0 ] = rotation[0][1];
 mat[ 1 ][ 1 ] = rotation[1][1];
 mat[ 1 ][ 2 ] = rotation[2][1];
 mat[ 1 ][ 3 ] = translation[1];
 mat[ 2 ][ 0 ] = rotation[0][2];
 mat[ 2 ][ 1 ] = rotation[1][2];
 mat[ 2 ][ 2 ] = rotation[2][2];
 mat[ 2 ][ 3 ] = translation[2];
 mat[ 3 ][ 0 ] = 0.0f;
 mat[ 3 ][ 1 ] = 0.0f;
 mat[ 3 ][ 2 ] = 0.0f;
 mat[ 3 ][ 3 ] = 1.0f;
}

inline idMat4::idMat4( const float src[ 4 ][ 4 ] ) {
 memcpy( mat, src, 4 * 4 * sizeof( float ) );
}

inline const idVec4 &idMat4::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec4 &idMat4::operator[]( int index ) {

 return mat[ index ];
}

inline idMat4 idMat4::operator*( const float a ) const {
 return idMat4(
  mat[0].x * a, mat[0].y * a, mat[0].z * a, mat[0].w * a,
  mat[1].x * a, mat[1].y * a, mat[1].z * a, mat[1].w * a,
  mat[2].x * a, mat[2].y * a, mat[2].z * a, mat[2].w * a,
  mat[3].x * a, mat[3].y * a, mat[3].z * a, mat[3].w * a );
}

inline idVec4 idMat4::operator*( const idVec4 &vec ) const {
 return idVec4(
  mat[ 0 ].x * vec.x + mat[ 0 ].y * vec.y + mat[ 0 ].z * vec.z + mat[ 0 ].w * vec.w,
  mat[ 1 ].x * vec.x + mat[ 1 ].y * vec.y + mat[ 1 ].z * vec.z + mat[ 1 ].w * vec.w,
  mat[ 2 ].x * vec.x + mat[ 2 ].y * vec.y + mat[ 2 ].z * vec.z + mat[ 2 ].w * vec.w,
  mat[ 3 ].x * vec.x + mat[ 3 ].y * vec.y + mat[ 3 ].z * vec.z + mat[ 3 ].w * vec.w );
}

inline idVec3 idMat4::operator*( const idVec3 &vec ) const {
 float s = mat[ 3 ].x * vec.x + mat[ 3 ].y * vec.y + mat[ 3 ].z * vec.z + mat[ 3 ].w;
 if ( s == 0.0f ) {
  return idVec3( 0.0f, 0.0f, 0.0f );
 }
 if ( s == 1.0f ) {
  return idVec3(
   mat[ 0 ].x * vec.x + mat[ 0 ].y * vec.y + mat[ 0 ].z * vec.z + mat[ 0 ].w,
   mat[ 1 ].x * vec.x + mat[ 1 ].y * vec.y + mat[ 1 ].z * vec.z + mat[ 1 ].w,
   mat[ 2 ].x * vec.x + mat[ 2 ].y * vec.y + mat[ 2 ].z * vec.z + mat[ 2 ].w );
 }
 else {
  float invS = 1.0f / s;
  return idVec3(
   (mat[ 0 ].x * vec.x + mat[ 0 ].y * vec.y + mat[ 0 ].z * vec.z + mat[ 0 ].w) * invS,
   (mat[ 1 ].x * vec.x + mat[ 1 ].y * vec.y + mat[ 1 ].z * vec.z + mat[ 1 ].w) * invS,
   (mat[ 2 ].x * vec.x + mat[ 2 ].y * vec.y + mat[ 2 ].z * vec.z + mat[ 2 ].w) * invS );
 }
}

inline idMat4 idMat4::operator*( const idMat4 &a ) const {
 int i, j;
 const float *m1Ptr, *m2Ptr;
 float *dstPtr;
 idMat4 dst;

 m1Ptr = reinterpret_cast<const float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);
 dstPtr = reinterpret_cast<float *>(&dst);

 for ( i = 0; i < 4; i++ ) {
  for ( j = 0; j < 4; j++ ) {
   *dstPtr = m1Ptr[0] * m2Ptr[ 0 * 4 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 4 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 4 + j ]
     + m1Ptr[3] * m2Ptr[ 3 * 4 + j ];
   dstPtr++;
  }
  m1Ptr += 4;
 }
 return dst;
}

inline idMat4 idMat4::operator+( const idMat4 &a ) const {
 return idMat4(
  mat[0].x + a[0].x, mat[0].y + a[0].y, mat[0].z + a[0].z, mat[0].w + a[0].w,
  mat[1].x + a[1].x, mat[1].y + a[1].y, mat[1].z + a[1].z, mat[1].w + a[1].w,
  mat[2].x + a[2].x, mat[2].y + a[2].y, mat[2].z + a[2].z, mat[2].w + a[2].w,
  mat[3].x + a[3].x, mat[3].y + a[3].y, mat[3].z + a[3].z, mat[3].w + a[3].w );
}

inline idMat4 idMat4::operator-( const idMat4 &a ) const {
 return idMat4(
  mat[0].x - a[0].x, mat[0].y - a[0].y, mat[0].z - a[0].z, mat[0].w - a[0].w,
  mat[1].x - a[1].x, mat[1].y - a[1].y, mat[1].z - a[1].z, mat[1].w - a[1].w,
  mat[2].x - a[2].x, mat[2].y - a[2].y, mat[2].z - a[2].z, mat[2].w - a[2].w,
  mat[3].x - a[3].x, mat[3].y - a[3].y, mat[3].z - a[3].z, mat[3].w - a[3].w );
}

inline idMat4 &idMat4::operator*=( const float a ) {
 mat[0].x *= a; mat[0].y *= a; mat[0].z *= a; mat[0].w *= a;
 mat[1].x *= a; mat[1].y *= a; mat[1].z *= a; mat[1].w *= a;
 mat[2].x *= a; mat[2].y *= a; mat[2].z *= a; mat[2].w *= a;
 mat[3].x *= a; mat[3].y *= a; mat[3].z *= a; mat[3].w *= a;
    return *this;
}

inline idMat4 &idMat4::operator*=( const idMat4 &a ) {
 *this = (*this) * a;
 return *this;
}

inline idMat4 &idMat4::operator+=( const idMat4 &a ) {
 mat[0].x += a[0].x; mat[0].y += a[0].y; mat[0].z += a[0].z; mat[0].w += a[0].w;
 mat[1].x += a[1].x; mat[1].y += a[1].y; mat[1].z += a[1].z; mat[1].w += a[1].w;
 mat[2].x += a[2].x; mat[2].y += a[2].y; mat[2].z += a[2].z; mat[2].w += a[2].w;
 mat[3].x += a[3].x; mat[3].y += a[3].y; mat[3].z += a[3].z; mat[3].w += a[3].w;
    return *this;
}

inline idMat4 &idMat4::operator-=( const idMat4 &a ) {
 mat[0].x -= a[0].x; mat[0].y -= a[0].y; mat[0].z -= a[0].z; mat[0].w -= a[0].w;
 mat[1].x -= a[1].x; mat[1].y -= a[1].y; mat[1].z -= a[1].z; mat[1].w -= a[1].w;
 mat[2].x -= a[2].x; mat[2].y -= a[2].y; mat[2].z -= a[2].z; mat[2].w -= a[2].w;
 mat[3].x -= a[3].x; mat[3].y -= a[3].y; mat[3].z -= a[3].z; mat[3].w -= a[3].w;
    return *this;
}

inline idMat4 operator*( const float a, const idMat4 &mat ) {
 return mat * a;
}

inline idVec4 operator*( const idVec4 &vec, const idMat4 &mat ) {
 return mat * vec;
}

inline idVec3 operator*( const idVec3 &vec, const idMat4 &mat ) {
 return mat * vec;
}

inline idVec4 &operator*=( idVec4 &vec, const idMat4 &mat ) {
 vec = mat * vec;
 return vec;
}

inline idVec3 &operator*=( idVec3 &vec, const idMat4 &mat ) {
 vec = mat * vec;
 return vec;
}

inline bool idMat4::Compare( const idMat4 &a ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 4*4; i++ ) {
  if ( ptr1[i] != ptr2[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idMat4::Compare( const idMat4 &a, const float epsilon ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 4*4; i++ ) {
  if ( idMath::Fabs( ptr1[i] - ptr2[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idMat4::operator==( const idMat4 &a ) const {
 return Compare( a );
}

inline bool idMat4::operator!=( const idMat4 &a ) const {
 return !Compare( a );
}

inline void idMat4::Zero( void ) {
 memset( mat, 0, sizeof( idMat4 ) );
}

inline void idMat4::Identity( void ) {
 *this = mat4_identity;
}

inline bool idMat4::IsIdentity( const float epsilon ) const {
 return Compare( mat4_identity, epsilon );
}

inline bool idMat4::IsSymmetric( const float epsilon ) const {
 for ( int i = 1; i < 4; i++ ) {
  for ( int j = 0; j < i; j++ ) {
   if ( idMath::Fabs( mat[i][j] - mat[j][i] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMat4::IsDiagonal( const float epsilon ) const {
 for ( int i = 0; i < 4; i++ ) {
  for ( int j = 0; j < 4; j++ ) {
   if ( i != j && idMath::Fabs( mat[i][j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMat4::IsRotated( void ) const {
 if ( !mat[ 0 ][ 1 ] && !mat[ 0 ][ 2 ] &&
  !mat[ 1 ][ 0 ] && !mat[ 1 ][ 2 ] &&
  !mat[ 2 ][ 0 ] && !mat[ 2 ][ 1 ] ) {
  return false;
 }
 return true;
}

inline void idMat4::ProjectVector( const idVec4 &src, idVec4 &dst ) const {
 dst.x = src * mat[ 0 ];
 dst.y = src * mat[ 1 ];
 dst.z = src * mat[ 2 ];
 dst.w = src * mat[ 3 ];
}

inline void idMat4::UnprojectVector( const idVec4 &src, idVec4 &dst ) const {
 dst = mat[ 0 ] * src.x + mat[ 1 ] * src.y + mat[ 2 ] * src.z + mat[ 3 ] * src.w;
}

inline float idMat4::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3] );
}

inline idMat4 idMat4::Inverse( void ) const {
 idMat4 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat4 idMat4::InverseFast( void ) const {
 idMat4 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline idMat4 idMat3::ToMat4( void ) const {

 return idMat4( mat[0][0], mat[1][0], mat[2][0], 0.0f,
     mat[0][1], mat[1][1], mat[2][1], 0.0f,
     mat[0][2], mat[1][2], mat[2][2], 0.0f,
     0.0f, 0.0f, 0.0f, 1.0f );
}

inline int idMat4::GetDimension( void ) const {
 return 16;
}

inline const float *idMat4::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat4::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 1152 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
class idMat5 {
public:
     idMat5( void );
     explicit idMat5( const idVec5 &v0, const idVec5 &v1, const idVec5 &v2, const idVec5 &v3, const idVec5 &v4 );
     explicit idMat5( const float src[ 5 ][ 5 ] );

 const idVec5 & operator[]( int index ) const;
 idVec5 & operator[]( int index );
 idMat5 operator*( const float a ) const;
 idVec5 operator*( const idVec5 &vec ) const;
 idMat5 operator*( const idMat5 &a ) const;
 idMat5 operator+( const idMat5 &a ) const;
 idMat5 operator-( const idMat5 &a ) const;
 idMat5 & operator*=( const float a );
 idMat5 & operator*=( const idMat5 &a );
 idMat5 & operator+=( const idMat5 &a );
 idMat5 & operator-=( const idMat5 &a );

 friend idMat5 operator*( const float a, const idMat5 &mat );
 friend idVec5 operator*( const idVec5 &vec, const idMat5 &mat );
 friend idVec5 & operator*=( idVec5 &vec, const idMat5 &mat );

 bool Compare( const idMat5 &a ) const;
 bool Compare( const idMat5 &a, const float epsilon ) const;
 bool operator==( const idMat5 &a ) const;
 bool operator!=( const idMat5 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;

 float Trace( void ) const;
 float Determinant( void ) const;
 idMat5 Transpose( void ) const;
 idMat5 & TransposeSelf( void );
 idMat5 Inverse( void ) const;
 bool InverseSelf( void );
 idMat5 InverseFast( void ) const;
 bool InverseFastSelf( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 idVec5 mat[ 5 ];
};

extern idMat5 mat5_zero;
extern idMat5 mat5_identity;


inline idMat5::idMat5( void ) {
}

inline idMat5::idMat5( const float src[ 5 ][ 5 ] ) {
 memcpy( mat, src, 5 * 5 * sizeof( float ) );
}

inline idMat5::idMat5( const idVec5 &v0, const idVec5 &v1, const idVec5 &v2, const idVec5 &v3, const idVec5 &v4 ) {
 mat[0] = v0;
 mat[1] = v1;
 mat[2] = v2;
 mat[3] = v3;
 mat[4] = v4;
}

inline const idVec5 &idMat5::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec5 &idMat5::operator[]( int index ) {

 return mat[ index ];
}

inline idMat5 idMat5::operator*( const idMat5 &a ) const {
 int i, j;
 const float *m1Ptr, *m2Ptr;
 float *dstPtr;
 idMat5 dst;

 m1Ptr = reinterpret_cast<const float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);
 dstPtr = reinterpret_cast<float *>(&dst);

 for ( i = 0; i < 5; i++ ) {
  for ( j = 0; j < 5; j++ ) {
   *dstPtr = m1Ptr[0] * m2Ptr[ 0 * 5 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 5 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 5 + j ]
     + m1Ptr[3] * m2Ptr[ 3 * 5 + j ]
     + m1Ptr[4] * m2Ptr[ 4 * 5 + j ];
   dstPtr++;
  }
  m1Ptr += 5;
 }
 return dst;
}

inline idMat5 idMat5::operator*( const float a ) const {
 return idMat5(
  idVec5( mat[0][0] * a, mat[0][1] * a, mat[0][2] * a, mat[0][3] * a, mat[0][4] * a ),
  idVec5( mat[1][0] * a, mat[1][1] * a, mat[1][2] * a, mat[1][3] * a, mat[1][4] * a ),
  idVec5( mat[2][0] * a, mat[2][1] * a, mat[2][2] * a, mat[2][3] * a, mat[2][4] * a ),
  idVec5( mat[3][0] * a, mat[3][1] * a, mat[3][2] * a, mat[3][3] * a, mat[3][4] * a ),
  idVec5( mat[4][0] * a, mat[4][1] * a, mat[4][2] * a, mat[4][3] * a, mat[4][4] * a ) );
}

inline idVec5 idMat5::operator*( const idVec5 &vec ) const {
 return idVec5(
  mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2] + mat[0][3] * vec[3] + mat[0][4] * vec[4],
  mat[1][0] * vec[0] + mat[1][1] * vec[1] + mat[1][2] * vec[2] + mat[1][3] * vec[3] + mat[1][4] * vec[4],
  mat[2][0] * vec[0] + mat[2][1] * vec[1] + mat[2][2] * vec[2] + mat[2][3] * vec[3] + mat[2][4] * vec[4],
  mat[3][0] * vec[0] + mat[3][1] * vec[1] + mat[3][2] * vec[2] + mat[3][3] * vec[3] + mat[3][4] * vec[4],
  mat[4][0] * vec[0] + mat[4][1] * vec[1] + mat[4][2] * vec[2] + mat[4][3] * vec[3] + mat[4][4] * vec[4] );
}

inline idMat5 idMat5::operator+( const idMat5 &a ) const {
 return idMat5(
  idVec5( mat[0][0] + a[0][0], mat[0][1] + a[0][1], mat[0][2] + a[0][2], mat[0][3] + a[0][3], mat[0][4] + a[0][4] ),
  idVec5( mat[1][0] + a[1][0], mat[1][1] + a[1][1], mat[1][2] + a[1][2], mat[1][3] + a[1][3], mat[1][4] + a[1][4] ),
  idVec5( mat[2][0] + a[2][0], mat[2][1] + a[2][1], mat[2][2] + a[2][2], mat[2][3] + a[2][3], mat[2][4] + a[2][4] ),
  idVec5( mat[3][0] + a[3][0], mat[3][1] + a[3][1], mat[3][2] + a[3][2], mat[3][3] + a[3][3], mat[3][4] + a[3][4] ),
  idVec5( mat[4][0] + a[4][0], mat[4][1] + a[4][1], mat[4][2] + a[4][2], mat[4][3] + a[4][3], mat[4][4] + a[4][4] ) );
}

inline idMat5 idMat5::operator-( const idMat5 &a ) const {
 return idMat5(
  idVec5( mat[0][0] - a[0][0], mat[0][1] - a[0][1], mat[0][2] - a[0][2], mat[0][3] - a[0][3], mat[0][4] - a[0][4] ),
  idVec5( mat[1][0] - a[1][0], mat[1][1] - a[1][1], mat[1][2] - a[1][2], mat[1][3] - a[1][3], mat[1][4] - a[1][4] ),
  idVec5( mat[2][0] - a[2][0], mat[2][1] - a[2][1], mat[2][2] - a[2][2], mat[2][3] - a[2][3], mat[2][4] - a[2][4] ),
  idVec5( mat[3][0] - a[3][0], mat[3][1] - a[3][1], mat[3][2] - a[3][2], mat[3][3] - a[3][3], mat[3][4] - a[3][4] ),
  idVec5( mat[4][0] - a[4][0], mat[4][1] - a[4][1], mat[4][2] - a[4][2], mat[4][3] - a[4][3], mat[4][4] - a[4][4] ) );
}

inline idMat5 &idMat5::operator*=( const float a ) {
 mat[0][0] *= a; mat[0][1] *= a; mat[0][2] *= a; mat[0][3] *= a; mat[0][4] *= a;
 mat[1][0] *= a; mat[1][1] *= a; mat[1][2] *= a; mat[1][3] *= a; mat[1][4] *= a;
 mat[2][0] *= a; mat[2][1] *= a; mat[2][2] *= a; mat[2][3] *= a; mat[2][4] *= a;
 mat[3][0] *= a; mat[3][1] *= a; mat[3][2] *= a; mat[3][3] *= a; mat[3][4] *= a;
 mat[4][0] *= a; mat[4][1] *= a; mat[4][2] *= a; mat[4][3] *= a; mat[4][4] *= a;
 return *this;
}

inline idMat5 &idMat5::operator*=( const idMat5 &a ) {
 *this = *this * a;
 return *this;
}

inline idMat5 &idMat5::operator+=( const idMat5 &a ) {
 mat[0][0] += a[0][0]; mat[0][1] += a[0][1]; mat[0][2] += a[0][2]; mat[0][3] += a[0][3]; mat[0][4] += a[0][4];
 mat[1][0] += a[1][0]; mat[1][1] += a[1][1]; mat[1][2] += a[1][2]; mat[1][3] += a[1][3]; mat[1][4] += a[1][4];
 mat[2][0] += a[2][0]; mat[2][1] += a[2][1]; mat[2][2] += a[2][2]; mat[2][3] += a[2][3]; mat[2][4] += a[2][4];
 mat[3][0] += a[3][0]; mat[3][1] += a[3][1]; mat[3][2] += a[3][2]; mat[3][3] += a[3][3]; mat[3][4] += a[3][4];
 mat[4][0] += a[4][0]; mat[4][1] += a[4][1]; mat[4][2] += a[4][2]; mat[4][3] += a[4][3]; mat[4][4] += a[4][4];
 return *this;
}

inline idMat5 &idMat5::operator-=( const idMat5 &a ) {
 mat[0][0] -= a[0][0]; mat[0][1] -= a[0][1]; mat[0][2] -= a[0][2]; mat[0][3] -= a[0][3]; mat[0][4] -= a[0][4];
 mat[1][0] -= a[1][0]; mat[1][1] -= a[1][1]; mat[1][2] -= a[1][2]; mat[1][3] -= a[1][3]; mat[1][4] -= a[1][4];
 mat[2][0] -= a[2][0]; mat[2][1] -= a[2][1]; mat[2][2] -= a[2][2]; mat[2][3] -= a[2][3]; mat[2][4] -= a[2][4];
 mat[3][0] -= a[3][0]; mat[3][1] -= a[3][1]; mat[3][2] -= a[3][2]; mat[3][3] -= a[3][3]; mat[3][4] -= a[3][4];
 mat[4][0] -= a[4][0]; mat[4][1] -= a[4][1]; mat[4][2] -= a[4][2]; mat[4][3] -= a[4][3]; mat[4][4] -= a[4][4];
 return *this;
}

inline idVec5 operator*( const idVec5 &vec, const idMat5 &mat ) {
 return mat * vec;
}

inline idMat5 operator*( const float a, idMat5 const &mat ) {
 return mat * a;
}

inline idVec5 &operator*=( idVec5 &vec, const idMat5 &mat ) {
 vec = mat * vec;
 return vec;
}

inline bool idMat5::Compare( const idMat5 &a ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 5*5; i++ ) {
  if ( ptr1[i] != ptr2[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idMat5::Compare( const idMat5 &a, const float epsilon ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 5*5; i++ ) {
  if ( idMath::Fabs( ptr1[i] - ptr2[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idMat5::operator==( const idMat5 &a ) const {
 return Compare( a );
}

inline bool idMat5::operator!=( const idMat5 &a ) const {
 return !Compare( a );
}

inline void idMat5::Zero( void ) {
 memset( mat, 0, sizeof( idMat5 ) );
}

inline void idMat5::Identity( void ) {
 *this = mat5_identity;
}

inline bool idMat5::IsIdentity( const float epsilon ) const {
 return Compare( mat5_identity, epsilon );
}

inline bool idMat5::IsSymmetric( const float epsilon ) const {
 for ( int i = 1; i < 5; i++ ) {
  for ( int j = 0; j < i; j++ ) {
   if ( idMath::Fabs( mat[i][j] - mat[j][i] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMat5::IsDiagonal( const float epsilon ) const {
 for ( int i = 0; i < 5; i++ ) {
  for ( int j = 0; j < 5; j++ ) {
   if ( i != j && idMath::Fabs( mat[i][j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline float idMat5::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3] + mat[4][4] );
}

inline idMat5 idMat5::Inverse( void ) const {
 idMat5 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat5 idMat5::InverseFast( void ) const {
 idMat5 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline int idMat5::GetDimension( void ) const {
 return 25;
}

inline const float *idMat5::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat5::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 1449 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
class idMat6 {
public:
     idMat6( void );
     explicit idMat6( const idVec6 &v0, const idVec6 &v1, const idVec6 &v2, const idVec6 &v3, const idVec6 &v4, const idVec6 &v5 );
     explicit idMat6( const idMat3 &m0, const idMat3 &m1, const idMat3 &m2, const idMat3 &m3 );
     explicit idMat6( const float src[ 6 ][ 6 ] );

 const idVec6 & operator[]( int index ) const;
 idVec6 & operator[]( int index );
 idMat6 operator*( const float a ) const;
 idVec6 operator*( const idVec6 &vec ) const;
 idMat6 operator*( const idMat6 &a ) const;
 idMat6 operator+( const idMat6 &a ) const;
 idMat6 operator-( const idMat6 &a ) const;
 idMat6 & operator*=( const float a );
 idMat6 & operator*=( const idMat6 &a );
 idMat6 & operator+=( const idMat6 &a );
 idMat6 & operator-=( const idMat6 &a );

 friend idMat6 operator*( const float a, const idMat6 &mat );
 friend idVec6 operator*( const idVec6 &vec, const idMat6 &mat );
 friend idVec6 & operator*=( idVec6 &vec, const idMat6 &mat );

 bool Compare( const idMat6 &a ) const;
 bool Compare( const idMat6 &a, const float epsilon ) const;
 bool operator==( const idMat6 &a ) const;
 bool operator!=( const idMat6 &a ) const;

 void Zero( void );
 void Identity( void );
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;

 idMat3 SubMat3( int n ) const;
 float Trace( void ) const;
 float Determinant( void ) const;
 idMat6 Transpose( void ) const;
 idMat6 & TransposeSelf( void );
 idMat6 Inverse( void ) const;
 bool InverseSelf( void );
 idMat6 InverseFast( void ) const;
 bool InverseFastSelf( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 idVec6 mat[ 6 ];
};

extern idMat6 mat6_zero;
extern idMat6 mat6_identity;


inline idMat6::idMat6( void ) {
}

inline idMat6::idMat6( const idMat3 &m0, const idMat3 &m1, const idMat3 &m2, const idMat3 &m3 ) {
 mat[0] = idVec6( m0[0][0], m0[0][1], m0[0][2], m1[0][0], m1[0][1], m1[0][2] );
 mat[1] = idVec6( m0[1][0], m0[1][1], m0[1][2], m1[1][0], m1[1][1], m1[1][2] );
 mat[2] = idVec6( m0[2][0], m0[2][1], m0[2][2], m1[2][0], m1[2][1], m1[2][2] );
 mat[3] = idVec6( m2[0][0], m2[0][1], m2[0][2], m3[0][0], m3[0][1], m3[0][2] );
 mat[4] = idVec6( m2[1][0], m2[1][1], m2[1][2], m3[1][0], m3[1][1], m3[1][2] );
 mat[5] = idVec6( m2[2][0], m2[2][1], m2[2][2], m3[2][0], m3[2][1], m3[2][2] );
}

inline idMat6::idMat6( const idVec6 &v0, const idVec6 &v1, const idVec6 &v2, const idVec6 &v3, const idVec6 &v4, const idVec6 &v5 ) {
 mat[0] = v0;
 mat[1] = v1;
 mat[2] = v2;
 mat[3] = v3;
 mat[4] = v4;
 mat[5] = v5;
}

inline idMat6::idMat6( const float src[ 6 ][ 6 ] ) {
 memcpy( mat, src, 6 * 6 * sizeof( float ) );
}

inline const idVec6 &idMat6::operator[]( int index ) const {

 return mat[ index ];
}

inline idVec6 &idMat6::operator[]( int index ) {

 return mat[ index ];
}

inline idMat6 idMat6::operator*( const idMat6 &a ) const {
 int i, j;
 const float *m1Ptr, *m2Ptr;
 float *dstPtr;
 idMat6 dst;

 m1Ptr = reinterpret_cast<const float *>(this);
 m2Ptr = reinterpret_cast<const float *>(&a);
 dstPtr = reinterpret_cast<float *>(&dst);

 for ( i = 0; i < 6; i++ ) {
  for ( j = 0; j < 6; j++ ) {
   *dstPtr = m1Ptr[0] * m2Ptr[ 0 * 6 + j ]
     + m1Ptr[1] * m2Ptr[ 1 * 6 + j ]
     + m1Ptr[2] * m2Ptr[ 2 * 6 + j ]
     + m1Ptr[3] * m2Ptr[ 3 * 6 + j ]
     + m1Ptr[4] * m2Ptr[ 4 * 6 + j ]
     + m1Ptr[5] * m2Ptr[ 5 * 6 + j ];
   dstPtr++;
  }
  m1Ptr += 6;
 }
 return dst;
}

inline idMat6 idMat6::operator*( const float a ) const {
 return idMat6(
  idVec6( mat[0][0] * a, mat[0][1] * a, mat[0][2] * a, mat[0][3] * a, mat[0][4] * a, mat[0][5] * a ),
  idVec6( mat[1][0] * a, mat[1][1] * a, mat[1][2] * a, mat[1][3] * a, mat[1][4] * a, mat[1][5] * a ),
  idVec6( mat[2][0] * a, mat[2][1] * a, mat[2][2] * a, mat[2][3] * a, mat[2][4] * a, mat[2][5] * a ),
  idVec6( mat[3][0] * a, mat[3][1] * a, mat[3][2] * a, mat[3][3] * a, mat[3][4] * a, mat[3][5] * a ),
  idVec6( mat[4][0] * a, mat[4][1] * a, mat[4][2] * a, mat[4][3] * a, mat[4][4] * a, mat[4][5] * a ),
  idVec6( mat[5][0] * a, mat[5][1] * a, mat[5][2] * a, mat[5][3] * a, mat[5][4] * a, mat[5][5] * a ) );
}

inline idVec6 idMat6::operator*( const idVec6 &vec ) const {
 return idVec6(
  mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2] + mat[0][3] * vec[3] + mat[0][4] * vec[4] + mat[0][5] * vec[5],
  mat[1][0] * vec[0] + mat[1][1] * vec[1] + mat[1][2] * vec[2] + mat[1][3] * vec[3] + mat[1][4] * vec[4] + mat[1][5] * vec[5],
  mat[2][0] * vec[0] + mat[2][1] * vec[1] + mat[2][2] * vec[2] + mat[2][3] * vec[3] + mat[2][4] * vec[4] + mat[2][5] * vec[5],
  mat[3][0] * vec[0] + mat[3][1] * vec[1] + mat[3][2] * vec[2] + mat[3][3] * vec[3] + mat[3][4] * vec[4] + mat[3][5] * vec[5],
  mat[4][0] * vec[0] + mat[4][1] * vec[1] + mat[4][2] * vec[2] + mat[4][3] * vec[3] + mat[4][4] * vec[4] + mat[4][5] * vec[5],
  mat[5][0] * vec[0] + mat[5][1] * vec[1] + mat[5][2] * vec[2] + mat[5][3] * vec[3] + mat[5][4] * vec[4] + mat[5][5] * vec[5] );
}

inline idMat6 idMat6::operator+( const idMat6 &a ) const {
 return idMat6(
  idVec6( mat[0][0] + a[0][0], mat[0][1] + a[0][1], mat[0][2] + a[0][2], mat[0][3] + a[0][3], mat[0][4] + a[0][4], mat[0][5] + a[0][5] ),
  idVec6( mat[1][0] + a[1][0], mat[1][1] + a[1][1], mat[1][2] + a[1][2], mat[1][3] + a[1][3], mat[1][4] + a[1][4], mat[1][5] + a[1][5] ),
  idVec6( mat[2][0] + a[2][0], mat[2][1] + a[2][1], mat[2][2] + a[2][2], mat[2][3] + a[2][3], mat[2][4] + a[2][4], mat[2][5] + a[2][5] ),
  idVec6( mat[3][0] + a[3][0], mat[3][1] + a[3][1], mat[3][2] + a[3][2], mat[3][3] + a[3][3], mat[3][4] + a[3][4], mat[3][5] + a[3][5] ),
  idVec6( mat[4][0] + a[4][0], mat[4][1] + a[4][1], mat[4][2] + a[4][2], mat[4][3] + a[4][3], mat[4][4] + a[4][4], mat[4][5] + a[4][5] ),
  idVec6( mat[5][0] + a[5][0], mat[5][1] + a[5][1], mat[5][2] + a[5][2], mat[5][3] + a[5][3], mat[5][4] + a[5][4], mat[5][5] + a[5][5] ) );
}

inline idMat6 idMat6::operator-( const idMat6 &a ) const {
 return idMat6(
  idVec6( mat[0][0] - a[0][0], mat[0][1] - a[0][1], mat[0][2] - a[0][2], mat[0][3] - a[0][3], mat[0][4] - a[0][4], mat[0][5] - a[0][5] ),
  idVec6( mat[1][0] - a[1][0], mat[1][1] - a[1][1], mat[1][2] - a[1][2], mat[1][3] - a[1][3], mat[1][4] - a[1][4], mat[1][5] - a[1][5] ),
  idVec6( mat[2][0] - a[2][0], mat[2][1] - a[2][1], mat[2][2] - a[2][2], mat[2][3] - a[2][3], mat[2][4] - a[2][4], mat[2][5] - a[2][5] ),
  idVec6( mat[3][0] - a[3][0], mat[3][1] - a[3][1], mat[3][2] - a[3][2], mat[3][3] - a[3][3], mat[3][4] - a[3][4], mat[3][5] - a[3][5] ),
  idVec6( mat[4][0] - a[4][0], mat[4][1] - a[4][1], mat[4][2] - a[4][2], mat[4][3] - a[4][3], mat[4][4] - a[4][4], mat[4][5] - a[4][5] ),
  idVec6( mat[5][0] - a[5][0], mat[5][1] - a[5][1], mat[5][2] - a[5][2], mat[5][3] - a[5][3], mat[5][4] - a[5][4], mat[5][5] - a[5][5] ) );
}

inline idMat6 &idMat6::operator*=( const float a ) {
 mat[0][0] *= a; mat[0][1] *= a; mat[0][2] *= a; mat[0][3] *= a; mat[0][4] *= a; mat[0][5] *= a;
 mat[1][0] *= a; mat[1][1] *= a; mat[1][2] *= a; mat[1][3] *= a; mat[1][4] *= a; mat[1][5] *= a;
 mat[2][0] *= a; mat[2][1] *= a; mat[2][2] *= a; mat[2][3] *= a; mat[2][4] *= a; mat[2][5] *= a;
 mat[3][0] *= a; mat[3][1] *= a; mat[3][2] *= a; mat[3][3] *= a; mat[3][4] *= a; mat[3][5] *= a;
 mat[4][0] *= a; mat[4][1] *= a; mat[4][2] *= a; mat[4][3] *= a; mat[4][4] *= a; mat[4][5] *= a;
 mat[5][0] *= a; mat[5][1] *= a; mat[5][2] *= a; mat[5][3] *= a; mat[5][4] *= a; mat[5][5] *= a;
 return *this;
}

inline idMat6 &idMat6::operator*=( const idMat6 &a ) {
 *this = *this * a;
 return *this;
}

inline idMat6 &idMat6::operator+=( const idMat6 &a ) {
 mat[0][0] += a[0][0]; mat[0][1] += a[0][1]; mat[0][2] += a[0][2]; mat[0][3] += a[0][3]; mat[0][4] += a[0][4]; mat[0][5] += a[0][5];
 mat[1][0] += a[1][0]; mat[1][1] += a[1][1]; mat[1][2] += a[1][2]; mat[1][3] += a[1][3]; mat[1][4] += a[1][4]; mat[1][5] += a[1][5];
 mat[2][0] += a[2][0]; mat[2][1] += a[2][1]; mat[2][2] += a[2][2]; mat[2][3] += a[2][3]; mat[2][4] += a[2][4]; mat[2][5] += a[2][5];
 mat[3][0] += a[3][0]; mat[3][1] += a[3][1]; mat[3][2] += a[3][2]; mat[3][3] += a[3][3]; mat[3][4] += a[3][4]; mat[3][5] += a[3][5];
 mat[4][0] += a[4][0]; mat[4][1] += a[4][1]; mat[4][2] += a[4][2]; mat[4][3] += a[4][3]; mat[4][4] += a[4][4]; mat[4][5] += a[4][5];
 mat[5][0] += a[5][0]; mat[5][1] += a[5][1]; mat[5][2] += a[5][2]; mat[5][3] += a[5][3]; mat[5][4] += a[5][4]; mat[5][5] += a[5][5];
 return *this;
}

inline idMat6 &idMat6::operator-=( const idMat6 &a ) {
 mat[0][0] -= a[0][0]; mat[0][1] -= a[0][1]; mat[0][2] -= a[0][2]; mat[0][3] -= a[0][3]; mat[0][4] -= a[0][4]; mat[0][5] -= a[0][5];
 mat[1][0] -= a[1][0]; mat[1][1] -= a[1][1]; mat[1][2] -= a[1][2]; mat[1][3] -= a[1][3]; mat[1][4] -= a[1][4]; mat[1][5] -= a[1][5];
 mat[2][0] -= a[2][0]; mat[2][1] -= a[2][1]; mat[2][2] -= a[2][2]; mat[2][3] -= a[2][3]; mat[2][4] -= a[2][4]; mat[2][5] -= a[2][5];
 mat[3][0] -= a[3][0]; mat[3][1] -= a[3][1]; mat[3][2] -= a[3][2]; mat[3][3] -= a[3][3]; mat[3][4] -= a[3][4]; mat[3][5] -= a[3][5];
 mat[4][0] -= a[4][0]; mat[4][1] -= a[4][1]; mat[4][2] -= a[4][2]; mat[4][3] -= a[4][3]; mat[4][4] -= a[4][4]; mat[4][5] -= a[4][5];
 mat[5][0] -= a[5][0]; mat[5][1] -= a[5][1]; mat[5][2] -= a[5][2]; mat[5][3] -= a[5][3]; mat[5][4] -= a[5][4]; mat[5][5] -= a[5][5];
 return *this;
}

inline idVec6 operator*( const idVec6 &vec, const idMat6 &mat ) {
 return mat * vec;
}

inline idMat6 operator*( const float a, idMat6 const &mat ) {
 return mat * a;
}

inline idVec6 &operator*=( idVec6 &vec, const idMat6 &mat ) {
 vec = mat * vec;
 return vec;
}

inline bool idMat6::Compare( const idMat6 &a ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 6*6; i++ ) {
  if ( ptr1[i] != ptr2[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idMat6::Compare( const idMat6 &a, const float epsilon ) const {
 dword i;
 const float *ptr1, *ptr2;

 ptr1 = reinterpret_cast<const float *>(mat);
 ptr2 = reinterpret_cast<const float *>(a.mat);
 for ( i = 0; i < 6*6; i++ ) {
  if ( idMath::Fabs( ptr1[i] - ptr2[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idMat6::operator==( const idMat6 &a ) const {
 return Compare( a );
}

inline bool idMat6::operator!=( const idMat6 &a ) const {
 return !Compare( a );
}

inline void idMat6::Zero( void ) {
 memset( mat, 0, sizeof( idMat6 ) );
}

inline void idMat6::Identity( void ) {
 *this = mat6_identity;
}

inline bool idMat6::IsIdentity( const float epsilon ) const {
 return Compare( mat6_identity, epsilon );
}

inline bool idMat6::IsSymmetric( const float epsilon ) const {
 for ( int i = 1; i < 6; i++ ) {
  for ( int j = 0; j < i; j++ ) {
   if ( idMath::Fabs( mat[i][j] - mat[j][i] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMat6::IsDiagonal( const float epsilon ) const {
 for ( int i = 0; i < 6; i++ ) {
  for ( int j = 0; j < 6; j++ ) {
   if ( i != j && idMath::Fabs( mat[i][j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline idMat3 idMat6::SubMat3( int n ) const {
 ((void)0);
 int b0 = ((n & 2) >> 1) * 3;
 int b1 = (n & 1) * 3;
 return idMat3(
  mat[b0 + 0][b1 + 0], mat[b0 + 0][b1 + 1], mat[b0 + 0][b1 + 2],
  mat[b0 + 1][b1 + 0], mat[b0 + 1][b1 + 1], mat[b0 + 1][b1 + 2],
  mat[b0 + 2][b1 + 0], mat[b0 + 2][b1 + 1], mat[b0 + 2][b1 + 2] );
}

inline float idMat6::Trace( void ) const {
 return ( mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3] + mat[4][4] + mat[5][5] );
}

inline idMat6 idMat6::Inverse( void ) const {
 idMat6 invMat;

 invMat = *this;
 invMat.InverseSelf();

 return invMat;
}

inline idMat6 idMat6::InverseFast( void ) const {
 idMat6 invMat;

 invMat = *this;
 invMat.InverseFastSelf();

 return invMat;
}

inline int idMat6::GetDimension( void ) const {
 return 36;
}

inline const float *idMat6::ToFloatPtr( void ) const {
 return mat[0].ToFloatPtr();
}

inline float *idMat6::ToFloatPtr( void ) {
 return mat[0].ToFloatPtr();
}
# 1786 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
class idMatX {
public:
     idMatX( void );
     explicit idMatX( int rows, int columns );
     explicit idMatX( int rows, int columns, float *src );
     ~idMatX( void );

 void Set( int rows, int columns, const float *src );
 void Set( const idMat3 &m1, const idMat3 &m2 );
 void Set( const idMat3 &m1, const idMat3 &m2, const idMat3 &m3, const idMat3 &m4 );

 const float * operator[]( int index ) const;
 float * operator[]( int index );
 idMatX & operator=( const idMatX &a );
 idMatX operator*( const float a ) const;
 idVecX operator*( const idVecX &vec ) const;
 idMatX operator*( const idMatX &a ) const;
 idMatX operator+( const idMatX &a ) const;
 idMatX operator-( const idMatX &a ) const;
 idMatX & operator*=( const float a );
 idMatX & operator*=( const idMatX &a );
 idMatX & operator+=( const idMatX &a );
 idMatX & operator-=( const idMatX &a );

 friend idMatX operator*( const float a, const idMatX &m );
 friend idVecX operator*( const idVecX &vec, const idMatX &m );
 friend idVecX & operator*=( idVecX &vec, const idMatX &m );

 bool Compare( const idMatX &a ) const;
 bool Compare( const idMatX &a, const float epsilon ) const;
 bool operator==( const idMatX &a ) const;
 bool operator!=( const idMatX &a ) const;

 void SetSize( int rows, int columns );
 void ChangeSize( int rows, int columns, bool makeZero = false );
 int GetNumRows( void ) const { return numRows; }
 int GetNumColumns( void ) const { return numColumns; }
 void SetData( int rows, int columns, float *data );
 void Zero( void );
 void Zero( int rows, int columns );
 void Identity( void );
 void Identity( int rows, int columns );
 void Diag( const idVecX &v );
 void Random( int seed, float l = 0.0f, float u = 1.0f );
 void Random( int rows, int columns, int seed, float l = 0.0f, float u = 1.0f );
 void Negate( void );
 void Clamp( float min, float max );
 idMatX & SwapRows( int r1, int r2 );
 idMatX & SwapColumns( int r1, int r2 );
 idMatX & SwapRowsColumns( int r1, int r2 );
 idMatX & RemoveRow( int r );
 idMatX & RemoveColumn( int r );
 idMatX & RemoveRowColumn( int r );
 void ClearUpperTriangle( void );
 void ClearLowerTriangle( void );
 void SquareSubMatrix( const idMatX &m, int size );
 float MaxDifference( const idMatX &m ) const;

 bool IsSquare( void ) const { return ( numRows == numColumns ); }
 bool IsZero( const float epsilon = 1e-6 ) const;
 bool IsIdentity( const float epsilon = 1e-6 ) const;
 bool IsDiagonal( const float epsilon = 1e-6 ) const;
 bool IsTriDiagonal( const float epsilon = 1e-6 ) const;
 bool IsSymmetric( const float epsilon = 1e-6 ) const;
 bool IsOrthogonal( const float epsilon = 1e-6 ) const;
 bool IsOrthonormal( const float epsilon = 1e-6 ) const;
 bool IsPMatrix( const float epsilon = 1e-6 ) const;
 bool IsZMatrix( const float epsilon = 1e-6 ) const;
 bool IsPositiveDefinite( const float epsilon = 1e-6 ) const;
 bool IsSymmetricPositiveDefinite( const float epsilon = 1e-6 ) const;
 bool IsPositiveSemiDefinite( const float epsilon = 1e-6 ) const;
 bool IsSymmetricPositiveSemiDefinite( const float epsilon = 1e-6 ) const;

 float Trace( void ) const;
 float Determinant( void ) const;
 idMatX Transpose( void ) const;
 idMatX & TransposeSelf( void );
 idMatX Inverse( void ) const;
 bool InverseSelf( void );
 idMatX InverseFast( void ) const;
 bool InverseFastSelf( void );

 bool LowerTriangularInverse( void );
 bool UpperTriangularInverse( void );

 idVecX Multiply( const idVecX &vec ) const;
 idVecX TransposeMultiply( const idVecX &vec ) const;

 idMatX Multiply( const idMatX &a ) const;
 idMatX TransposeMultiply( const idMatX &a ) const;

 void Multiply( idVecX &dst, const idVecX &vec ) const;
 void MultiplyAdd( idVecX &dst, const idVecX &vec ) const;
 void MultiplySub( idVecX &dst, const idVecX &vec ) const;
 void TransposeMultiply( idVecX &dst, const idVecX &vec ) const;
 void TransposeMultiplyAdd( idVecX &dst, const idVecX &vec ) const;
 void TransposeMultiplySub( idVecX &dst, const idVecX &vec ) const;

 void Multiply( idMatX &dst, const idMatX &a ) const;
 void TransposeMultiply( idMatX &dst, const idMatX &a ) const;

 int GetDimension( void ) const;

 const idVec6 & SubVec6( int row ) const;
 idVec6 & SubVec6( int row );
 const idVecX SubVecX( int row ) const;
 idVecX SubVecX( int row );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 void Update_RankOne( const idVecX &v, const idVecX &w, float alpha );
 void Update_RankOneSymmetric( const idVecX &v, float alpha );
 void Update_RowColumn( const idVecX &v, const idVecX &w, int r );
 void Update_RowColumnSymmetric( const idVecX &v, int r );
 void Update_Increment( const idVecX &v, const idVecX &w );
 void Update_IncrementSymmetric( const idVecX &v );
 void Update_Decrement( int r );

 bool Inverse_GaussJordan( void );
 bool Inverse_UpdateRankOne( const idVecX &v, const idVecX &w, float alpha );
 bool Inverse_UpdateRowColumn( const idVecX &v, const idVecX &w, int r );
 bool Inverse_UpdateIncrement( const idVecX &v, const idVecX &w );
 bool Inverse_UpdateDecrement( const idVecX &v, const idVecX &w, int r );
 void Inverse_Solve( idVecX &x, const idVecX &b ) const;

 bool LU_Factor( int *index, float *det = __null );
 bool LU_UpdateRankOne( const idVecX &v, const idVecX &w, float alpha, int *index );
 bool LU_UpdateRowColumn( const idVecX &v, const idVecX &w, int r, int *index );
 bool LU_UpdateIncrement( const idVecX &v, const idVecX &w, int *index );
 bool LU_UpdateDecrement( const idVecX &v, const idVecX &w, const idVecX &u, int r, int *index );
 void LU_Solve( idVecX &x, const idVecX &b, const int *index ) const;
 void LU_Inverse( idMatX &inv, const int *index ) const;
 void LU_UnpackFactors( idMatX &L, idMatX &U ) const;
 void LU_MultiplyFactors( idMatX &m, const int *index ) const;

 bool QR_Factor( idVecX &c, idVecX &d );
 bool QR_UpdateRankOne( idMatX &R, const idVecX &v, const idVecX &w, float alpha );
 bool QR_UpdateRowColumn( idMatX &R, const idVecX &v, const idVecX &w, int r );
 bool QR_UpdateIncrement( idMatX &R, const idVecX &v, const idVecX &w );
 bool QR_UpdateDecrement( idMatX &R, const idVecX &v, const idVecX &w, int r );
 void QR_Solve( idVecX &x, const idVecX &b, const idVecX &c, const idVecX &d ) const;
 void QR_Solve( idVecX &x, const idVecX &b, const idMatX &R ) const;
 void QR_Inverse( idMatX &inv, const idVecX &c, const idVecX &d ) const;
 void QR_UnpackFactors( idMatX &Q, idMatX &R, const idVecX &c, const idVecX &d ) const;
 void QR_MultiplyFactors( idMatX &m, const idVecX &c, const idVecX &d ) const;

 bool SVD_Factor( idVecX &w, idMatX &V );
 void SVD_Solve( idVecX &x, const idVecX &b, const idVecX &w, const idMatX &V ) const;
 void SVD_Inverse( idMatX &inv, const idVecX &w, const idMatX &V ) const;
 void SVD_MultiplyFactors( idMatX &m, const idVecX &w, const idMatX &V ) const;

 bool Cholesky_Factor( void );
 bool Cholesky_UpdateRankOne( const idVecX &v, float alpha, int offset = 0 );
 bool Cholesky_UpdateRowColumn( const idVecX &v, int r );
 bool Cholesky_UpdateIncrement( const idVecX &v );
 bool Cholesky_UpdateDecrement( const idVecX &v, int r );
 void Cholesky_Solve( idVecX &x, const idVecX &b ) const;
 void Cholesky_Inverse( idMatX &inv ) const;
 void Cholesky_MultiplyFactors( idMatX &m ) const;

 bool LDLT_Factor( void );
 bool LDLT_UpdateRankOne( const idVecX &v, float alpha, int offset = 0 );
 bool LDLT_UpdateRowColumn( const idVecX &v, int r );
 bool LDLT_UpdateIncrement( const idVecX &v );
 bool LDLT_UpdateDecrement( const idVecX &v, int r );
 void LDLT_Solve( idVecX &x, const idVecX &b ) const;
 void LDLT_Inverse( idMatX &inv ) const;
 void LDLT_UnpackFactors( idMatX &L, idMatX &D ) const;
 void LDLT_MultiplyFactors( idMatX &m ) const;

 void TriDiagonal_ClearTriangles( void );
 bool TriDiagonal_Solve( idVecX &x, const idVecX &b ) const;
 void TriDiagonal_Inverse( idMatX &inv ) const;

 bool Eigen_SolveSymmetricTriDiagonal( idVecX &eigenValues );
 bool Eigen_SolveSymmetric( idVecX &eigenValues );
 bool Eigen_Solve( idVecX &realEigenValues, idVecX &imaginaryEigenValues );
 void Eigen_SortIncreasing( idVecX &eigenValues );
 void Eigen_SortDecreasing( idVecX &eigenValues );

 static void Test( void );

private:
 int numRows;
 int numColumns;
 int alloced;
 float * mat;

 static float temp[1024 +4];
 static float * tempPtr;
 static int tempIndex;

private:
 void SetTempSize( int rows, int columns );
 float DeterminantGeneric( void ) const;
 bool InverseSelfGeneric( void );
 void QR_Rotate( idMatX &R, int i, float a, float b );
 float Pythag( float a, float b ) const;
 void SVD_BiDiag( idVecX &w, idVecX &rv1, float &anorm );
 void SVD_InitialWV( idVecX &w, idMatX &V, idVecX &rv1 );
 void HouseholderReduction( idVecX &diag, idVecX &subd );
 bool QL( idVecX &diag, idVecX &subd );
 void HessenbergReduction( idMatX &H );
 void ComplexDivision( float xr, float xi, float yr, float yi, float &cdivr, float &cdivi );
 bool HessenbergToRealSchur( idMatX &H, idVecX &realEigenValues, idVecX &imaginaryEigenValues );
};

inline idMatX::idMatX( void ) {
 numRows = numColumns = alloced = 0;
 mat = __null;
}

inline idMatX::~idMatX( void ) {

 if ( mat != __null && ( mat < idMatX::tempPtr || mat > idMatX::tempPtr + 1024 ) && alloced != -1 ) {
  Mem_Free16( mat );
 }
}

inline idMatX::idMatX( int rows, int columns ) {
 numRows = numColumns = alloced = 0;
 mat = __null;
 SetSize( rows, columns );
}

inline idMatX::idMatX( int rows, int columns, float *src ) {
 numRows = numColumns = alloced = 0;
 mat = __null;
 SetData( rows, columns, src );
}

inline void idMatX::Set( int rows, int columns, const float *src ) {
 SetSize( rows, columns );
 memcpy( this->mat, src, rows * columns * sizeof( float ) );
}

inline void idMatX::Set( const idMat3 &m1, const idMat3 &m2 ) {
 int i, j;

 SetSize( 3, 6 );
 for ( i = 0; i < 3; i++ ) {
  for ( j = 0; j < 3; j++ ) {
   mat[(i+0) * numColumns + (j+0)] = m1[i][j];
   mat[(i+0) * numColumns + (j+3)] = m2[i][j];
  }
 }
}

inline void idMatX::Set( const idMat3 &m1, const idMat3 &m2, const idMat3 &m3, const idMat3 &m4 ) {
 int i, j;

 SetSize( 6, 6 );
 for ( i = 0; i < 3; i++ ) {
  for ( j = 0; j < 3; j++ ) {
   mat[(i+0) * numColumns + (j+0)] = m1[i][j];
   mat[(i+0) * numColumns + (j+3)] = m2[i][j];
   mat[(i+3) * numColumns + (j+0)] = m3[i][j];
   mat[(i+3) * numColumns + (j+3)] = m4[i][j];
  }
 }
}

inline const float *idMatX::operator[]( int index ) const {
 ((void)0);
 return mat + index * numColumns;
}

inline float *idMatX::operator[]( int index ) {
 ((void)0);
 return mat + index * numColumns;
}

inline idMatX &idMatX::operator=( const idMatX &a ) {
 SetSize( a.numRows, a.numColumns );

 SIMDProcessor->Copy16( mat, a.mat, a.numRows * a.numColumns );



 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX idMatX::operator*( const float a ) const {
 idMatX m;

 m.SetTempSize( numRows, numColumns );

 SIMDProcessor->Mul16( m.mat, mat, a, numRows * numColumns );







 return m;
}

inline idVecX idMatX::operator*( const idVecX &vec ) const {
 idVecX dst;

 ((void)0);

 dst.SetTempSize( numRows );

 SIMDProcessor->MatX_MultiplyVecX( dst, *this, vec );



 return dst;
}

inline idMatX idMatX::operator*( const idMatX &a ) const {
 idMatX dst;

 ((void)0);

 dst.SetTempSize( numRows, a.numColumns );

 SIMDProcessor->MatX_MultiplyMatX( dst, *this, a );



 return dst;
}

inline idMatX idMatX::operator+( const idMatX &a ) const {
 idMatX m;

 ((void)0);
 m.SetTempSize( numRows, numColumns );

 SIMDProcessor->Add16( m.mat, mat, a.mat, numRows * numColumns );







 return m;
}

inline idMatX idMatX::operator-( const idMatX &a ) const {
 idMatX m;

 ((void)0);
 m.SetTempSize( numRows, numColumns );

 SIMDProcessor->Sub16( m.mat, mat, a.mat, numRows * numColumns );







 return m;
}

inline idMatX &idMatX::operator*=( const float a ) {

 SIMDProcessor->MulAssign16( mat, a, numRows * numColumns );







 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX &idMatX::operator*=( const idMatX &a ) {
 *this = *this * a;
 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX &idMatX::operator+=( const idMatX &a ) {
 ((void)0);

 SIMDProcessor->AddAssign16( mat, a.mat, numRows * numColumns );







 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX &idMatX::operator-=( const idMatX &a ) {
 ((void)0);

 SIMDProcessor->SubAssign16( mat, a.mat, numRows * numColumns );







 idMatX::tempIndex = 0;
 return *this;
}

inline idMatX operator*( const float a, idMatX const &m ) {
 return m * a;
}

inline idVecX operator*( const idVecX &vec, const idMatX &m ) {
 return m * vec;
}

inline idVecX &operator*=( idVecX &vec, const idMatX &m ) {
 vec = m * vec;
 return vec;
}

inline bool idMatX::Compare( const idMatX &a ) const {
 int i, s;

 ((void)0);

 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  if ( mat[i] != a.mat[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idMatX::Compare( const idMatX &a, const float epsilon ) const {
 int i, s;

 ((void)0);

 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  if ( idMath::Fabs( mat[i] - a.mat[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idMatX::operator==( const idMatX &a ) const {
 return Compare( a );
}

inline bool idMatX::operator!=( const idMatX &a ) const {
 return !Compare( a );
}

inline void idMatX::SetSize( int rows, int columns ) {
 ((void)0);
 int alloc = ( rows * columns + 3 ) & ~3;
 if ( alloc > alloced && alloced != -1 ) {
  if ( mat != __null ) {
   Mem_Free16( mat );
  }
  mat = (float *) Mem_Alloc16( alloc * sizeof( float ) );
  alloced = alloc;
 }
 numRows = rows;
 numColumns = columns;
 int s = numRows * numColumns; while( s < ( ( s + 3 ) & ~3 ) ) { mat[s++] = 0.0f; };
}

inline void idMatX::SetTempSize( int rows, int columns ) {
 int newSize;

 newSize = ( rows * columns + 3 ) & ~3;
 ((void)0);
 if ( idMatX::tempIndex + newSize > 1024 ) {
  idMatX::tempIndex = 0;
 }
 mat = idMatX::tempPtr + idMatX::tempIndex;
 idMatX::tempIndex += newSize;
 alloced = newSize;
 numRows = rows;
 numColumns = columns;
 int s = numRows * numColumns; while( s < ( ( s + 3 ) & ~3 ) ) { mat[s++] = 0.0f; };
}

inline void idMatX::SetData( int rows, int columns, float *data ) {
 ((void)0);
 if ( mat != __null && alloced != -1 ) {
  Mem_Free16( mat );
 }
 ((void)0);
 mat = data;
 alloced = -1;
 numRows = rows;
 numColumns = columns;
 int s = numRows * numColumns; while( s < ( ( s + 3 ) & ~3 ) ) { mat[s++] = 0.0f; };
}

inline void idMatX::Zero( void ) {

 SIMDProcessor->Zero16( mat, numRows * numColumns );



}

inline void idMatX::Zero( int rows, int columns ) {
 SetSize( rows, columns );

 SIMDProcessor->Zero16( mat, numRows * numColumns );



}

inline void idMatX::Identity( void ) {
 ((void)0);

 SIMDProcessor->Zero16( mat, numRows * numColumns );



 for ( int i = 0; i < numRows; i++ ) {
  mat[i * numColumns + i] = 1.0f;
 }
}

inline void idMatX::Identity( int rows, int columns ) {
 ((void)0);
 SetSize( rows, columns );
 idMatX::Identity();
}

inline void idMatX::Diag( const idVecX &v ) {
 Zero( v.GetSize(), v.GetSize() );
 for ( int i = 0; i < v.GetSize(); i++ ) {
  mat[i * numColumns + i] = v[i];
 }
}

inline void idMatX::Random( int seed, float l, float u ) {
 int i, s;
 float c;
 idRandom rnd(seed);

 c = u - l;
 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  mat[i] = l + rnd.RandomFloat() * c;
 }
}

inline void idMatX::Random( int rows, int columns, int seed, float l, float u ) {
 int i, s;
 float c;
 idRandom rnd(seed);

 SetSize( rows, columns );
 c = u - l;
 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  mat[i] = l + rnd.RandomFloat() * c;
 }
}

inline void idMatX::Negate( void ) {

 SIMDProcessor->Negate16( mat, numRows * numColumns );







}

inline void idMatX::Clamp( float min, float max ) {
 int i, s;
 s = numRows * numColumns;
 for ( i = 0; i < s; i++ ) {
  if ( mat[i] < min ) {
   mat[i] = min;
  } else if ( mat[i] > max ) {
   mat[i] = max;
  }
 }
}

inline idMatX &idMatX::SwapRows( int r1, int r2 ) {
 float *ptr;

 ptr = (float *) ((void *)((((int)__builtin_alloca((numColumns * sizeof( float ))+15)) + 15) & ~15));
 memcpy( ptr, mat + r1 * numColumns, numColumns * sizeof( float ) );
 memcpy( mat + r1 * numColumns, mat + r2 * numColumns, numColumns * sizeof( float ) );
 memcpy( mat + r2 * numColumns, ptr, numColumns * sizeof( float ) );

 return *this;
}

inline idMatX &idMatX::SwapColumns( int r1, int r2 ) {
 int i;
 float tmp, *ptr;

 for ( i = 0; i < numRows; i++ ) {
  ptr = mat + i * numColumns;
  tmp = ptr[r1];
  ptr[r1] = ptr[r2];
  ptr[r2] = tmp;
 }

 return *this;
}

inline idMatX &idMatX::SwapRowsColumns( int r1, int r2 ) {

 SwapRows( r1, r2 );
 SwapColumns( r1, r2 );
 return *this;
}

inline void idMatX::ClearUpperTriangle( void ) {
 ((void)0);
 for ( int i = numRows-2; i >= 0; i-- ) {
  memset( mat + i * numColumns + i + 1, 0, (numColumns - 1 - i) * sizeof(float) );
 }
}

inline void idMatX::ClearLowerTriangle( void ) {
 ((void)0);
 for ( int i = 1; i < numRows; i++ ) {
  memset( mat + i * numColumns, 0, i * sizeof(float) );
 }
}

inline void idMatX::SquareSubMatrix( const idMatX &m, int size ) {
 int i;
 ((void)0);
 SetSize( size, size );
 for ( i = 0; i < size; i++ ) {
  memcpy( mat + i * numColumns, m.mat + i * m.numColumns, size * sizeof( float ) );
 }
}

inline float idMatX::MaxDifference( const idMatX &m ) const {
 int i, j;
 float diff, maxDiff;

 ((void)0);

 maxDiff = -1.0f;
 for ( i = 0; i < numRows; i++ ) {
  for ( j = 0; j < numColumns; j++ ) {
   diff = idMath::Fabs( mat[ i * numColumns + j ] - m[i][j] );
   if ( maxDiff < 0.0f || diff > maxDiff ) {
    maxDiff = diff;
   }
  }
 }
 return maxDiff;
}

inline bool idMatX::IsZero( const float epsilon ) const {

 for ( int i = 0; i < numRows; i++ ) {
  for ( int j = 0; j < numColumns; j++ ) {
   if ( idMath::Fabs( mat[i * numColumns + j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMatX::IsIdentity( const float epsilon ) const {

 ((void)0);
 for ( int i = 0; i < numRows; i++ ) {
  for ( int j = 0; j < numColumns; j++ ) {
   if ( idMath::Fabs( mat[i * numColumns + j] - (float)( i == j ) ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMatX::IsDiagonal( const float epsilon ) const {

 ((void)0);
 for ( int i = 0; i < numRows; i++ ) {
  for ( int j = 0; j < numColumns; j++ ) {
   if ( i != j && idMath::Fabs( mat[i * numColumns + j] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMatX::IsTriDiagonal( const float epsilon ) const {


 if ( numRows != numColumns ) {
  return false;
 }
 for ( int i = 0; i < numRows-2; i++ ) {
  for ( int j = i+2; j < numColumns; j++ ) {
   if ( idMath::Fabs( (*this)[i][j] ) > epsilon ) {
    return false;
   }
   if ( idMath::Fabs( (*this)[j][i] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline bool idMatX::IsSymmetric( const float epsilon ) const {

 if ( numRows != numColumns ) {
  return false;
 }
 for ( int i = 0; i < numRows; i++ ) {
  for ( int j = 0; j < numColumns; j++ ) {
   if ( idMath::Fabs( mat[ i * numColumns + j ] - mat[ j * numColumns + i ] ) > epsilon ) {
    return false;
   }
  }
 }
 return true;
}

inline float idMatX::Trace( void ) const {
 float trace = 0.0f;

 ((void)0);


 for ( int i = 0; i < numRows; i++ ) {
  trace += mat[i * numRows + i];
 }
 return trace;
}

inline float idMatX::Determinant( void ) const {

 ((void)0);

 switch( numRows ) {
  case 1:
   return mat[0];
  case 2:
   return reinterpret_cast<const idMat2 *>(mat)->Determinant();
  case 3:
   return reinterpret_cast<const idMat3 *>(mat)->Determinant();
  case 4:
   return reinterpret_cast<const idMat4 *>(mat)->Determinant();
  case 5:
   return reinterpret_cast<const idMat5 *>(mat)->Determinant();
  case 6:
   return reinterpret_cast<const idMat6 *>(mat)->Determinant();
  default:
   return DeterminantGeneric();
 }
 return 0.0f;
}

inline idMatX idMatX::Transpose( void ) const {
 idMatX transpose;
 int i, j;

 transpose.SetTempSize( numColumns, numRows );

 for ( i = 0; i < numRows; i++ ) {
  for ( j = 0; j < numColumns; j++ ) {
   transpose.mat[j * transpose.numColumns + i] = mat[i * numColumns + j];
  }
 }

 return transpose;
}

inline idMatX &idMatX::TransposeSelf( void ) {
 *this = Transpose();
 return *this;
}

inline idMatX idMatX::Inverse( void ) const {
 idMatX invMat;

 invMat.SetTempSize( numRows, numColumns );
 memcpy( invMat.mat, mat, numRows * numColumns * sizeof( float ) );
 invMat.InverseSelf();

 return invMat;
}

inline bool idMatX::InverseSelf( void ) {

 ((void)0);

 switch( numRows ) {
  case 1:
   if ( idMath::Fabs( mat[0] ) < 1e-14 ) {
    return false;
   }
   mat[0] = 1.0f / mat[0];
   return true;
  case 2:
   return reinterpret_cast<idMat2 *>(mat)->InverseSelf();
  case 3:
   return reinterpret_cast<idMat3 *>(mat)->InverseSelf();
  case 4:
   return reinterpret_cast<idMat4 *>(mat)->InverseSelf();
  case 5:
   return reinterpret_cast<idMat5 *>(mat)->InverseSelf();
  case 6:
   return reinterpret_cast<idMat6 *>(mat)->InverseSelf();
  default:
   return InverseSelfGeneric();
 }
}

inline idMatX idMatX::InverseFast( void ) const {
 idMatX invMat;

 invMat.SetTempSize( numRows, numColumns );
 memcpy( invMat.mat, mat, numRows * numColumns * sizeof( float ) );
 invMat.InverseFastSelf();

 return invMat;
}

inline bool idMatX::InverseFastSelf( void ) {

 ((void)0);

 switch( numRows ) {
  case 1:
   if ( idMath::Fabs( mat[0] ) < 1e-14 ) {
    return false;
   }
   mat[0] = 1.0f / mat[0];
   return true;
  case 2:
   return reinterpret_cast<idMat2 *>(mat)->InverseFastSelf();
  case 3:
   return reinterpret_cast<idMat3 *>(mat)->InverseFastSelf();
  case 4:
   return reinterpret_cast<idMat4 *>(mat)->InverseFastSelf();
  case 5:
   return reinterpret_cast<idMat5 *>(mat)->InverseFastSelf();
  case 6:
   return reinterpret_cast<idMat6 *>(mat)->InverseFastSelf();
  default:
   return InverseSelfGeneric();
 }
 return false;
}

inline idVecX idMatX::Multiply( const idVecX &vec ) const {
 idVecX dst;

 ((void)0);

 dst.SetTempSize( numRows );

 SIMDProcessor->MatX_MultiplyVecX( dst, *this, vec );



 return dst;
}

inline idMatX idMatX::Multiply( const idMatX &a ) const {
 idMatX dst;

 ((void)0);

 dst.SetTempSize( numRows, a.numColumns );

 SIMDProcessor->MatX_MultiplyMatX( dst, *this, a );



 return dst;
}

inline idVecX idMatX::TransposeMultiply( const idVecX &vec ) const {
 idVecX dst;

 ((void)0);

 dst.SetTempSize( numColumns );

 SIMDProcessor->MatX_TransposeMultiplyVecX( dst, *this, vec );



 return dst;
}

inline idMatX idMatX::TransposeMultiply( const idMatX &a ) const {
 idMatX dst;

 ((void)0);

 dst.SetTempSize( numColumns, a.numColumns );

 SIMDProcessor->MatX_TransposeMultiplyMatX( dst, *this, a );



 return dst;
}

inline void idMatX::Multiply( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_MultiplyVecX( dst, *this, vec );
# 2731 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::MultiplyAdd( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_MultiplyAddVecX( dst, *this, vec );
# 2753 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::MultiplySub( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_MultiplySubVecX( dst, *this, vec );
# 2775 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::TransposeMultiply( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_TransposeMultiplyVecX( dst, *this, vec );
# 2797 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::TransposeMultiplyAdd( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_TransposeMultiplyAddVecX( dst, *this, vec );
# 2819 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::TransposeMultiplySub( idVecX &dst, const idVecX &vec ) const {

 SIMDProcessor->MatX_TransposeMultiplySubVecX( dst, *this, vec );
# 2841 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::Multiply( idMatX &dst, const idMatX &a ) const {

 SIMDProcessor->MatX_MultiplyMatX( dst, *this, a );
# 2873 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
}

inline void idMatX::TransposeMultiply( idMatX &dst, const idMatX &a ) const {

 SIMDProcessor->MatX_TransposeMultiplyMatX( dst, *this, a );
# 2905 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Matrix.h"
}

inline int idMatX::GetDimension( void ) const {
 return numRows * numColumns;
}

inline const idVec6 &idMatX::SubVec6( int row ) const {
 ((void)0);
 return *reinterpret_cast<const idVec6 *>(mat + row * numColumns);
}

inline idVec6 &idMatX::SubVec6( int row ) {
 ((void)0);
 return *reinterpret_cast<idVec6 *>(mat + row * numColumns);
}

inline const idVecX idMatX::SubVecX( int row ) const {
 idVecX v;
 ((void)0);
 v.SetData( numColumns, mat + row * numColumns );
 return v;
}

inline idVecX idMatX::SubVecX( int row ) {
 idVecX v;
 ((void)0);
 v.SetData( numColumns, mat + row * numColumns );
 return v;
}

inline const float *idMatX::ToFloatPtr( void ) const {
 return mat;
}

inline float *idMatX::ToFloatPtr( void ) {
 return mat;
}
# 180 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Angles.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Angles.h"
class idVec3;
class idQuat;
class idRotation;
class idMat3;
class idMat4;

class idAngles {
public:
 float pitch;
 float yaw;
 float roll;

     idAngles( void );
     idAngles( float pitch, float yaw, float roll );
     explicit idAngles( const idVec3 &v );

 void Set( float pitch, float yaw, float roll );
 idAngles & Zero( void );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idAngles operator-() const;
 idAngles & operator=( const idAngles &a );
 idAngles operator+( const idAngles &a ) const;
 idAngles & operator+=( const idAngles &a );
 idAngles operator-( const idAngles &a ) const;
 idAngles & operator-=( const idAngles &a );
 idAngles operator*( const float a ) const;
 idAngles & operator*=( const float a );
 idAngles operator/( const float a ) const;
 idAngles & operator/=( const float a );

 friend idAngles operator*( const float a, const idAngles &b );

 bool Compare( const idAngles &a ) const;
 bool Compare( const idAngles &a, const float epsilon ) const;
 bool operator==( const idAngles &a ) const;
 bool operator!=( const idAngles &a ) const;

 idAngles & Normalize360( void );
 idAngles & Normalize180( void );

 void Clamp( const idAngles &min, const idAngles &max );

 int GetDimension( void ) const;

 void ToVectors( idVec3 *forward, idVec3 *right = __null, idVec3 *up = __null ) const;
 idVec3 ToForward( void ) const;
 idQuat ToQuat( void ) const;
 idRotation ToRotation( void ) const;
 idMat3 ToMat3( void ) const;
 idMat4 ToMat4( void ) const;
 idVec3 ToAngularVelocity( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;
};

extern idAngles ang_zero;

inline idAngles::idAngles( void ) {
}

inline idAngles::idAngles( float pitch, float yaw, float roll ) {
 this->pitch = pitch;
 this->yaw = yaw;
 this->roll = roll;
}

inline idAngles::idAngles( const idVec3 &v ) {
 this->pitch = v[0];
 this->yaw = v[1];
 this->roll = v[2];
}

inline void idAngles::Set( float pitch, float yaw, float roll ) {
 this->pitch = pitch;
 this->yaw = yaw;
 this->roll = roll;
}

inline idAngles &idAngles::Zero( void ) {
 pitch = yaw = roll = 0.0f;
 return *this;
}

inline float idAngles::operator[]( int index ) const {
 ((void)0);
 return ( &pitch )[ index ];
}

inline float &idAngles::operator[]( int index ) {
 ((void)0);
 return ( &pitch )[ index ];
}

inline idAngles idAngles::operator-() const {
 return idAngles( -pitch, -yaw, -roll );
}

inline idAngles &idAngles::operator=( const idAngles &a ) {
 pitch = a.pitch;
 yaw = a.yaw;
 roll = a.roll;
 return *this;
}

inline idAngles idAngles::operator+( const idAngles &a ) const {
 return idAngles( pitch + a.pitch, yaw + a.yaw, roll + a.roll );
}

inline idAngles& idAngles::operator+=( const idAngles &a ) {
 pitch += a.pitch;
 yaw += a.yaw;
 roll += a.roll;

 return *this;
}

inline idAngles idAngles::operator-( const idAngles &a ) const {
 return idAngles( pitch - a.pitch, yaw - a.yaw, roll - a.roll );
}

inline idAngles& idAngles::operator-=( const idAngles &a ) {
 pitch -= a.pitch;
 yaw -= a.yaw;
 roll -= a.roll;

 return *this;
}

inline idAngles idAngles::operator*( const float a ) const {
 return idAngles( pitch * a, yaw * a, roll * a );
}

inline idAngles& idAngles::operator*=( float a ) {
 pitch *= a;
 yaw *= a;
 roll *= a;
 return *this;
}

inline idAngles idAngles::operator/( const float a ) const {
 float inva = 1.0f / a;
 return idAngles( pitch * inva, yaw * inva, roll * inva );
}

inline idAngles& idAngles::operator/=( float a ) {
 float inva = 1.0f / a;
 pitch *= inva;
 yaw *= inva;
 roll *= inva;
 return *this;
}

inline idAngles operator*( const float a, const idAngles &b ) {
 return idAngles( a * b.pitch, a * b.yaw, a * b.roll );
}

inline bool idAngles::Compare( const idAngles &a ) const {
 return ( ( a.pitch == pitch ) && ( a.yaw == yaw ) && ( a.roll == roll ) );
}

inline bool idAngles::Compare( const idAngles &a, const float epsilon ) const {
 if ( idMath::Fabs( pitch - a.pitch ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( yaw - a.yaw ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( roll - a.roll ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idAngles::operator==( const idAngles &a ) const {
 return Compare( a );
}

inline bool idAngles::operator!=( const idAngles &a ) const {
 return !Compare( a );
}

inline void idAngles::Clamp( const idAngles &min, const idAngles &max ) {
 if ( pitch < min.pitch ) {
  pitch = min.pitch;
 } else if ( pitch > max.pitch ) {
  pitch = max.pitch;
 }
 if ( yaw < min.yaw ) {
  yaw = min.yaw;
 } else if ( yaw > max.yaw ) {
  yaw = max.yaw;
 }
 if ( roll < min.roll ) {
  roll = min.roll;
 } else if ( roll > max.roll ) {
  roll = max.roll;
 }
}

inline int idAngles::GetDimension( void ) const {
 return 3;
}

inline const float *idAngles::ToFloatPtr( void ) const {
 return &pitch;
}

inline float *idAngles::ToFloatPtr( void ) {
 return &pitch;
}
# 181 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Quat.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Quat.h"
class idVec3;
class idAngles;
class idRotation;
class idMat3;
class idMat4;
class idCQuat;

class idQuat {
public:
 float x;
 float y;
 float z;
 float w;

     idQuat( void );
     idQuat( float x, float y, float z, float w );

 void Set( float x, float y, float z, float w );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idQuat operator-() const;
 idQuat & operator=( const idQuat &a );
 idQuat operator+( const idQuat &a ) const;
 idQuat & operator+=( const idQuat &a );
 idQuat operator-( const idQuat &a ) const;
 idQuat & operator-=( const idQuat &a );
 idQuat operator*( const idQuat &a ) const;
 idVec3 operator*( const idVec3 &a ) const;
 idQuat operator*( float a ) const;
 idQuat & operator*=( const idQuat &a );
 idQuat & operator*=( float a );

 friend idQuat operator*( const float a, const idQuat &b );
 friend idVec3 operator*( const idVec3 &a, const idQuat &b );

 bool Compare( const idQuat &a ) const;
 bool Compare( const idQuat &a, const float epsilon ) const;
 bool operator==( const idQuat &a ) const;
 bool operator!=( const idQuat &a ) const;

 idQuat Inverse( void ) const;
 float Length( void ) const;
 idQuat & Normalize( void );

 float CalcW( void ) const;
 int GetDimension( void ) const;

 idAngles ToAngles( void ) const;
 idRotation ToRotation( void ) const;
 idMat3 ToMat3( void ) const;
 idMat4 ToMat4( void ) const;
 idCQuat ToCQuat( void ) const;
 idVec3 ToAngularVelocity( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 idQuat & Slerp( const idQuat &from, const idQuat &to, float t );
};

inline idQuat::idQuat( void ) {
}

inline idQuat::idQuat( float x, float y, float z, float w ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->w = w;
}

inline float idQuat::operator[]( int index ) const {
 ((void)0);
 return ( &x )[ index ];
}

inline float& idQuat::operator[]( int index ) {
 ((void)0);
 return ( &x )[ index ];
}

inline idQuat idQuat::operator-() const {
 return idQuat( -x, -y, -z, -w );
}

inline idQuat &idQuat::operator=( const idQuat &a ) {
 x = a.x;
 y = a.y;
 z = a.z;
 w = a.w;

 return *this;
}

inline idQuat idQuat::operator+( const idQuat &a ) const {
 return idQuat( x + a.x, y + a.y, z + a.z, w + a.w );
}

inline idQuat& idQuat::operator+=( const idQuat &a ) {
 x += a.x;
 y += a.y;
 z += a.z;
 w += a.w;

 return *this;
}

inline idQuat idQuat::operator-( const idQuat &a ) const {
 return idQuat( x - a.x, y - a.y, z - a.z, w - a.w );
}

inline idQuat& idQuat::operator-=( const idQuat &a ) {
 x -= a.x;
 y -= a.y;
 z -= a.z;
 w -= a.w;

 return *this;
}

inline idQuat idQuat::operator*( const idQuat &a ) const {
 return idQuat( w*a.x + x*a.w + y*a.z - z*a.y,
     w*a.y + y*a.w + z*a.x - x*a.z,
     w*a.z + z*a.w + x*a.y - y*a.x,
     w*a.w - x*a.x - y*a.y - z*a.z );
}

inline idVec3 idQuat::operator*( const idVec3 &a ) const {





 float xxzz = x*x - z*z;
 float wwyy = w*w - y*y;

 float xw2 = x*w*2.0f;
 float xy2 = x*y*2.0f;
 float xz2 = x*z*2.0f;
 float yw2 = y*w*2.0f;
 float yz2 = y*z*2.0f;
 float zw2 = z*w*2.0f;

 return idVec3(
  (xxzz + wwyy)*a.x + (xy2 + zw2)*a.y + (xz2 - yw2)*a.z,
  (xy2 - zw2)*a.x + (y*y+w*w-x*x-z*z)*a.y + (yz2 + xw2)*a.z,
  (xz2 + yw2)*a.x + (yz2 - xw2)*a.y + (wwyy - xxzz)*a.z
 );

}

inline idQuat idQuat::operator*( float a ) const {
 return idQuat( x * a, y * a, z * a, w * a );
}

inline idQuat operator*( const float a, const idQuat &b ) {
 return b * a;
}

inline idVec3 operator*( const idVec3 &a, const idQuat &b ) {
 return b * a;
}

inline idQuat& idQuat::operator*=( const idQuat &a ) {
 *this = *this * a;

 return *this;
}

inline idQuat& idQuat::operator*=( float a ) {
 x *= a;
 y *= a;
 z *= a;
 w *= a;

 return *this;
}

inline bool idQuat::Compare( const idQuat &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) && ( z == a.z ) && ( w == a.w ) );
}

inline bool idQuat::Compare( const idQuat &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( z - a.z ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( w - a.w ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idQuat::operator==( const idQuat &a ) const {
 return Compare( a );
}

inline bool idQuat::operator!=( const idQuat &a ) const {
 return !Compare( a );
}

inline void idQuat::Set( float x, float y, float z, float w ) {
 this->x = x;
 this->y = y;
 this->z = z;
 this->w = w;
}

inline idQuat idQuat::Inverse( void ) const {
 return idQuat( -x, -y, -z, w );
}

inline float idQuat::Length( void ) const {
 float len;

 len = x * x + y * y + z * z + w * w;
 return idMath::Sqrt( len );
}

inline idQuat& idQuat::Normalize( void ) {
 float len;
 float ilength;

 len = this->Length();
 if ( len ) {
  ilength = 1 / len;
  x *= ilength;
  y *= ilength;
  z *= ilength;
  w *= ilength;
 }
 return *this;
}

inline float idQuat::CalcW( void ) const {

 return sqrt( fabs( 1.0f - ( x * x + y * y + z * z ) ) );
}

inline int idQuat::GetDimension( void ) const {
 return 4;
}

inline const float *idQuat::ToFloatPtr( void ) const {
 return &x;
}

inline float *idQuat::ToFloatPtr( void ) {
 return &x;
}
# 306 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Quat.h"
class idCQuat {
public:
 float x;
 float y;
 float z;

     idCQuat( void );
     idCQuat( float x, float y, float z );

 void Set( float x, float y, float z );

 float operator[]( int index ) const;
 float & operator[]( int index );

 bool Compare( const idCQuat &a ) const;
 bool Compare( const idCQuat &a, const float epsilon ) const;
 bool operator==( const idCQuat &a ) const;
 bool operator!=( const idCQuat &a ) const;

 int GetDimension( void ) const;

 idAngles ToAngles( void ) const;
 idRotation ToRotation( void ) const;
 idMat3 ToMat3( void ) const;
 idMat4 ToMat4( void ) const;
 idQuat ToQuat( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;
};

inline idCQuat::idCQuat( void ) {
}

inline idCQuat::idCQuat( float x, float y, float z ) {
 this->x = x;
 this->y = y;
 this->z = z;
}

inline void idCQuat::Set( float x, float y, float z ) {
 this->x = x;
 this->y = y;
 this->z = z;
}

inline float idCQuat::operator[]( int index ) const {
 ((void)0);
 return ( &x )[ index ];
}

inline float& idCQuat::operator[]( int index ) {
 ((void)0);
 return ( &x )[ index ];
}

inline bool idCQuat::Compare( const idCQuat &a ) const {
 return ( ( x == a.x ) && ( y == a.y ) && ( z == a.z ) );
}

inline bool idCQuat::Compare( const idCQuat &a, const float epsilon ) const {
 if ( idMath::Fabs( x - a.x ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( y - a.y ) > epsilon ) {
  return false;
 }
 if ( idMath::Fabs( z - a.z ) > epsilon ) {
  return false;
 }
 return true;
}

inline bool idCQuat::operator==( const idCQuat &a ) const {
 return Compare( a );
}

inline bool idCQuat::operator!=( const idCQuat &a ) const {
 return !Compare( a );
}

inline int idCQuat::GetDimension( void ) const {
 return 3;
}

inline idQuat idCQuat::ToQuat( void ) const {

 return idQuat( x, y, z, sqrt( fabs( 1.0f - ( x * x + y * y + z * z ) ) ) );
}

inline const float *idCQuat::ToFloatPtr( void ) const {
 return &x;
}

inline float *idCQuat::ToFloatPtr( void ) {
 return &x;
}
# 182 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Rotation.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Rotation.h"
class idAngles;
class idQuat;
class idMat3;

class idRotation {

 friend class idAngles;
 friend class idQuat;
 friend class idMat3;

public:
      idRotation( void );
      idRotation( const idVec3 &rotationOrigin, const idVec3 &rotationVec, const float rotationAngle );

 void Set( const idVec3 &rotationOrigin, const idVec3 &rotationVec, const float rotationAngle );
 void SetOrigin( const idVec3 &rotationOrigin );
 void SetVec( const idVec3 &rotationVec );
 void SetVec( const float x, const float y, const float z );
 void SetAngle( const float rotationAngle );
 void Scale( const float s );
 void ReCalculateMatrix( void );
 const idVec3 & GetOrigin( void ) const;
 const idVec3 & GetVec( void ) const;
 float GetAngle( void ) const;

 idRotation operator-() const;
 idRotation operator*( const float s ) const;
 idRotation operator/( const float s ) const;
 idRotation & operator*=( const float s );
 idRotation & operator/=( const float s );
 idVec3 operator*( const idVec3 &v ) const;

 friend idRotation operator*( const float s, const idRotation &r );
 friend idVec3 operator*( const idVec3 &v, const idRotation &r );
 friend idVec3 & operator*=( idVec3 &v, const idRotation &r );

 idAngles ToAngles( void ) const;
 idQuat ToQuat( void ) const;
 const idMat3 & ToMat3( void ) const;
 idMat4 ToMat4( void ) const;
 idVec3 ToAngularVelocity( void ) const;

 void RotatePoint( idVec3 &point ) const;

 void Normalize180( void );
 void Normalize360( void );

private:
 idVec3 origin;
 idVec3 vec;
 float angle;
 mutable idMat3 axis;
 mutable bool axisValid;
};


inline idRotation::idRotation( void ) {
}

inline idRotation::idRotation( const idVec3 &rotationOrigin, const idVec3 &rotationVec, const float rotationAngle ) {
 origin = rotationOrigin;
 vec = rotationVec;
 angle = rotationAngle;
 axisValid = false;
}

inline void idRotation::Set( const idVec3 &rotationOrigin, const idVec3 &rotationVec, const float rotationAngle ) {
 origin = rotationOrigin;
 vec = rotationVec;
 angle = rotationAngle;
 axisValid = false;
}

inline void idRotation::SetOrigin( const idVec3 &rotationOrigin ) {
 origin = rotationOrigin;
}

inline void idRotation::SetVec( const idVec3 &rotationVec ) {
 vec = rotationVec;
 axisValid = false;
}

inline void idRotation::SetVec( float x, float y, float z ) {
 vec[0] = x;
 vec[1] = y;
 vec[2] = z;
 axisValid = false;
}

inline void idRotation::SetAngle( const float rotationAngle ) {
 angle = rotationAngle;
 axisValid = false;
}

inline void idRotation::Scale( const float s ) {
 angle *= s;
 axisValid = false;
}

inline void idRotation::ReCalculateMatrix( void ) {
 axisValid = false;
 ToMat3();
}

inline const idVec3 &idRotation::GetOrigin( void ) const {
 return origin;
}

inline const idVec3 &idRotation::GetVec( void ) const {
 return vec;
}

inline float idRotation::GetAngle( void ) const {
 return angle;
}

inline idRotation idRotation::operator-() const {
 return idRotation( origin, vec, -angle );
}

inline idRotation idRotation::operator*( const float s ) const {
 return idRotation( origin, vec, angle * s );
}

inline idRotation idRotation::operator/( const float s ) const {
 ((void)0);
 return idRotation( origin, vec, angle / s );
}

inline idRotation &idRotation::operator*=( const float s ) {
 angle *= s;
 axisValid = false;
 return *this;
}

inline idRotation &idRotation::operator/=( const float s ) {
 ((void)0);
 angle /= s;
 axisValid = false;
 return *this;
}

inline idVec3 idRotation::operator*( const idVec3 &v ) const {
 if ( !axisValid ) {
  ToMat3();
 }
 return ((v - origin) * axis + origin);
}

inline idRotation operator*( const float s, const idRotation &r ) {
 return r * s;
}

inline idVec3 operator*( const idVec3 &v, const idRotation &r ) {
 return r * v;
}

inline idVec3 &operator*=( idVec3 &v, const idRotation &r ) {
 v = r * v;
 return v;
}

inline void idRotation::RotatePoint( idVec3 &point ) const {
 if ( !axisValid ) {
  ToMat3();
 }
 point = ((point - origin) * axis + origin);
}
# 183 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Plane.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Plane.h"
class idVec3;
class idMat3;
# 71 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Plane.h"
class idPlane {
public:
     idPlane( void );
     idPlane( float a, float b, float c, float d );
     idPlane( const idVec3 &normal, const float dist );

 float operator[]( int index ) const;
 float & operator[]( int index );
 idPlane operator-() const;
 idPlane & operator=( const idVec3 &v );
 idPlane operator+( const idPlane &p ) const;
 idPlane operator-( const idPlane &p ) const;
 idPlane & operator*=( const idMat3 &m );

 bool Compare( const idPlane &p ) const;
 bool Compare( const idPlane &p, const float epsilon ) const;
 bool Compare( const idPlane &p, const float normalEps, const float distEps ) const;
 bool operator==( const idPlane &p ) const;
 bool operator!=( const idPlane &p ) const;

 void Zero( void );
 void SetNormal( const idVec3 &normal );
 const idVec3 & Normal( void ) const;
 idVec3 & Normal( void );
 float Normalize( bool fixDegenerate = true );
 bool FixDegenerateNormal( void );
 bool FixDegeneracies( float distEpsilon );
 float Dist( void ) const;
 void SetDist( const float dist );
 int Type( void ) const;

 bool FromPoints( const idVec3 &p1, const idVec3 &p2, const idVec3 &p3, bool fixDegenerate = true );
 bool FromVecs( const idVec3 &dir1, const idVec3 &dir2, const idVec3 &p, bool fixDegenerate = true );
 void FitThroughPoint( const idVec3 &p );
 bool HeightFit( const idVec3 *points, const int numPoints );
 idPlane Translate( const idVec3 &translation ) const;
 idPlane & TranslateSelf( const idVec3 &translation );
 idPlane Rotate( const idVec3 &origin, const idMat3 &axis ) const;
 idPlane & RotateSelf( const idVec3 &origin, const idMat3 &axis );

 float Distance( const idVec3 &v ) const;
 int Side( const idVec3 &v, const float epsilon = 0.0f ) const;

 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale ) const;
 bool PlaneIntersection( const idPlane &plane, idVec3 &start, idVec3 &dir ) const;

 int GetDimension( void ) const;

 const idVec4 & ToVec4( void ) const;
 idVec4 & ToVec4( void );
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 float a;
 float b;
 float c;
 float d;
};

extern idPlane plane_origin;


inline idPlane::idPlane( void ) {
}

inline idPlane::idPlane( float a, float b, float c, float d ) {
 this->a = a;
 this->b = b;
 this->c = c;
 this->d = d;
}

inline idPlane::idPlane( const idVec3 &normal, const float dist ) {
 this->a = normal.x;
 this->b = normal.y;
 this->c = normal.z;
 this->d = -dist;
}

inline float idPlane::operator[]( int index ) const {
 return ( &a )[ index ];
}

inline float& idPlane::operator[]( int index ) {
 return ( &a )[ index ];
}

inline idPlane idPlane::operator-() const {
 return idPlane( -a, -b, -c, -d );
}

inline idPlane &idPlane::operator=( const idVec3 &v ) {
 a = v.x;
 b = v.y;
 c = v.z;
 d = 0;
 return *this;
}

inline idPlane idPlane::operator+( const idPlane &p ) const {
 return idPlane( a + p.a, b + p.b, c + p.c, d + p.d );
}

inline idPlane idPlane::operator-( const idPlane &p ) const {
 return idPlane( a - p.a, b - p.b, c - p.c, d - p.d );
}

inline idPlane &idPlane::operator*=( const idMat3 &m ) {
 Normal() *= m;
 return *this;
}

inline bool idPlane::Compare( const idPlane &p ) const {
 return ( a == p.a && b == p.b && c == p.c && d == p.d );
}

inline bool idPlane::Compare( const idPlane &p, const float epsilon ) const {
 if ( idMath::Fabs( a - p.a ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( b - p.b ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( c - p.c ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( d - p.d ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idPlane::Compare( const idPlane &p, const float normalEps, const float distEps ) const {
 if ( idMath::Fabs( d - p.d ) > distEps ) {
  return false;
 }
 if ( !Normal().Compare( p.Normal(), normalEps ) ) {
  return false;
 }
 return true;
}

inline bool idPlane::operator==( const idPlane &p ) const {
 return Compare( p );
}

inline bool idPlane::operator!=( const idPlane &p ) const {
 return !Compare( p );
}

inline void idPlane::Zero( void ) {
 a = b = c = d = 0.0f;
}

inline void idPlane::SetNormal( const idVec3 &normal ) {
 a = normal.x;
 b = normal.y;
 c = normal.z;
}

inline const idVec3 &idPlane::Normal( void ) const {
 return *reinterpret_cast<const idVec3 *>(&a);
}

inline idVec3 &idPlane::Normal( void ) {
 return *reinterpret_cast<idVec3 *>(&a);
}

inline float idPlane::Normalize( bool fixDegenerate ) {
 float length = reinterpret_cast<idVec3 *>(&a)->Normalize();

 if ( fixDegenerate ) {
  FixDegenerateNormal();
 }
 return length;
}

inline bool idPlane::FixDegenerateNormal( void ) {
 return Normal().FixDegenerateNormal();
}

inline bool idPlane::FixDegeneracies( float distEpsilon ) {
 bool fixedNormal = FixDegenerateNormal();

 if ( fixedNormal ) {
  if ( idMath::Fabs( d - idMath::Rint( d ) ) < distEpsilon ) {
   d = idMath::Rint( d );
  }
 }
 return fixedNormal;
}

inline float idPlane::Dist( void ) const {
 return -d;
}

inline void idPlane::SetDist( const float dist ) {
 d = -dist;
}

inline bool idPlane::FromPoints( const idVec3 &p1, const idVec3 &p2, const idVec3 &p3, bool fixDegenerate ) {
 Normal() = (p1 - p2).Cross( p3 - p2 );
 if ( Normalize( fixDegenerate ) == 0.0f ) {
  return false;
 }
 d = -( Normal() * p2 );
 return true;
}

inline bool idPlane::FromVecs( const idVec3 &dir1, const idVec3 &dir2, const idVec3 &p, bool fixDegenerate ) {
 Normal() = dir1.Cross( dir2 );
 if ( Normalize( fixDegenerate ) == 0.0f ) {
  return false;
 }
 d = -( Normal() * p );
 return true;
}

inline void idPlane::FitThroughPoint( const idVec3 &p ) {
 d = -( Normal() * p );
}

inline idPlane idPlane::Translate( const idVec3 &translation ) const {
 return idPlane( a, b, c, d - translation * Normal() );
}

inline idPlane &idPlane::TranslateSelf( const idVec3 &translation ) {
 d -= translation * Normal();
 return *this;
}

inline idPlane idPlane::Rotate( const idVec3 &origin, const idMat3 &axis ) const {
 idPlane p;
 p.Normal() = Normal() * axis;
 p.d = d + origin * Normal() - origin * p.Normal();
 return p;
}

inline idPlane &idPlane::RotateSelf( const idVec3 &origin, const idMat3 &axis ) {
 d += origin * Normal();
 Normal() *= axis;
 d -= origin * Normal();
 return *this;
}

inline float idPlane::Distance( const idVec3 &v ) const {
 return a * v.x + b * v.y + c * v.z + d;
}

inline int idPlane::Side( const idVec3 &v, const float epsilon ) const {
 float dist = Distance( v );
 if ( dist > epsilon ) {
  return 0;
 }
 else if ( dist < -epsilon ) {
  return 1;
 }
 else {
  return 2;
 }
}

inline bool idPlane::LineIntersection( const idVec3 &start, const idVec3 &end ) const {
 float d1, d2, fraction;

 d1 = Normal() * start + d;
 d2 = Normal() * end + d;
 if ( d1 == d2 ) {
  return false;
 }
 if ( d1 > 0.0f && d2 > 0.0f ) {
  return false;
 }
 if ( d1 < 0.0f && d2 < 0.0f ) {
  return false;
 }
 fraction = ( d1 / ( d1 - d2 ) );
 return ( fraction >= 0.0f && fraction <= 1.0f );
}

inline bool idPlane::RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale ) const {
 float d1, d2;

 d1 = Normal() * start + d;
 d2 = Normal() * dir;
 if ( d2 == 0.0f ) {
  return false;
 }
 scale = -( d1 / d2 );
 return true;
}

inline int idPlane::GetDimension( void ) const {
 return 4;
}

inline const idVec4 &idPlane::ToVec4( void ) const {
 return *reinterpret_cast<const idVec4 *>(&a);
}

inline idVec4 &idPlane::ToVec4( void ) {
 return *reinterpret_cast<idVec4 *>(&a);
}

inline const float *idPlane::ToFloatPtr( void ) const {
 return reinterpret_cast<const float *>(&a);
}

inline float *idPlane::ToFloatPtr( void ) {
 return reinterpret_cast<float *>(&a);
}
# 184 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Pluecker.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Pluecker.h"
class idPluecker {
public:
     idPluecker( void );
     explicit idPluecker( const float *a );
     explicit idPluecker( const idVec3 &start, const idVec3 &end );
     explicit idPluecker( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idPluecker operator-() const;
 idPluecker operator*( const float a ) const;
 idPluecker operator/( const float a ) const;
 float operator*( const idPluecker &a ) const;
 idPluecker operator-( const idPluecker &a ) const;
 idPluecker operator+( const idPluecker &a ) const;
 idPluecker & operator*=( const float a );
 idPluecker & operator/=( const float a );
 idPluecker & operator+=( const idPluecker &a );
 idPluecker & operator-=( const idPluecker &a );

 bool Compare( const idPluecker &a ) const;
 bool Compare( const idPluecker &a, const float epsilon ) const;
 bool operator==( const idPluecker &a ) const;
 bool operator!=( const idPluecker &a ) const;

 void Set( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 );
 void Zero( void );

 void FromLine( const idVec3 &start, const idVec3 &end );
 void FromRay( const idVec3 &start, const idVec3 &dir );
 bool FromPlanes( const idPlane &p1, const idPlane &p2 );
 bool ToLine( idVec3 &start, idVec3 &end ) const;
 bool ToRay( idVec3 &start, idVec3 &dir ) const;
 void ToDir( idVec3 &dir ) const;
 float PermutedInnerProduct( const idPluecker &a ) const;
 float Distance3DSqr( const idPluecker &a ) const;

 float Length( void ) const;
 float LengthSqr( void ) const;
 idPluecker Normalize( void ) const;
 float NormalizeSelf( void );

 int GetDimension( void ) const;

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

private:
 float p[6];
};

extern idPluecker pluecker_origin;


inline idPluecker::idPluecker( void ) {
}

inline idPluecker::idPluecker( const float *a ) {
 memcpy( p, a, 6 * sizeof( float ) );
}

inline idPluecker::idPluecker( const idVec3 &start, const idVec3 &end ) {
 FromLine( start, end );
}

inline idPluecker::idPluecker( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 ) {
 p[0] = a1;
 p[1] = a2;
 p[2] = a3;
 p[3] = a4;
 p[4] = a5;
 p[5] = a6;
}

inline idPluecker idPluecker::operator-() const {
 return idPluecker( -p[0], -p[1], -p[2], -p[3], -p[4], -p[5] );
}

inline float idPluecker::operator[]( const int index ) const {
 return p[index];
}

inline float &idPluecker::operator[]( const int index ) {
 return p[index];
}

inline idPluecker idPluecker::operator*( const float a ) const {
 return idPluecker( p[0]*a, p[1]*a, p[2]*a, p[3]*a, p[4]*a, p[5]*a );
}

inline float idPluecker::operator*( const idPluecker &a ) const {
 return p[0] * a.p[4] + p[1] * a.p[5] + p[2] * a.p[3] + p[4] * a.p[0] + p[5] * a.p[1] + p[3] * a.p[2];
}

inline idPluecker idPluecker::operator/( const float a ) const {
 float inva;

 ((void)0);
 inva = 1.0f / a;
 return idPluecker( p[0]*inva, p[1]*inva, p[2]*inva, p[3]*inva, p[4]*inva, p[5]*inva );
}

inline idPluecker idPluecker::operator+( const idPluecker &a ) const {
 return idPluecker( p[0] + a[0], p[1] + a[1], p[2] + a[2], p[3] + a[3], p[4] + a[4], p[5] + a[5] );
}

inline idPluecker idPluecker::operator-( const idPluecker &a ) const {
 return idPluecker( p[0] - a[0], p[1] - a[1], p[2] - a[2], p[3] - a[3], p[4] - a[4], p[5] - a[5] );
}

inline idPluecker &idPluecker::operator*=( const float a ) {
 p[0] *= a;
 p[1] *= a;
 p[2] *= a;
 p[3] *= a;
 p[4] *= a;
 p[5] *= a;
 return *this;
}

inline idPluecker &idPluecker::operator/=( const float a ) {
 float inva;

 ((void)0);
 inva = 1.0f / a;
 p[0] *= inva;
 p[1] *= inva;
 p[2] *= inva;
 p[3] *= inva;
 p[4] *= inva;
 p[5] *= inva;
 return *this;
}

inline idPluecker &idPluecker::operator+=( const idPluecker &a ) {
 p[0] += a[0];
 p[1] += a[1];
 p[2] += a[2];
 p[3] += a[3];
 p[4] += a[4];
 p[5] += a[5];
 return *this;
}

inline idPluecker &idPluecker::operator-=( const idPluecker &a ) {
 p[0] -= a[0];
 p[1] -= a[1];
 p[2] -= a[2];
 p[3] -= a[3];
 p[4] -= a[4];
 p[5] -= a[5];
 return *this;
}

inline bool idPluecker::Compare( const idPluecker &a ) const {
 return ( ( p[0] == a[0] ) && ( p[1] == a[1] ) && ( p[2] == a[2] ) &&
   ( p[3] == a[3] ) && ( p[4] == a[4] ) && ( p[5] == a[5] ) );
}

inline bool idPluecker::Compare( const idPluecker &a, const float epsilon ) const {
 if ( idMath::Fabs( p[0] - a[0] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[1] - a[1] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[2] - a[2] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[3] - a[3] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[4] - a[4] ) > epsilon ) {
  return false;
 }

 if ( idMath::Fabs( p[5] - a[5] ) > epsilon ) {
  return false;
 }

 return true;
}

inline bool idPluecker::operator==( const idPluecker &a ) const {
 return Compare( a );
}

inline bool idPluecker::operator!=( const idPluecker &a ) const {
 return !Compare( a );
}

inline void idPluecker::Set( const float a1, const float a2, const float a3, const float a4, const float a5, const float a6 ) {
 p[0] = a1;
 p[1] = a2;
 p[2] = a3;
 p[3] = a4;
 p[4] = a5;
 p[5] = a6;
}

inline void idPluecker::Zero( void ) {
 p[0] = p[1] = p[2] = p[3] = p[4] = p[5] = 0.0f;
}

inline void idPluecker::FromLine( const idVec3 &start, const idVec3 &end ) {
 p[0] = start[0] * end[1] - end[0] * start[1];
 p[1] = start[0] * end[2] - end[0] * start[2];
 p[2] = start[0] - end[0];
 p[3] = start[1] * end[2] - end[1] * start[2];
 p[4] = start[2] - end[2];
 p[5] = end[1] - start[1];
}

inline void idPluecker::FromRay( const idVec3 &start, const idVec3 &dir ) {
 p[0] = start[0] * dir[1] - dir[0] * start[1];
 p[1] = start[0] * dir[2] - dir[0] * start[2];
 p[2] = -dir[0];
 p[3] = start[1] * dir[2] - dir[1] * start[2];
 p[4] = -dir[2];
 p[5] = dir[1];
}

inline bool idPluecker::ToLine( idVec3 &start, idVec3 &end ) const {
 idVec3 dir1, dir2;
 float d;

 dir1[0] = p[3];
 dir1[1] = -p[1];
 dir1[2] = p[0];

 dir2[0] = -p[2];
 dir2[1] = p[5];
 dir2[2] = -p[4];

 d = dir2 * dir2;
 if ( d == 0.0f ) {
  return false;
 }

 start = dir2.Cross(dir1) * (1.0f / d);
 end = start + dir2;
 return true;
}

inline bool idPluecker::ToRay( idVec3 &start, idVec3 &dir ) const {
 idVec3 dir1;
 float d;

 dir1[0] = p[3];
 dir1[1] = -p[1];
 dir1[2] = p[0];

 dir[0] = -p[2];
 dir[1] = p[5];
 dir[2] = -p[4];

 d = dir * dir;
 if ( d == 0.0f ) {
  return false;
 }

 start = dir.Cross(dir1) * (1.0f / d);
 return true;
}

inline void idPluecker::ToDir( idVec3 &dir ) const {
 dir[0] = -p[2];
 dir[1] = p[5];
 dir[2] = -p[4];
}

inline float idPluecker::PermutedInnerProduct( const idPluecker &a ) const {
 return p[0] * a.p[4] + p[1] * a.p[5] + p[2] * a.p[3] + p[4] * a.p[0] + p[5] * a.p[1] + p[3] * a.p[2];
}

inline float idPluecker::Length( void ) const {
 return ( float )idMath::Sqrt( p[5] * p[5] + p[4] * p[4] + p[2] * p[2] );
}

inline float idPluecker::LengthSqr( void ) const {
 return ( p[5] * p[5] + p[4] * p[4] + p[2] * p[2] );
}

inline float idPluecker::NormalizeSelf( void ) {
 float l, d;

 l = LengthSqr();
 if ( l == 0.0f ) {
  return l;
 }
 d = idMath::InvSqrt( l );
 p[0] *= d;
 p[1] *= d;
 p[2] *= d;
 p[3] *= d;
 p[4] *= d;
 p[5] *= d;
 return d * l;
}

inline idPluecker idPluecker::Normalize( void ) const {
 float d;

 d = LengthSqr();
 if ( d == 0.0f ) {
  return *this;
 }
 d = idMath::InvSqrt( d );
 return idPluecker( p[0]*d, p[1]*d, p[2]*d, p[3]*d, p[4]*d, p[5]*d );
}

inline int idPluecker::GetDimension( void ) const {
 return 6;
}

inline const float *idPluecker::ToFloatPtr( void ) const {
 return p;
}

inline float *idPluecker::ToFloatPtr( void ) {
 return p;
}
# 185 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Polynomial.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Polynomial.h"
class idPolynomial {
public:
     idPolynomial( void );
     explicit idPolynomial( int d );
     explicit idPolynomial( float a, float b );
     explicit idPolynomial( float a, float b, float c );
     explicit idPolynomial( float a, float b, float c, float d );
     explicit idPolynomial( float a, float b, float c, float d, float e );

 float operator[]( int index ) const;
 float & operator[]( int index );

 idPolynomial operator-() const;
 idPolynomial & operator=( const idPolynomial &p );

 idPolynomial operator+( const idPolynomial &p ) const;
 idPolynomial operator-( const idPolynomial &p ) const;
 idPolynomial operator*( const float s ) const;
 idPolynomial operator/( const float s ) const;

 idPolynomial & operator+=( const idPolynomial &p );
 idPolynomial & operator-=( const idPolynomial &p );
 idPolynomial & operator*=( const float s );
 idPolynomial & operator/=( const float s );

 bool Compare( const idPolynomial &p ) const;
 bool Compare( const idPolynomial &p, const float epsilon ) const;
 bool operator==( const idPolynomial &p ) const;
 bool operator!=( const idPolynomial &p ) const;

 void Zero( void );
 void Zero( int d );

 int GetDimension( void ) const;
 int GetDegree( void ) const;
 float GetValue( const float x ) const;
 idComplex GetValue( const idComplex &x ) const;
 idPolynomial GetDerivative( void ) const;
 idPolynomial GetAntiDerivative( void ) const;

 int GetRoots( idComplex *roots ) const;
 int GetRoots( float *roots ) const;

 static int GetRoots1( float a, float b, float *roots );
 static int GetRoots2( float a, float b, float c, float *roots );
 static int GetRoots3( float a, float b, float c, float d, float *roots );
 static int GetRoots4( float a, float b, float c, float d, float e, float *roots );

 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );
 const char * ToString( int precision = 2 ) const;

 static void Test( void );

private:
 int degree;
 int allocated;
 float * coefficient;

 void Resize( int d, bool keep );
 int Laguer( const idComplex *coef, const int degree, idComplex &r ) const;
};

inline idPolynomial::idPolynomial( void ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
}

inline idPolynomial::idPolynomial( int d ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( d, false );
}

inline idPolynomial::idPolynomial( float a, float b ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( 1, false );
 coefficient[0] = b;
 coefficient[1] = a;
}

inline idPolynomial::idPolynomial( float a, float b, float c ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( 2, false );
 coefficient[0] = c;
 coefficient[1] = b;
 coefficient[2] = a;
}

inline idPolynomial::idPolynomial( float a, float b, float c, float d ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( 3, false );
 coefficient[0] = d;
 coefficient[1] = c;
 coefficient[2] = b;
 coefficient[3] = a;
}

inline idPolynomial::idPolynomial( float a, float b, float c, float d, float e ) {
 degree = -1;
 allocated = 0;
 coefficient = __null;
 Resize( 4, false );
 coefficient[0] = e;
 coefficient[1] = d;
 coefficient[2] = c;
 coefficient[3] = b;
 coefficient[4] = a;
}

inline float idPolynomial::operator[]( int index ) const {
 ((void)0);
 return coefficient[ index ];
}

inline float& idPolynomial::operator[]( int index ) {
 ((void)0);
 return coefficient[ index ];
}

inline idPolynomial idPolynomial::operator-() const {
 int i;
 idPolynomial n;

 n = *this;
 for ( i = 0; i <= degree; i++ ) {
  n[i] = -n[i];
 }
 return n;
}

inline idPolynomial &idPolynomial::operator=( const idPolynomial &p ) {
 Resize( p.degree, false );
 for ( int i = 0; i <= degree; i++ ) {
  coefficient[i] = p.coefficient[i];
 }
 return *this;
}

inline idPolynomial idPolynomial::operator+( const idPolynomial &p ) const {
 int i;
 idPolynomial n;

 if ( degree > p.degree ) {
  n.Resize( degree, false );
  for ( i = 0; i <= p.degree; i++ ) {
   n.coefficient[i] = coefficient[i] + p.coefficient[i];
  }
  for ( ; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i];
  }
  n.degree = degree;
 } else if ( p.degree > degree ) {
  n.Resize( p.degree, false );
  for ( i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] + p.coefficient[i];
  }
  for ( ; i <= p.degree; i++ ) {
   n.coefficient[i] = p.coefficient[i];
  }
  n.degree = p.degree;
 } else {
  n.Resize( degree, false );
  n.degree = 0;
  for ( i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] + p.coefficient[i];
   if ( n.coefficient[i] != 0.0f ) {
    n.degree = i;
   }
  }
 }
 return n;
}

inline idPolynomial idPolynomial::operator-( const idPolynomial &p ) const {
 int i;
 idPolynomial n;

 if ( degree > p.degree ) {
  n.Resize( degree, false );
  for ( i = 0; i <= p.degree; i++ ) {
   n.coefficient[i] = coefficient[i] - p.coefficient[i];
  }
  for ( ; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i];
  }
  n.degree = degree;
 } else if ( p.degree >= degree ) {
  n.Resize( p.degree, false );
  for ( i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] - p.coefficient[i];
  }
  for ( ; i <= p.degree; i++ ) {
   n.coefficient[i] = - p.coefficient[i];
  }
  n.degree = p.degree;
 } else {
  n.Resize( degree, false );
  n.degree = 0;
  for ( i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] - p.coefficient[i];
   if ( n.coefficient[i] != 0.0f ) {
    n.degree = i;
   }
  }
 }
 return n;
}

inline idPolynomial idPolynomial::operator*( const float s ) const {
 idPolynomial n;

 if ( s == 0.0f ) {
  n.degree = 0;
 } else {
  n.Resize( degree, false );
  for ( int i = 0; i <= degree; i++ ) {
   n.coefficient[i] = coefficient[i] * s;
  }
 }
 return n;
}

inline idPolynomial idPolynomial::operator/( const float s ) const {
 float invs;
 idPolynomial n;

 ((void)0);
 n.Resize( degree, false );
 invs = 1.0f / s;
 for ( int i = 0; i <= degree; i++ ) {
  n.coefficient[i] = coefficient[i] * invs;
 }
 return n;
}

inline idPolynomial &idPolynomial::operator+=( const idPolynomial &p ) {
 int i;

 if ( degree > p.degree ) {
  for ( i = 0; i <= p.degree; i++ ) {
   coefficient[i] += p.coefficient[i];
  }
 } else if ( p.degree > degree ) {
  Resize( p.degree, true );
  for ( i = 0; i <= degree; i++ ) {
   coefficient[i] += p.coefficient[i];
  }
  for ( ; i <= p.degree; i++ ) {
   coefficient[i] = p.coefficient[i];
  }
 } else {
  for ( i = 0; i <= degree; i++ ) {
   coefficient[i] += p.coefficient[i];
   if ( coefficient[i] != 0.0f ) {
    degree = i;
   }
  }
 }
 return *this;
}

inline idPolynomial &idPolynomial::operator-=( const idPolynomial &p ) {
 int i;

 if ( degree > p.degree ) {
  for ( i = 0; i <= p.degree; i++ ) {
   coefficient[i] -= p.coefficient[i];
  }
 } else if ( p.degree > degree ) {
  Resize( p.degree, true );
  for ( i = 0; i <= degree; i++ ) {
   coefficient[i] -= p.coefficient[i];
  }
  for ( ; i <= p.degree; i++ ) {
   coefficient[i] = - p.coefficient[i];
  }
 } else {
  for ( i = 0; i <= degree; i++ ) {
   coefficient[i] -= p.coefficient[i];
   if ( coefficient[i] != 0.0f ) {
    degree = i;
   }
  }
 }
 return *this;
}

inline idPolynomial &idPolynomial::operator*=( const float s ) {
 if ( s == 0.0f ) {
  degree = 0;
 } else {
  for ( int i = 0; i <= degree; i++ ) {
   coefficient[i] *= s;
  }
 }
 return *this;
}

inline idPolynomial &idPolynomial::operator/=( const float s ) {
 float invs;

 ((void)0);
 invs = 1.0f / s;
 for ( int i = 0; i <= degree; i++ ) {
  coefficient[i] = invs;
 }
 return *this;;
}

inline bool idPolynomial::Compare( const idPolynomial &p ) const {
 if ( degree != p.degree ) {
  return false;
 }
 for ( int i = 0; i <= degree; i++ ) {
  if ( coefficient[i] != p.coefficient[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idPolynomial::Compare( const idPolynomial &p, const float epsilon ) const {
 if ( degree != p.degree ) {
  return false;
 }
 for ( int i = 0; i <= degree; i++ ) {
  if ( idMath::Fabs( coefficient[i] - p.coefficient[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idPolynomial::operator==( const idPolynomial &p ) const {
 return Compare( p );
}

inline bool idPolynomial::operator!=( const idPolynomial &p ) const {
 return !Compare( p );
}

inline void idPolynomial::Zero( void ) {
 degree = 0;
}

inline void idPolynomial::Zero( int d ) {
 Resize( d, false );
 for ( int i = 0; i <= degree; i++ ) {
  coefficient[i] = 0.0f;
 }
}

inline int idPolynomial::GetDimension( void ) const {
 return degree;
}

inline int idPolynomial::GetDegree( void ) const {
 return degree;
}

inline float idPolynomial::GetValue( const float x ) const {
 float y, z;
 y = coefficient[0];
 z = x;
 for ( int i = 1; i <= degree; i++ ) {
  y += coefficient[i] * z;
  z *= x;
 }
 return y;
}

inline idComplex idPolynomial::GetValue( const idComplex &x ) const {
 idComplex y, z;
 y.Set( coefficient[0], 0.0f );
 z = x;
 for ( int i = 1; i <= degree; i++ ) {
  y += coefficient[i] * z;
  z *= x;
 }
 return y;
}

inline idPolynomial idPolynomial::GetDerivative( void ) const {
 idPolynomial n;

 if ( degree == 0 ) {
  return n;
 }
 n.Resize( degree - 1, false );
 for ( int i = 1; i <= degree; i++ ) {
  n.coefficient[i-1] = i * coefficient[i];
 }
 return n;
}

inline idPolynomial idPolynomial::GetAntiDerivative( void ) const {
 idPolynomial n;

 if ( degree == 0 ) {
  return n;
 }
 n.Resize( degree + 1, false );
 n.coefficient[0] = 0.0f;
 for ( int i = 0; i <= degree; i++ ) {
  n.coefficient[i+1] = coefficient[i] / ( i + 1 );
 }
 return n;
}

inline int idPolynomial::GetRoots1( float a, float b, float *roots ) {
 ((void)0);
 roots[0] = - b / a;
 return 1;
}

inline int idPolynomial::GetRoots2( float a, float b, float c, float *roots ) {
 float inva, ds;

 if ( a != 1.0f ) {
  ((void)0);
  inva = 1.0f / a;
  c *= inva;
  b *= inva;
 }
 ds = b * b - 4.0f * c;
 if ( ds < 0.0f ) {
  return 0;
 } else if ( ds > 0.0f ) {
  ds = idMath::Sqrt( ds );
  roots[0] = 0.5f * ( -b - ds );
  roots[1] = 0.5f * ( -b + ds );
  return 2;
 } else {
  roots[0] = 0.5f * -b;
  return 1;
 }
}

inline int idPolynomial::GetRoots3( float a, float b, float c, float d, float *roots ) {
 float inva, f, g, halfg, ofs, ds, dist, angle, cs, ss, t;

 if ( a != 1.0f ) {
  ((void)0);
  inva = 1.0f / a;
  d *= inva;
  c *= inva;
  b *= inva;
 }

 f = ( 1.0f / 3.0f ) * ( 3.0f * c - b * b );
 g = ( 1.0f / 27.0f ) * ( 2.0f * b * b * b - 9.0f * c * b + 27.0f * d );
 halfg = 0.5f * g;
 ofs = ( 1.0f / 3.0f ) * b;
 ds = 0.25f * g * g + ( 1.0f / 27.0f ) * f * f * f;

 if ( ds < 0.0f ) {
  dist = idMath::Sqrt( ( -1.0f / 3.0f ) * f );
  angle = ( 1.0f / 3.0f ) * idMath::ATan( idMath::Sqrt( -ds ), -halfg );
  cs = idMath::Cos( angle );
  ss = idMath::Sin( angle );
  roots[0] = 2.0f * dist * cs - ofs;
  roots[1] = -dist * ( cs + idMath::SQRT_THREE * ss ) - ofs;
  roots[2] = -dist * ( cs - idMath::SQRT_THREE * ss ) - ofs;
  return 3;
 } else if ( ds > 0.0f ) {
  ds = idMath::Sqrt( ds );
  t = -halfg + ds;
  if ( t >= 0.0f ) {
   roots[0] = idMath::Pow( t, ( 1.0f / 3.0f ) );
  } else {
   roots[0] = -idMath::Pow( -t, ( 1.0f / 3.0f ) );
  }
  t = -halfg - ds;
  if ( t >= 0.0f ) {
   roots[0] += idMath::Pow( t, ( 1.0f / 3.0f ) );
  } else {
   roots[0] -= idMath::Pow( -t, ( 1.0f / 3.0f ) );
  }
  roots[0] -= ofs;
  return 1;
 } else {
  if ( halfg >= 0.0f ) {
   t = -idMath::Pow( halfg, ( 1.0f / 3.0f ) );
  } else {
   t = idMath::Pow( -halfg, ( 1.0f / 3.0f ) );
  }
  roots[0] = 2.0f * t - ofs;
  roots[1] = -t - ofs;
  roots[2] = roots[1];
  return 3;
 }
}

inline int idPolynomial::GetRoots4( float a, float b, float c, float d, float e, float *roots ) {
 int count;
 float inva, y, ds, r, s1, s2, t1, t2, tp, tm;
 float roots3[3];

 if ( a != 1.0f ) {
  ((void)0);
  inva = 1.0f / a;
  e *= inva;
  d *= inva;
  c *= inva;
  b *= inva;
 }

 count = 0;

 GetRoots3( 1.0f, -c, b * d - 4.0f * e, -b * b * e + 4.0f * c * e - d * d, roots3 );
 y = roots3[0];
 ds = 0.25f * b * b - c + y;

 if ( ds < 0.0f ) {
  return 0;
 } else if ( ds > 0.0f ) {
  r = idMath::Sqrt( ds );
  t1 = 0.75f * b * b - r * r - 2.0f * c;
  t2 = ( 4.0f * b * c - 8.0f * d - b * b * b ) / ( 4.0f * r );
  tp = t1 + t2;
  tm = t1 - t2;

  if ( tp >= 0.0f ) {
   s1 = idMath::Sqrt( tp );
   roots[count++] = -0.25f * b + 0.5f * ( r + s1 );
   roots[count++] = -0.25f * b + 0.5f * ( r - s1 );
  }
  if ( tm >= 0.0f ) {
   s2 = idMath::Sqrt( tm );
   roots[count++] = -0.25f * b + 0.5f * ( s2 - r );
   roots[count++] = -0.25f * b - 0.5f * ( s2 + r );
  }
  return count;
 } else {
  t2 = y * y - 4.0f * e;
  if ( t2 >= 0.0f ) {
   t2 = 2.0f * idMath::Sqrt( t2 );
   t1 = 0.75f * b * b - 2.0f * c;
   if ( t1 + t2 >= 0.0f ) {
    s1 = idMath::Sqrt( t1 + t2 );
    roots[count++] = -0.25f * b + 0.5f * s1;
    roots[count++] = -0.25f * b - 0.5f * s1;
   }
   if ( t1 - t2 >= 0.0f ) {
    s2 = idMath::Sqrt( t1 - t2 );
    roots[count++] = -0.25f * b + 0.5f * s2;
    roots[count++] = -0.25f * b - 0.5f * s2;
   }
  }
  return count;
 }
}

inline const float *idPolynomial::ToFloatPtr( void ) const {
 return coefficient;
}

inline float *idPolynomial::ToFloatPtr( void ) {
 return coefficient;
}

inline void idPolynomial::Resize( int d, bool keep ) {
 int alloc = ( d + 1 + 3 ) & ~3;
 if ( alloc > allocated ) {
  float *ptr = (float *) Mem_Alloc16( alloc * sizeof( float ) );
  if ( coefficient != __null ) {
   if ( keep ) {
    for ( int i = 0; i <= degree; i++ ) {
     ptr[i] = coefficient[i];
    }
   }
   Mem_Free16( coefficient );
  }
  allocated = alloc;
  coefficient = ptr;
 }
 degree = d;
}
# 186 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Extrapolate.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Extrapolate.h"
typedef enum {
 EXTRAPOLATION_NONE = 0x01,
 EXTRAPOLATION_LINEAR = 0x02,
 EXTRAPOLATION_ACCELLINEAR = 0x04,
 EXTRAPOLATION_DECELLINEAR = 0x08,
 EXTRAPOLATION_ACCELSINE = 0x10,
 EXTRAPOLATION_DECELSINE = 0x20,
 EXTRAPOLATION_NOSTOP = 0x40
} extrapolation_t;

template< class type >
class idExtrapolate {
public:
      idExtrapolate();

 void Init( const float startTime, const float duration, const type &startValue, const type &baseSpeed, const type &speed, const extrapolation_t extrapolationType );
 type GetCurrentValue( float time ) const;
 type GetCurrentSpeed( float time ) const;
 bool IsDone( float time ) const { return ( !( extrapolationType & EXTRAPOLATION_NOSTOP ) && time >= startTime + duration ); }
 void SetStartTime( float time ) { startTime = time; currentTime = -1; }
 float GetStartTime( void ) const { return startTime; }
 float GetEndTime( void ) const { return ( !( extrapolationType & EXTRAPOLATION_NOSTOP ) && duration > 0 ) ? startTime + duration : 0; }
 float GetDuration( void ) const { return duration; }
 void SetStartValue( const type &value ) { startValue = value; currentTime = -1; }
 const type & GetStartValue( void ) const { return startValue; }
 const type & GetBaseSpeed( void ) const { return baseSpeed; }
 const type & GetSpeed( void ) const { return speed; }
 extrapolation_t GetExtrapolationType( void ) const { return extrapolationType; }

private:
 extrapolation_t extrapolationType;
 float startTime;
 float duration;
 type startValue;
 type baseSpeed;
 type speed;
 mutable float currentTime;
 mutable type currentValue;
};






template< class type >
inline idExtrapolate<type>::idExtrapolate() {
 extrapolationType = EXTRAPOLATION_NONE;
 startTime = duration = 0.0f;
 memset( &startValue, 0, sizeof( startValue ) );
 memset( &baseSpeed, 0, sizeof( baseSpeed ) );
 memset( &speed, 0, sizeof( speed ) );
 currentTime = -1;
 currentValue = startValue;
}






template< class type >
inline void idExtrapolate<type>::Init( const float startTime, const float duration, const type &startValue, const type &baseSpeed, const type &speed, const extrapolation_t extrapolationType ) {
 this->extrapolationType = extrapolationType;
 this->startTime = startTime;
 this->duration = duration;
 this->startValue = startValue;
 this->baseSpeed = baseSpeed;
 this->speed = speed;
 currentTime = -1;
 currentValue = startValue;
}






template< class type >
inline type idExtrapolate<type>::GetCurrentValue( float time ) const {
 float deltaTime, s;

 if ( time == currentTime ) {
  return currentValue;
 }

 currentTime = time;

 if ( time < startTime ) {
  return startValue;
 }

 if ( !( extrapolationType & EXTRAPOLATION_NOSTOP ) && ( time > startTime + duration ) ) {
  time = startTime + duration;
 }

 switch( extrapolationType & ~EXTRAPOLATION_NOSTOP ) {
  case EXTRAPOLATION_NONE: {
   deltaTime = ( time - startTime ) * 0.001f;
   currentValue = startValue + deltaTime * baseSpeed;
   break;
  }
  case EXTRAPOLATION_LINEAR: {
   deltaTime = ( time - startTime ) * 0.001f;
   currentValue = startValue + deltaTime * ( baseSpeed + speed );
   break;
  }
  case EXTRAPOLATION_ACCELLINEAR: {
   if ( !duration ) {
    currentValue = startValue;
   } else {
    deltaTime = ( time - startTime ) / duration;
    s = ( 0.5f * deltaTime * deltaTime ) * ( duration * 0.001f );
    currentValue = startValue + deltaTime * baseSpeed + s * speed;
   }
   break;
  }
  case EXTRAPOLATION_DECELLINEAR: {
   if ( !duration ) {
    currentValue = startValue;
   } else {
    deltaTime = ( time - startTime ) / duration;
    s = ( deltaTime - ( 0.5f * deltaTime * deltaTime ) ) * ( duration * 0.001f );
    currentValue = startValue + deltaTime * baseSpeed + s * speed;
   }
   break;
  }
  case EXTRAPOLATION_ACCELSINE: {
   if ( !duration ) {
    currentValue = startValue;
   } else {
    deltaTime = ( time - startTime ) / duration;
    s = ( 1.0f - idMath::Cos( deltaTime * idMath::HALF_PI ) ) * duration * 0.001f * idMath::SQRT_1OVER2;
    currentValue = startValue + deltaTime * baseSpeed + s * speed;
   }
   break;
  }
  case EXTRAPOLATION_DECELSINE: {
   if ( !duration ) {
    currentValue = startValue;
   } else {
    deltaTime = ( time - startTime ) / duration;
    s = idMath::Sin( deltaTime * idMath::HALF_PI ) * duration * 0.001f * idMath::SQRT_1OVER2;
    currentValue = startValue + deltaTime * baseSpeed + s * speed;
   }
   break;
  }
 }
 return currentValue;
}






template< class type >
inline type idExtrapolate<type>::GetCurrentSpeed( float time ) const {
 float deltaTime, s;

 if ( time < startTime || !duration ) {
  return ( startValue - startValue );
 }

 if ( !( extrapolationType & EXTRAPOLATION_NOSTOP ) && ( time > startTime + duration ) ) {
  return ( startValue - startValue );
 }

 switch( extrapolationType & ~EXTRAPOLATION_NOSTOP ) {
  case EXTRAPOLATION_NONE: {
   return baseSpeed;
  }
  case EXTRAPOLATION_LINEAR: {
   return baseSpeed + speed;
  }
  case EXTRAPOLATION_ACCELLINEAR: {
   deltaTime = ( time - startTime ) / duration;
   s = deltaTime;
   return baseSpeed + s * speed;
  }
  case EXTRAPOLATION_DECELLINEAR: {
   deltaTime = ( time - startTime ) / duration;
   s = 1.0f - deltaTime;
   return baseSpeed + s * speed;
  }
  case EXTRAPOLATION_ACCELSINE: {
   deltaTime = ( time - startTime ) / duration;
   s = idMath::Sin( deltaTime * idMath::HALF_PI );
   return baseSpeed + s * speed;
  }
  case EXTRAPOLATION_DECELSINE: {
   deltaTime = ( time - startTime ) / duration;
   s = idMath::Cos( deltaTime * idMath::HALF_PI );
   return baseSpeed + s * speed;
  }
  default: {
   return baseSpeed;
  }
 }
}
# 187 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Interpolate.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Interpolate.h"
template< class type >
class idInterpolate {
public:
      idInterpolate();

 void Init( const float startTime, const float duration, const type &startValue, const type &endValue );
 void SetStartTime( float time ) { this->startTime = time; }
 void SetDuration( float duration ) { this->duration = duration; }
 void SetStartValue( const type &startValue ) { this->startValue = startValue; }
 void SetEndValue( const type &endValue ) { this->endValue = endValue; }

 type GetCurrentValue( float time ) const;
 bool IsDone( float time ) const { return ( time >= startTime + duration ); }

 float GetStartTime( void ) const { return startTime; }
 float GetEndTime( void ) const { return startTime + duration; }
 float GetDuration( void ) const { return duration; }
 const type & GetStartValue( void ) const { return startValue; }
 const type & GetEndValue( void ) const { return endValue; }

private:
 float startTime;
 float duration;
 type startValue;
 type endValue;
 mutable float currentTime;
 mutable type currentValue;
};






template< class type >
inline idInterpolate<type>::idInterpolate() {
 currentTime = startTime = duration = 0;
 memset( &currentValue, 0, sizeof( currentValue ) );
 startValue = endValue = currentValue;
}






template< class type >
inline void idInterpolate<type>::Init( const float startTime, const float duration, const type &startValue, const type &endValue ) {
 this->startTime = startTime;
 this->duration = duration;
 this->startValue = startValue;
 this->endValue = endValue;
 this->currentTime = startTime - 1;
 this->currentValue = startValue;
}






template< class type >
inline type idInterpolate<type>::GetCurrentValue( float time ) const {
 float deltaTime;

 deltaTime = time - startTime;
 if ( time != currentTime ) {
  currentTime = time;
  if ( deltaTime <= 0 ) {
   currentValue = startValue;
  } else if ( deltaTime >= duration ) {
   currentValue = endValue;
  } else {
   currentValue = startValue + ( endValue - startValue ) * ( (float) deltaTime / duration );
  }
 }
 return currentValue;
}
# 129 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Interpolate.h"
template< class type >
class idInterpolateAccelDecelLinear {
public:
      idInterpolateAccelDecelLinear();

 void Init( const float startTime, const float accelTime, const float decelTime, const float duration, const type &startValue, const type &endValue );
 void SetStartTime( float time ) { startTime = time; Invalidate(); }
 void SetStartValue( const type &startValue ) { this->startValue = startValue; Invalidate(); }
 void SetEndValue( const type &endValue ) { this->endValue = endValue; Invalidate(); }

 type GetCurrentValue( float time ) const;
 type GetCurrentSpeed( float time ) const;
 bool IsDone( float time ) const { return ( time >= startTime + accelTime + linearTime + decelTime ); }

 float GetStartTime( void ) const { return startTime; }
 float GetEndTime( void ) const { return startTime + accelTime + linearTime + decelTime; }
 float GetDuration( void ) const { return accelTime + linearTime + decelTime; }
 float GetAcceleration( void ) const { return accelTime; }
 float GetDeceleration( void ) const { return decelTime; }
 const type & GetStartValue( void ) const { return startValue; }
 const type & GetEndValue( void ) const { return endValue; }

private:
 float startTime;
 float accelTime;
 float linearTime;
 float decelTime;
 type startValue;
 type endValue;
 mutable idExtrapolate<type> extrapolate;

 void Invalidate( void );
 void SetPhase( float time ) const;
};






template< class type >
inline idInterpolateAccelDecelLinear<type>::idInterpolateAccelDecelLinear() {
 startTime = accelTime = linearTime = decelTime = 0;
 memset( &startValue, 0, sizeof( startValue ) );
 endValue = startValue;
}






template< class type >
inline void idInterpolateAccelDecelLinear<type>::Init( const float startTime, const float accelTime, const float decelTime, const float duration, const type &startValue, const type &endValue ) {
 type speed;

 this->startTime = startTime;
 this->accelTime = accelTime;
 this->decelTime = decelTime;
 this->startValue = startValue;
 this->endValue = endValue;

 if ( duration <= 0.0f ) {
  return;
 }

 if ( this->accelTime + this->decelTime > duration ) {
  this->accelTime = this->accelTime * duration / ( this->accelTime + this->decelTime );
  this->decelTime = duration - this->accelTime;
 }
 this->linearTime = duration - this->accelTime - this->decelTime;
 speed = ( endValue - startValue ) * ( 1000.0f / ( (float) this->linearTime + ( this->accelTime + this->decelTime ) * 0.5f ) );

 if ( this->accelTime ) {
  extrapolate.Init( startTime, this->accelTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_ACCELLINEAR );
 } else if ( this->linearTime ) {
  extrapolate.Init( startTime, this->linearTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_LINEAR );
 } else {
  extrapolate.Init( startTime, this->decelTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_DECELLINEAR );
 }
}






template< class type >
inline void idInterpolateAccelDecelLinear<type>::Invalidate( void ) {
 extrapolate.Init( 0, 0, extrapolate.GetStartValue(), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_NONE );
}






template< class type >
inline void idInterpolateAccelDecelLinear<type>::SetPhase( float time ) const {
 float deltaTime;

 deltaTime = time - startTime;
 if ( deltaTime < accelTime ) {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_ACCELLINEAR ) {
   extrapolate.Init( startTime, accelTime, startValue, extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_ACCELLINEAR );
  }
 } else if ( deltaTime < accelTime + linearTime ) {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_LINEAR ) {
   extrapolate.Init( startTime + accelTime, linearTime, startValue + extrapolate.GetSpeed() * ( accelTime * 0.001f * 0.5f ), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_LINEAR );
  }
 } else {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_DECELLINEAR ) {
   extrapolate.Init( startTime + accelTime + linearTime, decelTime, endValue - ( extrapolate.GetSpeed() * ( decelTime * 0.001f * 0.5f ) ), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_DECELLINEAR );
  }
 }
}






template< class type >
inline type idInterpolateAccelDecelLinear<type>::GetCurrentValue( float time ) const {
 SetPhase( time );
 return extrapolate.GetCurrentValue( time );
}






template< class type >
inline type idInterpolateAccelDecelLinear<type>::GetCurrentSpeed( float time ) const {
 SetPhase( time );
 return extrapolate.GetCurrentSpeed( time );
}
# 278 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Interpolate.h"
template< class type >
class idInterpolateAccelDecelSine {
public:
      idInterpolateAccelDecelSine();

 void Init( const float startTime, const float accelTime, const float decelTime, const float duration, const type &startValue, const type &endValue );
 void SetStartTime( float time ) { startTime = time; Invalidate(); }
 void SetStartValue( const type &startValue ) { this->startValue = startValue; Invalidate(); }
 void SetEndValue( const type &endValue ) { this->endValue = endValue; Invalidate(); }

 type GetCurrentValue( float time ) const;
 type GetCurrentSpeed( float time ) const;
 bool IsDone( float time ) const { return ( time >= startTime + accelTime + linearTime + decelTime ); }

 float GetStartTime( void ) const { return startTime; }
 float GetEndTime( void ) const { return startTime + accelTime + linearTime + decelTime; }
 float GetDuration( void ) const { return accelTime + linearTime + decelTime; }
 float GetAcceleration( void ) const { return accelTime; }
 float GetDeceleration( void ) const { return decelTime; }
 const type & GetStartValue( void ) const { return startValue; }
 const type & GetEndValue( void ) const { return endValue; }

private:
 float startTime;
 float accelTime;
 float linearTime;
 float decelTime;
 type startValue;
 type endValue;
 mutable idExtrapolate<type> extrapolate;

 void Invalidate( void );
 void SetPhase( float time ) const;
};






template< class type >
inline idInterpolateAccelDecelSine<type>::idInterpolateAccelDecelSine() {
 startTime = accelTime = linearTime = decelTime = 0;
 memset( &startValue, 0, sizeof( startValue ) );
 endValue = startValue;
}






template< class type >
inline void idInterpolateAccelDecelSine<type>::Init( const float startTime, const float accelTime, const float decelTime, const float duration, const type &startValue, const type &endValue ) {
 type speed;

 this->startTime = startTime;
 this->accelTime = accelTime;
 this->decelTime = decelTime;
 this->startValue = startValue;
 this->endValue = endValue;

 if ( duration <= 0.0f ) {
  return;
 }

 if ( this->accelTime + this->decelTime > duration ) {
  this->accelTime = this->accelTime * duration / ( this->accelTime + this->decelTime );
  this->decelTime = duration - this->accelTime;
 }
 this->linearTime = duration - this->accelTime - this->decelTime;
 speed = ( endValue - startValue ) * ( 1000.0f / ( (float) this->linearTime + ( this->accelTime + this->decelTime ) * idMath::SQRT_1OVER2 ) );

 if ( this->accelTime ) {
  extrapolate.Init( startTime, this->accelTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_ACCELSINE );
 } else if ( this->linearTime ) {
  extrapolate.Init( startTime, this->linearTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_LINEAR );
 } else {
  extrapolate.Init( startTime, this->decelTime, startValue, ( startValue - startValue ), speed, EXTRAPOLATION_DECELSINE );
 }
}






template< class type >
inline void idInterpolateAccelDecelSine<type>::Invalidate( void ) {
 extrapolate.Init( 0, 0, extrapolate.GetStartValue(), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_NONE );
}






template< class type >
inline void idInterpolateAccelDecelSine<type>::SetPhase( float time ) const {
 float deltaTime;

 deltaTime = time - startTime;
 if ( deltaTime < accelTime ) {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_ACCELSINE ) {
   extrapolate.Init( startTime, accelTime, startValue, extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_ACCELSINE );
  }
 } else if ( deltaTime < accelTime + linearTime ) {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_LINEAR ) {
   extrapolate.Init( startTime + accelTime, linearTime, startValue + extrapolate.GetSpeed() * ( accelTime * 0.001f * idMath::SQRT_1OVER2 ), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_LINEAR );
  }
 } else {
  if ( extrapolate.GetExtrapolationType() != EXTRAPOLATION_DECELSINE ) {
   extrapolate.Init( startTime + accelTime + linearTime, decelTime, endValue - ( extrapolate.GetSpeed() * ( decelTime * 0.001f * idMath::SQRT_1OVER2 ) ), extrapolate.GetBaseSpeed(), extrapolate.GetSpeed(), EXTRAPOLATION_DECELSINE );
  }
 }
}






template< class type >
inline type idInterpolateAccelDecelSine<type>::GetCurrentValue( float time ) const {
 SetPhase( time );
 return extrapolate.GetCurrentValue( time );
}






template< class type >
inline type idInterpolateAccelDecelSine<type>::GetCurrentSpeed( float time ) const {
 SetPhase( time );
 return extrapolate.GetCurrentSpeed( time );
}
# 188 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve {
public:
      idCurve( void );
 virtual ~idCurve( void );

 virtual int AddValue( const float time, const type &value );
 virtual void RemoveIndex( const int index ) { values.RemoveIndex(index); times.RemoveIndex(index); changed = true; }
 virtual void Clear( void ) { values.Clear(); times.Clear(); currentIndex = -1; changed = true; }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

 virtual bool IsDone( const float time ) const;

 int GetNumValues( void ) const { return values.Num(); }
 void SetValue( const int index, const type &value ) { values[index] = value; changed = true; }
 type GetValue( const int index ) const { return values[index]; }
 type * GetValueAddress( const int index ) { return &values[index]; }
 float GetTime( const int index ) const { return times[index]; }

 float GetLengthForTime( const float time ) const;
 float GetTimeForLength( const float length, const float epsilon = 0.1f ) const;
 float GetLengthBetweenKnots( const int i0, const int i1 ) const;

 void MakeUniform( const float totalTime );
 void SetConstantSpeed( const float totalTime );
 void ShiftTime( const float deltaTime );
 void Translate( const type &translation );

protected:

 idList<float> times;
 idList<type> values;

 mutable int currentIndex;
 mutable bool changed;

 int IndexForTime( const float time ) const;
 float TimeForIndex( const int index ) const;
 type ValueForIndex( const int index ) const;

 float GetSpeed( const float time ) const;
 float RombergIntegral( const float t0, const float t1, const int order ) const;
};






template< class type >
inline idCurve<type>::idCurve( void ) {
 currentIndex = -1;
 changed = false;
}






template< class type >
inline idCurve<type>::~idCurve( void ) {
}
# 115 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve<type>::AddValue( const float time, const type &value ) {
 int i;

 i = IndexForTime( time );
 times.Insert( time, i );
 values.Insert( value, i );
 changed = true;
 return i;
}
# 133 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve<type>::GetCurrentValue( const float time ) const {
 int i;

 i = IndexForTime( time );
 if ( i >= values.Num() ) {
  return values[values.Num() - 1];
 } else {
  return values[i];
 }
}
# 152 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve<type>::GetCurrentFirstDerivative( const float time ) const {
 return ( values[0] - values[0] );
}
# 164 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve<type>::GetCurrentSecondDerivative( const float time ) const {
 return ( values[0] - values[0] );
}






template< class type >
inline bool idCurve<type>::IsDone( const float time ) const {
 return ( time >= times[ times.Num() - 1 ] );
}






template< class type >
inline float idCurve<type>::GetSpeed( const float time ) const {
 int i;
 float speed;
 type value;

 value = GetCurrentFirstDerivative( time );
 for ( speed = 0.0f, i = 0; i < value.GetDimension(); i++ ) {
  speed += value[i] * value[i];
 }
 return idMath::Sqrt( speed );
}






template< class type >
inline float idCurve<type>::RombergIntegral( const float t0, const float t1, const int order ) const {
 int i, j, k, m, n;
 float sum, delta;
 float *temp[2];

 temp[0] = (float *) ((void *)((((int)__builtin_alloca((order * sizeof( float ))+15)) + 15) & ~15));
 temp[1] = (float *) ((void *)((((int)__builtin_alloca((order * sizeof( float ))+15)) + 15) & ~15));

 delta = t1 - t0;
 temp[0][0] = 0.5f * delta * ( GetSpeed( t0 ) + GetSpeed( t1 ) );

 for ( i = 2, m = 1; i <= order; i++, m *= 2, delta *= 0.5f ) {


  sum = 0.0f;
  for ( j = 1; j <= m; j++ ) {
   sum += GetSpeed( t0 + delta * ( j - 0.5f ) );
  }


  temp[1][0] = 0.5f * ( temp[0][0] + delta * sum );
  for ( k = 1, n = 4; k < i; k++, n *= 4 ) {
   temp[1][k] = ( n * temp[1][k-1] - temp[0][k-1] ) / ( n - 1 );
  }

  for ( j = 0; j < i; j++ ) {
   temp[0][j] = temp[1][j];
  }
 }
 return temp[0][order-1];
}






template< class type >
inline float idCurve<type>::GetLengthBetweenKnots( const int i0, const int i1 ) const {
 float length = 0.0f;
 for ( int i = i0; i < i1; i++ ) {
  length += RombergIntegral( times[i], times[i+1], 5 );
 }
 return length;
}






template< class type >
inline float idCurve<type>::GetLengthForTime( const float time ) const {
 float length = 0.0f;
 int index = IndexForTime( time );
 for ( int i = 0; i < index; i++ ) {
  length += RombergIntegral( times[i], times[i+1], 5 );
 }
 length += RombergIntegral( times[index], time, 5 );
 return length;
}






template< class type >
inline float idCurve<type>::GetTimeForLength( const float length, const float epsilon ) const {
 int i, index;
 float *accumLength, totalLength, len0, len1, t, diff;

 if ( length <= 0.0f ) {
  return times[0];
 }

 accumLength = (float *) ((void *)((((int)__builtin_alloca((values.Num() * sizeof( float ))+15)) + 15) & ~15));
 totalLength = 0.0f;
 for ( index = 0; index < values.Num() - 1; index++ ) {
  totalLength += GetLengthBetweenKnots( index, index + 1 );
  accumLength[index] = totalLength;
  if ( length < accumLength[index] ) {
   break;
  }
 }

 if ( index >= values.Num() - 1 ) {
  return times[times.Num() - 1];
 }

 if ( index == 0 ) {
  len0 = length;
  len1 = accumLength[0];
 } else {
  len0 = length - accumLength[index-1];
  len1 = accumLength[index] - accumLength[index-1];
 }


 t = ( times[index+1] - times[index] ) * len0 / len1;
 for ( i = 0; i < 32; i++ ) {
  diff = RombergIntegral( times[index], times[index] + t, 5 ) - len0;
  if ( idMath::Fabs( diff ) <= epsilon ) {
   return times[index] + t;
  }
  t -= diff / GetSpeed( times[index] + t );
 }
 return times[index] + t;
}






template< class type >
inline void idCurve<type>::MakeUniform( const float totalTime ) {
 int i, n;

 n = times.Num() - 1;
 for ( i = 0; i <= n; i++ ) {
  times[i] = i * totalTime / n;
 }
 changed = true;
}






template< class type >
inline void idCurve<type>::SetConstantSpeed( const float totalTime ) {
 int i;
 float *length, totalLength, scale, t;

 length = (float *) ((void *)((((int)__builtin_alloca((values.Num() * sizeof( float ))+15)) + 15) & ~15));
 totalLength = 0.0f;
 for ( i = 0; i < values.Num() - 1; i++ ) {
  length[i] = GetLengthBetweenKnots( i, i + 1 );
  totalLength += length[i];
 }
 scale = totalTime / totalLength;
 for ( t = 0.0f, i = 0; i < times.Num() - 1; i++ ) {
  times[i] = t;
  t += scale * length[i];
 }
 times[times.Num() - 1] = totalTime;
 changed = true;
}






template< class type >
inline void idCurve<type>::ShiftTime( const float deltaTime ) {
 for ( int i = 0; i < times.Num(); i++ ) {
  times[i] += deltaTime;
 }
 changed = true;
}






template< class type >
inline void idCurve<type>::Translate( const type &translation ) {
 for ( int i = 0; i < values.Num(); i++ ) {
  values[i] += translation;
 }
 changed = true;
}
# 387 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve<type>::IndexForTime( const float time ) const {
 int len, mid, offset, res;

 if ( currentIndex >= 0 && currentIndex <= times.Num() ) {

  if ( currentIndex == 0 ) {
   if ( time <= times[currentIndex] ) {
    return currentIndex;
   }
  } else if ( currentIndex == times.Num() ) {
   if ( time > times[currentIndex-1] ) {
    return currentIndex;
   }
  } else if ( time > times[currentIndex-1] && time <= times[currentIndex] ) {
   return currentIndex;
  } else if ( time > times[currentIndex] && ( currentIndex+1 == times.Num() || time <= times[currentIndex+1] ) ) {

   currentIndex++;
   return currentIndex;
  }
 }


 len = times.Num();
 mid = len;
 offset = 0;
 res = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( time == times[offset+mid] ) {
   return offset+mid;
  } else if ( time > times[offset+mid] ) {
   offset += mid;
   len -= mid;
   res = 1;
  } else {
   len -= mid;
   res = 0;
  }
 }
 currentIndex = offset+res;
 return currentIndex;
}
# 439 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve<type>::ValueForIndex( const int index ) const {
 int n = values.Num()-1;

 if ( index < 0 ) {
  return values[0] + index * ( values[1] - values[0] );
 } else if ( index > n ) {
  return values[n] + ( index - n ) * ( values[n] - values[n-1] );
 }
 return values[index];
}
# 458 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve<type>::TimeForIndex( const int index ) const {
 int n = times.Num()-1;

 if ( index < 0 ) {
  return times[0] + index * ( times[1] - times[0] );
 } else if ( index > n ) {
  return times[n] + ( index - n ) * ( times[n] - times[n-1] );
 }
 return times[index];
}
# 480 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_Bezier : public idCurve<type> {
public:
      idCurve_Bezier( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const int order, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int order, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int order, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_Bezier<type>::idCurve_Bezier( void ) {
}
# 511 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_Bezier<type>::GetCurrentValue( const float time ) const {
 int i;
 float *bvals;
 type v;

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));

 Basis( this->values.Num(), time, bvals );
 v = bvals[0] * this->values[0];
 for ( i = 1; i < this->values.Num(); i++ ) {
  v += bvals[i] * this->values[i];
 }
 return v;
}
# 534 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_Bezier<type>::GetCurrentFirstDerivative( const float time ) const {
 int i;
 float *bvals, d;
 type v;

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));

 BasisFirstDerivative( this->values.Num(), time, bvals );
 v = bvals[0] * this->values[0];
 for ( i = 1; i < this->values.Num(); i++ ) {
  v += bvals[i] * this->values[i];
 }
 d = ( this->times[this->times.Num()-1] - this->times[0] );
 return ( (float) (this->values.Num()-1) / d ) * v;
}
# 558 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_Bezier<type>::GetCurrentSecondDerivative( const float time ) const {
 int i;
 float *bvals, d;
 type v;

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));

 BasisSecondDerivative( this->values.Num(), time, bvals );
 v = bvals[0] * this->values[0];
 for ( i = 1; i < this->values.Num(); i++ ) {
  v += bvals[i] * this->values[i];
 }
 d = ( this->times[this->times.Num()-1] - this->times[0] );
 return ( (float) (this->values.Num()-2) * (this->values.Num()-1) / ( d * d ) ) * v;
}
# 582 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_Bezier<type>::Basis( const int order, const float t, float *bvals ) const {
 int i, j, d;
 float *c, c1, c2, s, o, ps, po;

 bvals[0] = 1.0f;
 d = order - 1;
 if ( d <= 0 ) {
  return;
 }

 c = (float *) ((void *)((((int)__builtin_alloca(((d+1) * sizeof( float ))+15)) + 15) & ~15));
 s = (float) ( t - this->times[0] ) / ( this->times[this->times.Num()-1] - this->times[0] );
    o = 1.0f - s;
 ps = s;
 po = o;

 for ( i = 1; i < d; i++ ) {
  c[i] = 1.0f;
 }
 for ( i = 1; i < d; i++ ) {
  c[i-1] = 0.0f;
  c1 = c[i];
  c[i] = 1.0f;
  for ( j = i+1; j <= d; j++ ) {
   c2 = c[j];
   c[j] = c1 + c[j-1];
   c1 = c2;
  }
  bvals[i] = c[d] * ps;
  ps *= s;
 }
 for ( i = d-1; i >= 0; i-- ) {
  bvals[i] *= po;
  po *= o;
 }
 bvals[d] = ps;
}
# 628 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_Bezier<type>::BasisFirstDerivative( const int order, const float t, float *bvals ) const {
 int i;

 Basis( order-1, t, bvals+1 );
 bvals[0] = 0.0f;
 for ( i = 0; i < order-1; i++ ) {
  bvals[i] -= bvals[i+1];
 }
}
# 646 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_Bezier<type>::BasisSecondDerivative( const int order, const float t, float *bvals ) const {
 int i;

 BasisFirstDerivative( order-1, t, bvals+1 );
 bvals[0] = 0.0f;
 for ( i = 0; i < order-1; i++ ) {
  bvals[i] -= bvals[i+1];
 }
}
# 667 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_QuadraticBezier : public idCurve<type> {

public:
      idCurve_QuadraticBezier( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const float t, float *bvals ) const;
 void BasisFirstDerivative( const float t, float *bvals ) const;
 void BasisSecondDerivative( const float t, float *bvals ) const;
};






template< class type >
inline idCurve_QuadraticBezier<type>::idCurve_QuadraticBezier( void ) {
}
# 700 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_QuadraticBezier<type>::GetCurrentValue( const float time ) const {
 float bvals[3];
 ((void)0);
 Basis( time, bvals );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] );
}
# 715 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_QuadraticBezier<type>::GetCurrentFirstDerivative( const float time ) const {
 float bvals[3], d;
 ((void)0);
 BasisFirstDerivative( time, bvals );
 d = ( this->times[2] - this->times[0] );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] ) / d;
}
# 731 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_QuadraticBezier<type>::GetCurrentSecondDerivative( const float time ) const {
 float bvals[3], d;
 ((void)0);
 BasisSecondDerivative( time, bvals );
 d = ( this->times[2] - this->times[0] );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] ) / ( d * d );
}
# 747 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_QuadraticBezier<type>::Basis( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[2] - this->times[0] );
 float s2 = s1 * s1;
 bvals[0] = s2 - 2.0f * s1 + 1.0f;
 bvals[1] = -2.0f * s2 + 2.0f * s1;
 bvals[2] = s2;
}
# 763 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_QuadraticBezier<type>::BasisFirstDerivative( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[2] - this->times[0] );
 bvals[0] = 2.0f * s1 - 2.0f;
 bvals[1] = -4.0f * s1 + 2.0f;
 bvals[2] = 2.0f * s1;
}
# 778 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_QuadraticBezier<type>::BasisSecondDerivative( const float t, float *bvals ) const {

 bvals[0] = 2.0f;
 bvals[1] = -4.0f;
 bvals[2] = 2.0f;
}
# 796 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_CubicBezier : public idCurve<type> {

public:
      idCurve_CubicBezier( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const float t, float *bvals ) const;
 void BasisFirstDerivative( const float t, float *bvals ) const;
 void BasisSecondDerivative( const float t, float *bvals ) const;
};






template< class type >
inline idCurve_CubicBezier<type>::idCurve_CubicBezier( void ) {
}
# 829 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CubicBezier<type>::GetCurrentValue( const float time ) const {
 float bvals[4];
 ((void)0);
 Basis( time, bvals );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] + bvals[3] * this->values[3] );
}
# 844 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CubicBezier<type>::GetCurrentFirstDerivative( const float time ) const {
 float bvals[4], d;
 ((void)0);
 BasisFirstDerivative( time, bvals );
 d = ( this->times[3] - this->times[0] );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] + bvals[3] * this->values[3] ) / d;
}
# 860 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CubicBezier<type>::GetCurrentSecondDerivative( const float time ) const {
 float bvals[4], d;
 ((void)0);
 BasisSecondDerivative( time, bvals );
 d = ( this->times[3] - this->times[0] );
 return ( bvals[0] * this->values[0] + bvals[1] * this->values[1] + bvals[2] * this->values[2] + bvals[3] * this->values[3] ) / ( d * d );
}
# 876 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CubicBezier<type>::Basis( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[3] - this->times[0] );
 float s2 = s1 * s1;
 float s3 = s2 * s1;
 bvals[0] = -s3 + 3.0f * s2 - 3.0f * s1 + 1.0f;
 bvals[1] = 3.0f * s3 - 6.0f * s2 + 3.0f * s1;
 bvals[2] = -3.0f * s3 + 3.0f * s2;
 bvals[3] = s3;
}
# 894 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CubicBezier<type>::BasisFirstDerivative( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[3] - this->times[0] );
 float s2 = s1 * s1;
 bvals[0] = -3.0f * s2 + 6.0f * s1 - 3.0f;
 bvals[1] = 9.0f * s2 - 12.0f * s1 + 3.0f;
 bvals[2] = -9.0f * s2 + 6.0f * s1;
 bvals[3] = 3.0f * s2;
}
# 911 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CubicBezier<type>::BasisSecondDerivative( const float t, float *bvals ) const {
 float s1 = (float) ( t - this->times[0] ) / ( this->times[3] - this->times[0] );
 bvals[0] = -6.0f * s1 + 6.0f;
 bvals[1] = 18.0f * s1 - 12.0f;
 bvals[2] = -18.0f * s1 + 6.0f;
 bvals[3] = 6.0f * s1;
}
# 929 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_Spline : public idCurve<type> {

public:
 enum boundary_t { BT_FREE, BT_CLAMPED, BT_CLOSED };

      idCurve_Spline( void );

 virtual bool IsDone( const float time ) const;

 virtual void SetBoundaryType( const boundary_t bt ) { boundaryType = bt; this->changed = true; }
 virtual boundary_t GetBoundaryType( void ) const { return boundaryType; }

 virtual void SetCloseTime( const float t ) { closeTime = t; this->changed = true; }
 virtual float GetCloseTime( void ) { return boundaryType == BT_CLOSED ? closeTime : 0.0f; }

protected:
 boundary_t boundaryType;
 float closeTime;

 type ValueForIndex( const int index ) const;
 float TimeForIndex( const int index ) const;
 float ClampedTime( const float t ) const;
};






template< class type >
inline idCurve_Spline<type>::idCurve_Spline( void ) {
 boundaryType = BT_FREE;
 closeTime = 0.0f;
}
# 972 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_Spline<type>::ValueForIndex( const int index ) const {
 int n = this->values.Num()-1;

 if ( index < 0 ) {
  if ( boundaryType == BT_CLOSED ) {
   return this->values[ this->values.Num() + index % this->values.Num() ];
  }
  else {
   return this->values[0] + index * ( this->values[1] - this->values[0] );
  }
 }
 else if ( index > n ) {
  if ( boundaryType == BT_CLOSED ) {
   return this->values[ index % this->values.Num() ];
  }
  else {
   return this->values[n] + ( index - n ) * ( this->values[n] - this->values[n-1] );
  }
 }
 return this->values[index];
}
# 1002 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_Spline<type>::TimeForIndex( const int index ) const {
 int n = this->times.Num()-1;

 if ( index < 0 ) {
  if ( boundaryType == BT_CLOSED ) {
   return ( index / this->times.Num() ) * ( this->times[n] + closeTime ) - ( this->times[n] + closeTime - this->times[this->times.Num() + index % this->times.Num()] );
  }
  else {
   return this->times[0] + index * ( this->times[1] - this->times[0] );
  }
 }
 else if ( index > n ) {
  if ( boundaryType == BT_CLOSED ) {
   return ( index / this->times.Num() ) * ( this->times[n] + closeTime ) + this->times[index % this->times.Num()];
  }
  else {
   return this->times[n] + ( index - n ) * ( this->times[n] - this->times[n-1] );
  }
 }
 return this->times[index];
}
# 1032 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_Spline<type>::ClampedTime( const float t ) const {
 if ( boundaryType == BT_CLAMPED ) {
  if ( t < this->times[0] ) {
   return this->times[0];
  }
  else if ( t >= this->times[this->times.Num()-1] ) {
   return this->times[this->times.Num()-1];
  }
 }
 return t;
}






template< class type >
inline bool idCurve_Spline<type>::IsDone( const float time ) const {
 return ( boundaryType != BT_CLOSED && time >= this->times[ this->times.Num() - 1 ] );
}
# 1065 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_NaturalCubicSpline : public idCurve_Spline<type> {
public:
      idCurve_NaturalCubicSpline( void );

 virtual void Clear( void ) { idCurve_Spline<type>::Clear(); this->values.Clear(); b.Clear(); c.Clear(); d.Clear(); }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 mutable idList<type>b;
 mutable idList<type>c;
 mutable idList<type>d;

 void Setup( void ) const;
 void SetupFree( void ) const;
 void SetupClamped( void ) const;
 void SetupClosed( void ) const;
};






template< class type >
inline idCurve_NaturalCubicSpline<type>::idCurve_NaturalCubicSpline( void ) {
}
# 1103 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NaturalCubicSpline<type>::GetCurrentValue( const float time ) const {
 float clampedTime = this->ClampedTime( time );
 int i = this->IndexForTime( clampedTime );
 float s = time - this->TimeForIndex( i );
 Setup();
 return ( this->values[i] + s * ( b[i] + s * ( c[i] + s * d[i] ) ) );
}
# 1119 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NaturalCubicSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 float clampedTime = this->ClampedTime( time );
 int i = this->IndexForTime( clampedTime );
 float s = time - this->TimeForIndex( i );
 Setup();
 return ( b[i] + s * ( 2.0f * c[i] + 3.0f * s * d[i] ) );
}
# 1135 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NaturalCubicSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 float clampedTime = this->ClampedTime( time );
 int i = this->IndexForTime( clampedTime );
 float s = time - this->TimeForIndex( i );
 Setup();
 return ( 2.0f * c[i] + 6.0f * s * d[i] );
}






template< class type >
inline void idCurve_NaturalCubicSpline<type>::Setup( void ) const {
 if ( this->changed ) {
  switch( this->boundaryType ) {
   case idCurve_Spline<type>::BT_FREE: SetupFree(); break;
   case idCurve_Spline<type>::BT_CLAMPED: SetupClamped(); break;
   case idCurve_Spline<type>::BT_CLOSED: SetupClosed(); break;
  }
  this->changed = false;
 }
}






template< class type >
inline void idCurve_NaturalCubicSpline<type>::SetupFree( void ) const {
 int i;
 float inv;
 float *d0, *d1, *beta, *gamma;
 type *alpha, *delta;

 d0 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 d1 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 alpha = (type *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( type ))+15)) + 15) & ~15));
 beta = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));
 gamma = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 delta = (type *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( type ))+15)) + 15) & ~15));

 for ( i = 0; i < this->values.Num() - 1; i++ ) {
  d0[i] = this->times[i+1] - this->times[i];
 }

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  d1[i] = this->times[i+1] - this->times[i-1];
 }

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  type sum = 3.0f * ( d0[i-1] * this->values[i+1] - d1[i] * this->values[i] + d0[i] * this->values[i-1] );
  inv = 1.0f / ( d0[i-1] * d0[i] );
  alpha[i] = inv * sum;
 }

 beta[0] = 1.0f;
 gamma[0] = 0.0f;
 delta[0] = this->values[0] - this->values[0];

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  beta[i] = 2.0f * d1[i] - d0[i-1] * gamma[i-1];
  inv = 1.0f / beta[i];
  gamma[i] = inv * d0[i];
  delta[i] = inv * ( alpha[i] - d0[i-1] * delta[i-1] );
 }
 beta[this->values.Num() - 1] = 1.0f;
 delta[this->values.Num() - 1] = this->values[0] - this->values[0];

 b.AssureSize( this->values.Num() );
 c.AssureSize( this->values.Num() );
 d.AssureSize( this->values.Num() );

 c[this->values.Num() - 1] = this->values[0] - this->values[0];

 for ( i = this->values.Num() - 2; i >= 0; i-- ) {
  c[i] = delta[i] - gamma[i] * c[i+1];
  inv = 1.0f / d0[i];
  b[i] = inv * ( this->values[i+1] - this->values[i] ) - ( 1.0f / 3.0f ) * d0[i] * ( c[i+1] + 2.0f * c[i] );
  d[i] = ( 1.0f / 3.0f ) * inv * ( c[i+1] - c[i] );
 }
}






template< class type >
inline void idCurve_NaturalCubicSpline<type>::SetupClamped( void ) const {
 int i;
 float inv;
 float *d0, *d1, *beta, *gamma;
 type *alpha, *delta;

 d0 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 d1 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 alpha = (type *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( type ))+15)) + 15) & ~15));
 beta = (float *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( float ))+15)) + 15) & ~15));
 gamma = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 delta = (type *) ((void *)((((int)__builtin_alloca((this->values.Num() * sizeof( type ))+15)) + 15) & ~15));

 for ( i = 0; i < this->values.Num() - 1; i++ ) {
  d0[i] = this->times[i+1] - this->times[i];
 }

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  d1[i] = this->times[i+1] - this->times[i-1];
 }

 inv = 1.0f / d0[0];
 alpha[0] = 3.0f * ( inv - 1.0f ) * ( this->values[1] - this->values[0] );
 inv = 1.0f / d0[this->values.Num() - 2];
 alpha[this->values.Num() - 1] = 3.0f * ( 1.0f - inv ) * ( this->values[this->values.Num() - 1] - this->values[this->values.Num() - 2] );

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  type sum = 3.0f * ( d0[i-1] * this->values[i+1] - d1[i] * this->values[i] + d0[i] * this->values[i-1] );
  inv = 1.0f / ( d0[i-1] * d0[i] );
  alpha[i] = inv * sum;
 }

 beta[0] = 2.0f * d0[0];
 gamma[0] = 0.5f;
 inv = 1.0f / beta[0];
 delta[0] = inv * alpha[0];

 for ( i = 1; i < this->values.Num() - 1; i++ ) {
  beta[i] = 2.0f * d1[i] - d0[i-1] * gamma[i-1];
  inv = 1.0f / beta[i];
  gamma[i] = inv * d0[i];
  delta[i] = inv * ( alpha[i] - d0[i-1] * delta[i-1] );
 }

 beta[this->values.Num() - 1] = d0[this->values.Num() - 2] * ( 2.0f - gamma[this->values.Num() - 2] );
 inv = 1.0f / beta[this->values.Num() - 1];
 delta[this->values.Num() - 1] = inv * ( alpha[this->values.Num() - 1] - d0[this->values.Num() - 2] * delta[this->values.Num() - 2] );

 b.AssureSize( this->values.Num() );
 c.AssureSize( this->values.Num() );
 d.AssureSize( this->values.Num() );

 c[this->values.Num() - 1] = delta[this->values.Num() - 1];

 for ( i = this->values.Num() - 2; i >= 0; i-- ) {
  c[i] = delta[i] - gamma[i] * c[i+1];
  inv = 1.0f / d0[i];
  b[i] = inv * ( this->values[i+1] - this->values[i] ) - ( 1.0f / 3.0f ) * d0[i]* ( c[i+1] + 2.0f * c[i] );
  d[i] = ( 1.0f / 3.0f ) * inv * ( c[i+1] - c[i] );
 }
}






template< class type >
inline void idCurve_NaturalCubicSpline<type>::SetupClosed( void ) const {
 int i, j;
 float c0, c1;
 float *d0;
 idMatX mat;
 idVecX x;

 d0 = (float *) ((void *)((((int)__builtin_alloca((( this->values.Num() - 1 ) * sizeof( float ))+15)) + 15) & ~15));
 x.SetData( this->values.Num(), ( (float *) ((void *)((((int)__builtin_alloca((( ( ( ( this->values.Num() ) + 3 ) & ~3 ) * sizeof( float ) ))+15)) + 15) & ~15)) ) );
 mat.SetData( this->values.Num(), this->values.Num(), ( (float *) ((void *)((((int)__builtin_alloca((( ( ( ( this->values.Num() * this->values.Num() ) + 3 ) & ~3 ) * sizeof( float ) ))+15)) + 15) & ~15)) ) );

 b.AssureSize( this->values.Num() );
 c.AssureSize( this->values.Num() );
 d.AssureSize( this->values.Num() );

 for ( i = 0; i < this->values.Num() - 1; i++ ) {
  d0[i] = this->times[i+1] - this->times[i];
 }


 mat[0][0] = 1.0f;
 mat[0][this->values.Num() - 1] = -1.0f;
 for ( i = 1; i <= this->values.Num() - 2; i++ ) {
  mat[i][i-1] = d0[i-1];
  mat[i][i ] = 2.0f * ( d0[i-1] + d0[i] );
  mat[i][i+1] = d0[i];
 }
 mat[this->values.Num() - 1][this->values.Num() - 2] = d0[this->values.Num() - 2];
 mat[this->values.Num() - 1][0] = 2.0f * ( d0[this->values.Num() - 2] + d0[0] );
 mat[this->values.Num() - 1][1] = d0[0];


 c[0].Zero();
 for ( i = 1; i <= this->values.Num() - 2; i++ ) {
  c0 = 1.0f / d0[i];
  c1 = 1.0f / d0[i-1];
  c[i] = 3.0f * ( c0 * ( this->values[i + 1] - this->values[i] ) - c1 * ( this->values[i] - this->values[i - 1] ) );
 }
 c0 = 1.0f / d0[0];
 c1 = 1.0f / d0[this->values.Num() - 2];
 c[this->values.Num() - 1] = 3.0f * ( c0 * ( this->values[1] - this->values[0] ) - c1 * ( this->values[0] - this->values[this->values.Num() - 2] ) );


 mat.LU_Factor( __null );
 for ( i = 0; i < this->values[0].GetDimension(); i++ ) {
  for ( j = 0; j < this->values.Num(); j++ ) {
   x[j] = c[j][i];
  }
  mat.LU_Solve( x, x, __null );
  for ( j = 0; j < this->values.Num(); j++ ) {
   c[j][i] = x[j];
  }
 }

 for ( i = 0; i < this->values.Num() - 1; i++ ) {
  c0 = 1.0f / d0[i];
  b[i] = c0 * ( this->values[i + 1] - this->values[i] ) - ( 1.0f / 3.0f ) * ( c[i+1] + 2.0f * c[i] ) * d0[i];
  d[i] = ( 1.0f / 3.0f ) * c0 * ( c[i + 1] - c[i] );
 }
}
# 1366 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_CatmullRomSpline : public idCurve_Spline<type> {

public:
      idCurve_CatmullRomSpline( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const int index, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int index, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int index, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_CatmullRomSpline<type>::idCurve_CatmullRomSpline( void ) {
}
# 1398 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CatmullRomSpline<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float bvals[4], clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 Basis( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 1426 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CatmullRomSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float bvals[4], d, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisFirstDerivative( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / d;
}
# 1455 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_CatmullRomSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float bvals[4], d, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisSecondDerivative( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / ( d * d );
}
# 1484 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CatmullRomSpline<type>::Basis( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( ( -s + 2.0f ) * s - 1.0f ) * s * 0.5f;
 bvals[1] = ( ( ( 3.0f * s - 5.0f ) * s ) * s + 2.0f ) * 0.5f;
 bvals[2] = ( ( -3.0f * s + 4.0f ) * s + 1.0f ) * s * 0.5f;
 bvals[3] = ( ( s - 1.0f ) * s * s ) * 0.5f;
}
# 1500 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CatmullRomSpline<type>::BasisFirstDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( -1.5f * s + 2.0f ) * s - 0.5f;
 bvals[1] = ( 4.5f * s - 5.0f ) * s;
 bvals[2] = ( -4.5 * s + 4.0f ) * s + 0.5f;
 bvals[3] = 1.5f * s * s - s;
}
# 1516 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_CatmullRomSpline<type>::BasisSecondDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = -3.0f * s + 2.0f;
 bvals[1] = 9.0f * s - 5.0f;
 bvals[2] = -9.0f * s + 4.0f;
 bvals[3] = 3.0f * s - 1.0f;
}
# 1537 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_KochanekBartelsSpline : public idCurve_Spline<type> {

public:
      idCurve_KochanekBartelsSpline( void );

 virtual int AddValue( const float time, const type &value );
 virtual int AddValue( const float time, const type &value, const float tension, const float continuity, const float bias );
 virtual void RemoveIndex( const int index ) { this->values.RemoveIndex(index); this->times.RemoveIndex(index); tension.RemoveIndex(index); continuity.RemoveIndex(index); bias.RemoveIndex(index); }
 virtual void Clear( void ) { this->values.Clear(); this->times.Clear(); tension.Clear(); continuity.Clear(); bias.Clear(); this->currentIndex = -1; }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 idList<float> tension;
 idList<float> continuity;
 idList<float> bias;

 void TangentsForIndex( const int index, type &t0, type &t1 ) const;

 void Basis( const int index, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int index, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int index, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_KochanekBartelsSpline<type>::idCurve_KochanekBartelsSpline( void ) {
}
# 1581 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve_KochanekBartelsSpline<type>::AddValue( const float time, const type &value ) {
 int i;

 i = this->IndexForTime( time );
 this->times.Insert( time, i );
 this->values.Insert( value, i );
 tension.Insert( 0.0f, i );
 continuity.Insert( 0.0f, i );
 bias.Insert( 0.0f, i );
 return i;
}
# 1602 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve_KochanekBartelsSpline<type>::AddValue( const float time, const type &value, const float tension, const float continuity, const float bias ) {
 int i;

 i = this->IndexForTime( time );
 this->times.Insert( time, i );
 this->values.Insert( value, i );
 this->tension.Insert( tension, i );
 this->continuity.Insert( continuity, i );
 this->bias.Insert( bias, i );
 return i;
}
# 1622 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_KochanekBartelsSpline<type>::GetCurrentValue( const float time ) const {
 int i;
 float bvals[4], clampedTime;
 type v, t0, t1;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 TangentsForIndex( i - 1, t0, t1 );
 Basis( i - 1, clampedTime, bvals );
 v = bvals[0] * this->ValueForIndex( i - 1 );
 v += bvals[1] * this->ValueForIndex( i );
 v += bvals[2] * t0;
 v += bvals[3] * t1;
 return v;
}
# 1650 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_KochanekBartelsSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i;
 float bvals[4], d, clampedTime;
 type v, t0, t1;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 TangentsForIndex( i - 1, t0, t1 );
 BasisFirstDerivative( i - 1, clampedTime, bvals );
 v = bvals[0] * this->ValueForIndex( i - 1 );
 v += bvals[1] * this->ValueForIndex( i );
 v += bvals[2] * t0;
 v += bvals[3] * t1;
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / d;
}
# 1679 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_KochanekBartelsSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i;
 float bvals[4], d, clampedTime;
 type v, t0, t1;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 TangentsForIndex( i - 1, t0, t1 );
 BasisSecondDerivative( i - 1, clampedTime, bvals );
 v = bvals[0] * this->ValueForIndex( i - 1 );
 v += bvals[1] * this->ValueForIndex( i );
 v += bvals[2] * t0;
 v += bvals[3] * t1;
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / ( d * d );
}






template< class type >
inline void idCurve_KochanekBartelsSpline<type>::TangentsForIndex( const int index, type &t0, type &t1 ) const {
 float dt, omt, omc, opc, omb, opb, adj, s0, s1;
 type delta;

 delta = this->ValueForIndex( index + 1 ) - this->ValueForIndex( index );
 dt = this->TimeForIndex( index + 1 ) - this->TimeForIndex( index );

 omt = 1.0f - tension[index];
 omc = 1.0f - continuity[index];
 opc = 1.0f + continuity[index];
 omb = 1.0f - bias[index];
 opb = 1.0f + bias[index];
 adj = 2.0f * dt / ( this->TimeForIndex( index + 1 ) - this->TimeForIndex( index - 1 ) );
 s0 = 0.5f * adj * omt * opc * opb;
 s1 = 0.5f * adj * omt * omc * omb;


 t0 = s1 * delta + s0 * ( this->ValueForIndex( index ) - this->ValueForIndex( index - 1 ) );

 omt = 1.0f - tension[index + 1];
 omc = 1.0f - continuity[index + 1];
 opc = 1.0f + continuity[index + 1];
 omb = 1.0f - bias[index + 1];
 opb = 1.0f + bias[index + 1];
 adj = 2.0f * dt / ( this->TimeForIndex( index + 2 ) - this->TimeForIndex( index ) );
 s0 = 0.5f * adj * omt * omc * opb;
 s1 = 0.5f * adj * omt * opc * omb;


 t1 = s1 * ( this->ValueForIndex( index + 2 ) - this->ValueForIndex( index + 1 ) ) + s0 * delta;
}
# 1746 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_KochanekBartelsSpline<type>::Basis( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( ( 2.0f * s - 3.0f ) * s ) * s + 1.0f;
 bvals[1] = ( ( -2.0f * s + 3.0f ) * s ) * s;
 bvals[2] = ( ( s - 2.0f ) * s ) * s + s;
 bvals[3] = ( ( s - 1.0f ) * s ) * s;
}
# 1762 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_KochanekBartelsSpline<type>::BasisFirstDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( 6.0f * s - 6.0f ) * s;
 bvals[1] = ( -6.0f * s + 6.0f ) * s;
 bvals[2] = ( 3.0f * s - 4.0f ) * s + 1.0f;
 bvals[3] = ( 3.0f * s - 2.0f ) * s;
}
# 1778 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_KochanekBartelsSpline<type>::BasisSecondDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = 12.0f * s - 6.0f;
 bvals[1] = -12.0f * s + 6.0f;
 bvals[2] = 6.0f * s - 4.0f;
 bvals[3] = 6.0f * s - 2.0f;
}
# 1797 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_BSpline : public idCurve_Spline<type> {

public:
      idCurve_BSpline( void );

 virtual int GetOrder( void ) const { return order; }
 virtual void SetOrder( const int i ) { ((void)0); order = i; }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 int order;

 float Basis( const int index, const int order, const float t ) const;
 float BasisFirstDerivative( const int index, const int order, const float t ) const;
 float BasisSecondDerivative( const int index, const int order, const float t ) const;
};






template< class type >
inline idCurve_BSpline<type>::idCurve_BSpline( void ) {
 order = 4;
}
# 1835 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_BSpline<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < order; j++ ) {
  k = i + j - ( order >> 1 );
  v += Basis( k-2, order, clampedTime ) * this->ValueForIndex( k );
 }
 return v;
}
# 1862 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_BSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < order; j++ ) {
  k = i + j - ( order >> 1 );
  v += BasisFirstDerivative( k-2, order, clampedTime ) * this->ValueForIndex( k );
 }
 return v;
}
# 1889 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_BSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < order; j++ ) {
  k = i + j - ( order >> 1 );
  v += BasisSecondDerivative( k-2, order, clampedTime ) * this->ValueForIndex( k );
 }
 return v;
}
# 1916 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_BSpline<type>::Basis( const int index, const int order, const float t ) const {
 if ( order <= 1 ) {
  if ( this->TimeForIndex( index ) < t && t <= this->TimeForIndex( index + 1 ) ) {
   return 1.0f;
  } else {
   return 0.0f;
  }
 } else {
  float sum = 0.0f;
  float d1 = this->TimeForIndex( index+order-1 ) - this->TimeForIndex( index );
  if ( d1 != 0.0f ) {
   sum += (float) ( t - this->TimeForIndex( index ) ) * Basis( index, order-1, t ) / d1;
  }

  float d2 = this->TimeForIndex( index+order ) - this->TimeForIndex( index+1 );
  if ( d2 != 0.0f ) {
   sum += (float) ( this->TimeForIndex( index+order ) - t ) * Basis( index+1, order-1, t ) / d2;
  }
  return sum;
 }
}
# 1946 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_BSpline<type>::BasisFirstDerivative( const int index, const int order, const float t ) const {
 return ( Basis( index, order-1, t ) - Basis( index+1, order-1, t ) ) *
   (float) ( order - 1 ) / ( this->TimeForIndex( index + ( order - 1 ) - 2 ) - this->TimeForIndex( index - 2 ) );
}
# 1959 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_BSpline<type>::BasisSecondDerivative( const int index, const int order, const float t ) const {
 return ( BasisFirstDerivative( index, order-1, t ) - BasisFirstDerivative( index+1, order-1, t ) ) *
   (float) ( order - 1 ) / ( this->TimeForIndex( index + ( order - 1 ) - 2 ) - this->TimeForIndex( index - 2 ) );
}
# 1974 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_UniformCubicBSpline : public idCurve_BSpline<type> {

public:
      idCurve_UniformCubicBSpline( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const int index, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int index, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int index, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_UniformCubicBSpline<type>::idCurve_UniformCubicBSpline( void ) {
 this->order = 4;
}
# 2007 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_UniformCubicBSpline<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float bvals[4], clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 Basis( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 2035 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_UniformCubicBSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float bvals[4], d, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisFirstDerivative( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / d;
}
# 2064 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_UniformCubicBSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float bvals[4], d, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisSecondDerivative( i-1, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < 4; j++ ) {
  k = i + j - 2;
  v += bvals[j] * this->ValueForIndex( k );
 }
 d = ( this->TimeForIndex( i ) - this->TimeForIndex( i-1 ) );
 return v / ( d * d );
}
# 2093 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_UniformCubicBSpline<type>::Basis( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = ( ( ( -s + 3.0f ) * s - 3.0f ) * s + 1.0f ) * ( 1.0f / 6.0f );
 bvals[1] = ( ( ( 3.0f * s - 6.0f ) * s ) * s + 4.0f ) * ( 1.0f / 6.0f );
 bvals[2] = ( ( ( -3.0f * s + 3.0f ) * s + 3.0f ) * s + 1.0f ) * ( 1.0f / 6.0f );
 bvals[3] = ( s * s * s ) * ( 1.0f / 6.0f );
}
# 2109 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_UniformCubicBSpline<type>::BasisFirstDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = -0.5f * s * s + s - 0.5f;
 bvals[1] = 1.5f * s * s - 2.0f * s;
 bvals[2] = -1.5f * s * s + s + 0.5f;
 bvals[3] = 0.5f * s * s;
}
# 2125 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_UniformCubicBSpline<type>::BasisSecondDerivative( const int index, const float t, float *bvals ) const {
 float s = (float) ( t - this->TimeForIndex( index ) ) / ( this->TimeForIndex( index+1 ) - this->TimeForIndex( index ) );
 bvals[0] = -s + 1.0f;
 bvals[1] = 3.0f * s - 2.0f;
 bvals[2] = -3.0f * s + 1.0f;
 bvals[3] = s;
}
# 2143 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_NonUniformBSpline : public idCurve_BSpline<type> {

public:
      idCurve_NonUniformBSpline( void );

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 void Basis( const int index, const int order, const float t, float *bvals ) const;
 void BasisFirstDerivative( const int index, const int order, const float t, float *bvals ) const;
 void BasisSecondDerivative( const int index, const int order, const float t, float *bvals ) const;
};






template< class type >
inline idCurve_NonUniformBSpline<type>::idCurve_NonUniformBSpline( void ) {
}
# 2175 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NonUniformBSpline<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;
 float *bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 Basis( i-1, this->order, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 2204 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NonUniformBSpline<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;
 float *bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisFirstDerivative( i-1, this->order, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 2233 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NonUniformBSpline<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float clampedTime;
 type v;
 float *bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 if ( this->times.Num() == 1 ) {
  return ( this->values[0] - this->values[0] );
 }

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 BasisSecondDerivative( i-1, this->order, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  v += bvals[j] * this->ValueForIndex( k );
 }
 return v;
}
# 2262 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_NonUniformBSpline<type>::Basis( const int index, const int order, const float t, float *bvals ) const {
    int r, s, i;
    float omega;

    bvals[order-1] = 1.0f;
    for ( r = 2; r <= order; r++ ) {
  i = index - r + 1;
  bvals[order - r] = 0.0f;
  for ( s = order - r + 1; s < order; s++ ) {
   i++;
   omega = (float) ( t - this->TimeForIndex( i ) ) / ( this->TimeForIndex( i + r - 1 ) - this->TimeForIndex( i ) );
   bvals[s - 1] += ( 1.0f - omega ) * bvals[s];
   bvals[s] *= omega;
  }
    }
}
# 2287 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_NonUniformBSpline<type>::BasisFirstDerivative( const int index, const int order, const float t, float *bvals ) const {
 int i;

 Basis( index, order-1, t, bvals+1 );
 bvals[0] = 0.0f;
 for ( i = 0; i < order-1; i++ ) {
  bvals[i] -= bvals[i+1];
  bvals[i] *= (float) ( order - 1) / ( this->TimeForIndex( index + i + (order-1) - 2 ) - this->TimeForIndex( index + i - 2 ) );
 }
 bvals[i] *= (float) ( order - 1) / ( this->TimeForIndex( index + i + (order-1) - 2 ) - this->TimeForIndex( index + i - 2 ) );
}
# 2307 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline void idCurve_NonUniformBSpline<type>::BasisSecondDerivative( const int index, const int order, const float t, float *bvals ) const {
 int i;

 BasisFirstDerivative( index, order-1, t, bvals+1 );
 bvals[0] = 0.0f;
 for ( i = 0; i < order-1; i++ ) {
  bvals[i] -= bvals[i+1];
  bvals[i] *= (float) ( order - 1) / ( this->TimeForIndex( index + i + (order-1) - 2 ) - this->TimeForIndex( index + i - 2 ) );
 }
 bvals[i] *= (float) ( order - 1) / ( this->TimeForIndex( index + i + (order-1) - 2 ) - this->TimeForIndex( index + i - 2 ) );
}
# 2329 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
class idCurve_NURBS : public idCurve_NonUniformBSpline<type> {

public:
      idCurve_NURBS( void );

 virtual int AddValue( const float time, const type &value );
 virtual int AddValue( const float time, const type &value, const float weight );
 virtual void RemoveIndex( const int index ) { this->values.RemoveIndex(index); this->times.RemoveIndex(index); weights.RemoveIndex(index); }
 virtual void Clear( void ) { this->values.Clear(); this->times.Clear(); weights.Clear(); this->currentIndex = -1; }

 virtual type GetCurrentValue( const float time ) const;
 virtual type GetCurrentFirstDerivative( const float time ) const;
 virtual type GetCurrentSecondDerivative( const float time ) const;

protected:
 idList<float> weights;

 float WeightForIndex( const int index ) const;
};






template< class type >
inline idCurve_NURBS<type>::idCurve_NURBS( void ) {
}
# 2367 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve_NURBS<type>::AddValue( const float time, const type &value ) {
 int i;

 i = this->IndexForTime( time );
 this->times.Insert( time, i );
 this->values.Insert( value, i );
 weights.Insert( 1.0f, i );
 return i;
}
# 2386 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline int idCurve_NURBS<type>::AddValue( const float time, const type &value, const float weight ) {
 int i;

 i = this->IndexForTime( time );
 this->times.Insert( time, i );
 this->values.Insert( value, i );
 weights.Insert( weight, i );
 return i;
}
# 2404 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NURBS<type>::GetCurrentValue( const float time ) const {
 int i, j, k;
 float w, b, *bvals, clampedTime;
 type v;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 this->Basis( i-1, this->order, clampedTime, bvals );
 v = this->values[0] - this->values[0];
 w = 0.0f;
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  b = bvals[j] * WeightForIndex( k );
  w += b;
  v += b * this->ValueForIndex( k );
 }
 return v / w;
}
# 2437 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NURBS<type>::GetCurrentFirstDerivative( const float time ) const {
 int i, j, k;
 float w, wb, wd1, b, d1, *bvals, *d1vals, clampedTime;
 type v, vb, vd1;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));
 d1vals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 this->Basis( i-1, this->order, clampedTime, bvals );
 this->BasisFirstDerivative( i-1, this->order, clampedTime, d1vals );
 vb = vd1 = this->values[0] - this->values[0];
 wb = wd1 = 0.0f;
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  w = WeightForIndex( k );
  b = bvals[j] * w;
  d1 = d1vals[j] * w;
  wb += b;
  wd1 += d1;
  v = this->ValueForIndex( k );
  vb += b * v;
  vd1 += d1 * v;
 }
 return ( wb * vd1 - vb * wd1 ) / ( wb * wb );
}
# 2477 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline type idCurve_NURBS<type>::GetCurrentSecondDerivative( const float time ) const {
 int i, j, k;
 float w, wb, wd1, wd2, b, d1, d2, *bvals, *d1vals, *d2vals, clampedTime;
 type v, vb, vd1, vd2;

 if ( this->times.Num() == 1 ) {
  return this->values[0];
 }

 bvals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));
 d1vals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));
 d2vals = (float *) ((void *)((((int)__builtin_alloca((this->order * sizeof(float))+15)) + 15) & ~15));

 clampedTime = this->ClampedTime( time );
 i = this->IndexForTime( clampedTime );
 this->Basis( i-1, this->order, clampedTime, bvals );
 this->BasisFirstDerivative( i-1, this->order, clampedTime, d1vals );
 this->BasisSecondDerivative( i-1, this->order, clampedTime, d2vals );
 vb = vd1 = vd2 = this->values[0] - this->values[0];
 wb = wd1 = wd2 = 0.0f;
 for ( j = 0; j < this->order; j++ ) {
  k = i + j - ( this->order >> 1 );
  w = WeightForIndex( k );
  b = bvals[j] * w;
  d1 = d1vals[j] * w;
  d2 = d2vals[j] * w;
  wb += b;
  wd1 += d1;
  wd2 += d2;
  v = this->ValueForIndex( k );
  vb += b * v;
  vd1 += d1 * v;
  vd2 += d2 * v;
 }
 return ( ( wb * wb ) * ( wb * vd2 - vb * wd2 ) - ( wb * vd1 - vb * wd1 ) * 2.0f * wb * wd1 ) / ( wb * wb * wb * wb );
}
# 2522 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Curve.h"
template< class type >
inline float idCurve_NURBS<type>::WeightForIndex( const int index ) const {
 int n = weights.Num()-1;

 if ( index < 0 ) {
  if ( this->boundaryType == idCurve_Spline<type>::BT_CLOSED ) {
   return weights[ weights.Num() + index % weights.Num() ];
  } else {
   return weights[0] + index * ( weights[1] - weights[0] );
  }
 } else if ( index > n ) {
  if ( this->boundaryType == idCurve_Spline<type>::BT_CLOSED ) {
   return weights[ index % weights.Num() ];
  } else {
   return weights[n] + ( index - n ) * ( weights[n] - weights[n-1] );
  }
 }
 return weights[index];
}
# 189 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Ode.h" 1
# 47 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Ode.h"
typedef void (*deriveFunction_t)( const float t, const void *userData, const float *state, float *derivatives );

class idODE {

public:
 virtual ~idODE( void ) {}

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 ) = 0;

protected:
 int dimension;
 deriveFunction_t derive;
 const void * userData;
};







class idODE_Euler : public idODE {

public:
      idODE_Euler( const int dim, const deriveFunction_t dr, const void *ud );
 virtual ~idODE_Euler( void );

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 );

protected:
 float * derivatives;
};







class idODE_Midpoint : public idODE {

public:
      idODE_Midpoint( const int dim, const deriveFunction_t dr, const void *ud );
 virtual ~idODE_Midpoint( void );

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 );

protected:
 float * tmpState;
 float * derivatives;
};







class idODE_RK4 : public idODE {

public:
      idODE_RK4( const int dim, const deriveFunction_t dr, const void *ud );
 virtual ~idODE_RK4( void );

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 );

protected:
 float * tmpState;
 float * d1;
 float * d2;
 float * d3;
 float * d4;
};







class idODE_RK4Adaptive : public idODE {

public:
      idODE_RK4Adaptive( const int dim, const deriveFunction_t dr, const void *ud );
 virtual ~idODE_RK4Adaptive( void );

 virtual float Evaluate( const float *state, float *newState, float t0, float t1 );
 void SetMaxError( const float err );

protected:
 float maxError;
 float * tmpState;
 float * d1;
 float * d1half;
 float * d2;
 float * d3;
 float * d4;
};
# 190 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Lcp.h" 1
# 62 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/math/Lcp.h"
class idLCP {
public:
 static idLCP * AllocSquare( void );
 static idLCP * AllocSymmetric( void );

 virtual ~idLCP( void );

 virtual bool Solve( const idMatX &A, idVecX &x, const idVecX &b, const idVecX &lo, const idVecX &hi, const int *boxIndex = __null ) = 0;
 virtual void SetMaxIterations( int max );
 virtual int GetMaxIterations( void );

protected:
 int maxIterations;
};
# 191 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/bv/Sphere.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/bv/Sphere.h"
class idSphere {
public:
     idSphere( void );
     explicit idSphere( const idVec3 &point );
     explicit idSphere( const idVec3 &point, const float r );

 float operator[]( const int index ) const;
 float & operator[]( const int index );
 idSphere operator+( const idVec3 &t ) const;
 idSphere & operator+=( const idVec3 &t );
 idSphere operator+( const idSphere &s ) const;
 idSphere & operator+=( const idSphere &s );

 bool Compare( const idSphere &a ) const;
 bool Compare( const idSphere &a, const float epsilon ) const;
 bool operator==( const idSphere &a ) const;
 bool operator!=( const idSphere &a ) const;

 void Clear( void );
 void Zero( void );
 void SetOrigin( const idVec3 &o );
 void SetRadius( const float r );

 const idVec3 & GetOrigin( void ) const;
 float GetRadius( void ) const;
 bool IsCleared( void ) const;

 bool AddPoint( const idVec3 &p );
 bool AddSphere( const idSphere &s );
 idSphere Expand( const float d ) const;
 idSphere & ExpandSelf( const float d );
 idSphere Translate( const idVec3 &translation ) const;
 idSphere & TranslateSelf( const idVec3 &translation );

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;

 bool ContainsPoint( const idVec3 &p ) const;
 bool IntersectsSphere( const idSphere &s ) const;
 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;


 void FromPoints( const idVec3 *points, const int numPoints );

 void FromPointTranslation( const idVec3 &point, const idVec3 &translation );
 void FromSphereTranslation( const idSphere &sphere, const idVec3 &start, const idVec3 &translation );

 void FromPointRotation( const idVec3 &point, const idRotation &rotation );
 void FromSphereRotation( const idSphere &sphere, const idVec3 &start, const idRotation &rotation );

 void AxisProjection( const idVec3 &dir, float &min, float &max ) const;

private:
 idVec3 origin;
 float radius;
};

extern idSphere sphere_zero;

inline idSphere::idSphere( void ) {
}

inline idSphere::idSphere( const idVec3 &point ) {
 origin = point;
 radius = 0.0f;
}

inline idSphere::idSphere( const idVec3 &point, const float r ) {
 origin = point;
 radius = r;
}

inline float idSphere::operator[]( const int index ) const {
 return ((float *) &origin)[index];
}

inline float &idSphere::operator[]( const int index ) {
 return ((float *) &origin)[index];
}

inline idSphere idSphere::operator+( const idVec3 &t ) const {
 return idSphere( origin + t, radius );
}

inline idSphere &idSphere::operator+=( const idVec3 &t ) {
 origin += t;
 return *this;
}

inline bool idSphere::Compare( const idSphere &a ) const {
 return ( origin.Compare( a.origin ) && radius == a.radius );
}

inline bool idSphere::Compare( const idSphere &a, const float epsilon ) const {
 return ( origin.Compare( a.origin, epsilon ) && idMath::Fabs( radius - a.radius ) <= epsilon );
}

inline bool idSphere::operator==( const idSphere &a ) const {
 return Compare( a );
}

inline bool idSphere::operator!=( const idSphere &a ) const {
 return !Compare( a );
}

inline void idSphere::Clear( void ) {
 origin.Zero();
 radius = -1.0f;
}

inline void idSphere::Zero( void ) {
 origin.Zero();
 radius = 0.0f;
}

inline void idSphere::SetOrigin( const idVec3 &o ) {
 origin = o;
}

inline void idSphere::SetRadius( const float r ) {
 radius = r;
}

inline const idVec3 &idSphere::GetOrigin( void ) const {
 return origin;
}

inline float idSphere::GetRadius( void ) const {
 return radius;
}

inline bool idSphere::IsCleared( void ) const {
 return ( radius < 0.0f );
}

inline bool idSphere::AddPoint( const idVec3 &p ) {
 if ( radius < 0.0f ) {
  origin = p;
  radius = 0.0f;
  return true;
 }
 else {
  float r = ( p - origin ).LengthSqr();
  if ( r > radius * radius ) {
   r = idMath::Sqrt( r );
   origin += ( p - origin ) * 0.5f * (1.0f - radius / r );
   radius += 0.5f * ( r - radius );
   return true;
  }
  return false;
 }
}

inline bool idSphere::AddSphere( const idSphere &s ) {
 if ( radius < 0.0f ) {
  origin = s.origin;
  radius = s.radius;
  return true;
 }
 else {
  float r = ( s.origin - origin ).LengthSqr();
  if ( r > ( radius + s.radius ) * ( radius + s.radius ) ) {
   r = idMath::Sqrt( r );
   origin += ( s.origin - origin ) * 0.5f * (1.0f - radius / ( r + s.radius ) );
   radius += 0.5f * ( ( r + s.radius ) - radius );
   return true;
  }
  return false;
 }
}

inline idSphere idSphere::Expand( const float d ) const {
 return idSphere( origin, radius + d );
}

inline idSphere &idSphere::ExpandSelf( const float d ) {
 radius += d;
 return *this;
}

inline idSphere idSphere::Translate( const idVec3 &translation ) const {
 return idSphere( origin + translation, radius );
}

inline idSphere &idSphere::TranslateSelf( const idVec3 &translation ) {
 origin += translation;
 return *this;
}

inline bool idSphere::ContainsPoint( const idVec3 &p ) const {
 if ( ( p - origin ).LengthSqr() > radius * radius ) {
  return false;
 }
 return true;
}

inline bool idSphere::IntersectsSphere( const idSphere &s ) const {
 float r = s.radius + radius;
 if ( ( s.origin - origin ).LengthSqr() > r * r ) {
  return false;
 }
 return true;
}

inline void idSphere::FromPointTranslation( const idVec3 &point, const idVec3 &translation ) {
 origin = point + 0.5f * translation;
 radius = idMath::Sqrt( 0.5f * translation.LengthSqr() );
}

inline void idSphere::FromSphereTranslation( const idSphere &sphere, const idVec3 &start, const idVec3 &translation ) {
 origin = start + sphere.origin + 0.5f * translation;
 radius = idMath::Sqrt( 0.5f * translation.LengthSqr() ) + sphere.radius;
}

inline void idSphere::FromPointRotation( const idVec3 &point, const idRotation &rotation ) {
 idVec3 end = rotation * point;
 origin = ( point + end ) * 0.5f;
 radius = idMath::Sqrt( 0.5f * ( end - point ).LengthSqr() );
}

inline void idSphere::FromSphereRotation( const idSphere &sphere, const idVec3 &start, const idRotation &rotation ) {
 idVec3 end = rotation * sphere.origin;
 origin = start + ( sphere.origin + end ) * 0.5f;
 radius = idMath::Sqrt( 0.5f * ( end - sphere.origin ).LengthSqr() ) + sphere.radius;
}

inline void idSphere::AxisProjection( const idVec3 &dir, float &min, float &max ) const {
 float d;
 d = dir * origin;
 min = d - radius;
 max = d + radius;
}
# 194 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/bv/Bounds.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/bv/Bounds.h"
class idBounds {
public:
     idBounds( void );
     explicit idBounds( const idVec3 &mins, const idVec3 &maxs );
     explicit idBounds( const idVec3 &point );

 const idVec3 & operator[]( const int index ) const;
 idVec3 & operator[]( const int index );
 idBounds operator+( const idVec3 &t ) const;
 idBounds & operator+=( const idVec3 &t );
 idBounds operator*( const idMat3 &r ) const;
 idBounds & operator*=( const idMat3 &r );
 idBounds operator+( const idBounds &a ) const;
 idBounds & operator+=( const idBounds &a );
 idBounds operator-( const idBounds &a ) const;
 idBounds & operator-=( const idBounds &a );

 bool Compare( const idBounds &a ) const;
 bool Compare( const idBounds &a, const float epsilon ) const;
 bool operator==( const idBounds &a ) const;
 bool operator!=( const idBounds &a ) const;

 void Clear( void );
 void Zero( void );

 idVec3 GetCenter( void ) const;
 float GetRadius( void ) const;
 float GetRadius( const idVec3 &center ) const;
 float GetVolume( void ) const;
 bool IsCleared( void ) const;

 bool AddPoint( const idVec3 &v );
 bool AddBounds( const idBounds &a );
 idBounds Intersect( const idBounds &a ) const;
 idBounds & IntersectSelf( const idBounds &a );
 idBounds Expand( const float d ) const;
 idBounds & ExpandSelf( const float d );
 idBounds Translate( const idVec3 &translation ) const;
 idBounds & TranslateSelf( const idVec3 &translation );
 idBounds Rotate( const idMat3 &rotation ) const;
 idBounds & RotateSelf( const idMat3 &rotation );

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;

 bool ContainsPoint( const idVec3 &p ) const;
 bool IntersectsBounds( const idBounds &a ) const;
 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale ) const;


 void FromTransformedBounds( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis );

 void FromPoints( const idVec3 *points, const int numPoints );

 void FromPointTranslation( const idVec3 &point, const idVec3 &translation );
 void FromBoundsTranslation( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis, const idVec3 &translation );

 void FromPointRotation( const idVec3 &point, const idRotation &rotation );
 void FromBoundsRotation( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis, const idRotation &rotation );

 void ToPoints( idVec3 points[8] ) const;
 idSphere ToSphere( void ) const;

 void AxisProjection( const idVec3 &dir, float &min, float &max ) const;
 void AxisProjection( const idVec3 &origin, const idMat3 &axis, const idVec3 &dir, float &min, float &max ) const;

private:
 idVec3 b[2];
};

extern idBounds bounds_zero;

inline idBounds::idBounds( void ) {
}

inline idBounds::idBounds( const idVec3 &mins, const idVec3 &maxs ) {
 b[0] = mins;
 b[1] = maxs;
}

inline idBounds::idBounds( const idVec3 &point ) {
 b[0] = point;
 b[1] = point;
}

inline const idVec3 &idBounds::operator[]( const int index ) const {
 return b[index];
}

inline idVec3 &idBounds::operator[]( const int index ) {
 return b[index];
}

inline idBounds idBounds::operator+( const idVec3 &t ) const {
 return idBounds( b[0] + t, b[1] + t );
}

inline idBounds &idBounds::operator+=( const idVec3 &t ) {
 b[0] += t;
 b[1] += t;
 return *this;
}

inline idBounds idBounds::operator*( const idMat3 &r ) const {
 idBounds bounds;
 bounds.FromTransformedBounds( *this, vec3_origin, r );
 return bounds;
}

inline idBounds &idBounds::operator*=( const idMat3 &r ) {
 this->FromTransformedBounds( *this, vec3_origin, r );
 return *this;
}

inline idBounds idBounds::operator+( const idBounds &a ) const {
 idBounds newBounds;
 newBounds = *this;
 newBounds.AddBounds( a );
 return newBounds;
}

inline idBounds &idBounds::operator+=( const idBounds &a ) {
 idBounds::AddBounds( a );
 return *this;
}

inline idBounds idBounds::operator-( const idBounds &a ) const {
 ((void)0)

                                                ;
 return idBounds( idVec3( b[0][0] + a.b[1][0], b[0][1] + a.b[1][1], b[0][2] + a.b[1][2] ),
     idVec3( b[1][0] + a.b[0][0], b[1][1] + a.b[0][1], b[1][2] + a.b[0][2] ) );
}

inline idBounds &idBounds::operator-=( const idBounds &a ) {
 ((void)0)

                                                ;
 b[0] += a.b[1];
 b[1] += a.b[0];
 return *this;
}

inline bool idBounds::Compare( const idBounds &a ) const {
 return ( b[0].Compare( a.b[0] ) && b[1].Compare( a.b[1] ) );
}

inline bool idBounds::Compare( const idBounds &a, const float epsilon ) const {
 return ( b[0].Compare( a.b[0], epsilon ) && b[1].Compare( a.b[1], epsilon ) );
}

inline bool idBounds::operator==( const idBounds &a ) const {
 return Compare( a );
}

inline bool idBounds::operator!=( const idBounds &a ) const {
 return !Compare( a );
}

inline void idBounds::Clear( void ) {
 b[0][0] = b[0][1] = b[0][2] = idMath::INFINITY;
 b[1][0] = b[1][1] = b[1][2] = -idMath::INFINITY;
}

inline void idBounds::Zero( void ) {
 b[0][0] = b[0][1] = b[0][2] =
 b[1][0] = b[1][1] = b[1][2] = 0;
}

inline idVec3 idBounds::GetCenter( void ) const {
 return idVec3( ( b[1][0] + b[0][0] ) * 0.5f, ( b[1][1] + b[0][1] ) * 0.5f, ( b[1][2] + b[0][2] ) * 0.5f );
}

inline float idBounds::GetVolume( void ) const {
 if ( b[0][0] >= b[1][0] || b[0][1] >= b[1][1] || b[0][2] >= b[1][2] ) {
  return 0.0f;
 }
 return ( ( b[1][0] - b[0][0] ) * ( b[1][1] - b[0][1] ) * ( b[1][2] - b[0][2] ) );
}

inline bool idBounds::IsCleared( void ) const {
 return b[0][0] > b[1][0];
}

inline bool idBounds::AddPoint( const idVec3 &v ) {
 bool expanded = false;
 if ( v[0] < b[0][0]) {
  b[0][0] = v[0];
  expanded = true;
 }
 if ( v[0] > b[1][0]) {
  b[1][0] = v[0];
  expanded = true;
 }
 if ( v[1] < b[0][1] ) {
  b[0][1] = v[1];
  expanded = true;
 }
 if ( v[1] > b[1][1]) {
  b[1][1] = v[1];
  expanded = true;
 }
 if ( v[2] < b[0][2] ) {
  b[0][2] = v[2];
  expanded = true;
 }
 if ( v[2] > b[1][2]) {
  b[1][2] = v[2];
  expanded = true;
 }
 return expanded;
}

inline bool idBounds::AddBounds( const idBounds &a ) {
 bool expanded = false;
 if ( a.b[0][0] < b[0][0] ) {
  b[0][0] = a.b[0][0];
  expanded = true;
 }
 if ( a.b[0][1] < b[0][1] ) {
  b[0][1] = a.b[0][1];
  expanded = true;
 }
 if ( a.b[0][2] < b[0][2] ) {
  b[0][2] = a.b[0][2];
  expanded = true;
 }
 if ( a.b[1][0] > b[1][0] ) {
  b[1][0] = a.b[1][0];
  expanded = true;
 }
 if ( a.b[1][1] > b[1][1] ) {
  b[1][1] = a.b[1][1];
  expanded = true;
 }
 if ( a.b[1][2] > b[1][2] ) {
  b[1][2] = a.b[1][2];
  expanded = true;
 }
 return expanded;
}

inline idBounds idBounds::Intersect( const idBounds &a ) const {
 idBounds n;
 n.b[0][0] = ( a.b[0][0] > b[0][0] ) ? a.b[0][0] : b[0][0];
 n.b[0][1] = ( a.b[0][1] > b[0][1] ) ? a.b[0][1] : b[0][1];
 n.b[0][2] = ( a.b[0][2] > b[0][2] ) ? a.b[0][2] : b[0][2];
 n.b[1][0] = ( a.b[1][0] < b[1][0] ) ? a.b[1][0] : b[1][0];
 n.b[1][1] = ( a.b[1][1] < b[1][1] ) ? a.b[1][1] : b[1][1];
 n.b[1][2] = ( a.b[1][2] < b[1][2] ) ? a.b[1][2] : b[1][2];
 return n;
}

inline idBounds &idBounds::IntersectSelf( const idBounds &a ) {
 if ( a.b[0][0] > b[0][0] ) {
  b[0][0] = a.b[0][0];
 }
 if ( a.b[0][1] > b[0][1] ) {
  b[0][1] = a.b[0][1];
 }
 if ( a.b[0][2] > b[0][2] ) {
  b[0][2] = a.b[0][2];
 }
 if ( a.b[1][0] < b[1][0] ) {
  b[1][0] = a.b[1][0];
 }
 if ( a.b[1][1] < b[1][1] ) {
  b[1][1] = a.b[1][1];
 }
 if ( a.b[1][2] < b[1][2] ) {
  b[1][2] = a.b[1][2];
 }
 return *this;
}

inline idBounds idBounds::Expand( const float d ) const {
 return idBounds( idVec3( b[0][0] - d, b[0][1] - d, b[0][2] - d ),
      idVec3( b[1][0] + d, b[1][1] + d, b[1][2] + d ) );
}

inline idBounds &idBounds::ExpandSelf( const float d ) {
 b[0][0] -= d;
 b[0][1] -= d;
 b[0][2] -= d;
 b[1][0] += d;
 b[1][1] += d;
 b[1][2] += d;
 return *this;
}

inline idBounds idBounds::Translate( const idVec3 &translation ) const {
 return idBounds( b[0] + translation, b[1] + translation );
}

inline idBounds &idBounds::TranslateSelf( const idVec3 &translation ) {
 b[0] += translation;
 b[1] += translation;
 return *this;
}

inline idBounds idBounds::Rotate( const idMat3 &rotation ) const {
 idBounds bounds;
 bounds.FromTransformedBounds( *this, vec3_origin, rotation );
 return bounds;
}

inline idBounds &idBounds::RotateSelf( const idMat3 &rotation ) {
 FromTransformedBounds( *this, vec3_origin, rotation );
 return *this;
}

inline bool idBounds::ContainsPoint( const idVec3 &p ) const {
 if ( p[0] < b[0][0] || p[1] < b[0][1] || p[2] < b[0][2]
  || p[0] > b[1][0] || p[1] > b[1][1] || p[2] > b[1][2] ) {
  return false;
 }
 return true;
}

inline bool idBounds::IntersectsBounds( const idBounds &a ) const {
 if ( a.b[1][0] < b[0][0] || a.b[1][1] < b[0][1] || a.b[1][2] < b[0][2]
  || a.b[0][0] > b[1][0] || a.b[0][1] > b[1][1] || a.b[0][2] > b[1][2] ) {
  return false;
 }
 return true;
}

inline idSphere idBounds::ToSphere( void ) const {
 idSphere sphere;
 sphere.SetOrigin( ( b[0] + b[1] ) * 0.5f );
 sphere.SetRadius( ( b[1] - sphere.GetOrigin() ).Length() );
 return sphere;
}

inline void idBounds::AxisProjection( const idVec3 &dir, float &min, float &max ) const {
 float d1, d2;
 idVec3 center, extents;

 center = ( b[0] + b[1] ) * 0.5f;
 extents = b[1] - center;

 d1 = dir * center;
 d2 = idMath::Fabs( extents[0] * dir[0] ) +
   idMath::Fabs( extents[1] * dir[1] ) +
    idMath::Fabs( extents[2] * dir[2] );

 min = d1 - d2;
 max = d1 + d2;
}

inline void idBounds::AxisProjection( const idVec3 &origin, const idMat3 &axis, const idVec3 &dir, float &min, float &max ) const {
 float d1, d2;
 idVec3 center, extents;

 center = ( b[0] + b[1] ) * 0.5f;
 extents = b[1] - center;
 center = origin + center * axis;

 d1 = dir * center;
 d2 = idMath::Fabs( extents[0] * ( dir * axis[0] ) ) +
   idMath::Fabs( extents[1] * ( dir * axis[1] ) ) +
    idMath::Fabs( extents[2] * ( dir * axis[2] ) );

 min = d1 - d2;
 max = d1 + d2;
}
# 195 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/bv/Box.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/bv/Box.h"
class idBox {
public:
     idBox( void );
     explicit idBox( const idVec3 &center, const idVec3 &extents, const idMat3 &axis );
     explicit idBox( const idVec3 &point );
     explicit idBox( const idBounds &bounds );
     explicit idBox( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis );

 idBox operator+( const idVec3 &t ) const;
 idBox & operator+=( const idVec3 &t );
 idBox operator*( const idMat3 &r ) const;
 idBox & operator*=( const idMat3 &r );
 idBox operator+( const idBox &a ) const;
 idBox & operator+=( const idBox &a );
 idBox operator-( const idBox &a ) const;
 idBox & operator-=( const idBox &a );

 bool Compare( const idBox &a ) const;
 bool Compare( const idBox &a, const float epsilon ) const;
 bool operator==( const idBox &a ) const;
 bool operator!=( const idBox &a ) const;

 void Clear( void );
 void Zero( void );

 const idVec3 & GetCenter( void ) const;
 const idVec3 & GetExtents( void ) const;
 const idMat3 & GetAxis( void ) const;
 float GetVolume( void ) const;
 bool IsCleared( void ) const;

 bool AddPoint( const idVec3 &v );
 bool AddBox( const idBox &a );
 idBox Expand( const float d ) const;
 idBox & ExpandSelf( const float d );
 idBox Translate( const idVec3 &translation ) const;
 idBox & TranslateSelf( const idVec3 &translation );
 idBox Rotate( const idMat3 &rotation ) const;
 idBox & RotateSelf( const idMat3 &rotation );

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;

 bool ContainsPoint( const idVec3 &p ) const;
 bool IntersectsBox( const idBox &a ) const;
 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;


 void FromPoints( const idVec3 *points, const int numPoints );

 void FromPointTranslation( const idVec3 &point, const idVec3 &translation );
 void FromBoxTranslation( const idBox &box, const idVec3 &translation );

 void FromPointRotation( const idVec3 &point, const idRotation &rotation );
 void FromBoxRotation( const idBox &box, const idRotation &rotation );

 void ToPoints( idVec3 points[8] ) const;
 idSphere ToSphere( void ) const;


 void AxisProjection( const idVec3 &dir, float &min, float &max ) const;
 void AxisProjection( const idMat3 &ax, idBounds &bounds ) const;


 int GetProjectionSilhouetteVerts( const idVec3 &projectionOrigin, idVec3 silVerts[6] ) const;
 int GetParallelProjectionSilhouetteVerts( const idVec3 &projectionDir, idVec3 silVerts[6] ) const;

private:
 idVec3 center;
 idVec3 extents;
 idMat3 axis;
};

extern idBox box_zero;

inline idBox::idBox( void ) {
}

inline idBox::idBox( const idVec3 &center, const idVec3 &extents, const idMat3 &axis ) {
 this->center = center;
 this->extents = extents;
 this->axis = axis;
}

inline idBox::idBox( const idVec3 &point ) {
 this->center = point;
 this->extents.Zero();
 this->axis.Identity();
}

inline idBox::idBox( const idBounds &bounds ) {
 this->center = ( bounds[0] + bounds[1] ) * 0.5f;
 this->extents = bounds[1] - this->center;
 this->axis.Identity();
}

inline idBox::idBox( const idBounds &bounds, const idVec3 &origin, const idMat3 &axis ) {
 this->center = ( bounds[0] + bounds[1] ) * 0.5f;
 this->extents = bounds[1] - this->center;
 this->center = origin + this->center * axis;
 this->axis = axis;
}

inline idBox idBox::operator+( const idVec3 &t ) const {
 return idBox( center + t, extents, axis );
}

inline idBox &idBox::operator+=( const idVec3 &t ) {
 center += t;
 return *this;
}

inline idBox idBox::operator*( const idMat3 &r ) const {
 return idBox( center * r, extents, axis * r );
}

inline idBox &idBox::operator*=( const idMat3 &r ) {
 center *= r;
 axis *= r;
 return *this;
}

inline idBox idBox::operator+( const idBox &a ) const {
 idBox newBox;
 newBox = *this;
 newBox.AddBox( a );
 return newBox;
}

inline idBox &idBox::operator+=( const idBox &a ) {
 idBox::AddBox( a );
 return *this;
}

inline idBox idBox::operator-( const idBox &a ) const {
 return idBox( center, extents - a.extents, axis );
}

inline idBox &idBox::operator-=( const idBox &a ) {
 extents -= a.extents;
 return *this;
}

inline bool idBox::Compare( const idBox &a ) const {
 return ( center.Compare( a.center ) && extents.Compare( a.extents ) && axis.Compare( a.axis ) );
}

inline bool idBox::Compare( const idBox &a, const float epsilon ) const {
 return ( center.Compare( a.center, epsilon ) && extents.Compare( a.extents, epsilon ) && axis.Compare( a.axis, epsilon ) );
}

inline bool idBox::operator==( const idBox &a ) const {
 return Compare( a );
}

inline bool idBox::operator!=( const idBox &a ) const {
 return !Compare( a );
}

inline void idBox::Clear( void ) {
 center.Zero();
 extents[0] = extents[1] = extents[2] = -idMath::INFINITY;
 axis.Identity();
}

inline void idBox::Zero( void ) {
 center.Zero();
 extents.Zero();
 axis.Identity();
}

inline const idVec3 &idBox::GetCenter( void ) const {
 return center;
}

inline const idVec3 &idBox::GetExtents( void ) const {
 return extents;
}

inline const idMat3 &idBox::GetAxis( void ) const {
 return axis;
}

inline float idBox::GetVolume( void ) const {
 return ( extents * 2.0f ).LengthSqr();
}

inline bool idBox::IsCleared( void ) const {
 return extents[0] < 0.0f;
}

inline idBox idBox::Expand( const float d ) const {
 return idBox( center, extents + idVec3( d, d, d ), axis );
}

inline idBox &idBox::ExpandSelf( const float d ) {
 extents[0] += d;
 extents[1] += d;
 extents[2] += d;
 return *this;
}

inline idBox idBox::Translate( const idVec3 &translation ) const {
 return idBox( center + translation, extents, axis );
}

inline idBox &idBox::TranslateSelf( const idVec3 &translation ) {
 center += translation;
 return *this;
}

inline idBox idBox::Rotate( const idMat3 &rotation ) const {
 return idBox( center * rotation, extents, axis * rotation );
}

inline idBox &idBox::RotateSelf( const idMat3 &rotation ) {
 center *= rotation;
 axis *= rotation;
 return *this;
}

inline bool idBox::ContainsPoint( const idVec3 &p ) const {
 idVec3 lp = p - center;
 if ( idMath::Fabs( lp * axis[0] ) > extents[0] ||
   idMath::Fabs( lp * axis[1] ) > extents[1] ||
    idMath::Fabs( lp * axis[2] ) > extents[2] ) {
  return false;
 }
 return true;
}

inline idSphere idBox::ToSphere( void ) const {
 return idSphere( center, extents.Length() );
}

inline void idBox::AxisProjection( const idVec3 &dir, float &min, float &max ) const {
 float d1 = dir * center;
 float d2 = idMath::Fabs( extents[0] * ( dir * axis[0] ) ) +
    idMath::Fabs( extents[1] * ( dir * axis[1] ) ) +
    idMath::Fabs( extents[2] * ( dir * axis[2] ) );
 min = d1 - d2;
 max = d1 + d2;
}

inline void idBox::AxisProjection( const idMat3 &ax, idBounds &bounds ) const {
 for ( int i = 0; i < 3; i++ ) {
  float d1 = ax[i] * center;
  float d2 = idMath::Fabs( extents[0] * ( ax[i] * axis[0] ) ) +
     idMath::Fabs( extents[1] * ( ax[i] * axis[1] ) ) +
     idMath::Fabs( extents[2] * ( ax[i] * axis[2] ) );
  bounds[0][i] = d1 - d2;
  bounds[1][i] = d1 + d2;
 }
}
# 196 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/bv/Frustum.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/bv/Frustum.h"
class idFrustum {
public:
     idFrustum( void );

 void SetOrigin( const idVec3 &origin );
 void SetAxis( const idMat3 &axis );
 void SetSize( float dNear, float dFar, float dLeft, float dUp );
 void SetPyramid( float dNear, float dFar );
 void MoveNearDistance( float dNear );
 void MoveFarDistance( float dFar );

 const idVec3 & GetOrigin( void ) const;
 const idMat3 & GetAxis( void ) const;
 idVec3 GetCenter( void ) const;

 bool IsValid( void ) const;
 float GetNearDistance( void ) const;
 float GetFarDistance( void ) const;
 float GetLeft( void ) const;
 float GetUp( void ) const;

 idFrustum Expand( const float d ) const;
 idFrustum & ExpandSelf( const float d );
 idFrustum Translate( const idVec3 &translation ) const;
 idFrustum & TranslateSelf( const idVec3 &translation );
 idFrustum Rotate( const idMat3 &rotation ) const;
 idFrustum & RotateSelf( const idMat3 &rotation );

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;


 bool CullPoint( const idVec3 &point ) const;
 bool CullBounds( const idBounds &bounds ) const;
 bool CullBox( const idBox &box ) const;
 bool CullSphere( const idSphere &sphere ) const;
 bool CullFrustum( const idFrustum &frustum ) const;
 bool CullWinding( const class idWinding &winding ) const;


 bool ContainsPoint( const idVec3 &point ) const;
 bool IntersectsBounds( const idBounds &bounds ) const;
 bool IntersectsBox( const idBox &box ) const;
 bool IntersectsSphere( const idSphere &sphere ) const;
 bool IntersectsFrustum( const idFrustum &frustum ) const;
 bool IntersectsWinding( const idWinding &winding ) const;
 bool LineIntersection( const idVec3 &start, const idVec3 &end ) const;
 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;


 bool FromProjection( const idBounds &bounds, const idVec3 &projectionOrigin, const float dFar );
 bool FromProjection( const idBox &box, const idVec3 &projectionOrigin, const float dFar );
 bool FromProjection( const idSphere &sphere, const idVec3 &projectionOrigin, const float dFar );


 bool ConstrainToBounds( const idBounds &bounds );
 bool ConstrainToBox( const idBox &box );
 bool ConstrainToSphere( const idSphere &sphere );
 bool ConstrainToFrustum( const idFrustum &frustum );

 void ToPlanes( idPlane planes[6] ) const;
 void ToPoints( idVec3 points[8] ) const;


 void AxisProjection( const idVec3 &dir, float &min, float &max ) const;
 void AxisProjection( const idMat3 &ax, idBounds &bounds ) const;


 bool ProjectionBounds( const idBounds &bounds, idBounds &projectionBounds ) const;
 bool ProjectionBounds( const idBox &box, idBounds &projectionBounds ) const;
 bool ProjectionBounds( const idSphere &sphere, idBounds &projectionBounds ) const;
 bool ProjectionBounds( const idFrustum &frustum, idBounds &projectionBounds ) const;
 bool ProjectionBounds( const idWinding &winding, idBounds &projectionBounds ) const;


 bool ClippedProjectionBounds( const idFrustum &frustum, const idBox &clipBox, idBounds &projectionBounds ) const;

private:
 idVec3 origin;
 idMat3 axis;
 float dNear;
 float dFar;
 float dLeft;
 float dUp;
 float invFar;

private:
 bool CullLocalBox( const idVec3 &localOrigin, const idVec3 &extents, const idMat3 &localAxis ) const;
 bool CullLocalFrustum( const idFrustum &localFrustum, const idVec3 indexPoints[8], const idVec3 cornerVecs[4] ) const;
 bool CullLocalWinding( const idVec3 *points, const int numPoints, int *pointCull ) const;
 bool BoundsCullLocalFrustum( const idBounds &bounds, const idFrustum &localFrustum, const idVec3 indexPoints[8], const idVec3 cornerVecs[4] ) const;
 bool LocalLineIntersection( const idVec3 &start, const idVec3 &end ) const;
 bool LocalRayIntersection( const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;
 bool LocalFrustumIntersectsFrustum( const idVec3 points[8], const bool testFirstSide ) const;
 bool LocalFrustumIntersectsBounds( const idVec3 points[8], const idBounds &bounds ) const;
 void ToClippedPoints( const float fractions[4], idVec3 points[8] ) const;
 void ToIndexPoints( idVec3 indexPoints[8] ) const;
 void ToIndexPointsAndCornerVecs( idVec3 indexPoints[8], idVec3 cornerVecs[4] ) const;
 void AxisProjection( const idVec3 indexPoints[8], const idVec3 cornerVecs[4], const idVec3 &dir, float &min, float &max ) const;
 void AddLocalLineToProjectionBoundsSetCull( const idVec3 &start, const idVec3 &end, int &startCull, int &endCull, idBounds &bounds ) const;
 void AddLocalLineToProjectionBoundsUseCull( const idVec3 &start, const idVec3 &end, int startCull, int endCull, idBounds &bounds ) const;
 bool AddLocalCapsToProjectionBounds( const idVec3 endPoints[4], const int endPointCull[4], const idVec3 &point, int pointCull, int pointClip, idBounds &projectionBounds ) const;
 bool BoundsRayIntersection( const idBounds &bounds, const idVec3 &start, const idVec3 &dir, float &scale1, float &scale2 ) const;
 void ClipFrustumToBox( const idBox &box, float clipFractions[4], int clipPlanes[4] ) const;
 bool ClipLine( const idVec3 localPoints[8], const idVec3 points[8], int startIndex, int endIndex, idVec3 &start, idVec3 &end, int &startClip, int &endClip ) const;
};


inline idFrustum::idFrustum( void ) {
 dNear = dFar = 0.0f;
}

inline void idFrustum::SetOrigin( const idVec3 &origin ) {
 this->origin = origin;
}

inline void idFrustum::SetAxis( const idMat3 &axis ) {
 this->axis = axis;
}

inline void idFrustum::SetSize( float dNear, float dFar, float dLeft, float dUp ) {
 ((void)0);
 this->dNear = dNear;
 this->dFar = dFar;
 this->dLeft = dLeft;
 this->dUp = dUp;
 this->invFar = 1.0f / dFar;
}

inline void idFrustum::SetPyramid( float dNear, float dFar ) {
 ((void)0);
 this->dNear = dNear;
 this->dFar = dFar;
 this->dLeft = dFar;
 this->dUp = dFar;
 this->invFar = 1.0f / dFar;
}

inline void idFrustum::MoveNearDistance( float dNear ) {
 ((void)0);
 this->dNear = dNear;
}

inline void idFrustum::MoveFarDistance( float dFar ) {
 ((void)0);
 float scale = dFar / this->dFar;
 this->dFar = dFar;
 this->dLeft *= scale;
 this->dUp *= scale;
 this->invFar = 1.0f / dFar;
}

inline const idVec3 &idFrustum::GetOrigin( void ) const {
 return origin;
}

inline const idMat3 &idFrustum::GetAxis( void ) const {
 return axis;
}

inline idVec3 idFrustum::GetCenter( void ) const {
 return ( origin + axis[0] * ( ( dFar - dNear ) * 0.5f ) );
}

inline bool idFrustum::IsValid( void ) const {
 return ( dFar > dNear );
}

inline float idFrustum::GetNearDistance( void ) const {
 return dNear;
}

inline float idFrustum::GetFarDistance( void ) const {
 return dFar;
}

inline float idFrustum::GetLeft( void ) const {
 return dLeft;
}

inline float idFrustum::GetUp( void ) const {
 return dUp;
}

inline idFrustum idFrustum::Expand( const float d ) const {
 idFrustum f = *this;
 f.origin -= d * f.axis[0];
 f.dFar += 2.0f * d;
 f.dLeft = f.dFar * dLeft * invFar;
 f.dUp = f.dFar * dUp * invFar;
 f.invFar = 1.0f / dFar;
 return f;
}

inline idFrustum &idFrustum::ExpandSelf( const float d ) {
 origin -= d * axis[0];
 dFar += 2.0f * d;
 dLeft = dFar * dLeft * invFar;
 dUp = dFar * dUp * invFar;
 invFar = 1.0f / dFar;
 return *this;
}

inline idFrustum idFrustum::Translate( const idVec3 &translation ) const {
 idFrustum f = *this;
 f.origin += translation;
 return f;
}

inline idFrustum &idFrustum::TranslateSelf( const idVec3 &translation ) {
 origin += translation;
 return *this;
}

inline idFrustum idFrustum::Rotate( const idMat3 &rotation ) const {
 idFrustum f = *this;
 f.axis *= rotation;
 return f;
}

inline idFrustum &idFrustum::RotateSelf( const idMat3 &rotation ) {
 axis *= rotation;
 return *this;
}
# 197 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/DrawVert.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/DrawVert.h"
class idDrawVert {
public:
 idVec3 xyz;
 idVec2 st;
 idVec3 normal;
 idVec3 tangents[2];
 byte color[4];



 float operator[]( const int index ) const;
 float & operator[]( const int index );

 void Clear( void );

 void Lerp( const idDrawVert &a, const idDrawVert &b, const float f );
 void LerpAll( const idDrawVert &a, const idDrawVert &b, const float f );

 void Normalize( void );

 void SetColor( dword color );
 dword GetColor( void ) const;
};

inline float idDrawVert::operator[]( const int index ) const {
 ((void)0);
 return ((float *)(&xyz))[index];
}
inline float &idDrawVert::operator[]( const int index ) {
 ((void)0);
 return ((float *)(&xyz))[index];
}

inline void idDrawVert::Clear( void ) {
 xyz.Zero();
 st.Zero();
 normal.Zero();
 tangents[0].Zero();
 tangents[1].Zero();
 color[0] = color[1] = color[2] = color[3] = 0;
}

inline void idDrawVert::Lerp( const idDrawVert &a, const idDrawVert &b, const float f ) {
 xyz = a.xyz + f * ( b.xyz - a.xyz );
 st = a.st + f * ( b.st - a.st );
}

inline void idDrawVert::LerpAll( const idDrawVert &a, const idDrawVert &b, const float f ) {
 xyz = a.xyz + f * ( b.xyz - a.xyz );
 st = a.st + f * ( b.st - a.st );
 normal = a.normal + f * ( b.normal - a.normal );
 tangents[0] = a.tangents[0] + f * ( b.tangents[0] - a.tangents[0] );
 tangents[1] = a.tangents[1] + f * ( b.tangents[1] - a.tangents[1] );
 color[0] = (byte)( a.color[0] + f * ( b.color[0] - a.color[0] ) );
 color[1] = (byte)( a.color[1] + f * ( b.color[1] - a.color[1] ) );
 color[2] = (byte)( a.color[2] + f * ( b.color[2] - a.color[2] ) );
 color[3] = (byte)( a.color[3] + f * ( b.color[3] - a.color[3] ) );
}

inline void idDrawVert::SetColor( dword color ) {
 *reinterpret_cast<dword *>(this->color) = color;
}

inline dword idDrawVert::GetColor( void ) const {
 return *reinterpret_cast<const dword *>(this->color);
}
# 200 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/JointTransform.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/JointTransform.h"
class idJointQuat {
public:

 idQuat q;
 idVec3 t;
};
# 63 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/JointTransform.h"
class idJointMat {
public:

 void SetRotation( const idMat3 &m );
 void SetTranslation( const idVec3 &t );

 idVec3 operator*( const idVec3 &v ) const;
 idVec3 operator*( const idVec4 &v ) const;

 idJointMat & operator*=( const idJointMat &a );
 idJointMat & operator/=( const idJointMat &a );

 bool Compare( const idJointMat &a ) const;
 bool Compare( const idJointMat &a, const float epsilon ) const;
 bool operator==( const idJointMat &a ) const;
 bool operator!=( const idJointMat &a ) const;

 idMat3 ToMat3( void ) const;
 idVec3 ToVec3( void ) const;
 idJointQuat ToJointQuat( void ) const;
 const float * ToFloatPtr( void ) const;
 float * ToFloatPtr( void );

private:
 float mat[3*4];
};

inline void idJointMat::SetRotation( const idMat3 &m ) {

 mat[0 * 4 + 0] = m[0][0];
 mat[0 * 4 + 1] = m[1][0];
 mat[0 * 4 + 2] = m[2][0];
 mat[1 * 4 + 0] = m[0][1];
 mat[1 * 4 + 1] = m[1][1];
 mat[1 * 4 + 2] = m[2][1];
 mat[2 * 4 + 0] = m[0][2];
 mat[2 * 4 + 1] = m[1][2];
 mat[2 * 4 + 2] = m[2][2];
}

inline void idJointMat::SetTranslation( const idVec3 &t ) {
 mat[0 * 4 + 3] = t[0];
 mat[1 * 4 + 3] = t[1];
 mat[2 * 4 + 3] = t[2];
}

inline idVec3 idJointMat::operator*( const idVec3 &v ) const {
 return idVec3( mat[0 * 4 + 0] * v[0] + mat[0 * 4 + 1] * v[1] + mat[0 * 4 + 2] * v[2],
     mat[1 * 4 + 0] * v[0] + mat[1 * 4 + 1] * v[1] + mat[1 * 4 + 2] * v[2],
     mat[2 * 4 + 0] * v[0] + mat[2 * 4 + 1] * v[1] + mat[2 * 4 + 2] * v[2] );
}

inline idVec3 idJointMat::operator*( const idVec4 &v ) const {
 return idVec3( mat[0 * 4 + 0] * v[0] + mat[0 * 4 + 1] * v[1] + mat[0 * 4 + 2] * v[2] + mat[0 * 4 + 3] * v[3],
     mat[1 * 4 + 0] * v[0] + mat[1 * 4 + 1] * v[1] + mat[1 * 4 + 2] * v[2] + mat[1 * 4 + 3] * v[3],
     mat[2 * 4 + 0] * v[0] + mat[2 * 4 + 1] * v[1] + mat[2 * 4 + 2] * v[2] + mat[2 * 4 + 3] * v[3] );
}

inline idJointMat &idJointMat::operator*=( const idJointMat &a ) {
 float dst[3];

 dst[0] = mat[0 * 4 + 0] * a.mat[0 * 4 + 0] + mat[1 * 4 + 0] * a.mat[0 * 4 + 1] + mat[2 * 4 + 0] * a.mat[0 * 4 + 2];
 dst[1] = mat[0 * 4 + 0] * a.mat[1 * 4 + 0] + mat[1 * 4 + 0] * a.mat[1 * 4 + 1] + mat[2 * 4 + 0] * a.mat[1 * 4 + 2];
 dst[2] = mat[0 * 4 + 0] * a.mat[2 * 4 + 0] + mat[1 * 4 + 0] * a.mat[2 * 4 + 1] + mat[2 * 4 + 0] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 0] = dst[0];
 mat[1 * 4 + 0] = dst[1];
 mat[2 * 4 + 0] = dst[2];

 dst[0] = mat[0 * 4 + 1] * a.mat[0 * 4 + 0] + mat[1 * 4 + 1] * a.mat[0 * 4 + 1] + mat[2 * 4 + 1] * a.mat[0 * 4 + 2];
 dst[1] = mat[0 * 4 + 1] * a.mat[1 * 4 + 0] + mat[1 * 4 + 1] * a.mat[1 * 4 + 1] + mat[2 * 4 + 1] * a.mat[1 * 4 + 2];
 dst[2] = mat[0 * 4 + 1] * a.mat[2 * 4 + 0] + mat[1 * 4 + 1] * a.mat[2 * 4 + 1] + mat[2 * 4 + 1] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 1] = dst[0];
 mat[1 * 4 + 1] = dst[1];
 mat[2 * 4 + 1] = dst[2];

 dst[0] = mat[0 * 4 + 2] * a.mat[0 * 4 + 0] + mat[1 * 4 + 2] * a.mat[0 * 4 + 1] + mat[2 * 4 + 2] * a.mat[0 * 4 + 2];
 dst[1] = mat[0 * 4 + 2] * a.mat[1 * 4 + 0] + mat[1 * 4 + 2] * a.mat[1 * 4 + 1] + mat[2 * 4 + 2] * a.mat[1 * 4 + 2];
 dst[2] = mat[0 * 4 + 2] * a.mat[2 * 4 + 0] + mat[1 * 4 + 2] * a.mat[2 * 4 + 1] + mat[2 * 4 + 2] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 2] = dst[0];
 mat[1 * 4 + 2] = dst[1];
 mat[2 * 4 + 2] = dst[2];

 dst[0] = mat[0 * 4 + 3] * a.mat[0 * 4 + 0] + mat[1 * 4 + 3] * a.mat[0 * 4 + 1] + mat[2 * 4 + 3] * a.mat[0 * 4 + 2];
 dst[1] = mat[0 * 4 + 3] * a.mat[1 * 4 + 0] + mat[1 * 4 + 3] * a.mat[1 * 4 + 1] + mat[2 * 4 + 3] * a.mat[1 * 4 + 2];
 dst[2] = mat[0 * 4 + 3] * a.mat[2 * 4 + 0] + mat[1 * 4 + 3] * a.mat[2 * 4 + 1] + mat[2 * 4 + 3] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 3] = dst[0];
 mat[1 * 4 + 3] = dst[1];
 mat[2 * 4 + 3] = dst[2];

 mat[0 * 4 + 3] += a.mat[0 * 4 + 3];
 mat[1 * 4 + 3] += a.mat[1 * 4 + 3];
 mat[2 * 4 + 3] += a.mat[2 * 4 + 3];

 return *this;
}

inline idJointMat &idJointMat::operator/=( const idJointMat &a ) {
 float dst[3];

 mat[0 * 4 + 3] -= a.mat[0 * 4 + 3];
 mat[1 * 4 + 3] -= a.mat[1 * 4 + 3];
 mat[2 * 4 + 3] -= a.mat[2 * 4 + 3];

 dst[0] = mat[0 * 4 + 0] * a.mat[0 * 4 + 0] + mat[1 * 4 + 0] * a.mat[1 * 4 + 0] + mat[2 * 4 + 0] * a.mat[2 * 4 + 0];
 dst[1] = mat[0 * 4 + 0] * a.mat[0 * 4 + 1] + mat[1 * 4 + 0] * a.mat[1 * 4 + 1] + mat[2 * 4 + 0] * a.mat[2 * 4 + 1];
 dst[2] = mat[0 * 4 + 0] * a.mat[0 * 4 + 2] + mat[1 * 4 + 0] * a.mat[1 * 4 + 2] + mat[2 * 4 + 0] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 0] = dst[0];
 mat[1 * 4 + 0] = dst[1];
 mat[2 * 4 + 0] = dst[2];

 dst[0] = mat[0 * 4 + 1] * a.mat[0 * 4 + 0] + mat[1 * 4 + 1] * a.mat[1 * 4 + 0] + mat[2 * 4 + 1] * a.mat[2 * 4 + 0];
 dst[1] = mat[0 * 4 + 1] * a.mat[0 * 4 + 1] + mat[1 * 4 + 1] * a.mat[1 * 4 + 1] + mat[2 * 4 + 1] * a.mat[2 * 4 + 1];
 dst[2] = mat[0 * 4 + 1] * a.mat[0 * 4 + 2] + mat[1 * 4 + 1] * a.mat[1 * 4 + 2] + mat[2 * 4 + 1] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 1] = dst[0];
 mat[1 * 4 + 1] = dst[1];
 mat[2 * 4 + 1] = dst[2];

 dst[0] = mat[0 * 4 + 2] * a.mat[0 * 4 + 0] + mat[1 * 4 + 2] * a.mat[1 * 4 + 0] + mat[2 * 4 + 2] * a.mat[2 * 4 + 0];
 dst[1] = mat[0 * 4 + 2] * a.mat[0 * 4 + 1] + mat[1 * 4 + 2] * a.mat[1 * 4 + 1] + mat[2 * 4 + 2] * a.mat[2 * 4 + 1];
 dst[2] = mat[0 * 4 + 2] * a.mat[0 * 4 + 2] + mat[1 * 4 + 2] * a.mat[1 * 4 + 2] + mat[2 * 4 + 2] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 2] = dst[0];
 mat[1 * 4 + 2] = dst[1];
 mat[2 * 4 + 2] = dst[2];

 dst[0] = mat[0 * 4 + 3] * a.mat[0 * 4 + 0] + mat[1 * 4 + 3] * a.mat[1 * 4 + 0] + mat[2 * 4 + 3] * a.mat[2 * 4 + 0];
 dst[1] = mat[0 * 4 + 3] * a.mat[0 * 4 + 1] + mat[1 * 4 + 3] * a.mat[1 * 4 + 1] + mat[2 * 4 + 3] * a.mat[2 * 4 + 1];
 dst[2] = mat[0 * 4 + 3] * a.mat[0 * 4 + 2] + mat[1 * 4 + 3] * a.mat[1 * 4 + 2] + mat[2 * 4 + 3] * a.mat[2 * 4 + 2];
 mat[0 * 4 + 3] = dst[0];
 mat[1 * 4 + 3] = dst[1];
 mat[2 * 4 + 3] = dst[2];

 return *this;
}

inline bool idJointMat::Compare( const idJointMat &a ) const {
 int i;

 for ( i = 0; i < 12; i++ ) {
  if ( mat[i] != a.mat[i] ) {
   return false;
  }
 }
 return true;
}

inline bool idJointMat::Compare( const idJointMat &a, const float epsilon ) const {
 int i;

 for ( i = 0; i < 12; i++ ) {
  if ( idMath::Fabs( mat[i] - a.mat[i] ) > epsilon ) {
   return false;
  }
 }
 return true;
}

inline bool idJointMat::operator==( const idJointMat &a ) const {
 return Compare( a );
}

inline bool idJointMat::operator!=( const idJointMat &a ) const {
 return !Compare( a );
}

inline idMat3 idJointMat::ToMat3( void ) const {
 return idMat3( mat[0 * 4 + 0], mat[1 * 4 + 0], mat[2 * 4 + 0],
     mat[0 * 4 + 1], mat[1 * 4 + 1], mat[2 * 4 + 1],
     mat[0 * 4 + 2], mat[1 * 4 + 2], mat[2 * 4 + 2] );
}

inline idVec3 idJointMat::ToVec3( void ) const {
 return idVec3( mat[0 * 4 + 3], mat[1 * 4 + 3], mat[2 * 4 + 3] );
}

inline const float *idJointMat::ToFloatPtr( void ) const {
 return mat;
}

inline float *idJointMat::ToFloatPtr( void ) {
 return mat;
}
# 201 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Winding.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Winding.h"
class idWinding {

public:
     idWinding( void );
     explicit idWinding( const int n );
     explicit idWinding( const idVec3 *verts, const int n );
     explicit idWinding( const idVec3 &normal, const float dist );
     explicit idWinding( const idPlane &plane );
     explicit idWinding( const idWinding &winding );
 virtual ~idWinding( void );

 idWinding & operator=( const idWinding &winding );
 const idVec5 & operator[]( const int index ) const;
 idVec5 & operator[]( const int index );


 idWinding & operator+=( const idVec3 &v );
 idWinding & operator+=( const idVec5 &v );
 void AddPoint( const idVec3 &v );
 void AddPoint( const idVec5 &v );


 int GetNumPoints( void ) const;
 void SetNumPoints( int n );
 virtual void Clear( void );


 void BaseForPlane( const idVec3 &normal, const float dist );
 void BaseForPlane( const idPlane &plane );



 int Split( const idPlane &plane, const float epsilon, idWinding **front, idWinding **back ) const;


 idWinding * Clip( const idPlane &plane, const float epsilon = 0.1f, const bool keepOn = false );


 bool ClipInPlace( const idPlane &plane, const float epsilon = 0.1f, const bool keepOn = false );


 idWinding * Copy( void ) const;
 idWinding * Reverse( void ) const;
 void ReverseSelf( void );
 void RemoveEqualPoints( const float epsilon = 0.1f );
 void RemoveColinearPoints( const idVec3 &normal, const float epsilon = 0.1f );
 void RemovePoint( int point );
 void InsertPoint( const idVec3 &point, int spot );
 bool InsertPointIfOnEdge( const idVec3 &point, const idPlane &plane, const float epsilon = 0.1f );

 void AddToConvexHull( const idWinding *winding, const idVec3 &normal, const float epsilon = 0.1f );

 void AddToConvexHull( const idVec3 &point, const idVec3 &normal, const float epsilon = 0.1f );


 idWinding * TryMerge( const idWinding &w, const idVec3 &normal, int keep = false ) const;

 bool Check( bool print = true ) const;

 float GetArea( void ) const;
 idVec3 GetCenter( void ) const;
 float GetRadius( const idVec3 &center ) const;
 void GetPlane( idVec3 &normal, float &dist ) const;
 void GetPlane( idPlane &plane ) const;
 void GetBounds( idBounds &bounds ) const;

 bool IsTiny( void ) const;
 bool IsHuge( void ) const;
 void Print( void ) const;

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;

 bool PlanesConcave( const idWinding &w2, const idVec3 &normal1, const idVec3 &normal2, float dist1, float dist2 ) const;

 bool PointInside( const idVec3 &normal, const idVec3 &point, const float epsilon ) const;

 bool LineIntersection( const idPlane &windingPlane, const idVec3 &start, const idVec3 &end, bool backFaceCull = false ) const;

 bool RayIntersection( const idPlane &windingPlane, const idVec3 &start, const idVec3 &dir, float &scale, bool backFaceCull = false ) const;

 static float TriangleArea( const idVec3 &a, const idVec3 &b, const idVec3 &c );

protected:
 int numPoints;
 idVec5 * p;
 int allocedSize;

 bool EnsureAlloced( int n, bool keep = false );
 virtual bool ReAllocate( int n, bool keep = false );
};

inline idWinding::idWinding( void ) {
 numPoints = allocedSize = 0;
 p = __null;
}

inline idWinding::idWinding( int n ) {
 numPoints = allocedSize = 0;
 p = __null;
 EnsureAlloced( n );
}

inline idWinding::idWinding( const idVec3 *verts, const int n ) {
 int i;

 numPoints = allocedSize = 0;
 p = __null;
 if ( !EnsureAlloced( n ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < n; i++ ) {
  p[i].ToVec3() = verts[i];
  p[i].s = p[i].t = 0.0f;
 }
 numPoints = n;
}

inline idWinding::idWinding( const idVec3 &normal, const float dist ) {
 numPoints = allocedSize = 0;
 p = __null;
 BaseForPlane( normal, dist );
}

inline idWinding::idWinding( const idPlane &plane ) {
 numPoints = allocedSize = 0;
 p = __null;
 BaseForPlane( plane );
}

inline idWinding::idWinding( const idWinding &winding ) {
 int i;
 if ( !EnsureAlloced( winding.GetNumPoints() ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < winding.GetNumPoints(); i++ ) {
  p[i] = winding[i];
 }
 numPoints = winding.GetNumPoints();
}

inline idWinding::~idWinding( void ) {
 delete[] p;
 p = __null;
}

inline idWinding &idWinding::operator=( const idWinding &winding ) {
 int i;

 if ( !EnsureAlloced( winding.numPoints ) ) {
  numPoints = 0;
  return *this;
 }
 for ( i = 0; i < winding.numPoints; i++ ) {
  p[i] = winding.p[i];
 }
 numPoints = winding.numPoints;
 return *this;
}

inline const idVec5 &idWinding::operator[]( const int index ) const {

 return p[ index ];
}

inline idVec5 &idWinding::operator[]( const int index ) {

 return p[ index ];
}

inline idWinding &idWinding::operator+=( const idVec3 &v ) {
 AddPoint( v );
 return *this;
}

inline idWinding &idWinding::operator+=( const idVec5 &v ) {
 AddPoint( v );
 return *this;
}

inline void idWinding::AddPoint( const idVec3 &v ) {
 if ( !EnsureAlloced(numPoints+1, true) ) {
  return;
 }
 p[numPoints] = v;
 numPoints++;
}

inline void idWinding::AddPoint( const idVec5 &v ) {
 if ( !EnsureAlloced(numPoints+1, true) ) {
  return;
 }
 p[numPoints] = v;
 numPoints++;
}

inline int idWinding::GetNumPoints( void ) const {
 return numPoints;
}

inline void idWinding::SetNumPoints( int n ) {
 if ( !EnsureAlloced( n, true ) ) {
  return;
 }
 numPoints = n;
}

inline void idWinding::Clear( void ) {
 numPoints = 0;
 delete[] p;
 p = __null;
}

inline void idWinding::BaseForPlane( const idPlane &plane ) {
 BaseForPlane( plane.Normal(), plane.Dist() );
}

inline bool idWinding::EnsureAlloced( int n, bool keep ) {
 if ( n > allocedSize ) {
  return ReAllocate( n, keep );
 }
 return true;
}
# 281 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Winding.h"
class idFixedWinding : public idWinding {

public:
     idFixedWinding( void );
     explicit idFixedWinding( const int n );
     explicit idFixedWinding( const idVec3 *verts, const int n );
     explicit idFixedWinding( const idVec3 &normal, const float dist );
     explicit idFixedWinding( const idPlane &plane );
     explicit idFixedWinding( const idWinding &winding );
     explicit idFixedWinding( const idFixedWinding &winding );
 virtual ~idFixedWinding( void );

 idFixedWinding &operator=( const idWinding &winding );

 virtual void Clear( void );



 int Split( idFixedWinding *back, const idPlane &plane, const float epsilon = 0.1f );

protected:
 idVec5 data[64];

 virtual bool ReAllocate( int n, bool keep = false );
};

inline idFixedWinding::idFixedWinding( void ) {
 numPoints = 0;
 p = data;
 allocedSize = 64;
}

inline idFixedWinding::idFixedWinding( int n ) {
 numPoints = 0;
 p = data;
 allocedSize = 64;
}

inline idFixedWinding::idFixedWinding( const idVec3 *verts, const int n ) {
 int i;

 numPoints = 0;
 p = data;
 allocedSize = 64;
 if ( !EnsureAlloced( n ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < n; i++ ) {
  p[i].ToVec3() = verts[i];
  p[i].s = p[i].t = 0;
 }
 numPoints = n;
}

inline idFixedWinding::idFixedWinding( const idVec3 &normal, const float dist ) {
 numPoints = 0;
 p = data;
 allocedSize = 64;
 BaseForPlane( normal, dist );
}

inline idFixedWinding::idFixedWinding( const idPlane &plane ) {
 numPoints = 0;
 p = data;
 allocedSize = 64;
 BaseForPlane( plane );
}

inline idFixedWinding::idFixedWinding( const idWinding &winding ) {
 int i;

 p = data;
 allocedSize = 64;
 if ( !EnsureAlloced( winding.GetNumPoints() ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < winding.GetNumPoints(); i++ ) {
  p[i] = winding[i];
 }
 numPoints = winding.GetNumPoints();
}

inline idFixedWinding::idFixedWinding( const idFixedWinding &winding ) {
 int i;

 p = data;
 allocedSize = 64;
 if ( !EnsureAlloced( winding.GetNumPoints() ) ) {
  numPoints = 0;
  return;
 }
 for ( i = 0; i < winding.GetNumPoints(); i++ ) {
  p[i] = winding[i];
 }
 numPoints = winding.GetNumPoints();
}

inline idFixedWinding::~idFixedWinding( void ) {
 p = __null;
}

inline idFixedWinding &idFixedWinding::operator=( const idWinding &winding ) {
 int i;

 if ( !EnsureAlloced( winding.GetNumPoints() ) ) {
  numPoints = 0;
  return *this;
 }
 for ( i = 0; i < winding.GetNumPoints(); i++ ) {
  p[i] = winding[i];
 }
 numPoints = winding.GetNumPoints();
 return *this;
}

inline void idFixedWinding::Clear( void ) {
 numPoints = 0;
}
# 202 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Winding2D.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Winding2D.h"
class idWinding2D {
public:
     idWinding2D( void );

 idWinding2D & operator=( const idWinding2D &winding );
 const idVec2 & operator[]( const int index ) const;
 idVec2 & operator[]( const int index );

 void Clear( void );
 void AddPoint( const idVec2 &point );
 int GetNumPoints( void ) const;

 void Expand( const float d );
 void ExpandForAxialBox( const idVec2 bounds[2] );



 int Split( const idVec3 &plane, const float epsilon, idWinding2D **front, idWinding2D **back ) const;


 bool ClipInPlace( const idVec3 &plane, const float epsilon = 0.1f, const bool keepOn = false );

 idWinding2D * Copy( void ) const;
 idWinding2D * Reverse( void ) const;

 float GetArea( void ) const;
 idVec2 GetCenter( void ) const;
 float GetRadius( const idVec2 &center ) const;
 void GetBounds( idVec2 bounds[2] ) const;

 bool IsTiny( void ) const;
 bool IsHuge( void ) const;
 void Print( void ) const;

 float PlaneDistance( const idVec3 &plane ) const;
 int PlaneSide( const idVec3 &plane, const float epsilon = 0.1f ) const;

 bool PointInside( const idVec2 &point, const float epsilon ) const;
 bool LineIntersection( const idVec2 &start, const idVec2 &end ) const;
 bool RayIntersection( const idVec2 &start, const idVec2 &dir, float &scale1, float &scale2, int *edgeNums = __null ) const;

 static idVec3 Plane2DFromPoints( const idVec2 &start, const idVec2 &end, const bool normalize = false );
 static idVec3 Plane2DFromVecs( const idVec2 &start, const idVec2 &dir, const bool normalize = false );
 static bool Plane2DIntersection( const idVec3 &plane1, const idVec3 &plane2, idVec2 &point );

private:
 int numPoints;
 idVec2 p[16];
};

inline idWinding2D::idWinding2D( void ) {
 numPoints = 0;
}

inline idWinding2D &idWinding2D::operator=( const idWinding2D &winding ) {
 int i;

 for ( i = 0; i < winding.numPoints; i++ ) {
  p[i] = winding.p[i];
 }
 numPoints = winding.numPoints;
 return *this;
}

inline const idVec2 &idWinding2D::operator[]( const int index ) const {
 return p[ index ];
}

inline idVec2 &idWinding2D::operator[]( const int index ) {
 return p[ index ];
}

inline void idWinding2D::Clear( void ) {
 numPoints = 0;
}

inline void idWinding2D::AddPoint( const idVec2 &point ) {
 p[numPoints++] = point;
}

inline int idWinding2D::GetNumPoints( void ) const {
 return numPoints;
}

inline idVec3 idWinding2D::Plane2DFromPoints( const idVec2 &start, const idVec2 &end, const bool normalize ) {
 idVec3 plane;
 plane.x = start.y - end.y;
 plane.y = end.x - start.x;
 if ( normalize ) {
  plane.ToVec2().Normalize();
 }
 plane.z = - ( start.x * plane.x + start.y * plane.y );
 return plane;
}

inline idVec3 idWinding2D::Plane2DFromVecs( const idVec2 &start, const idVec2 &dir, const bool normalize ) {
 idVec3 plane;
 plane.x = -dir.y;
 plane.y = dir.x;
 if ( normalize ) {
  plane.ToVec2().Normalize();
 }
 plane.z = - ( start.x * plane.x + start.y * plane.y );
 return plane;
}

inline bool idWinding2D::Plane2DIntersection( const idVec3 &plane1, const idVec3 &plane2, idVec2 &point ) {
 float n00, n01, n11, det, invDet, f0, f1;

 n00 = plane1.x * plane1.x + plane1.y * plane1.y;
 n01 = plane1.x * plane2.x + plane1.y * plane2.y;
 n11 = plane2.x * plane2.x + plane2.y * plane2.y;
 det = n00 * n11 - n01 * n01;

 if ( idMath::Fabs(det) < 1e-6f ) {
  return false;
 }

 invDet = 1.0f / det;
 f0 = ( n01 * plane2.z - n11 * plane1.z ) * invDet;
 f1 = ( n01 * plane1.z - n00 * plane2.z ) * invDet;
 point.x = f0 * plane1.x + f1 * plane2.x;
 point.y = f0 * plane1.y + f1 * plane2.y;
 return true;
}
# 203 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Surface.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Surface.h"
typedef struct surfaceEdge_s {
 int verts[2];
 int tris[2];
} surfaceEdge_t;


class idSurface {
public:
       idSurface( void );
       explicit idSurface( const idSurface &surf );
       explicit idSurface( const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes );
       ~idSurface( void );

 const idDrawVert & operator[]( const int index ) const;
 idDrawVert & operator[]( const int index );
 idSurface & operator+=( const idSurface &surf );

 int GetNumIndexes( void ) const { return indexes.Num(); }
 const int * GetIndexes( void ) const { return indexes.Ptr(); }
 int GetNumVertices( void ) const { return verts.Num(); }
 const idDrawVert * GetVertices( void ) const { return verts.Ptr(); }
 const int * GetEdgeIndexes( void ) const { return edgeIndexes.Ptr(); }
 const surfaceEdge_t * GetEdges( void ) const { return edges.Ptr(); }

 void Clear( void );
 void SwapTriangles( idSurface &surf );
 void TranslateSelf( const idVec3 &translation );
 void RotateSelf( const idMat3 &rotation );




 int Split( const idPlane &plane, const float epsilon, idSurface **front, idSurface **back, int *frontOnPlaneEdges = __null, int *backOnPlaneEdges = __null ) const;


 bool ClipInPlace( const idPlane &plane, const float epsilon = 0.1f, const bool keepOn = false );


 bool IsConnected( void ) const;

 bool IsClosed( void ) const;

 bool IsPolytope( const float epsilon = 0.1f ) const;

 float PlaneDistance( const idPlane &plane ) const;
 int PlaneSide( const idPlane &plane, const float epsilon = 0.1f ) const;


 bool LineIntersection( const idVec3 &start, const idVec3 &end, bool backFaceCull = false ) const;

 bool RayIntersection( const idVec3 &start, const idVec3 &dir, float &scale, bool backFaceCull = false ) const;

protected:
 idList<idDrawVert> verts;
 idList<int> indexes;
 idList<surfaceEdge_t> edges;
 idList<int> edgeIndexes;

protected:
 void GenerateEdgeIndexes( void );
 int FindEdge( int v1, int v2 ) const;
};






inline idSurface::idSurface( void ) {
}






inline idSurface::idSurface( const idDrawVert *verts, const int numVerts, const int *indexes, const int numIndexes ) {
 ((void)0);
 this->verts.SetNum( numVerts );
 memcpy( this->verts.Ptr(), verts, numVerts * sizeof( verts[0] ) );
 this->indexes.SetNum( numIndexes );
 memcpy( this->indexes.Ptr(), indexes, numIndexes * sizeof( indexes[0] ) );
 GenerateEdgeIndexes();
}






inline idSurface::idSurface( const idSurface &surf ) {
 this->verts = surf.verts;
 this->indexes = surf.indexes;
 this->edges = surf.edges;
 this->edgeIndexes = surf.edgeIndexes;
}






inline idSurface::~idSurface( void ) {
}






inline const idDrawVert &idSurface::operator[]( const int index ) const {
 return verts[ index ];
};






inline idDrawVert &idSurface::operator[]( const int index ) {
 return verts[ index ];
};






inline idSurface &idSurface::operator+=( const idSurface &surf ) {
 int i, m, n;
 n = verts.Num();
 m = indexes.Num();
 verts.Append( surf.verts );
 indexes.Append( surf.indexes );
 for ( i = m; i < indexes.Num(); i++ ) {
  indexes[i] += n;
 }
 GenerateEdgeIndexes();
 return *this;
}






inline void idSurface::Clear( void ) {
 verts.Clear();
 indexes.Clear();
 edges.Clear();
 edgeIndexes.Clear();
}






inline void idSurface::SwapTriangles( idSurface &surf ) {
 verts.Swap( surf.verts );
 indexes.Swap( surf.indexes );
 edges.Swap( surf.edges );
 edgeIndexes.Swap( surf.edgeIndexes );
}






inline void idSurface::TranslateSelf( const idVec3 &translation ) {
 for ( int i = 0; i < verts.Num(); i++ ) {
  verts[i].xyz += translation;
 }
}






inline void idSurface::RotateSelf( const idMat3 &rotation ) {
 for ( int i = 0; i < verts.Num(); i++ ) {
  verts[i].xyz *= rotation;
  verts[i].normal *= rotation;
  verts[i].tangents[0] *= rotation;
  verts[i].tangents[1] *= rotation;
 }
}
# 204 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Surface_Patch.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Surface_Patch.h"
class idSurface_Patch : public idSurface {

public:
      idSurface_Patch( void );
      idSurface_Patch( int maxPatchWidth, int maxPatchHeight );
      idSurface_Patch( const idSurface_Patch &patch );
      ~idSurface_Patch( void );

 void SetSize( int patchWidth, int patchHeight );
 int GetWidth( void ) const;
 int GetHeight( void ) const;


 void Subdivide( float maxHorizontalError, float maxVerticalError, float maxLength, bool genNormals = false );

 void SubdivideExplicit( int horzSubdivisions, int vertSubdivisions, bool genNormals, bool removeLinear = false );

protected:
 int width;
 int height;
 int maxWidth;
 int maxHeight;
 bool expanded;

private:

 void PutOnCurve( void );

 void RemoveLinearColumnsRows( void );

 void ResizeExpanded( int height, int width );

 void Expand( void );

 void Collapse( void );

 void ProjectPointOntoVector( const idVec3 &point, const idVec3 &vStart, const idVec3 &vEnd, idVec3 &vProj );

 void GenerateNormals( void );

 void GenerateIndexes( void );

 void LerpVert( const idDrawVert &a, const idDrawVert &b, idDrawVert &out ) const;

 void SampleSinglePatchPoint( const idDrawVert ctrl[3][3], float u, float v, idDrawVert *out ) const;
 void SampleSinglePatch( const idDrawVert ctrl[3][3], int baseCol, int baseRow, int width, int horzSub, int vertSub, idDrawVert *outVerts ) const;
};






inline idSurface_Patch::idSurface_Patch( void ) {
 height = width = maxHeight = maxWidth = 0;
 expanded = false;
}






inline idSurface_Patch::idSurface_Patch( int maxPatchWidth, int maxPatchHeight ) {
 width = height = 0;
 maxWidth = maxPatchWidth;
 maxHeight = maxPatchHeight;
 verts.SetNum( maxWidth * maxHeight );
 expanded = false;
}






inline idSurface_Patch::idSurface_Patch( const idSurface_Patch &patch ) {
 (*this) = patch;
}






inline idSurface_Patch::~idSurface_Patch() {
}






inline int idSurface_Patch::GetWidth( void ) const {
 return width;
}






inline int idSurface_Patch::GetHeight( void ) const {
 return height;
}
# 205 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Surface_Polytope.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Surface_Polytope.h"
class idSurface_Polytope : public idSurface {
public:
      idSurface_Polytope( void );

 void FromPlanes( const idPlane *planes, const int numPlanes );

 void SetupTetrahedron( const idBounds &bounds );
 void SetupHexahedron( const idBounds &bounds );
 void SetupOctahedron( const idBounds &bounds );
 void SetupDodecahedron( const idBounds &bounds );
 void SetupIcosahedron( const idBounds &bounds );
 void SetupCylinder( const idBounds &bounds, const int numSides );
 void SetupCone( const idBounds &bounds, const int numSides );

 int SplitPolytope( const idPlane &plane, const float epsilon, idSurface_Polytope **front, idSurface_Polytope **back ) const;

protected:

};






inline idSurface_Polytope::idSurface_Polytope( void ) {
}
# 206 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Surface_SweptSpline.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/Surface_SweptSpline.h"
class idSurface_SweptSpline : public idSurface {
public:
       idSurface_SweptSpline( void );
       ~idSurface_SweptSpline( void );

 void SetSpline( idCurve_Spline<idVec4> *spline );
 void SetSweptSpline( idCurve_Spline<idVec4> *sweptSpline );
 void SetSweptCircle( const float radius );

 void Tessellate( const int splineSubdivisions, const int sweptSplineSubdivisions );

 void Clear( void );

protected:
 idCurve_Spline<idVec4> *spline;
 idCurve_Spline<idVec4> *sweptSpline;

 void GetFrame( const idMat3 &previousFrame, const idVec3 dir, idMat3 &newFrame );
};






inline idSurface_SweptSpline::idSurface_SweptSpline( void ) {
 spline = __null;
 sweptSpline = __null;
}






inline idSurface_SweptSpline::~idSurface_SweptSpline( void ) {
 delete spline;
 delete sweptSpline;
}






inline void idSurface_SweptSpline::Clear( void ) {
 idSurface::Clear();
 delete spline;
 spline = __null;
 delete sweptSpline;
 sweptSpline = __null;
}
# 207 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/TraceModel.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/geometry/TraceModel.h"
class idVec3;
class idMat3;
class idBounds;


typedef enum {
 TRM_INVALID,
 TRM_BOX,
 TRM_OCTAHEDRON,
 TRM_DODECAHEDRON,
 TRM_CYLINDER,
 TRM_CONE,
 TRM_BONE,
 TRM_POLYGON,
 TRM_POLYGONVOLUME,
 TRM_CUSTOM
} traceModel_t;







typedef idVec3 traceModelVert_t;

typedef struct {
 int v[2];
 idVec3 normal;
} traceModelEdge_t;

typedef struct {
 idVec3 normal;
 float dist;
 idBounds bounds;
 int numEdges;
 int edges[16];
} traceModelPoly_t;

class idTraceModel {

public:
 traceModel_t type;
 int numVerts;
 traceModelVert_t verts[32];
 int numEdges;
 traceModelEdge_t edges[32 +1];
 int numPolys;
 traceModelPoly_t polys[16];
 idVec3 offset;
 idBounds bounds;
 bool isConvex;

public:
      idTraceModel( void );

      idTraceModel( const idBounds &boxBounds );

      idTraceModel( const idBounds &cylBounds, const int numSides );

      idTraceModel( const float length, const float width );


 void SetupBox( const idBounds &boxBounds );
 void SetupBox( const float size );

 void SetupOctahedron( const idBounds &octBounds );
 void SetupOctahedron( const float size );

 void SetupDodecahedron( const idBounds &dodBounds );
 void SetupDodecahedron( const float size );

 void SetupCylinder( const idBounds &cylBounds, const int numSides );
 void SetupCylinder( const float height, const float width, const int numSides );

 void SetupCone( const idBounds &coneBounds, const int numSides );
 void SetupCone( const float height, const float width, const int numSides );

 void SetupBone( const float length, const float width );

 void SetupPolygon( const idVec3 *v, const int count );
 void SetupPolygon( const idWinding &w );

 int GenerateEdgeNormals( void );

 void Translate( const idVec3 &translation );

 void Rotate( const idMat3 &rotation );

 void Shrink( const float m );

 bool Compare( const idTraceModel &trm ) const;
 bool operator==( const idTraceModel &trm ) const;
 bool operator!=( const idTraceModel &trm ) const;

 float GetPolygonArea( int polyNum ) const;

 int GetProjectionSilhouetteEdges( const idVec3 &projectionOrigin, int silEdges[32] ) const;
 int GetParallelProjectionSilhouetteEdges( const idVec3 &projectionDir, int silEdges[32] ) const;

 void GetMassProperties( const float density, float &mass, idVec3 &centerOfMass, idMat3 &inertiaTensor ) const;

private:
 void InitBox( void );
 void InitOctahedron( void );
 void InitDodecahedron( void );
 void InitBone( void );

 void ProjectionIntegrals( int polyNum, int a, int b, struct projectionIntegrals_s &integrals ) const;
 void PolygonIntegrals( int polyNum, int a, int b, int c, struct polygonIntegrals_s &integrals ) const;
 void VolumeIntegrals( struct volumeIntegrals_s &integrals ) const;
 void VolumeFromPolygon( idTraceModel &trm, float thickness ) const;
 int GetOrderedSilhouetteEdges( const int edgeIsSilEdge[32 +1], int silEdges[32] ) const;
};


inline idTraceModel::idTraceModel( void ) {
 type = TRM_INVALID;
 numVerts = numEdges = numPolys = 0;
 bounds.Zero();
}

inline idTraceModel::idTraceModel( const idBounds &boxBounds ) {
 InitBox();
 SetupBox( boxBounds );
}

inline idTraceModel::idTraceModel( const idBounds &cylBounds, const int numSides ) {
 SetupCylinder( cylBounds, numSides );
}

inline idTraceModel::idTraceModel( const float length, const float width ) {
 InitBone();
 SetupBone( length, width );
}

inline bool idTraceModel::operator==( const idTraceModel &trm ) const {
 return Compare( trm );
}

inline bool idTraceModel::operator!=( const idTraceModel &trm ) const {
 return !Compare( trm );
}
# 208 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Str.h" 1
# 96 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Str.h"
class idVec4;






const int C_COLOR_ESCAPE = '^';
const int C_COLOR_DEFAULT = '0';
const int C_COLOR_RED = '1';
const int C_COLOR_GREEN = '2';
const int C_COLOR_YELLOW = '3';
const int C_COLOR_BLUE = '4';
const int C_COLOR_CYAN = '5';
const int C_COLOR_MAGENTA = '6';
const int C_COLOR_WHITE = '7';
const int C_COLOR_GRAY = '8';
const int C_COLOR_BLACK = '9';
# 129 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Str.h"
const int STR_ALLOC_BASE = 20;
const int STR_ALLOC_GRAN = 32;

typedef enum {
 MEASURE_SIZE = 0,
 MEASURE_BANDWIDTH
} Measure_t;

class idStr {

public:
      idStr( void );
      idStr( const idStr &text );
      idStr( const idStr &text, int start, int end );
      idStr( const char *text );
      idStr( const char *text, int start, int end );
      explicit idStr( const bool b );
      explicit idStr( const char c );
      explicit idStr( const int i );
      explicit idStr( const unsigned u );
      explicit idStr( const float f );
      ~idStr( void );

 size_t Size( void ) const;
 const char * c_str( void ) const;
 operator const char *( void ) const;
 operator const char *( void );

 char operator[]( int index ) const;
 char & operator[]( int index );

 void operator=( const idStr &text );
 void operator=( const char *text );

 friend idStr operator+( const idStr &a, const idStr &b );
 friend idStr operator+( const idStr &a, const char *b );
 friend idStr operator+( const char *a, const idStr &b );

 friend idStr operator+( const idStr &a, const float b );
 friend idStr operator+( const idStr &a, const int b );
 friend idStr operator+( const idStr &a, const unsigned b );
 friend idStr operator+( const idStr &a, const bool b );
 friend idStr operator+( const idStr &a, const char b );

 idStr & operator+=( const idStr &a );
 idStr & operator+=( const char *a );
 idStr & operator+=( const float a );
 idStr & operator+=( const char a );
 idStr & operator+=( const int a );
 idStr & operator+=( const unsigned a );
 idStr & operator+=( const bool a );


 friend bool operator==( const idStr &a, const idStr &b );
 friend bool operator==( const idStr &a, const char *b );
 friend bool operator==( const char *a, const idStr &b );


 friend bool operator!=( const idStr &a, const idStr &b );
 friend bool operator!=( const idStr &a, const char *b );
 friend bool operator!=( const char *a, const idStr &b );


 int Cmp( const char *text ) const;
 int Cmpn( const char *text, int n ) const;
 int CmpPrefix( const char *text ) const;


 int Icmp( const char *text ) const;
 int Icmpn( const char *text, int n ) const;
 int IcmpPrefix( const char *text ) const;


 int IcmpNoColor( const char *text ) const;


 int IcmpPath( const char *text ) const;
 int IcmpnPath( const char *text, int n ) const;
 int IcmpPrefixPath( const char *text ) const;

 int Length( void ) const;
 int Allocated( void ) const;
 void Empty( void );
 bool IsEmpty( void ) const;
 void Clear( void );
 void Append( const char a );
 void Append( const idStr &text );
 void Append( const char *text );
 void Append( const char *text, int len );
 void Insert( const char a, int index );
 void Insert( const char *text, int index );
 void ToLower( void );
 void ToUpper( void );
 bool IsNumeric( void ) const;
 bool IsColor( void ) const;
 bool HasLower( void ) const;
 bool HasUpper( void ) const;
 int LengthWithoutColors( void ) const;
 idStr & RemoveColors( void );
 void CapLength( int );
 void Fill( const char ch, int newlen );

 int Find( const char c, int start = 0, int end = -1 ) const;
 int Find( const char *text, bool casesensitive = true, int start = 0, int end = -1 ) const;
 bool Filter( const char *filter, bool casesensitive ) const;
 int Last( const char c ) const;
 const char * Left( int len, idStr &result ) const;
 const char * Right( int len, idStr &result ) const;
 const char * Mid( int start, int len, idStr &result ) const;
 idStr Left( int len ) const;
 idStr Right( int len ) const;
 idStr Mid( int start, int len ) const;
 void StripLeading( const char c );
 void StripLeading( const char *string );
 bool StripLeadingOnce( const char *string );
 void StripTrailing( const char c );
 void StripTrailing( const char *string );
 bool StripTrailingOnce( const char *string );
 void Strip( const char c );
 void Strip( const char *string );
 void StripTrailingWhitespace( void );
 idStr & StripQuotes( void );
 void Replace( const char *old, const char *nw );


 int FileNameHash( void ) const;
 idStr & BackSlashesToSlashes( void );
 idStr & SetFileExtension( const char *extension );
 idStr & StripFileExtension( void );
 idStr & StripAbsoluteFileExtension( void );
 idStr & DefaultFileExtension( const char *extension );
 idStr & DefaultPath( const char *basepath );
 void AppendPath( const char *text );
 idStr & StripFilename( void );
 idStr & StripPath( void );
 void ExtractFilePath( idStr &dest ) const;
 void ExtractFileName( idStr &dest ) const;
 void ExtractFileBase( idStr &dest ) const;
 void ExtractFileExtension( idStr &dest ) const;
 bool CheckExtension( const char *ext );


 static int Length( const char *s );
 static char * ToLower( char *s );
 static char * ToUpper( char *s );
 static bool IsNumeric( const char *s );
 static bool IsColor( const char *s );
 static bool HasLower( const char *s );
 static bool HasUpper( const char *s );
 static int LengthWithoutColors( const char *s );
 static char * RemoveColors( char *s );
 static int Cmp( const char *s1, const char *s2 );
 static int Cmpn( const char *s1, const char *s2, int n );
 static int Icmp( const char *s1, const char *s2 );
 static int Icmpn( const char *s1, const char *s2, int n );
 static int IcmpNoColor( const char *s1, const char *s2 );
 static int IcmpPath( const char *s1, const char *s2 );
 static int IcmpnPath( const char *s1, const char *s2, int n );
 static void Append( char *dest, int size, const char *src );
 static void Copynz( char *dest, const char *src, int destsize );
 static int snPrintf( char *dest, int size, const char *fmt, ... ) __attribute__((format(printf,3,4)));
 static int vsnPrintf( char *dest, int size, const char *fmt, va_list argptr );
 static int FindChar( const char *str, const char c, int start = 0, int end = -1 );
 static int FindText( const char *str, const char *text, bool casesensitive = true, int start = 0, int end = -1 );
 static bool Filter( const char *filter, const char *name, bool casesensitive );
 static void StripMediaName( const char *name, idStr &mediaName );
 static bool CheckExtension( const char *name, const char *ext );
 static const char * FloatArrayToString( const float *array, const int length, const int precision );


 static int Hash( const char *string );
 static int Hash( const char *string, int length );
 static int IHash( const char *string );
 static int IHash( const char *string, int length );


 static char ToLower( char c );
 static char ToUpper( char c );
 static bool CharIsPrintable( int c );
 static bool CharIsLower( int c );
 static bool CharIsUpper( int c );
 static bool CharIsAlpha( int c );
 static bool CharIsNumeric( int c );
 static bool CharIsNewLine( char c );
 static bool CharIsTab( char c );
 static int ColorIndex( int c );
 static idVec4 & ColorForIndex( int i );

 friend int sprintf( idStr &dest, const char *fmt, ... );
 friend int vsprintf( idStr &dest, const char *fmt, va_list ap );

 void ReAllocate( int amount, bool keepold );
 void FreeData( void );


 int BestUnit( const char *format, float value, Measure_t measure );

 void SetUnit( const char *format, float value, int unit, Measure_t measure );

 static void InitMemory( void );
 static void ShutdownMemory( void );
 static void PurgeMemory( void );
 static void ShowMemoryUsage_f( const idCmdArgs &args );

 int DynamicMemoryUsed() const;
 static idStr FormatNumber( int number );

protected:
 int len;
 char * data;
 int alloced;
 char baseBuffer[ STR_ALLOC_BASE ];

 void Init( void );
 void EnsureAlloced( int amount, bool keepold = true );
};

char * va( const char *fmt, ... ) __attribute__((format(printf,1,2)));


inline void idStr::EnsureAlloced( int amount, bool keepold ) {
 if ( amount > alloced ) {
  ReAllocate( amount, keepold );
 }
}

inline void idStr::Init( void ) {
 len = 0;
 alloced = STR_ALLOC_BASE;
 data = baseBuffer;
 data[ 0 ] = '\0';



}

inline idStr::idStr( void ) {
 Init();
}

inline idStr::idStr( const idStr &text ) {
 int l;

 Init();
 l = text.Length();
 EnsureAlloced( l + 1 );
 strcpy( data, text.data );
 len = l;
}

inline idStr::idStr( const idStr &text, int start, int end ) {
 int i;
 int l;

 Init();
 if ( end > text.Length() ) {
  end = text.Length();
 }
 if ( start > text.Length() ) {
  start = text.Length();
 } else if ( start < 0 ) {
  start = 0;
 }

 l = end - start;
 if ( l < 0 ) {
  l = 0;
 }

 EnsureAlloced( l + 1 );

 for ( i = 0; i < l; i++ ) {
  data[ i ] = text[ start + i ];
 }

 data[ l ] = '\0';
 len = l;
}

inline idStr::idStr( const char *text ) {
 int l;

 Init();
 if ( text ) {
  l = strlen( text );
  EnsureAlloced( l + 1 );
  strcpy( data, text );
  len = l;
 }
}

inline idStr::idStr( const char *text, int start, int end ) {
 int i;
 int l = strlen( text );

 Init();
 if ( end > l ) {
  end = l;
 }
 if ( start > l ) {
  start = l;
 } else if ( start < 0 ) {
  start = 0;
 }

 l = end - start;
 if ( l < 0 ) {
  l = 0;
 }

 EnsureAlloced( l + 1 );

 for ( i = 0; i < l; i++ ) {
  data[ i ] = text[ start + i ];
 }

 data[ l ] = '\0';
 len = l;
}

inline idStr::idStr( const bool b ) {
 Init();
 EnsureAlloced( 2 );
 data[ 0 ] = b ? '1' : '0';
 data[ 1 ] = '\0';
 len = 1;
}

inline idStr::idStr( const char c ) {
 Init();
 EnsureAlloced( 2 );
 data[ 0 ] = c;
 data[ 1 ] = '\0';
 len = 1;
}

inline idStr::idStr( const int i ) {
 char text[ 64 ];
 int l;

 Init();
 l = sprintf( text, "%d", i );
 EnsureAlloced( l + 1 );
 strcpy( data, text );
 len = l;
}

inline idStr::idStr( const unsigned u ) {
 char text[ 64 ];
 int l;

 Init();
 l = sprintf( text, "%u", u );
 EnsureAlloced( l + 1 );
 strcpy( data, text );
 len = l;
}

inline idStr::idStr( const float f ) {
 char text[ 64 ];
 int l;

 Init();
 l = idStr::snPrintf( text, sizeof( text ), "%f", f );
 while( l > 0 && text[l-1] == '0' ) text[--l] = '\0';
 while( l > 0 && text[l-1] == '.' ) text[--l] = '\0';
 EnsureAlloced( l + 1 );
 strcpy( data, text );
 len = l;
}

inline idStr::~idStr( void ) {
 FreeData();
}

inline size_t idStr::Size( void ) const {
 return sizeof( *this ) + Allocated();
}

inline const char *idStr::c_str( void ) const {
 return data;
}

inline idStr::operator const char *( void ) {
 return c_str();
}

inline idStr::operator const char *( void ) const {
 return c_str();
}

inline char idStr::operator[]( int index ) const {
 ((void)0);
 return data[ index ];
}

inline char &idStr::operator[]( int index ) {
 ((void)0);
 return data[ index ];
}

inline void idStr::operator=( const idStr &text ) {
 int l;

 l = text.Length();
 EnsureAlloced( l + 1, false );
 memcpy( data, text.data, l );
 data[l] = '\0';
 len = l;
}

inline idStr operator+( const idStr &a, const idStr &b ) {
 idStr result( a );
 result.Append( b );
 return result;
}

inline idStr operator+( const idStr &a, const char *b ) {
 idStr result( a );
 result.Append( b );
 return result;
}

inline idStr operator+( const char *a, const idStr &b ) {
 idStr result( a );
 result.Append( b );
 return result;
}

inline idStr operator+( const idStr &a, const bool b ) {
 idStr result( a );
 result.Append( b ? "true" : "false" );
 return result;
}

inline idStr operator+( const idStr &a, const char b ) {
 idStr result( a );
 result.Append( b );
 return result;
}

inline idStr operator+( const idStr &a, const float b ) {
 char text[ 64 ];
 idStr result( a );

 sprintf( text, "%f", b );
 result.Append( text );

 return result;
}

inline idStr operator+( const idStr &a, const int b ) {
 char text[ 64 ];
 idStr result( a );

 sprintf( text, "%d", b );
 result.Append( text );

 return result;
}

inline idStr operator+( const idStr &a, const unsigned b ) {
 char text[ 64 ];
 idStr result( a );

 sprintf( text, "%u", b );
 result.Append( text );

 return result;
}

inline idStr &idStr::operator+=( const float a ) {
 char text[ 64 ];

 sprintf( text, "%f", a );
 Append( text );

 return *this;
}

inline idStr &idStr::operator+=( const int a ) {
 char text[ 64 ];

 sprintf( text, "%d", a );
 Append( text );

 return *this;
}

inline idStr &idStr::operator+=( const unsigned a ) {
 char text[ 64 ];

 sprintf( text, "%u", a );
 Append( text );

 return *this;
}

inline idStr &idStr::operator+=( const idStr &a ) {
 Append( a );
 return *this;
}

inline idStr &idStr::operator+=( const char *a ) {
 Append( a );
 return *this;
}

inline idStr &idStr::operator+=( const char a ) {
 Append( a );
 return *this;
}

inline idStr &idStr::operator+=( const bool a ) {
 Append( a ? "true" : "false" );
 return *this;
}

inline bool operator==( const idStr &a, const idStr &b ) {
 return ( !idStr::Cmp( a.data, b.data ) );
}

inline bool operator==( const idStr &a, const char *b ) {
 ((void)0);
 return ( !idStr::Cmp( a.data, b ) );
}

inline bool operator==( const char *a, const idStr &b ) {
 ((void)0);
 return ( !idStr::Cmp( a, b.data ) );
}

inline bool operator!=( const idStr &a, const idStr &b ) {
 return !( a == b );
}

inline bool operator!=( const idStr &a, const char *b ) {
 return !( a == b );
}

inline bool operator!=( const char *a, const idStr &b ) {
 return !( a == b );
}

inline int idStr::Cmp( const char *text ) const {
 ((void)0);
 return idStr::Cmp( data, text );
}

inline int idStr::Cmpn( const char *text, int n ) const {
 ((void)0);
 return idStr::Cmpn( data, text, n );
}

inline int idStr::CmpPrefix( const char *text ) const {
 ((void)0);
 return idStr::Cmpn( data, text, strlen( text ) );
}

inline int idStr::Icmp( const char *text ) const {
 ((void)0);
 return idStr::Icmp( data, text );
}

inline int idStr::Icmpn( const char *text, int n ) const {
 ((void)0);
 return idStr::Icmpn( data, text, n );
}

inline int idStr::IcmpPrefix( const char *text ) const {
 ((void)0);
 return idStr::Icmpn( data, text, strlen( text ) );
}

inline int idStr::IcmpNoColor( const char *text ) const {
 ((void)0);
 return idStr::IcmpNoColor( data, text );
}

inline int idStr::IcmpPath( const char *text ) const {
 ((void)0);
 return idStr::IcmpPath( data, text );
}

inline int idStr::IcmpnPath( const char *text, int n ) const {
 ((void)0);
 return idStr::IcmpnPath( data, text, n );
}

inline int idStr::IcmpPrefixPath( const char *text ) const {
 ((void)0);
 return idStr::IcmpnPath( data, text, strlen( text ) );
}

inline int idStr::Length( void ) const {
 return len;
}

inline int idStr::Allocated( void ) const {
 if ( data != baseBuffer ) {
  return alloced;
 } else {
  return 0;
 }
}

inline void idStr::Empty( void ) {
 EnsureAlloced( 1 );
 data[ 0 ] = '\0';
 len = 0;
}

inline bool idStr::IsEmpty( void ) const {
 return ( idStr::Cmp( data, "" ) == 0 );
}

inline void idStr::Clear( void ) {
 FreeData();
 Init();
}

inline void idStr::Append( const char a ) {
 EnsureAlloced( len + 2 );
 data[ len ] = a;
 len++;
 data[ len ] = '\0';
}

inline void idStr::Append( const idStr &text ) {
 int newLen;
 int i;

 newLen = len + text.Length();
 EnsureAlloced( newLen + 1 );
 for ( i = 0; i < text.len; i++ ) {
  data[ len + i ] = text[ i ];
 }
 len = newLen;
 data[ len ] = '\0';
}

inline void idStr::Append( const char *text ) {
 int newLen;
 int i;

 if ( text ) {
  newLen = len + strlen( text );
  EnsureAlloced( newLen + 1 );
  for ( i = 0; text[ i ]; i++ ) {
   data[ len + i ] = text[ i ];
  }
  len = newLen;
  data[ len ] = '\0';
 }
}

inline void idStr::Append( const char *text, int l ) {
 int newLen;
 int i;

 if ( text && l ) {
  newLen = len + l;
  EnsureAlloced( newLen + 1 );
  for ( i = 0; text[ i ] && i < l; i++ ) {
   data[ len + i ] = text[ i ];
  }
  len = newLen;
  data[ len ] = '\0';
 }
}

inline void idStr::Insert( const char a, int index ) {
 int i, l;

 if ( index < 0 ) {
  index = 0;
 } else if ( index > len ) {
  index = len;
 }

 l = 1;
 EnsureAlloced( len + l + 1 );
 for ( i = len; i >= index; i-- ) {
  data[i+l] = data[i];
 }
 data[index] = a;
 len++;
}

inline void idStr::Insert( const char *text, int index ) {
 int i, l;

 if ( index < 0 ) {
  index = 0;
 } else if ( index > len ) {
  index = len;
 }

 l = strlen( text );
 EnsureAlloced( len + l + 1 );
 for ( i = len; i >= index; i-- ) {
  data[i+l] = data[i];
 }
 for ( i = 0; i < l; i++ ) {
  data[index+i] = text[i];
 }
 len += l;
}

inline void idStr::ToLower( void ) {
 for (int i = 0; data[i]; i++ ) {
  if ( CharIsUpper( data[i] ) ) {
   data[i] += ( 'a' - 'A' );
  }
 }
}

inline void idStr::ToUpper( void ) {
 for (int i = 0; data[i]; i++ ) {
  if ( CharIsLower( data[i] ) ) {
   data[i] -= ( 'a' - 'A' );
  }
 }
}

inline bool idStr::IsNumeric( void ) const {
 return idStr::IsNumeric( data );
}

inline bool idStr::IsColor( void ) const {
 return idStr::IsColor( data );
}

inline bool idStr::HasLower( void ) const {
 return idStr::HasLower( data );
}

inline bool idStr::HasUpper( void ) const {
 return idStr::HasUpper( data );
}

inline idStr &idStr::RemoveColors( void ) {
 idStr::RemoveColors( data );
 len = Length( data );
 return *this;
}

inline int idStr::LengthWithoutColors( void ) const {
 return idStr::LengthWithoutColors( data );
}

inline void idStr::CapLength( int newlen ) {
 if ( len <= newlen ) {
  return;
 }
 data[ newlen ] = 0;
 len = newlen;
}

inline void idStr::Fill( const char ch, int newlen ) {
 EnsureAlloced( newlen + 1 );
 len = newlen;
 memset( data, ch, len );
 data[ len ] = 0;
}

inline int idStr::Find( const char c, int start, int end ) const {
 if ( end == -1 ) {
  end = len;
 }
 return idStr::FindChar( data, c, start, end );
}

inline int idStr::Find( const char *text, bool casesensitive, int start, int end ) const {
 if ( end == -1 ) {
  end = len;
 }
 return idStr::FindText( data, text, casesensitive, start, end );
}

inline bool idStr::Filter( const char *filter, bool casesensitive ) const {
 return idStr::Filter( filter, data, casesensitive );
}

inline const char *idStr::Left( int len, idStr &result ) const {
 return Mid( 0, len, result );
}

inline const char *idStr::Right( int len, idStr &result ) const {
 if ( len >= Length() ) {
  result = *this;
  return result;
 }
 return Mid( Length() - len, len, result );
}

inline idStr idStr::Left( int len ) const {
 return Mid( 0, len );
}

inline idStr idStr::Right( int len ) const {
 if ( len >= Length() ) {
  return *this;
 }
 return Mid( Length() - len, len );
}

inline void idStr::Strip( const char c ) {
 StripLeading( c );
 StripTrailing( c );
}

inline void idStr::Strip( const char *string ) {
 StripLeading( string );
 StripTrailing( string );
}

inline bool idStr::CheckExtension( const char *ext ) {
 return idStr::CheckExtension( data, ext );
}

inline int idStr::Length( const char *s ) {
 int i;
 for ( i = 0; s[i]; i++ ) {}
 return i;
}

inline char *idStr::ToLower( char *s ) {
 for ( int i = 0; s[i]; i++ ) {
  if ( CharIsUpper( s[i] ) ) {
   s[i] += ( 'a' - 'A' );
  }
 }
 return s;
}

inline char *idStr::ToUpper( char *s ) {
 for ( int i = 0; s[i]; i++ ) {
  if ( CharIsLower( s[i] ) ) {
   s[i] -= ( 'a' - 'A' );
  }
 }
 return s;
}

inline int idStr::Hash( const char *string ) {
 int i, hash = 0;
 for ( i = 0; *string != '\0'; i++ ) {
  hash += ( *string++ ) * ( i + 119 );
 }
 return hash;
}

inline int idStr::Hash( const char *string, int length ) {
 int i, hash = 0;
 for ( i = 0; i < length; i++ ) {
  hash += ( *string++ ) * ( i + 119 );
 }
 return hash;
}

inline int idStr::IHash( const char *string ) {
 int i, hash = 0;
 for( i = 0; *string != '\0'; i++ ) {
  hash += ToLower( *string++ ) * ( i + 119 );
 }
 return hash;
}

inline int idStr::IHash( const char *string, int length ) {
 int i, hash = 0;
 for ( i = 0; i < length; i++ ) {
  hash += ToLower( *string++ ) * ( i + 119 );
 }
 return hash;
}

inline bool idStr::IsColor( const char *s ) {
 return ( s[0] == C_COLOR_ESCAPE && s[1] != '\0' && s[1] != ' ' );
}

inline char idStr::ToLower( char c ) {
 if ( c <= 'Z' && c >= 'A' ) {
  return ( c + ( 'a' - 'A' ) );
 }
 return c;
}

inline char idStr::ToUpper( char c ) {
 if ( c >= 'a' && c <= 'z' ) {
  return ( c - ( 'a' - 'A' ) );
 }
 return c;
}

inline bool idStr::CharIsPrintable( int c ) {

 return ( c >= 0x20 && c <= 0x7E ) || ( c >= 0xA1 && c <= 0xFF );
}

inline bool idStr::CharIsLower( int c ) {

 return ( c >= 'a' && c <= 'z' ) || ( c >= 0xE0 && c <= 0xFF );
}

inline bool idStr::CharIsUpper( int c ) {

 return ( c <= 'Z' && c >= 'A' ) || ( c >= 0xC0 && c <= 0xDF );
}

inline bool idStr::CharIsAlpha( int c ) {

 return ( ( c >= 'a' && c <= 'z' ) || ( c >= 'A' && c <= 'Z' ) ||
    ( c >= 0xC0 && c <= 0xFF ) );
}

inline bool idStr::CharIsNumeric( int c ) {
 return ( c <= '9' && c >= '0' );
}

inline bool idStr::CharIsNewLine( char c ) {
 return ( c == '\n' || c == '\r' || c == '\v' );
}

inline bool idStr::CharIsTab( char c ) {
 return ( c == '\t' );
}

inline int idStr::ColorIndex( int c ) {
 return ( c & 15 );
}

inline int idStr::DynamicMemoryUsed() const {
 return ( data == baseBuffer ) ? 0 : alloced;
}
# 211 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Token.h" 1
# 71 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Token.h"
class idToken : public idStr {

 friend class idParser;
 friend class idLexer;

public:
 int type;
 int subtype;
 int line;
 int linesCrossed;
 int flags;

public:
     idToken( void );
     idToken( const idToken *token );
     ~idToken( void );

 void operator=( const idStr& text );
 void operator=( const char *text );

 double GetDoubleValue( void );
 float GetFloatValue( void );
 unsigned long GetUnsignedLongValue( void );
 int GetIntValue( void );
 int WhiteSpaceBeforeToken( void ) const;
 void ClearTokenWhiteSpace( void );

 void NumberValue( void );

private:
 unsigned long intvalue;
 double floatvalue;


 int whiteSpaceStart_p;
 int whiteSpaceEnd_p;
 idToken * next;

 void AppendDirty( const char a );
};

inline idToken::idToken( void ) {
}

inline idToken::idToken( const idToken *token ) {
 *this = *token;
}

inline idToken::~idToken( void ) {
}

inline void idToken::operator=( const char *text) {
 *static_cast<idStr *>(this) = text;
}

inline void idToken::operator=( const idStr& text ) {
 *static_cast<idStr *>(this) = text;
}

inline double idToken::GetDoubleValue( void ) {
 if ( type != 3 ) {
  return 0.0;
 }
 if ( !(subtype & 0x10000) ) {
  NumberValue();
 }
 return floatvalue;
}

inline float idToken::GetFloatValue( void ) {
 return (float) GetDoubleValue();
}

inline unsigned long idToken::GetUnsignedLongValue( void ) {
 if ( type != 3 ) {
  return 0;
 }
 if ( !(subtype & 0x10000) ) {
  NumberValue();
 }
 return intvalue;
}

inline int idToken::GetIntValue( void ) {
 return (int) GetUnsignedLongValue();
}

inline int idToken::WhiteSpaceBeforeToken( void ) const {
 return ( whiteSpaceEnd_p > whiteSpaceStart_p );
}

inline void idToken::AppendDirty( const char a ) {
 EnsureAlloced( len + 2, true );
 data[len++] = a;
}
# 212 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lexer.h" 1
# 49 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lexer.h"
typedef enum {
 LEXFL_NOERRORS = ( 1 << ( 0 ) ),
 LEXFL_NOWARNINGS = ( 1 << ( 1 ) ),
 LEXFL_NOFATALERRORS = ( 1 << ( 2 ) ),
 LEXFL_NOSTRINGCONCAT = ( 1 << ( 3 ) ),
 LEXFL_NOSTRINGESCAPECHARS = ( 1 << ( 4 ) ),
 LEXFL_NODOLLARPRECOMPILE = ( 1 << ( 5 ) ),
 LEXFL_NOBASEINCLUDES = ( 1 << ( 6 ) ),
 LEXFL_ALLOWPATHNAMES = ( 1 << ( 7 ) ),
 LEXFL_ALLOWNUMBERNAMES = ( 1 << ( 8 ) ),
 LEXFL_ALLOWIPADDRESSES = ( 1 << ( 9 ) ),
 LEXFL_ALLOWFLOATEXCEPTIONS = ( 1 << ( 10 ) ),
 LEXFL_ALLOWMULTICHARLITERALS = ( 1 << ( 11 ) ),
 LEXFL_ALLOWBACKSLASHSTRINGCONCAT = ( 1 << ( 12 ) ),
 LEXFL_ONLYSTRINGS = ( 1 << ( 13 ) )
} lexerFlags_t;
# 130 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lexer.h"
typedef struct punctuation_s
{
 const char *p;
 int n;
} punctuation_t;



class fileDataPtr {
public:
 fileDataPtr();
 ~fileDataPtr();

 fileDataPtr(const fileDataPtr &other);
 fileDataPtr(fileDataPtr &other);

 void setFile(const char *filename);
 void setBuffer(char *buffer, int length);

 operator const int ( void ) const;
 operator const int ( void );

 char operator*(void);
 char operator[](int & index);
 fileDataPtr & operator++();
 fileDataPtr operator++(int);
 fileDataPtr & operator--();
 fileDataPtr operator--(int);
 fileDataPtr & operator+=(const int & plus);
 fileDataPtr & operator-=(const int & minus);
 fileDataPtr operator+(const int & plus);
 fileDataPtr operator-(const int & minus);
 fileDataPtr & operator=(const int & ptr);
 bool operator==(const int & ptr) const;
 bool operator!=(const int & ptr) const;
 bool operator<(const int & ptr) const;
 bool operator>(const int & ptr) const;
 bool operator<=(const int & ptr) const;
 bool operator>=(const int & ptr) const;


 int ptr;
 char * buf;
 idFile * file;

private:

 char readBuf(int position);

 int posStart;
 int posEnd;
 int size;
 bool allocated;
 bool master;

};



class idLexer {

 friend class idParser;

public:

     idLexer();
     idLexer( int flags );
     idLexer( const char *filename, int flags = 0, bool OSPath = false );
     idLexer( const char *ptr, int length, const char *name, int flags = 0 );

     ~idLexer();

 int LoadFile( const char *filename, bool OSPath = false );



 int LoadMemory( const char *ptr, int length, const char *name, int startLine = 1 );

 void FreeSource( void );

 int IsLoaded( void ) { return idLexer::loaded; };

 int ReadToken( idToken *token );

 int ExpectTokenString( const char *string );

 int ExpectTokenType( int type, int subtype, idToken *token );

 int ExpectAnyToken( idToken *token );

 int CheckTokenString( const char *string );

 int CheckTokenType( int type, int subtype, idToken *token );

 int PeekTokenString( const char *string );

 int PeekTokenType( int type, int subtype, idToken *token );

 int SkipUntilString( const char *string );

 int SkipRestOfLine( void );

 int SkipBracedSection( bool parseFirstBrace = true );

 void UnreadToken( const idToken *token );

 int ReadTokenOnLine( idToken *token );


 const char* ReadRestOfLine(idStr& out);


 int ParseInt( void );

 bool ParseBool( void );


 float ParseFloat( bool *errorFlag = __null );

 int Parse1DMatrix( int x, float *m );
 int Parse2DMatrix( int y, int x, float *m );
 int Parse3DMatrix( int z, int y, int x, float *m );

 const char * ParseBracedSection( idStr &out );

 const char * ParseBracedSectionExact ( idStr &out, int tabs = -1 );

 const char * ParseRestOfLine( idStr &out );

 int GetLastWhiteSpace( idStr &whiteSpace ) const;

 int GetLastWhiteSpaceStart( void ) const;

 int GetLastWhiteSpaceEnd( void ) const;

 void SetPunctuations( const punctuation_t *p );

 const char * GetPunctuationFromId( int id );

 int GetPunctuationId( const char *p );

 void SetFlags( int flags );

 int GetFlags( void );

 void Reset( void );

 int EndOfFile( void );

 const char * GetFileName( void );

 const int GetFileOffset( void );
 void SetFileOffset( int offset );

 const time_t GetFileTime( void );

 const int GetLineNum( void );

 void Error( const char *str, ... ) __attribute__((format(printf,2,3)));

 void Warning( const char *str, ... ) __attribute__((format(printf,2,3)));

 bool HadError( void ) const;


 static void SetBaseFolder( const char *path );

private:
 int loaded;
 idStr filename;
 int allocated;

 fileDataPtr script_p;
 int end_p;
 int lastScript_p;
 int whiteSpaceStart_p;
 int whiteSpaceEnd_p;
# 315 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lexer.h"
 time_t fileTime;
 int length;
 int line;
 int lastline;
 int tokenavailable;
 int flags;
 const punctuation_t *punctuations;
 int * punctuationtable;
 int * nextpunctuation;
 idToken token;
 idLexer * next;
 bool hadError;

 static char baseFolder[ 256 ];

private:
 void CreatePunctuationTable( const punctuation_t *punctuations );
 int ReadWhiteSpace( void );
 int ReadEscapeCharacter( char *ch );
 int ReadString( idToken *token, int quote );
 int ReadName( idToken *token );
 int ReadNumber( idToken *token );
 int ReadPunctuation( idToken *token );
 int ReadPrimitive( idToken *token );
 int CheckString( const char *str );
 int NumLinesCrossed( void );
};

inline const char *idLexer::GetFileName( void ) {
 return idLexer::filename;
}

inline const int idLexer::GetFileOffset( void ) {

 return idLexer::script_p;
}

inline void idLexer::SetFileOffset( int offset ) {
 idLexer::script_p = offset;
}



inline const time_t idLexer::GetFileTime( void ) {
 return idLexer::fileTime;
}

inline const int idLexer::GetLineNum( void ) {
 return idLexer::line;
}

inline void idLexer::SetFlags( int flags ) {
 idLexer::flags = flags;
}

inline int idLexer::GetFlags( void ) {
 return idLexer::flags;
}
# 213 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Parser.h" 1
# 55 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Parser.h"
typedef struct define_s {
 char * name;
 int flags;
 int builtin;
 int numparms;
 idToken * parms;
 idToken * tokens;
 struct define_s *next;
 struct define_s *hashnext;
} define_t;



typedef struct indent_s {
 int type;
 int skip;
 idLexer * script;
 struct indent_s *next;
} indent_t;


class idParser {

public:

     idParser();
     idParser( int flags );
     idParser( const char *filename, int flags = 0, bool OSPath = false );
     idParser( const char *ptr, int length, const char *name, int flags = 0 );

     ~idParser();

 int LoadFile( const char *filename, bool OSPath = false );


 int LoadMemory( const char *ptr, int length, const char *name );

 void FreeSource( bool keepDefines = false );

 int IsLoaded( void ) const { return idParser::loaded; }

 int ReadToken( idToken *token );

 int ExpectTokenString( const char *string );

 int ExpectTokenType( int type, int subtype, idToken *token );

 int ExpectAnyToken( idToken *token );

 int CheckTokenString( const char *string );

 int CheckTokenType( int type, int subtype, idToken *token );

 int PeekTokenString( const char *string );

 int PeekTokenType( int type, int subtype, idToken *token );

 int SkipUntilString( const char *string );

 int SkipRestOfLine( void );

 int SkipBracedSection( bool parseFirstBrace = true );

 const char * ParseBracedSection( idStr &out, int tabs = -1 );

 const char * ParseBracedSectionExact( idStr &out, int tabs = -1 );

 const char * ParseRestOfLine( idStr &out );

 void UnreadToken( idToken *token );

 int ReadTokenOnLine( idToken *token );

 int ParseInt( void );

 bool ParseBool( void );

 float ParseFloat( void );

 int Parse1DMatrix( int x, float *m );
 int Parse2DMatrix( int y, int x, float *m );
 int Parse3DMatrix( int z, int y, int x, float *m );

 int GetLastWhiteSpace( idStr &whiteSpace ) const;

 void SetMarker( void );

 void GetStringFromMarker( idStr& out, bool clean = false );

 int AddDefine( const char *string );

 void AddBuiltinDefines( void );

 void SetIncludePath( const char *path );

 void SetPunctuations( const punctuation_t *p );

 const char * GetPunctuationFromId( int id );

 int GetPunctuationId( const char *p );

 void SetFlags( int flags );

 int GetFlags( void ) const;

 const char * GetFileName( void ) const;

 const int GetFileOffset( void ) const;

 const time_t GetFileTime( void ) const;

 const int GetLineNum( void ) const;

 void Error( const char *str, ... ) const __attribute__((format(printf,2,3)));

 void Warning( const char *str, ... ) const __attribute__((format(printf,2,3)));


 static int AddGlobalDefine( const char *string );

 static int RemoveGlobalDefine( const char *name );

 static void RemoveAllGlobalDefines( void );

 static void SetBaseFolder( const char *path );

private:
 int loaded;
 idStr filename;
 idStr includepath;
 bool OSPath;
 const punctuation_t *punctuations;
 int flags;
 idLexer * scriptstack;
 idToken * tokens;
 define_t * defines;
 define_t ** definehash;
 indent_t * indentstack;
 int skip;

 int marker_p;

 static define_t *globaldefines;

private:
 void PushIndent( int type, int skip );
 void PopIndent( int *type, int *skip );
 void PushScript( idLexer *script );
 int ReadSourceToken( idToken *token );
 int ReadLine( idToken *token );
 int UnreadSourceToken( idToken *token );
 int ReadDefineParms( define_t *define, idToken **parms, int maxparms );
 int StringizeTokens( idToken *tokens, idToken *token );
 int MergeTokens( idToken *t1, idToken *t2 );
 int ExpandBuiltinDefine( idToken *deftoken, define_t *define, idToken **firsttoken, idToken **lasttoken );
 int ExpandDefine( idToken *deftoken, define_t *define, idToken **firsttoken, idToken **lasttoken );
 int ExpandDefineIntoSource( idToken *deftoken, define_t *define );
 void AddGlobalDefinesToSource( void );
 define_t * CopyDefine( define_t *define );
 define_t * FindHashedDefine(define_t **definehash, const char *name);
 int FindDefineParm( define_t *define, const char *name );
 void AddDefineToHash(define_t *define, define_t **definehash);
 static void PrintDefine( define_t *define );
 static void FreeDefine( define_t *define );
 static define_t *FindDefine( define_t *defines, const char *name );
 static define_t *DefineFromString( const char *string);
 define_t * CopyFirstDefine( void );
 int Directive_include( void );
 int Directive_undef( void );
 int Directive_if_def( int type );
 int Directive_ifdef( void );
 int Directive_ifndef( void );
 int Directive_else( void );
 int Directive_endif( void );
 int EvaluateTokens( idToken *tokens, signed long int *intvalue, double *floatvalue, int integer );
 int Evaluate( signed long int *intvalue, double *floatvalue, int integer );
 int DollarEvaluate( signed long int *intvalue, double *floatvalue, int integer);
 int Directive_define( void );
 int Directive_elif( void );
 int Directive_if( void );
 int Directive_line( void );
 int Directive_error( void );
 int Directive_warning( void );
 int Directive_pragma( void );
 void UnreadSignToken( void );
 int Directive_eval( void );
 int Directive_evalfloat( void );
 int ReadDirective( void );
 int DollarDirective_evalint( void );
 int DollarDirective_evalfloat( void );
 int ReadDollarDirective( void );
};

inline const char *idParser::GetFileName( void ) const {
 if ( idParser::scriptstack ) {
  return idParser::scriptstack->GetFileName();
 }
 else {
  return "";
 }
}

inline const int idParser::GetFileOffset( void ) const {
 if ( idParser::scriptstack ) {
  return idParser::scriptstack->GetFileOffset();
 }
 else {
  return 0;
 }
}

inline const time_t idParser::GetFileTime( void ) const {
 if ( idParser::scriptstack ) {
  return idParser::scriptstack->GetFileTime();
 }
 else {
  return 0;
 }
}

inline const int idParser::GetLineNum( void ) const {
 if ( idParser::scriptstack ) {
  return idParser::scriptstack->GetLineNum();
 }
 else {
  return 0;
 }
}
# 214 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Base64.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Base64.h"
class idBase64 {
public:
    idBase64( void );
    idBase64( const idStr &s );
    ~idBase64( void );

 void Encode( const byte *from, int size );
 void Encode( const idStr &src );
 int DecodeLength( void ) const;
 int Decode( byte *to ) const;
 void Decode( idStr &dest ) const;
 void Decode( idFile *dest ) const;

 const char *c_str() const;

 void operator=( const idStr &s );

private:
 byte * data;
 int len;
 int alloced;

 void Init( void );
 void Release( void );
 void EnsureAlloced( int size );
};

inline idBase64::idBase64( void ) {
 Init();
}

inline idBase64::idBase64( const idStr &s ) {
 Init();
 *this = s;
}

inline idBase64::~idBase64( void ) {
 Release();
}

inline const char *idBase64::c_str( void ) const {
 return (const char *)data;
}

inline void idBase64::Init( void ) {
 len = 0;
 alloced = 0;
 data = __null;
}

inline void idBase64::Release( void ) {
 if ( data ) {
  delete[] data;
 }
 Init();
}

inline void idBase64::EnsureAlloced( int size ) {
 if ( size > alloced ) {
  Release();
 }
 data = new byte[size];
 alloced = size;
}

inline void idBase64::operator=( const idStr &s ) {
 EnsureAlloced( s.Length()+1 );
 strcpy( (char *)data, s.c_str() );
 len = s.Length();
}
# 215 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/CmdArgs.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/CmdArgs.h"
class idCmdArgs {
public:
       idCmdArgs( void ) { argc = 0; }
       idCmdArgs( const char *text, bool keepAsStrings ) { TokenizeString( text, keepAsStrings ); }

 void operator=( const idCmdArgs &args );


 int Argc( void ) const { return argc; }

 const char * Argv( int arg ) const { return ( arg >= 0 && arg < argc ) ? argv[arg] : ""; }


 const char * Args( int start = 1, int end = -1, bool escapeArgs = false ) const;




 void TokenizeString( const char *text, bool keepAsStrings );

 void AppendArg( const char *text );
 void Clear( void ) { argc = 0; }
 const char ** GetArgs( int *argc );

private:
 static const int MAX_COMMAND_ARGS = 64;
 static const int MAX_COMMAND_STRING = 2 * 1024;

 int argc;
 char * argv[MAX_COMMAND_ARGS];
 char tokenized[MAX_COMMAND_STRING];
};
# 216 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2



# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/BinSearch.h" 1
# 49 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/BinSearch.h"
template< class type >
inline int idBinSearch_Less( const type *array, const int arraySize, const type &value ) {
 int len = arraySize;
 int mid = len;
 int offset = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( array[offset+mid] < value ) {
   offset += mid;
  }
  len -= mid;
 }
 return offset;
}
# 71 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/BinSearch.h"
template< class type >
inline int idBinSearch_LessEqual( const type *array, const int arraySize, const type &value ) {
 int len = arraySize;
 int mid = len;
 int offset = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( array[offset+mid] <= value ) {
   offset += mid;
  }
  len -= mid;
 }
 return offset;
}
# 93 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/BinSearch.h"
template< class type >
inline int idBinSearch_Greater( const type *array, const int arraySize, const type &value ) {
 int len = arraySize;
 int mid = len;
 int offset = 0;
 int res = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( array[offset+mid] > value ) {
   res = 0;
  } else {
   offset += mid;
   res = 1;
  }
  len -= mid;
 }
 return offset+res;
}
# 119 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/BinSearch.h"
template< class type >
inline int idBinSearch_GreaterEqual( const type *array, const int arraySize, const type &value ) {
 int len = arraySize;
 int mid = len;
 int offset = 0;
 int res = 0;
 while( mid > 0 ) {
  mid = len >> 1;
  if ( array[offset+mid] >= value ) {
   res = 0;
  } else {
   offset += mid;
   res = 1;
  }
  len -= mid;
 }
 return offset+res;
}
# 220 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/HashIndex.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/HashIndex.h"
class idHashIndex {
public:
     idHashIndex( void );
     idHashIndex( const int initialHashSize, const int initialIndexSize );
     ~idHashIndex( void );


 size_t Allocated( void ) const;

 size_t Size( void ) const;

 idHashIndex & operator=( const idHashIndex &other );

 void Add( const int key, const int index );

 void Remove( const int key, const int index );

 int First( const int key ) const;

 int Next( const int index ) const;

 void InsertIndex( const int key, const int index );

 void RemoveIndex( const int key, const int index );

 void Clear( void );

 void Clear( const int newHashSize, const int newIndexSize );

 void Free( void );

 int GetHashSize( void ) const;

 int GetIndexSize( void ) const;

 void SetGranularity( const int newGranularity );

 void ResizeIndex( const int newIndexSize );

 int GetSpread( void ) const;

 int GenerateKey( const char *string, bool caseSensitive = true ) const;

 int GenerateKey( const idVec3 &v ) const;

 int GenerateKey( const int n1, const int n2 ) const;

private:
 int hashSize;
 int * hash;
 int indexSize;
 int * indexChain;
 int granularity;
 int hashMask;
 int lookupMask;

 static int INVALID_INDEX[1];

 void Init( const int initialHashSize, const int initialIndexSize );
 void Allocate( const int newHashSize, const int newIndexSize );
};






inline idHashIndex::idHashIndex( void ) {
 Init( 1024, 1024 );
}






inline idHashIndex::idHashIndex( const int initialHashSize, const int initialIndexSize ) {
 Init( initialHashSize, initialIndexSize );
}






inline idHashIndex::~idHashIndex( void ) {
 Free();
}






inline size_t idHashIndex::Allocated( void ) const {
 return hashSize * sizeof( int ) + indexSize * sizeof( int );
}






inline size_t idHashIndex::Size( void ) const {
 return sizeof( *this ) + Allocated();
}






inline idHashIndex &idHashIndex::operator=( const idHashIndex &other ) {
 granularity = other.granularity;
 hashMask = other.hashMask;
 lookupMask = other.lookupMask;

 if ( other.lookupMask == 0 ) {
  hashSize = other.hashSize;
  indexSize = other.indexSize;
  Free();
 }
 else {
  if ( other.hashSize != hashSize || hash == INVALID_INDEX ) {
   if ( hash != INVALID_INDEX ) {
    delete[] hash;
   }
   hashSize = other.hashSize;
   hash = new int[hashSize];
  }
  if ( other.indexSize != indexSize || indexChain == INVALID_INDEX ) {
   if ( indexChain != INVALID_INDEX ) {
    delete[] indexChain;
   }
   indexSize = other.indexSize;
   indexChain = new int[indexSize];
  }
  memcpy( hash, other.hash, hashSize * sizeof( hash[0] ) );
  memcpy( indexChain, other.indexChain, indexSize * sizeof( indexChain[0] ) );
 }

 return *this;
}






inline void idHashIndex::Add( const int key, const int index ) {
 int h;

 ((void)0);
 if ( hash == INVALID_INDEX ) {
  Allocate( hashSize, index >= indexSize ? index + 1 : indexSize );
 }
 else if ( index >= indexSize ) {
  ResizeIndex( index + 1 );
 }
 h = key & hashMask;
 indexChain[index] = hash[h];
 hash[h] = index;
}






inline void idHashIndex::Remove( const int key, const int index ) {
 int k = key & hashMask;

 if ( hash == INVALID_INDEX ) {
  return;
 }
 if ( hash[k] == index ) {
  hash[k] = indexChain[index];
 }
 else {
  for ( int i = hash[k]; i != -1; i = indexChain[i] ) {
   if ( indexChain[i] == index ) {
    indexChain[i] = indexChain[index];
    break;
   }
  }
 }
 indexChain[index] = -1;
}






inline int idHashIndex::First( const int key ) const {
 return hash[key & hashMask & lookupMask];
}






inline int idHashIndex::Next( const int index ) const {
 ((void)0);
 return indexChain[index & lookupMask];
}






inline void idHashIndex::InsertIndex( const int key, const int index ) {
 int i, max;

 if ( hash != INVALID_INDEX ) {
  max = index;
  for ( i = 0; i < hashSize; i++ ) {
   if ( hash[i] >= index ) {
    hash[i]++;
    if ( hash[i] > max ) {
     max = hash[i];
    }
   }
  }
  for ( i = 0; i < indexSize; i++ ) {
   if ( indexChain[i] >= index ) {
    indexChain[i]++;
    if ( indexChain[i] > max ) {
     max = indexChain[i];
    }
   }
  }
  if ( max >= indexSize ) {
   ResizeIndex( max + 1 );
  }
  for ( i = max; i > index; i-- ) {
   indexChain[i] = indexChain[i-1];
  }
  indexChain[index] = -1;
 }
 Add( key, index );
}






inline void idHashIndex::RemoveIndex( const int key, const int index ) {
 int i, max;

 Remove( key, index );
 if ( hash != INVALID_INDEX ) {
  max = index;
  for ( i = 0; i < hashSize; i++ ) {
   if ( hash[i] >= index ) {
    if ( hash[i] > max ) {
     max = hash[i];
    }
    hash[i]--;
   }
  }
  for ( i = 0; i < indexSize; i++ ) {
   if ( indexChain[i] >= index ) {
    if ( indexChain[i] > max ) {
     max = indexChain[i];
    }
    indexChain[i]--;
   }
  }
  for ( i = index; i < max; i++ ) {
   indexChain[i] = indexChain[i+1];
  }
  indexChain[max] = -1;
 }
}






inline void idHashIndex::Clear( void ) {

 if ( hash != INVALID_INDEX ) {
  memset( hash, 0xff, hashSize * sizeof( hash[0] ) );
 }
}






inline void idHashIndex::Clear( const int newHashSize, const int newIndexSize ) {
 Free();
 hashSize = newHashSize;
 indexSize = newIndexSize;
}






inline int idHashIndex::GetHashSize( void ) const {
 return hashSize;
}






inline int idHashIndex::GetIndexSize( void ) const {
 return indexSize;
}






inline void idHashIndex::SetGranularity( const int newGranularity ) {
 ((void)0);
 granularity = newGranularity;
}






inline int idHashIndex::GenerateKey( const char *string, bool caseSensitive ) const {
 if ( caseSensitive ) {
  return ( idStr::Hash( string ) & hashMask );
 } else {
  return ( idStr::IHash( string ) & hashMask );
 }
}






inline int idHashIndex::GenerateKey( const idVec3 &v ) const {
 return ( (((int) v[0]) + ((int) v[1]) + ((int) v[2])) & hashMask );
}






inline int idHashIndex::GenerateKey( const int n1, const int n2 ) const {
 return ( ( n1 + n2 ) & hashMask );
}
# 221 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/HashTable.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/HashTable.h"
template< class Type >
class idHashTable {
public:
     idHashTable( int newtablesize = 256 );
     idHashTable( const idHashTable<Type> &map );
     ~idHashTable( void );


 size_t Allocated( void ) const;

 size_t Size( void ) const;

 void Set( const char *key, Type &value );
 bool Get( const char *key, Type **value = __null ) const;
 bool Remove( const char *key );

 void Clear( void );
 void DeleteContents( void );



 int Num( void ) const;
 Type * GetIndex( int index ) const;

 int GetSpread( void ) const;

private:
 struct hashnode_s {
  idStr key;
  Type value;
  hashnode_s *next;

  hashnode_s( const idStr &k, Type v, hashnode_s *n ) : key( k ), value( v ), next( n ) {};
  hashnode_s( const char *k, Type v, hashnode_s *n ) : key( k ), value( v ), next( n ) {};
 };

 hashnode_s ** heads;

 int tablesize;
 int numentries;
 int tablesizemask;

 int GetHash( const char *key ) const;
};






template< class Type >
inline idHashTable<Type>::idHashTable( int newtablesize ) {

 ((void)0);

 tablesize = newtablesize;
 ((void)0);

 heads = new hashnode_s *[ tablesize ];
 memset( heads, 0, sizeof( *heads ) * tablesize );

 numentries = 0;

 tablesizemask = tablesize - 1;
}






template< class Type >
inline idHashTable<Type>::idHashTable( const idHashTable<Type> &map ) {
 int i;
 hashnode_s *node;
 hashnode_s **prev;

 ((void)0);

 tablesize = map.tablesize;
 heads = new hashnode_s *[ tablesize ];
 numentries = map.numentries;
 tablesizemask = map.tablesizemask;

 for( i = 0; i < tablesize; i++ ) {
  if ( !map.heads[ i ] ) {
   heads[ i ] = __null;
   continue;
  }

  prev = &heads[ i ];
  for( node = map.heads[ i ]; node != __null; node = node->next ) {
   *prev = new hashnode_s( node->key, node->value, __null );
   prev = &( *prev )->next;
  }
 }
}






template< class Type >
inline idHashTable<Type>::~idHashTable( void ) {
 Clear();
 delete[] heads;
}






template< class Type >
inline size_t idHashTable<Type>::Allocated( void ) const {
 return sizeof( heads ) * tablesize + sizeof( *heads ) * numentries;
}






template< class Type >
inline size_t idHashTable<Type>::Size( void ) const {
 return sizeof( idHashTable<Type> ) + sizeof( heads ) * tablesize + sizeof( *heads ) * numentries;
}






template< class Type >
inline int idHashTable<Type>::GetHash( const char *key ) const {
 return ( idStr::Hash( key ) & tablesizemask );
}






template< class Type >
inline void idHashTable<Type>::Set( const char *key, Type &value ) {
 hashnode_s *node, **nextPtr;
 int hash, s;

 hash = GetHash( key );
 for( nextPtr = &(heads[hash]), node = *nextPtr; node != __null; nextPtr = &(node->next), node = *nextPtr ) {
  s = node->key.Cmp( key );
  if ( s == 0 ) {
   node->value = value;
   return;
  }
  if ( s > 0 ) {
   break;
  }
 }

 numentries++;

 *nextPtr = new hashnode_s( key, value, heads[ hash ] );
 (*nextPtr)->next = node;
}






template< class Type >
inline bool idHashTable<Type>::Get( const char *key, Type **value ) const {
 hashnode_s *node;
 int hash, s;

 hash = GetHash( key );
 for( node = heads[ hash ]; node != __null; node = node->next ) {
  s = node->key.Cmp( key );
  if ( s == 0 ) {
   if ( value ) {
    *value = &node->value;
   }
   return true;
  }
  if ( s > 0 ) {
   break;
  }
 }

 if ( value ) {
  *value = __null;
 }

 return false;
}
# 247 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/HashTable.h"
template< class Type >
inline Type *idHashTable<Type>::GetIndex( int index ) const {
 hashnode_s *node;
 int count;
 int i;

 if ( ( index < 0 ) || ( index > numentries ) ) {
  ((void)0);
  return __null;
 }

 count = 0;
 for( i = 0; i < tablesize; i++ ) {
  for( node = heads[ i ]; node != __null; node = node->next ) {
   if ( count == index ) {
    return &node->value;
   }
   count++;
  }
 }

 return __null;
}






template< class Type >
inline bool idHashTable<Type>::Remove( const char *key ) {
 hashnode_s **head;
 hashnode_s *node;
 hashnode_s *prev;
 int hash;

 hash = GetHash( key );
 head = &heads[ hash ];
 if ( *head ) {
  for( prev = __null, node = *head; node != __null; prev = node, node = node->next ) {
   if ( node->key == key ) {
    if ( prev ) {
     prev->next = node->next;
    } else {
     *head = node->next;
    }

    delete node;
    numentries--;
    return true;
   }
  }
 }

 return false;
}






template< class Type >
inline void idHashTable<Type>::Clear( void ) {
 int i;
 hashnode_s *node;
 hashnode_s *next;

 for( i = 0; i < tablesize; i++ ) {
  next = heads[ i ];
  while( next != __null ) {
   node = next;
   next = next->next;
   delete node;
  }

  heads[ i ] = __null;
 }

 numentries = 0;
}






template< class Type >
inline void idHashTable<Type>::DeleteContents( void ) {
 int i;
 hashnode_s *node;
 hashnode_s *next;

 for( i = 0; i < tablesize; i++ ) {
  next = heads[ i ];
  while( next != __null ) {
   node = next;
   next = next->next;
   delete node->value;
   delete node;
  }

  heads[ i ] = __null;
 }

 numentries = 0;
}






template< class Type >
inline int idHashTable<Type>::Num( void ) const {
 return numentries;
}
# 222 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
class idStaticList {
public:

      idStaticList();
      idStaticList( const idStaticList<type,size> &other );
      ~idStaticList<type,size>( void );

 void Clear( void );
 int Num( void ) const;
 int Max( void ) const;
 void SetNum( int newnum );

 size_t Allocated( void ) const;
 size_t Size( void ) const;
 size_t MemoryUsed( void ) const;

 const type & operator[]( int index ) const;
 type & operator[]( int index );

 type * Ptr( void );
 const type * Ptr( void ) const;
 type * Alloc( void );
 int Append( const type & obj );
 int Append( const idStaticList<type,size> &other );
 int AddUnique( const type & obj );
 int Insert( const type & obj, int index );
 int FindIndex( const type & obj ) const;
 type * Find( type const & obj ) const;
 int FindNull( void ) const;
 int IndexOf( const type *obj ) const;
 bool RemoveIndex( int index );
 bool Remove( const type & obj );
 void Swap( idStaticList<type,size> &other );
 void DeleteContents( bool clear );

private:
 int num;
 type list[ size ];
};






template<class type,int size>
inline idStaticList<type,size>::idStaticList() {
 num = 0;
}






template<class type,int size>
inline idStaticList<type,size>::idStaticList( const idStaticList<type,size> &other ) {
 *this = other;
}






template<class type,int size>
inline idStaticList<type,size>::~idStaticList( void ) {
}
# 118 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline void idStaticList<type,size>::Clear( void ) {
 num = 0;
}
# 135 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline void idStaticList<type,size>::DeleteContents( bool clear ) {
 int i;

 for( i = 0; i < size; i++ ) {
  delete list[ i ];
  list[ i ] = __null;
 }

 if ( clear ) {
  Clear();
 } else {
  memset( list, 0, sizeof( list ) );
 }
}
# 158 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Num( void ) const {
 return num;
}
# 170 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Max( void ) const {
 return size;
}






template<class type,int size>
inline size_t idStaticList<type,size>::Allocated( void ) const {
 return size * sizeof( type );
}






template<class type,int size>
inline size_t idStaticList<type,size>::Size( void ) const {
 return sizeof( idStaticList<type,size> ) + Allocated();
}






template<class type,int size>
inline size_t idStaticList<type,size>::MemoryUsed( void ) const {
 return num * sizeof( list[ 0 ] );
}
# 212 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline void idStaticList<type,size>::SetNum( int newnum ) {
 ((void)0);
 ((void)0);
 num = newnum;
}
# 227 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline const type &idStaticList<type,size>::operator[]( int index ) const {
 ((void)0);
 ((void)0);

 return list[ index ];
}
# 243 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline type &idStaticList<type,size>::operator[]( int index ) {
 ((void)0);
 ((void)0);

 return list[ index ];
}
# 262 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline type *idStaticList<type,size>::Ptr( void ) {
 return &list[ 0 ];
}
# 278 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline const type *idStaticList<type,size>::Ptr( void ) const {
 return &list[ 0 ];
}
# 290 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline type *idStaticList<type,size>::Alloc( void ) {
 if ( num >= size ) {
  return __null;
 }

 return &list[ num++ ];
}
# 308 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Append( type const & obj ) {
 ((void)0);
 if ( num < size ) {
  list[ num ] = obj;
  num++;
  return num - 1;
 }

 return -1;
}
# 331 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Insert( type const & obj, int index ) {
 int i;

 ((void)0);
 if ( num >= size ) {
  return -1;
 }

 ((void)0);
 if ( index < 0 ) {
  index = 0;
 } else if ( index > num ) {
  index = num;
 }

 for( i = num; i > index; --i ) {
  list[i] = list[i-1];
 }

 num++;
 list[index] = obj;
 return index;
}
# 365 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::Append( const idStaticList<type,size> &other ) {
 int i;
 int n = other.Num();

 if ( num + n > size ) {
  n = size - num;
 }
 for( i = 0; i < n; i++ ) {
  list[i + num] = other.list[i];
 }
 num += n;
 return Num();
}
# 387 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::AddUnique( type const & obj ) {
 int index;

 index = FindIndex( obj );
 if ( index < 0 ) {
  index = Append( obj );
 }

 return index;
}
# 406 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::FindIndex( type const & obj ) const {
 int i;

 for( i = 0; i < num; i++ ) {
  if ( list[ i ] == obj ) {
   return i;
  }
 }


 return -1;
}
# 427 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline type *idStaticList<type,size>::Find( type const & obj ) const {
 int i;

 i = FindIndex( obj );
 if ( i >= 0 ) {
  return &list[ i ];
 }

 return __null;
}
# 449 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::FindNull( void ) const {
 int i;

 for( i = 0; i < num; i++ ) {
  if ( list[ i ] == __null ) {
   return i;
  }
 }


 return -1;
}
# 473 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline int idStaticList<type,size>::IndexOf( type const *objptr ) const {
 int index;

 index = objptr - list;

 ((void)0);
 ((void)0);

 return index;
}
# 494 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline bool idStaticList<type,size>::RemoveIndex( int index ) {
 int i;

 ((void)0);
 ((void)0);

 if ( ( index < 0 ) || ( index >= num ) ) {
  return false;
 }

 num--;
 for( i = index; i < num; i++ ) {
  list[ i ] = list[ i + 1 ];
 }

 return true;
}
# 522 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline bool idStaticList<type,size>::Remove( type const & obj ) {
 int index;

 index = FindIndex( obj );
 if ( index >= 0 ) {
  return RemoveIndex( index );
 }

 return false;
}
# 541 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StaticList.h"
template<class type,int size>
inline void idStaticList<type,size>::Swap( idStaticList<type,size> &other ) {
 idStaticList<type,size> temp = *this;
 *this = other;
 other = temp;
}
# 223 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
class idLinkList {
public:
      idLinkList();
      ~idLinkList();

 bool IsListEmpty( void ) const;
 bool InList( void ) const;
 int Num( void ) const;
 void Clear( void );

 void InsertBefore( idLinkList &node );
 void InsertAfter( idLinkList &node );
 void AddToEnd( idLinkList &node );
 void AddToFront( idLinkList &node );

 void Remove( void );

 type * Next( void ) const;
 type * Prev( void ) const;

 type * Owner( void ) const;
 void SetOwner( type *object );

 idLinkList * ListHead( void ) const;
 idLinkList * NextNode( void ) const;
 idLinkList * PrevNode( void ) const;

private:
 idLinkList * head;
 idLinkList * next;
 idLinkList * prev;
 type * owner;
};
# 84 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type>::idLinkList() {
 owner = __null;
 head = this;
 next = this;
 prev = this;
}
# 100 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type>::~idLinkList() {
 Clear();
}
# 112 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
bool idLinkList<type>::IsListEmpty( void ) const {
 return head->next == head;
}
# 124 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
bool idLinkList<type>::InList( void ) const {
 return head != this;
}
# 136 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
int idLinkList<type>::Num( void ) const {
 idLinkList<type> *node;
 int num;

 num = 0;
 for( node = head->next; node != head; node = node->next ) {
  num++;
 }

 return num;
}
# 156 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::Clear( void ) {
 if ( head == this ) {
  while( next != this ) {
   next->Remove();
  }
 } else {
  Remove();
 }
}
# 174 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::Remove( void ) {
 prev->next = next;
 next->prev = prev;

 next = this;
 prev = this;
 head = this;
}
# 192 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::InsertBefore( idLinkList &node ) {
 Remove();

 next = &node;
 prev = node.prev;
 node.prev = this;
 prev->next = this;
 head = node.head;
}
# 211 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::InsertAfter( idLinkList &node ) {
 Remove();

 prev = &node;
 next = node.next;
 node.next = this;
 next->prev = this;
 head = node.head;
}
# 229 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::AddToEnd( idLinkList &node ) {
 InsertBefore( *node.head );
}
# 241 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::AddToFront( idLinkList &node ) {
 InsertAfter( *node.head );
}
# 254 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type> *idLinkList<type>::ListHead( void ) const {
 return head;
}
# 266 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
type *idLinkList<type>::Next( void ) const {
 if ( !next || ( next == head ) ) {
  return __null;
 }
 return next->owner;
}
# 281 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
type *idLinkList<type>::Prev( void ) const {
 if ( !prev || ( prev == head ) ) {
  return __null;
 }
 return prev->owner;
}
# 296 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type> *idLinkList<type>::NextNode( void ) const {
 if ( next == head ) {
  return __null;
 }
 return next;
}
# 311 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
idLinkList<type> *idLinkList<type>::PrevNode( void ) const {
 if ( prev == head ) {
  return __null;
 }
 return prev;
}
# 326 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
type *idLinkList<type>::Owner( void ) const {
 return owner;
}
# 338 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/LinkList.h"
template< class type >
void idLinkList<type>::SetOwner( type *object ) {
 owner = object;
}
# 224 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
class idHierarchy {
public:

      idHierarchy();
      ~idHierarchy();

 void SetOwner( type *object );
 type * Owner( void ) const;
 void ParentTo( idHierarchy &node );
 void MakeSiblingAfter( idHierarchy &node );
 bool ParentedBy( const idHierarchy &node ) const;
 void RemoveFromParent( void );
 void RemoveFromHierarchy( void );

 type * GetParent( void ) const;
 type * GetChild( void ) const;
 type * GetSibling( void ) const;
 type * GetPriorSibling( void ) const;
 type * GetNext( void ) const;
 type * GetNextLeaf( void ) const;

private:
 idHierarchy * parent;
 idHierarchy * sibling;
 idHierarchy * child;
 type * owner;

 idHierarchy<type> *GetPriorSiblingNode( void ) const;
};






template< class type >
idHierarchy<type>::idHierarchy() {
 owner = __null;
 parent = __null;
 sibling = __null;
 child = __null;
}






template< class type >
idHierarchy<type>::~idHierarchy() {
 RemoveFromHierarchy();
}
# 101 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
type *idHierarchy<type>::Owner( void ) const {
 return owner;
}
# 113 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
void idHierarchy<type>::SetOwner( type *object ) {
 owner = object;
}






template< class type >
bool idHierarchy<type>::ParentedBy( const idHierarchy &node ) const {
 if ( parent == &node ) {
  return true;
 } else if ( parent ) {
  return parent->ParentedBy( node );
 }
 return false;
}
# 140 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
void idHierarchy<type>::ParentTo( idHierarchy &node ) {
 RemoveFromParent();

 parent = &node;
 sibling = node.child;
 node.child = this;
}
# 156 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
void idHierarchy<type>::MakeSiblingAfter( idHierarchy &node ) {
 RemoveFromParent();
 parent = node.parent;
 sibling = node.sibling;
 node.sibling = this;
}






template< class type >
void idHierarchy<type>::RemoveFromParent( void ) {
 idHierarchy<type> *prev;

 if ( parent ) {
  prev = GetPriorSiblingNode();
  if ( prev ) {
   prev->sibling = sibling;
  } else {
   parent->child = sibling;
  }
 }

 parent = __null;
 sibling = __null;
}
# 193 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
void idHierarchy<type>::RemoveFromHierarchy( void ) {
 idHierarchy<type> *parentNode;
 idHierarchy<type> *node;

 parentNode = parent;
 RemoveFromParent();

 if ( parentNode ) {
  while( child ) {
   node = child;
   node->RemoveFromParent();
   node->ParentTo( *parentNode );
  }
 } else {
  while( child ) {
   child->RemoveFromParent();
  }
 }
}






template< class type >
type *idHierarchy<type>::GetParent( void ) const {
 if ( parent ) {
  return parent->owner;
 }
 return __null;
}






template< class type >
type *idHierarchy<type>::GetChild( void ) const {
 if ( child ) {
  return child->owner;
 }
 return __null;
}






template< class type >
type *idHierarchy<type>::GetSibling( void ) const {
 if ( sibling ) {
  return sibling->owner;
 }
 return __null;
}
# 260 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
idHierarchy<type> *idHierarchy<type>::GetPriorSiblingNode( void ) const {
 if ( !parent || ( parent->child == this ) ) {
  return __null;
 }

 idHierarchy<type> *prev;
 idHierarchy<type> *node;

 node = parent->child;
 prev = __null;
 while( ( node != this ) && ( node != __null ) ) {
  prev = node;
  node = node->sibling;
 }

 if ( node != this ) {
  idLib::Error( "idHierarchy::GetPriorSibling: could not find node in parent's list of children" );
 }

 return prev;
}
# 290 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
type *idHierarchy<type>::GetPriorSibling( void ) const {
 idHierarchy<type> *prior;

 prior = GetPriorSiblingNode();
 if ( prior ) {
  return prior->owner;
 }

 return __null;
}
# 309 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
type *idHierarchy<type>::GetNext( void ) const {
 const idHierarchy<type> *node;

 if ( child ) {
  return child->owner;
 } else {
  node = this;
  while( node && node->sibling == __null ) {
   node = node->parent;
  }
  if ( node ) {
   return node->sibling->owner;
  } else {
   return __null;
  }
 }
}
# 335 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Hierarchy.h"
template< class type >
type *idHierarchy<type>::GetNextLeaf( void ) const {
 const idHierarchy<type> *node;

 if ( child ) {
  node = child;
  while ( node->child ) {
   node = node->child;
  }
  return node->owner;
 } else {
  node = this;
  while( node && node->sibling == __null ) {
   node = node->parent;
  }
  if ( node ) {
   node = node->sibling;
   while ( node->child ) {
    node = node->child;
   }
   return node->owner;
  } else {
   return __null;
  }
 }
}
# 225 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Queue.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Queue.h"
template< class type, int nextOffset >
class idQueueTemplate {
public:
       idQueueTemplate( void );

 void Add( type *element );
 type * Get( void );

private:
 type * first;
 type * last;
};



template< class type, int nextOffset >
idQueueTemplate<type,nextOffset>::idQueueTemplate( void ) {
 first = last = __null;
}

template< class type, int nextOffset >
void idQueueTemplate<type,nextOffset>::Add( type *element ) {
 (*((type**)(((byte*)element)+nextOffset))) = __null;
 if ( last ) {
  (*((type**)(((byte*)last)+nextOffset))) = element;
 } else {
  first = element;
 }
 last = element;
}

template< class type, int nextOffset >
type *idQueueTemplate<type,nextOffset>::Get( void ) {
 type *element;

 element = first;
 if ( element ) {
  first = (*((type**)(((byte*)first)+nextOffset)));
  if ( last == element ) {
   last = __null;
  }
  (*((type**)(((byte*)element)+nextOffset))) = __null;
 }
 return element;
}
# 226 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Stack.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/Stack.h"
template< class type, int nextOffset >
class idStackTemplate {
public:
       idStackTemplate( void );

 void Add( type *element );
 type * Get( void );

private:
 type * top;
 type * bottom;
};



template< class type, int nextOffset >
idStackTemplate<type,nextOffset>::idStackTemplate( void ) {
 top = bottom = __null;
}

template< class type, int nextOffset >
void idStackTemplate<type,nextOffset>::Add( type *element ) {
 (*(type**)(((byte*)element)+nextOffset)) = top;
 top = element;
 if ( !bottom ) {
  bottom = element;
 }
}

template< class type, int nextOffset >
type *idStackTemplate<type,nextOffset>::Get( void ) {
 type *element;

 element = top;
 if ( element ) {
  top = (*(type**)(((byte*)top)+nextOffset));
  if ( bottom == element ) {
   bottom = __null;
  }
  (*(type**)(((byte*)element)+nextOffset)) = __null;
 }
 return element;
}
# 227 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrList.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrList.h"
typedef idList<idStr> idStrList;
typedef idList<idStr*> idStrPtrList;
typedef idStr *idStrPtr;
# 51 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrList.h"
template<>
inline int idListSortCompare<idStrPtr>( const idStrPtr *a, const idStrPtr *b ) {
 return ( *a )->Icmp( **b );
}
# 64 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrList.h"
template<>
inline void idStrList::Sort( cmp_t *compare ) {
 int i;

 if ( !num ) {
  return;
 }

 idList<idStr> other;
 idList<idStrPtr> pointerList;

 pointerList.SetNum( num );
 for( i = 0; i < num; i++ ) {
  pointerList[ i ] = &( *this )[ i ];
 }

 pointerList.Sort();

 other.SetNum( num );
 other.SetGranularity( granularity );
 for( i = 0; i < other.Num(); i++ ) {
  other[ i ] = *pointerList[ i ];
 }

 this->Swap( other );
}
# 98 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrList.h"
template<>
inline void idStrList::SortSubSection( int startIndex, int endIndex, cmp_t *compare ) {
 int i, s;

 if ( !num ) {
  return;
 }
 if ( startIndex < 0 ) {
  startIndex = 0;
 }
 if ( endIndex >= num ) {
  endIndex = num - 1;
 }
 if ( startIndex >= endIndex ) {
  return;
 }

 idList<idStr> other;
 idList<idStrPtr> pointerList;

 s = endIndex - startIndex + 1;
 other.SetNum( s );
 pointerList.SetNum( s );
 for( i = 0; i < s; i++ ) {
  other[ i ] = ( *this )[ startIndex + i ];
  pointerList[ i ] = &other[ i ];
 }

 pointerList.Sort();

 for( i = 0; i < s; i++ ) {
  (*this)[ startIndex + i ] = *pointerList[ i ];
 }
}






template<>
inline size_t idStrList::Size( void ) const {
 size_t s;
 int i;

 s = sizeof( *this );
 for( i = 0; i < Num(); i++ ) {
  s += ( *this )[ i ].Size();
 }

 return s;
}
# 166 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrList.h"
template<class idStrPtr>
inline int idListSortComparePaths( const idStrPtr *a, const idStrPtr *b ) {
 return ( *a )->IcmpPath( **b );
}
# 178 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrList.h"
inline void idStrListSortPaths( idStrList &list ) {
 int i;

 if ( !list.Num() ) {
  return;
 }

 idList<idStr> other;
 idList<idStrPtr> pointerList;

 pointerList.SetNum( list.Num() );
 for( i = 0; i < list.Num(); i++ ) {
  pointerList[ i ] = &list[ i ];
 }

 pointerList.Sort( idListSortComparePaths<idStrPtr> );

 other.SetNum( list.Num() );
 other.SetGranularity( list.GetGranularity() );
 for( i = 0; i < other.Num(); i++ ) {
  other[ i ] = *pointerList[ i ];
 }

 list.Swap( other );
}
# 228 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrPool.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/StrPool.h"
class idStrPool;

class idPoolStr : public idStr {
 friend class idStrPool;

public:
      idPoolStr() { numUsers = 0; }
      ~idPoolStr() { ((void)0); }


 size_t Allocated( void ) const { return idStr::Allocated(); }

 size_t Size( void ) const { return sizeof( *this ) + Allocated(); }

 const idStrPool * GetPool( void ) const { return pool; }

private:
 idStrPool * pool;
 mutable int numUsers;
};

class idStrPool {
public:
      idStrPool() { caseSensitive = true; }

 void SetCaseSensitive( bool caseSensitive );

 int Num( void ) const { return pool.Num(); }
 size_t Allocated( void ) const;
 size_t Size( void ) const;

 const idPoolStr * operator[]( int index ) const { return pool[index]; }

 const idPoolStr * AllocString( const char *string );
 void FreeString( const idPoolStr *poolStr );
 const idPoolStr * CopyString( const idPoolStr *poolStr );
 void Clear( void );

private:
 bool caseSensitive;
 idList<idPoolStr *> pool;
 idHashIndex poolHash;
};






inline void idStrPool::SetCaseSensitive( bool caseSensitive ) {
 this->caseSensitive = caseSensitive;
}






inline const idPoolStr *idStrPool::AllocString( const char *string ) {
 int i, hash;
 idPoolStr *poolStr;

 hash = poolHash.GenerateKey( string, caseSensitive );
 if ( caseSensitive ) {
  for ( i = poolHash.First( hash ); i != -1; i = poolHash.Next( i ) ) {
   if ( pool[i]->Cmp( string ) == 0 ) {
    pool[i]->numUsers++;
    return pool[i];
   }
  }
 } else {
  for ( i = poolHash.First( hash ); i != -1; i = poolHash.Next( i ) ) {
   if ( pool[i]->Icmp( string ) == 0 ) {
    pool[i]->numUsers++;
    return pool[i];
   }
  }
 }

 poolStr = new idPoolStr;
 *static_cast<idStr *>(poolStr) = string;
 poolStr->pool = this;
 poolStr->numUsers = 1;
 poolHash.Add( hash, pool.Append( poolStr ) );
 return poolStr;
}






inline void idStrPool::FreeString( const idPoolStr *poolStr ) {
 int i, hash;

 ((void)0);
 ((void)0);

 poolStr->numUsers--;
 if ( poolStr->numUsers <= 0 ) {
  hash = poolHash.GenerateKey( poolStr->c_str(), caseSensitive );
  if ( caseSensitive ) {
   for ( i = poolHash.First( hash ); i != -1; i = poolHash.Next( i ) ) {
    if ( pool[i]->Cmp( poolStr->c_str() ) == 0 ) {
     break;
    }
   }
  } else {
   for ( i = poolHash.First( hash ); i != -1; i = poolHash.Next( i ) ) {
    if ( pool[i]->Icmp( poolStr->c_str() ) == 0 ) {
     break;
    }
   }
  }
  ((void)0);
  ((void)0);
  delete pool[i];
  pool.RemoveIndex( i );
  poolHash.RemoveIndex( hash, i );
 }
}






inline const idPoolStr *idStrPool::CopyString( const idPoolStr *poolStr ) {

 ((void)0);

 if ( poolStr->pool == this ) {

  poolStr->numUsers++;
  return poolStr;
 } else {

  return AllocString( poolStr->c_str() );
 }
}






inline void idStrPool::Clear( void ) {
 int i;

 for ( i = 0; i < pool.Num(); i++ ) {
  pool[i]->numUsers = 0;
 }
 pool.DeleteContents( true );
 poolHash.Free();
}






inline size_t idStrPool::Allocated( void ) const {
 int i;
 size_t size;

 size = pool.Allocated() + poolHash.Allocated();
 for ( i = 0; i < pool.Num(); i++ ) {
  size += pool[i]->Allocated();
 }
 return size;
}






inline size_t idStrPool::Size( void ) const {
 int i;
 size_t size;

 size = pool.Size() + poolHash.Size();
 for ( i = 0; i < pool.Num(); i++ ) {
  size += pool[i]->Size();
 }
 return size;
}
# 229 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/VectorSet.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/VectorSet.h"
template< class type, int dimension >
class idVectorSet : public idList<type> {
public:
       idVectorSet( void );
       idVectorSet( const type &mins, const type &maxs, const int boxHashSize, const int initialSize );


 size_t Allocated( void ) const { return idList<type>::Allocated() + hash.Allocated(); }

 size_t Size( void ) const { return sizeof( *this ) + Allocated(); }

 void Init( const type &mins, const type &maxs, const int boxHashSize, const int initialSize );
 void ResizeIndex( const int newSize );
 void Clear( void );

 int FindVector( const type &v, const float epsilon );

private:
 idHashIndex hash;
 type mins;
 type maxs;
 int boxHashSize;
 float boxInvSize[dimension];
 float boxHalfSize[dimension];
};

template< class type, int dimension >
inline idVectorSet<type,dimension>::idVectorSet( void ) {
 hash.Clear( idMath::IPow( boxHashSize, dimension ), 128 );
 boxHashSize = 16;
 memset( boxInvSize, 0, dimension * sizeof( boxInvSize[0] ) );
 memset( boxHalfSize, 0, dimension * sizeof( boxHalfSize[0] ) );
}

template< class type, int dimension >
inline idVectorSet<type,dimension>::idVectorSet( const type &mins, const type &maxs, const int boxHashSize, const int initialSize ) {
 Init( mins, maxs, boxHashSize, initialSize );
}

template< class type, int dimension >
inline void idVectorSet<type,dimension>::Init( const type &mins, const type &maxs, const int boxHashSize, const int initialSize ) {
 int i;
 float boxSize;

 idList<type>::AssureSize( initialSize );
 idList<type>::SetNum( 0, false );

 hash.Clear( idMath::IPow( boxHashSize, dimension ), initialSize );

 this->mins = mins;
 this->maxs = maxs;
 this->boxHashSize = boxHashSize;

 for ( i = 0; i < dimension; i++ ) {
  boxSize = ( maxs[i] - mins[i] ) / (float) boxHashSize;
  boxInvSize[i] = 1.0f / boxSize;
  boxHalfSize[i] = boxSize * 0.5f;
 }
}

template< class type, int dimension >
inline void idVectorSet<type,dimension>::ResizeIndex( const int newSize ) {
 idList<type>::Resize( newSize );
 hash.ResizeIndex( newSize );
}

template< class type, int dimension >
inline void idVectorSet<type,dimension>::Clear( void ) {
 idList<type>::Clear();
 hash.Clear();
}

template< class type, int dimension >
inline int idVectorSet<type,dimension>::FindVector( const type &v, const float epsilon ) {
 int i, j, k, hashKey, partialHashKey[dimension];

 for ( i = 0; i < dimension; i++ ) {
  ((void)0);
  partialHashKey[i] = (int) ( ( v[i] - mins[i] - boxHalfSize[i] ) * boxInvSize[i] );
 }

 for ( i = 0; i < ( 1 << dimension ); i++ ) {

  hashKey = 0;
  for ( j = 0; j < dimension; j++ ) {
   hashKey *= boxHashSize;
   hashKey += partialHashKey[j] + ( ( i >> j ) & 1 );
  }

  for ( j = hash.First( hashKey ); j >= 0; j = hash.Next( j ) ) {
   const type &lv = (*this)[j];
   for ( k = 0; k < dimension; k++ ) {
    if ( idMath::Fabs( lv[k] - v[k] ) > epsilon ) {
     break;
    }
   }
   if ( k >= dimension ) {
    return j;
   }
  }
 }

 hashKey = 0;
 for ( i = 0; i < dimension; i++ ) {
  hashKey *= boxHashSize;
  hashKey += (int) ( ( v[i] - mins[i] ) * boxInvSize[i] );
 }

 hash.Add( hashKey, idList<type>::Num() );
 this->Append( v );
 return idList<type>::Num()-1;
}
# 166 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/VectorSet.h"
template< class type, int dimension >
class idVectorSubset {
public:
       idVectorSubset( void );
       idVectorSubset( const type &mins, const type &maxs, const int boxHashSize, const int initialSize );


 size_t Allocated( void ) const { return idList<type>::Allocated() + hash.Allocated(); }

 size_t Size( void ) const { return sizeof( *this ) + Allocated(); }

 void Init( const type &mins, const type &maxs, const int boxHashSize, const int initialSize );
 void Clear( void );


 int FindVector( const type *vectorList, const int vectorNum, const float epsilon );

private:
 idHashIndex hash;
 type mins;
 type maxs;
 int boxHashSize;
 float boxInvSize[dimension];
 float boxHalfSize[dimension];
};

template< class type, int dimension >
inline idVectorSubset<type,dimension>::idVectorSubset( void ) {
 hash.Clear( idMath::IPow( boxHashSize, dimension ), 128 );
 boxHashSize = 16;
 memset( boxInvSize, 0, dimension * sizeof( boxInvSize[0] ) );
 memset( boxHalfSize, 0, dimension * sizeof( boxHalfSize[0] ) );
}

template< class type, int dimension >
inline idVectorSubset<type,dimension>::idVectorSubset( const type &mins, const type &maxs, const int boxHashSize, const int initialSize ) {
 Init( mins, maxs, boxHashSize, initialSize );
}

template< class type, int dimension >
inline void idVectorSubset<type,dimension>::Init( const type &mins, const type &maxs, const int boxHashSize, const int initialSize ) {
 int i;
 float boxSize;

 hash.Clear( idMath::IPow( boxHashSize, dimension ), initialSize );

 this->mins = mins;
 this->maxs = maxs;
 this->boxHashSize = boxHashSize;

 for ( i = 0; i < dimension; i++ ) {
  boxSize = ( maxs[i] - mins[i] ) / (float) boxHashSize;
  boxInvSize[i] = 1.0f / boxSize;
  boxHalfSize[i] = boxSize * 0.5f;
 }
}

template< class type, int dimension >
inline void idVectorSubset<type,dimension>::Clear( void ) {
 idList<type>::Clear();
 hash.Clear();
}

template< class type, int dimension >
inline int idVectorSubset<type,dimension>::FindVector( const type *vectorList, const int vectorNum, const float epsilon ) {
 int i, j, k, hashKey, partialHashKey[dimension];
 const type &v = vectorList[vectorNum];

 for ( i = 0; i < dimension; i++ ) {
  ((void)0);
  partialHashKey[i] = (int) ( ( v[i] - mins[i] - boxHalfSize[i] ) * boxInvSize[i] );
 }

 for ( i = 0; i < ( 1 << dimension ); i++ ) {

  hashKey = 0;
  for ( j = 0; j < dimension; j++ ) {
   hashKey *= boxHashSize;
   hashKey += partialHashKey[j] + ( ( i >> j ) & 1 );
  }

  for ( j = hash.First( hashKey ); j >= 0; j = hash.Next( j ) ) {
   const type &lv = vectorList[j];
   for ( k = 0; k < dimension; k++ ) {
    if ( idMath::Fabs( lv[k] - v[k] ) > epsilon ) {
     break;
    }
   }
   if ( k >= dimension ) {
    return j;
   }
  }
 }

 hashKey = 0;
 for ( i = 0; i < dimension; i++ ) {
  hashKey *= boxHashSize;
  hashKey += (int) ( ( v[i] - mins[i] ) * boxInvSize[i] );
 }

 hash.Add( hashKey, vectorNum );
 return vectorNum;
}
# 230 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/PlaneSet.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/containers/PlaneSet.h"
class idPlaneSet : public idList<idPlane> {
public:

 void Clear( void ) { idList<idPlane>::Clear(); hash.Free(); }

 int FindPlane( const idPlane &plane, const float normalEps, const float distEps );

private:
 idHashIndex hash;
};

inline int idPlaneSet::FindPlane( const idPlane &plane, const float normalEps, const float distEps ) {
 int i, border, hashKey;

 ((void)0);

 hashKey = (int)( idMath::Fabs( plane.Dist() ) * 0.125f );
 for ( border = -1; border <= 1; border++ ) {
  for ( i = hash.First( hashKey + border ); i >= 0; i = hash.Next( i ) ) {
   if ( (*this)[i].Compare( plane, normalEps, distEps ) ) {
    return i;
   }
  }
 }

 if ( plane.Type() >= 3 && plane.Type() < 6 ) {
  Append( -plane );
  hash.Add( hashKey, Num()-1 );
  Append( plane );
  hash.Add( hashKey, Num()-1 );
  return ( Num() - 1 );
 }
 else {
  Append( plane );
  hash.Add( hashKey, Num()-1 );
  Append( -plane );
  hash.Add( hashKey, Num()-1 );
  return ( Num() - 2 );
 }
}
# 231 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/hashing/CRC32.h" 1
# 13 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/hashing/CRC32.h"
void CRC32_InitChecksum( unsigned long &crcvalue );
void CRC32_UpdateChecksum( unsigned long &crcvalue, const void *data, int length );
void CRC32_FinishChecksum( unsigned long &crcvalue );
unsigned long CRC32_BlockChecksum( const void *data, int length );
# 234 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/hashing/MD4.h" 1
# 13 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/hashing/MD4.h"
unsigned long MD4_BlockChecksum( const void *data, int length );
# 235 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/hashing/MD5.h" 1
# 13 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/hashing/MD5.h"
unsigned long MD5_BlockChecksum( const void *data, int length );
# 236 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Dict.h" 1
# 48 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Dict.h"
class idKeyValue {
 friend class idDict;

public:
 const idStr & GetKey( void ) const { return *key; }
 const idStr & GetValue( void ) const { return *value; }

 size_t Allocated( void ) const { return key->Allocated() + value->Allocated(); }
 size_t Size( void ) const { return sizeof( *this ) + key->Size() + value->Size(); }

 bool operator==( const idKeyValue &kv ) const { return ( key == kv.key && value == kv.value ); }

private:
 const idPoolStr * key;
 const idPoolStr * value;
};

class idDict {
public:
      idDict( void );
      idDict( const idDict &other );
      ~idDict( void );


 void SetGranularity( int granularity );

 void SetHashSize( int hashSize );

 idDict & operator=( const idDict &other );

 void Copy( const idDict &other );

 void TransferKeyValues( idDict &other );

 bool Parse( idParser &parser );

 void SetDefaults( const idDict *dict );

 void Clear( void );

 void Print() const;

 size_t Allocated( void ) const;
 size_t Size( void ) const { return sizeof( *this ) + Allocated(); }

 void Set( const char *key, const char *value );
 void SetFloat( const char *key, float val );
 void SetInt( const char *key, int val );
 void SetBool( const char *key, bool val );
 void SetVector( const char *key, const idVec3 &val );
 void SetVec2( const char *key, const idVec2 &val );
 void SetVec4( const char *key, const idVec4 &val );
 void SetAngles( const char *key, const idAngles &val );
 void SetMatrix( const char *key, const idMat3 &val );


 const char * GetString( const char *key, const char *defaultString = "" ) const;
 float GetFloat( const char *key, const char *defaultString = "0" ) const;
 int GetInt( const char *key, const char *defaultString = "0" ) const;
 bool GetBool( const char *key, const char *defaultString = "0" ) const;
 idVec3 GetVector( const char *key, const char *defaultString = __null ) const;
 idVec2 GetVec2( const char *key, const char *defaultString = __null ) const;
 idVec4 GetVec4( const char *key, const char *defaultString = __null ) const;
 idAngles GetAngles( const char *key, const char *defaultString = __null ) const;
 idMat3 GetMatrix( const char *key, const char *defaultString = __null ) const;

 bool GetString( const char *key, const char *defaultString, const char **out ) const;
 bool GetString( const char *key, const char *defaultString, idStr &out ) const;
 bool GetFloat( const char *key, const char *defaultString, float &out ) const;
 bool GetInt( const char *key, const char *defaultString, int &out ) const;
 bool GetBool( const char *key, const char *defaultString, bool &out ) const;
 bool GetVector( const char *key, const char *defaultString, idVec3 &out ) const;
 bool GetVec2( const char *key, const char *defaultString, idVec2 &out ) const;
 bool GetVec4( const char *key, const char *defaultString, idVec4 &out ) const;
 bool GetAngles( const char *key, const char *defaultString, idAngles &out ) const;
 bool GetMatrix( const char *key, const char *defaultString, idMat3 &out ) const;

 int GetNumKeyVals( void ) const;
 const idKeyValue * GetKeyVal( int index ) const;


 const idKeyValue * FindKey( const char *key ) const;


 int FindKeyIndex( const char *key ) const;

 void Delete( const char *key );


 const idKeyValue * MatchPrefix( const char *prefix, const idKeyValue *lastMatch = __null ) const;

 const char * RandomPrefix( const char *prefix, idRandom &random ) const;

 void WriteToFileHandle( idFile *f ) const;
 void ReadFromFileHandle( idFile *f );


 int Checksum( void ) const;

 static void Init( void );
 static void Shutdown( void );

 static void ShowMemoryUsage_f( const idCmdArgs &args );
 static void ListKeys_f( const idCmdArgs &args );
 static void ListValues_f( const idCmdArgs &args );

private:
 idList<idKeyValue> args;
 idHashIndex argHash;

 static idStrPool globalKeys;
 static idStrPool globalValues;
};


inline idDict::idDict( void ) {
 args.SetGranularity( 16 );
 argHash.SetGranularity( 16 );
 argHash.Clear( 128, 16 );
}

inline idDict::idDict( const idDict &other ) {
 *this = other;
}

inline idDict::~idDict( void ) {
 Clear();
}

inline void idDict::SetGranularity( int granularity ) {
 args.SetGranularity( granularity );
 argHash.SetGranularity( granularity );
}

inline void idDict::SetHashSize( int hashSize ) {
 if ( args.Num() == 0 ) {
  argHash.Clear( hashSize, 16 );
 }
}

inline void idDict::SetFloat( const char *key, float val ) {
 Set( key, va( "%f", val ) );
}

inline void idDict::SetInt( const char *key, int val ) {
 Set( key, va( "%i", val ) );
}

inline void idDict::SetBool( const char *key, bool val ) {
 Set( key, va( "%i", val ) );
}

inline void idDict::SetVector( const char *key, const idVec3 &val ) {
 Set( key, val.ToString() );
}

inline void idDict::SetVec4( const char *key, const idVec4 &val ) {
 Set( key, val.ToString() );
}

inline void idDict::SetVec2( const char *key, const idVec2 &val ) {
 Set( key, val.ToString() );
}

inline void idDict::SetAngles( const char *key, const idAngles &val ) {
 Set( key, val.ToString() );
}

inline void idDict::SetMatrix( const char *key, const idMat3 &val ) {
 Set( key, val.ToString() );
}

inline bool idDict::GetString( const char *key, const char *defaultString, const char **out ) const {
 const idKeyValue *kv = FindKey( key );
 if ( kv ) {
  *out = kv->GetValue();
  return true;
 }
 *out = defaultString;
 return false;
}

inline bool idDict::GetString( const char *key, const char *defaultString, idStr &out ) const {
 const idKeyValue *kv = FindKey( key );
 if ( kv ) {
  out = kv->GetValue();
  return true;
 }
 out = defaultString;
 return false;
}

inline const char *idDict::GetString( const char *key, const char *defaultString ) const {
 const idKeyValue *kv = FindKey( key );
 if ( kv ) {
  return kv->GetValue();
 }
 return defaultString;
}

inline float idDict::GetFloat( const char *key, const char *defaultString ) const {
 return atof( GetString( key, defaultString ) );
}

inline int idDict::GetInt( const char *key, const char *defaultString ) const {
 return atoi( GetString( key, defaultString ) );
}

inline bool idDict::GetBool( const char *key, const char *defaultString ) const {
 return ( atoi( GetString( key, defaultString ) ) != 0 );
}

inline idVec3 idDict::GetVector( const char *key, const char *defaultString ) const {
 idVec3 out;
 GetVector( key, defaultString, out );
 return out;
}

inline idVec2 idDict::GetVec2( const char *key, const char *defaultString ) const {
 idVec2 out;
 GetVec2( key, defaultString, out );
 return out;
}

inline idVec4 idDict::GetVec4( const char *key, const char *defaultString ) const {
 idVec4 out;
 GetVec4( key, defaultString, out );
 return out;
}

inline idAngles idDict::GetAngles( const char *key, const char *defaultString ) const {
 idAngles out;
 GetAngles( key, defaultString, out );
 return out;
}

inline idMat3 idDict::GetMatrix( const char *key, const char *defaultString ) const {
 idMat3 out;
 GetMatrix( key, defaultString, out );
 return out;
}

inline int idDict::GetNumKeyVals( void ) const {
 return args.Num();
}

inline const idKeyValue *idDict::GetKeyVal( int index ) const {
 if ( index >= 0 && index < args.Num() ) {
  return &args[ index ];
 }
 return __null;
}
# 239 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/LangDict.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/LangDict.h"
class idLangKeyValue {
public:
 idStr key;
 idStr value;
};

class idLangDict {
public:
       idLangDict( void );
       ~idLangDict( void );

 void Clear( void );
 bool Load( const char *fileName, bool clear = true );
 void Save( const char *fileName );

 const char * AddString( const char *str );
 const char * GetString( const char *str ) const;


 void AddKeyVal( const char *key, const char *val );

 int GetNumKeyVals( void ) const;
 const idLangKeyValue * GetKeyVal( int i ) const;

 void SetBaseID(int id) { baseID = id; };

private:
 idList<idLangKeyValue> args;
 idHashIndex hash;

 bool ExcludeString( const char *str ) const;
 int GetNextId( void ) const;
 int GetHashKey( const char *str ) const;

 int baseID;
};
# 240 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/BitMsg.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/BitMsg.h"
class idBitMsg {
public:
     idBitMsg();
     ~idBitMsg() {}

 void Init( byte *data, int length );
 void Init( const byte *data, int length );
 byte * GetData( void );
 const byte * GetData( void ) const;
 int GetMaxSize( void ) const;
 void SetAllowOverflow( bool set );
 bool IsOverflowed( void ) const;

 int GetSize( void ) const;
 void SetSize( int size );
 int GetWriteBit( void ) const;
 void SetWriteBit( int bit );
 int GetNumBitsWritten( void ) const;
 int GetRemainingWriteBits( void ) const;
 void SaveWriteState( int &s, int &b ) const;
 void RestoreWriteState( int s, int b );

 int GetReadCount( void ) const;
 void SetReadCount( int bytes );
 int GetReadBit( void ) const;
 void SetReadBit( int bit );
 int GetNumBitsRead( void ) const;
 int GetRemainingReadBits( void ) const;
 void SaveReadState( int &c, int &b ) const;
 void RestoreReadState( int c, int b );

 void BeginWriting( void );
 int GetRemainingSpace( void ) const;
 void WriteByteAlign( void );
 void WriteBits( int value, int numBits );
 void WriteChar( int c );
 void WriteByte( int c );
 void WriteShort( int c );
 void WriteUShort( int c );
 void WriteLong( int c );
 void WriteFloat( float f );
 void WriteFloat( float f, int exponentBits, int mantissaBits );
 void WriteAngle8( float f );
 void WriteAngle16( float f );
 void WriteDir( const idVec3 &dir, int numBits );
 void WriteString( const char *s, int maxLength = -1, bool make7Bit = true );
 void WriteData( const void *data, int length );
 void WriteNetadr( const netadr_t adr );

 void WriteDeltaChar( int oldValue, int newValue );
 void WriteDeltaByte( int oldValue, int newValue );
 void WriteDeltaShort( int oldValue, int newValue );
 void WriteDeltaLong( int oldValue, int newValue );
 void WriteDeltaFloat( float oldValue, float newValue );
 void WriteDeltaFloat( float oldValue, float newValue, int exponentBits, int mantissaBits );
 void WriteDeltaByteCounter( int oldValue, int newValue );
 void WriteDeltaShortCounter( int oldValue, int newValue );
 void WriteDeltaLongCounter( int oldValue, int newValue );
 bool WriteDeltaDict( const idDict &dict, const idDict *base );

 void BeginReading( void ) const;
 int GetRemaingData( void ) const;
 void ReadByteAlign( void ) const;
 int ReadBits( int numBits ) const;
 int ReadChar( void ) const;
 int ReadByte( void ) const;
 int ReadShort( void ) const;
 int ReadUShort( void ) const;
 int ReadLong( void ) const;
 float ReadFloat( void ) const;
 float ReadFloat( int exponentBits, int mantissaBits ) const;
 float ReadAngle8( void ) const;
 float ReadAngle16( void ) const;
 idVec3 ReadDir( int numBits ) const;
 int ReadString( char *buffer, int bufferSize ) const;
 int ReadData( void *data, int length ) const;
 void ReadNetadr( netadr_t *adr ) const;

 int ReadDeltaChar( int oldValue ) const;
 int ReadDeltaByte( int oldValue ) const;
 int ReadDeltaShort( int oldValue ) const;
 int ReadDeltaLong( int oldValue ) const;
 float ReadDeltaFloat( float oldValue ) const;
 float ReadDeltaFloat( float oldValue, int exponentBits, int mantissaBits ) const;
 int ReadDeltaByteCounter( int oldValue ) const;
 int ReadDeltaShortCounter( int oldValue ) const;
 int ReadDeltaLongCounter( int oldValue ) const;
 bool ReadDeltaDict( idDict &dict, const idDict *base ) const;

 static int DirToBits( const idVec3 &dir, int numBits );
 static idVec3 BitsToDir( int bits, int numBits );

private:
 byte * writeData;
 const byte * readData;
 int maxSize;
 int curSize;
 int writeBit;
 mutable int readCount;
 mutable int readBit;
 bool allowOverflow;
 bool overflowed;

private:
 bool CheckOverflow( int numBits );
 byte * GetByteSpace( int length );
 void WriteDelta( int oldValue, int newValue, int numBits );
 int ReadDelta( int oldValue, int numBits ) const;
};


inline void idBitMsg::Init( byte *data, int length ) {
 writeData = data;
 readData = data;
 maxSize = length;
}

inline void idBitMsg::Init( const byte *data, int length ) {
 writeData = __null;
 readData = data;
 maxSize = length;
}

inline byte *idBitMsg::GetData( void ) {
 return writeData;
}

inline const byte *idBitMsg::GetData( void ) const {
 return readData;
}

inline int idBitMsg::GetMaxSize( void ) const {
 return maxSize;
}

inline void idBitMsg::SetAllowOverflow( bool set ) {
 allowOverflow = set;
}

inline bool idBitMsg::IsOverflowed( void ) const {
 return overflowed;
}

inline int idBitMsg::GetSize( void ) const {
 return curSize;
}

inline void idBitMsg::SetSize( int size ) {
 if ( size > maxSize ) {
  curSize = maxSize;
 } else {
  curSize = size;
 }
}

inline int idBitMsg::GetWriteBit( void ) const {
 return writeBit;
}

inline void idBitMsg::SetWriteBit( int bit ) {
 writeBit = bit & 7;
 if ( writeBit ) {
  writeData[curSize - 1] &= ( 1 << writeBit ) - 1;
 }
}

inline int idBitMsg::GetNumBitsWritten( void ) const {
 return ( ( curSize << 3 ) - ( ( 8 - writeBit ) & 7 ) );
}

inline int idBitMsg::GetRemainingWriteBits( void ) const {
 return ( maxSize << 3 ) - GetNumBitsWritten();
}

inline void idBitMsg::SaveWriteState( int &s, int &b ) const {
 s = curSize;
 b = writeBit;
}

inline void idBitMsg::RestoreWriteState( int s, int b ) {
 curSize = s;
 writeBit = b & 7;
 if ( writeBit ) {
  writeData[curSize - 1] &= ( 1 << writeBit ) - 1;
 }
}

inline int idBitMsg::GetReadCount( void ) const {
 return readCount;
}

inline void idBitMsg::SetReadCount( int bytes ) {
 readCount = bytes;
}

inline int idBitMsg::GetReadBit( void ) const {
 return readBit;
}

inline void idBitMsg::SetReadBit( int bit ) {
 readBit = bit & 7;
}

inline int idBitMsg::GetNumBitsRead( void ) const {
 return ( ( readCount << 3 ) - ( ( 8 - readBit ) & 7 ) );
}

inline int idBitMsg::GetRemainingReadBits( void ) const {
 return ( curSize << 3 ) - GetNumBitsRead();
}

inline void idBitMsg::SaveReadState( int &c, int &b ) const {
 c = readCount;
 b = readBit;
}

inline void idBitMsg::RestoreReadState( int c, int b ) {
 readCount = c;
 readBit = b & 7;
}

inline void idBitMsg::BeginWriting( void ) {
 curSize = 0;
 overflowed = false;
 writeBit = 0;
}

inline int idBitMsg::GetRemainingSpace( void ) const {
 return maxSize - curSize;
}

inline void idBitMsg::WriteByteAlign( void ) {
 writeBit = 0;
}

inline void idBitMsg::WriteChar( int c ) {
 WriteBits( c, -8 );
}

inline void idBitMsg::WriteByte( int c ) {
 WriteBits( c, 8 );
}

inline void idBitMsg::WriteShort( int c ) {
 WriteBits( c, -16 );
}

inline void idBitMsg::WriteUShort( int c ) {
 WriteBits( c, 16 );
}

inline void idBitMsg::WriteLong( int c ) {
 WriteBits( c, 32 );
}

inline void idBitMsg::WriteFloat( float f ) {
 WriteBits( *reinterpret_cast<int *>(&f), 32 );
}

inline void idBitMsg::WriteFloat( float f, int exponentBits, int mantissaBits ) {
 int bits = idMath::FloatToBits( f, exponentBits, mantissaBits );
 WriteBits( bits, 1 + exponentBits + mantissaBits );
}

inline void idBitMsg::WriteAngle8( float f ) {
 WriteByte( ( idMath::FtoiFast( (f) * 256.0f / 360.0f ) & 255 ) );
}

inline void idBitMsg::WriteAngle16( float f ) {
 WriteShort( ( idMath::FtoiFast( (f) * 65536.0f / 360.0f ) & 65535 ) );
}

inline void idBitMsg::WriteDir( const idVec3 &dir, int numBits ) {
 WriteBits( DirToBits( dir, numBits ), numBits );
}

inline void idBitMsg::WriteDeltaChar( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, -8 );
}

inline void idBitMsg::WriteDeltaByte( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, 8 );
}

inline void idBitMsg::WriteDeltaShort( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, -16 );
}

inline void idBitMsg::WriteDeltaLong( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, 32 );
}

inline void idBitMsg::WriteDeltaFloat( float oldValue, float newValue ) {
 WriteDelta( *reinterpret_cast<int *>(&oldValue), *reinterpret_cast<int *>(&newValue), 32 );
}

inline void idBitMsg::WriteDeltaFloat( float oldValue, float newValue, int exponentBits, int mantissaBits ) {
 int oldBits = idMath::FloatToBits( oldValue, exponentBits, mantissaBits );
 int newBits = idMath::FloatToBits( newValue, exponentBits, mantissaBits );
 WriteDelta( oldBits, newBits, 1 + exponentBits + mantissaBits );
}

inline void idBitMsg::BeginReading( void ) const {
 readCount = 0;
 readBit = 0;
}

inline int idBitMsg::GetRemaingData( void ) const {
 return curSize - readCount;
}

inline void idBitMsg::ReadByteAlign( void ) const {
 readBit = 0;
}

inline int idBitMsg::ReadChar( void ) const {
 return (signed char)ReadBits( -8 );
}

inline int idBitMsg::ReadByte( void ) const {
 return (unsigned char)ReadBits( 8 );
}

inline int idBitMsg::ReadShort( void ) const {
 return (short)ReadBits( -16 );
}

inline int idBitMsg::ReadUShort( void ) const {
 return (unsigned short)ReadBits( 16 );
}

inline int idBitMsg::ReadLong( void ) const {
 return ReadBits( 32 );
}

inline float idBitMsg::ReadFloat( void ) const {
 float value;
 *reinterpret_cast<int *>(&value) = ReadBits( 32 );
 return value;
}

inline float idBitMsg::ReadFloat( int exponentBits, int mantissaBits ) const {
 int bits = ReadBits( 1 + exponentBits + mantissaBits );
 return idMath::BitsToFloat( bits, exponentBits, mantissaBits );
}

inline float idBitMsg::ReadAngle8( void ) const {
 return ( (ReadByte()) * ( 360.0f / 256.0f ) );
}

inline float idBitMsg::ReadAngle16( void ) const {
 return ( (ReadShort()) * ( 360.0f / 65536.0f ) );
}

inline idVec3 idBitMsg::ReadDir( int numBits ) const {
 return BitsToDir( ReadBits( numBits ), numBits );
}

inline int idBitMsg::ReadDeltaChar( int oldValue ) const {
 return (signed char)ReadDelta( oldValue, -8 );
}

inline int idBitMsg::ReadDeltaByte( int oldValue ) const {
 return (unsigned char)ReadDelta( oldValue, 8 );
}

inline int idBitMsg::ReadDeltaShort( int oldValue ) const {
 return (short)ReadDelta( oldValue, -16 );
}

inline int idBitMsg::ReadDeltaLong( int oldValue ) const {
 return ReadDelta( oldValue, 32 );
}

inline float idBitMsg::ReadDeltaFloat( float oldValue ) const {
 float value;
 *reinterpret_cast<int *>(&value) = ReadDelta( *reinterpret_cast<int *>(&oldValue), 32 );
 return value;
}

inline float idBitMsg::ReadDeltaFloat( float oldValue, int exponentBits, int mantissaBits ) const {
 int oldBits = idMath::FloatToBits( oldValue, exponentBits, mantissaBits );
 int newBits = ReadDelta( oldBits, 1 + exponentBits + mantissaBits );
 return idMath::BitsToFloat( newBits, exponentBits, mantissaBits );
}
# 439 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/BitMsg.h"
class idBitMsgDelta {
public:
     idBitMsgDelta();
     ~idBitMsgDelta() {}

 void Init( const idBitMsg *base, idBitMsg *newBase, idBitMsg *delta );
 void Init( const idBitMsg *base, idBitMsg *newBase, const idBitMsg *delta );
 bool HasChanged( void ) const;

 void WriteBits( int value, int numBits );
 void WriteChar( int c );
 void WriteByte( int c );
 void WriteShort( int c );
 void WriteUShort( int c );
 void WriteLong( int c );
 void WriteFloat( float f );
 void WriteFloat( float f, int exponentBits, int mantissaBits );
 void WriteAngle8( float f );
 void WriteAngle16( float f );
 void WriteDir( const idVec3 &dir, int numBits );
 void WriteString( const char *s, int maxLength = -1 );
 void WriteData( const void *data, int length );
 void WriteDict( const idDict &dict );

 void WriteDeltaChar( int oldValue, int newValue );
 void WriteDeltaByte( int oldValue, int newValue );
 void WriteDeltaShort( int oldValue, int newValue );
 void WriteDeltaLong( int oldValue, int newValue );
 void WriteDeltaFloat( float oldValue, float newValue );
 void WriteDeltaFloat( float oldValue, float newValue, int exponentBits, int mantissaBits );
 void WriteDeltaByteCounter( int oldValue, int newValue );
 void WriteDeltaShortCounter( int oldValue, int newValue );
 void WriteDeltaLongCounter( int oldValue, int newValue );

 int ReadBits( int numBits ) const;
 int ReadChar( void ) const;
 int ReadByte( void ) const;
 int ReadShort( void ) const;
 int ReadUShort( void ) const;
 int ReadLong( void ) const;
 float ReadFloat( void ) const;
 float ReadFloat( int exponentBits, int mantissaBits ) const;
 float ReadAngle8( void ) const;
 float ReadAngle16( void ) const;
 idVec3 ReadDir( int numBits ) const;
 void ReadString( char *buffer, int bufferSize ) const;
 void ReadData( void *data, int length ) const;
 void ReadDict( idDict &dict );

 int ReadDeltaChar( int oldValue ) const;
 int ReadDeltaByte( int oldValue ) const;
 int ReadDeltaShort( int oldValue ) const;
 int ReadDeltaLong( int oldValue ) const;
 float ReadDeltaFloat( float oldValue ) const;
 float ReadDeltaFloat( float oldValue, int exponentBits, int mantissaBits ) const;
 int ReadDeltaByteCounter( int oldValue ) const;
 int ReadDeltaShortCounter( int oldValue ) const;
 int ReadDeltaLongCounter( int oldValue ) const;

private:
 const idBitMsg *base;
 idBitMsg * newBase;
 idBitMsg * writeDelta;
 const idBitMsg *readDelta;
 mutable bool changed;

private:
 void WriteDelta( int oldValue, int newValue, int numBits );
 int ReadDelta( int oldValue, int numBits ) const;
};

inline idBitMsgDelta::idBitMsgDelta() {
 base = __null;
 newBase = __null;
 writeDelta = __null;
 readDelta = __null;
 changed = false;
}

inline void idBitMsgDelta::Init( const idBitMsg *base, idBitMsg *newBase, idBitMsg *delta ) {
 this->base = base;
 this->newBase = newBase;
 this->writeDelta = delta;
 this->readDelta = delta;
 this->changed = false;
}

inline void idBitMsgDelta::Init( const idBitMsg *base, idBitMsg *newBase, const idBitMsg *delta ) {
 this->base = base;
 this->newBase = newBase;
 this->writeDelta = __null;
 this->readDelta = delta;
 this->changed = false;
}

inline bool idBitMsgDelta::HasChanged( void ) const {
 return changed;
}

inline void idBitMsgDelta::WriteChar( int c ) {
 WriteBits( c, -8 );
}

inline void idBitMsgDelta::WriteByte( int c ) {
 WriteBits( c, 8 );
}

inline void idBitMsgDelta::WriteShort( int c ) {
 WriteBits( c, -16 );
}

inline void idBitMsgDelta::WriteUShort( int c ) {
 WriteBits( c, 16 );
}

inline void idBitMsgDelta::WriteLong( int c ) {
 WriteBits( c, 32 );
}

inline void idBitMsgDelta::WriteFloat( float f ) {
 WriteBits( *reinterpret_cast<int *>(&f), 32 );
}

inline void idBitMsgDelta::WriteFloat( float f, int exponentBits, int mantissaBits ) {
 int bits = idMath::FloatToBits( f, exponentBits, mantissaBits );
 WriteBits( bits, 1 + exponentBits + mantissaBits );
}

inline void idBitMsgDelta::WriteAngle8( float f ) {
 WriteBits( ( idMath::FtoiFast( (f) * 256.0f / 360.0f ) & 255 ), 8 );
}

inline void idBitMsgDelta::WriteAngle16( float f ) {
 WriteBits( ( idMath::FtoiFast( (f) * 65536.0f / 360.0f ) & 65535 ), 16 );
}

inline void idBitMsgDelta::WriteDir( const idVec3 &dir, int numBits ) {
 WriteBits( idBitMsg::DirToBits( dir, numBits ), numBits );
}

inline void idBitMsgDelta::WriteDeltaChar( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, -8 );
}

inline void idBitMsgDelta::WriteDeltaByte( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, 8 );
}

inline void idBitMsgDelta::WriteDeltaShort( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, -16 );
}

inline void idBitMsgDelta::WriteDeltaLong( int oldValue, int newValue ) {
 WriteDelta( oldValue, newValue, 32 );
}

inline void idBitMsgDelta::WriteDeltaFloat( float oldValue, float newValue ) {
 WriteDelta( *reinterpret_cast<int *>(&oldValue), *reinterpret_cast<int *>(&newValue), 32 );
}

inline void idBitMsgDelta::WriteDeltaFloat( float oldValue, float newValue, int exponentBits, int mantissaBits ) {
 int oldBits = idMath::FloatToBits( oldValue, exponentBits, mantissaBits );
 int newBits = idMath::FloatToBits( newValue, exponentBits, mantissaBits );
 WriteDelta( oldBits, newBits, 1 + exponentBits + mantissaBits );
}

inline int idBitMsgDelta::ReadChar( void ) const {
 return (signed char)ReadBits( -8 );
}

inline int idBitMsgDelta::ReadByte( void ) const {
 return (unsigned char)ReadBits( 8 );
}

inline int idBitMsgDelta::ReadShort( void ) const {
 return (short)ReadBits( -16 );
}

inline int idBitMsgDelta::ReadUShort( void ) const {
 return (unsigned short)ReadBits( 16 );
}

inline int idBitMsgDelta::ReadLong( void ) const {
 return ReadBits( 32 );
}

inline float idBitMsgDelta::ReadFloat( void ) const {
 float value;
 *reinterpret_cast<int *>(&value) = ReadBits( 32 );
 return value;
}

inline float idBitMsgDelta::ReadFloat( int exponentBits, int mantissaBits ) const {
 int bits = ReadBits( 1 + exponentBits + mantissaBits );
 return idMath::BitsToFloat( bits, exponentBits, mantissaBits );
}

inline float idBitMsgDelta::ReadAngle8( void ) const {
 return ( (ReadByte()) * ( 360.0f / 256.0f ) );
}

inline float idBitMsgDelta::ReadAngle16( void ) const {
 return ( (ReadShort()) * ( 360.0f / 65536.0f ) );
}

inline idVec3 idBitMsgDelta::ReadDir( int numBits ) const {
 return idBitMsg::BitsToDir( ReadBits( numBits ), numBits );
}

inline int idBitMsgDelta::ReadDeltaChar( int oldValue ) const {
 return (signed char)ReadDelta( oldValue, -8 );
}

inline int idBitMsgDelta::ReadDeltaByte( int oldValue ) const {
 return (unsigned char)ReadDelta( oldValue, 8 );
}

inline int idBitMsgDelta::ReadDeltaShort( int oldValue ) const {
 return (short)ReadDelta( oldValue, -16 );
}

inline int idBitMsgDelta::ReadDeltaLong( int oldValue ) const {
 return ReadDelta( oldValue, 32 );
}

inline float idBitMsgDelta::ReadDeltaFloat( float oldValue ) const {
 float value;
 *reinterpret_cast<int *>(&value) = ReadDelta( *reinterpret_cast<int *>(&oldValue), 32 );
 return value;
}

inline float idBitMsgDelta::ReadDeltaFloat( float oldValue, int exponentBits, int mantissaBits ) const {
 int oldBits = idMath::FloatToBits( oldValue, exponentBits, mantissaBits );
 int newBits = ReadDelta( oldBits, 1 + exponentBits + mantissaBits );
 return idMath::BitsToFloat( newBits, exponentBits, mantissaBits );
}
# 241 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/MapFile.h" 1
# 46 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/MapFile.h"
const int OLD_MAP_VERSION = 1;
const int CURRENT_MAP_VERSION = 2;
const int DEFAULT_CURVE_SUBDIVISION = 4;
const float DEFAULT_CURVE_MAX_ERROR = 4.0f;
const float DEFAULT_CURVE_MAX_ERROR_CD = 24.0f;
const float DEFAULT_CURVE_MAX_LENGTH = -1.0f;
const float DEFAULT_CURVE_MAX_LENGTH_CD = -1.0f;


class idMapPrimitive {
public:
 enum { TYPE_INVALID = -1, TYPE_BRUSH, TYPE_PATCH };

 idDict epairs;

       idMapPrimitive( void ) { type = TYPE_INVALID; }
 virtual ~idMapPrimitive( void ) { }
 int GetType( void ) const { return type; }

protected:
 int type;
};


class idMapBrushSide {
 friend class idMapBrush;

public:
       idMapBrushSide( void );
       ~idMapBrushSide( void ) { }
 const char * GetMaterial( void ) const { return material; }
 void SetMaterial( const char *p ) { material = p; }
 const idPlane & GetPlane( void ) const { return plane; }
 void SetPlane( const idPlane &p ) { plane = p; }
 void SetTextureMatrix( const idVec3 mat[2] ) { texMat[0] = mat[0]; texMat[1] = mat[1]; }
 void GetTextureMatrix( idVec3 &mat1, idVec3 &mat2 ) { mat1 = texMat[0]; mat2 = texMat[1]; }
 void GetTextureVectors( idVec4 v[2] ) const;

protected:
 idStr material;
 idPlane plane;
 idVec3 texMat[2];
 idVec3 origin;
};

inline idMapBrushSide::idMapBrushSide( void ) {
 plane.Zero();
 texMat[0].Zero();
 texMat[1].Zero();
 origin.Zero();
}


class idMapBrush : public idMapPrimitive {
public:
       idMapBrush( void ) { type = TYPE_BRUSH; sides.Resize( 8, 4 ); }
       ~idMapBrush( void ) { sides.DeleteContents( true ); }
 static idMapBrush * Parse( idLexer &src, const idVec3 &origin, bool newFormat = true, float version = CURRENT_MAP_VERSION );
 static idMapBrush * ParseQ3( idLexer &src, const idVec3 &origin );
 bool Write( idFile *fp, int primitiveNum, const idVec3 &origin ) const;
 int GetNumSides( void ) const { return sides.Num(); }
 int AddSide( idMapBrushSide *side ) { return sides.Append( side ); }
 idMapBrushSide * GetSide( int i ) const { return sides[i]; }
 unsigned int GetGeometryCRC( void ) const;

protected:
 int numSides;
 idList<idMapBrushSide*> sides;
};


class idMapPatch : public idMapPrimitive, public idSurface_Patch {
public:
       idMapPatch( void );
       idMapPatch( int maxPatchWidth, int maxPatchHeight );
       ~idMapPatch( void ) { }
 static idMapPatch * Parse( idLexer &src, const idVec3 &origin, bool patchDef3 = true, float version = CURRENT_MAP_VERSION );
 bool Write( idFile *fp, int primitiveNum, const idVec3 &origin ) const;
 const char * GetMaterial( void ) const { return material; }
 void SetMaterial( const char *p ) { material = p; }
 int GetHorzSubdivisions( void ) const { return horzSubdivisions; }
 int GetVertSubdivisions( void ) const { return vertSubdivisions; }
 bool GetExplicitlySubdivided( void ) const { return explicitSubdivisions; }
 void SetHorzSubdivisions( int n ) { horzSubdivisions = n; }
 void SetVertSubdivisions( int n ) { vertSubdivisions = n; }
 void SetExplicitlySubdivided( bool b ) { explicitSubdivisions = b; }
 unsigned int GetGeometryCRC( void ) const;

protected:
 idStr material;
 int horzSubdivisions;
 int vertSubdivisions;
 bool explicitSubdivisions;
};

inline idMapPatch::idMapPatch( void ) {
 type = TYPE_PATCH;
 horzSubdivisions = vertSubdivisions = 0;
 explicitSubdivisions = false;
 width = height = 0;
 maxWidth = maxHeight = 0;
 expanded = false;
}

inline idMapPatch::idMapPatch( int maxPatchWidth, int maxPatchHeight ) {
 type = TYPE_PATCH;
 horzSubdivisions = vertSubdivisions = 0;
 explicitSubdivisions = false;
 width = height = 0;
 maxWidth = maxPatchWidth;
 maxHeight = maxPatchHeight;
 verts.SetNum( maxWidth * maxHeight );
 expanded = false;
}


class idMapEntity {
 friend class idMapFile;

public:
 idDict epairs;

public:
       idMapEntity( void ) { epairs.SetHashSize( 64 ); }
       ~idMapEntity( void ) { primitives.DeleteContents( true ); }
 static idMapEntity * Parse( idLexer &src, bool worldSpawn = false, float version = CURRENT_MAP_VERSION );
 bool Write( idFile *fp, int entityNum ) const;
 int GetNumPrimitives( void ) const { return primitives.Num(); }
 idMapPrimitive * GetPrimitive( int i ) const { return primitives[i]; }
 void AddPrimitive( idMapPrimitive *p ) { primitives.Append( p ); }
 unsigned int GetGeometryCRC( void ) const;
 void RemovePrimitiveData();

protected:
 idList<idMapPrimitive*> primitives;
};


class idMapFile {
public:
       idMapFile( void );
       ~idMapFile( void ) { entities.DeleteContents( true ); }





 bool Parse( const char *filename, bool ignoreRegion = false, bool osPath = false );
 bool Write( const char *fileName, const char *ext, bool fromBasePath = true );

 int GetNumEntities( void ) const { return entities.Num(); }

 idMapEntity * GetEntity( int i ) const { return entities[i]; }

 const char * GetName( void ) const { return name; }

 time_t GetFileTime( void ) const { return fileTime; }


 unsigned int GetGeometryCRC( void ) const { return geometryCRC; }

 bool NeedsReload();

 int AddEntity( idMapEntity *mapentity );
 idMapEntity * FindEntity( const char *name );
 void RemoveEntity( idMapEntity *mapEnt );
 void RemoveEntities( const char *classname );
 void RemoveAllEntities();
 void RemovePrimitiveData();
 bool HasPrimitiveData() { return hasPrimitiveData; }

protected:
 float version;
 time_t fileTime;
 unsigned int geometryCRC;
 idList<idMapEntity *> entities;
 idStr name;
 bool hasPrimitiveData;

private:
 void SetGeometryCRC( void );
};

inline idMapFile::idMapFile( void ) {
 version = CURRENT_MAP_VERSION;
 fileTime = 0;
 geometryCRC = 0;
 entities.Resize( 1024, 256 );
 hasPrimitiveData = false;
}
# 242 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Timer.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Timer.h"
class idTimer {
public:
     idTimer( void );
     idTimer( double clockTicks );
     ~idTimer( void );

 idTimer operator+( const idTimer &t ) const;
 idTimer operator-( const idTimer &t ) const;
 idTimer & operator+=( const idTimer &t );
 idTimer & operator-=( const idTimer &t );

 void Start( void );
 void Stop( void );
 void Clear( void );
 double ClockTicks( void ) const;
 double Milliseconds( void ) const;

private:
 static double base;
 enum {
      TS_STARTED,
      TS_STOPPED
     } state;
 double start;
 double clockTicks;

 void InitBaseClockTicks( void ) const;
};






inline idTimer::idTimer( void ) {
 state = TS_STOPPED;
 clockTicks = 0.0;
}






inline idTimer::idTimer( double _clockTicks ) {
 state = TS_STOPPED;
 clockTicks = _clockTicks;
}






inline idTimer::~idTimer( void ) {
}






inline idTimer idTimer::operator+( const idTimer &t ) const {
 ((void)0);
 return idTimer( clockTicks + t.clockTicks );
}






inline idTimer idTimer::operator-( const idTimer &t ) const {
 ((void)0);
 return idTimer( clockTicks - t.clockTicks );
}






inline idTimer &idTimer::operator+=( const idTimer &t ) {
 ((void)0);
 clockTicks += t.clockTicks;
 return *this;
}






inline idTimer &idTimer::operator-=( const idTimer &t ) {
 ((void)0);
 clockTicks -= t.clockTicks;
 return *this;
}






inline void idTimer::Start( void ) {
 ((void)0);
 state = TS_STARTED;
 start = idLib::sys->GetClockTicks();
}






inline void idTimer::Stop( void ) {
 ((void)0);
 clockTicks += idLib::sys->GetClockTicks() - start;
 if ( base < 0.0 ) {
  InitBaseClockTicks();
 }
 if ( clockTicks > base ) {
  clockTicks -= base;
 }
 state = TS_STOPPED;
}






inline void idTimer::Clear( void ) {
 clockTicks = 0.0;
}






inline double idTimer::ClockTicks( void ) const {
 ((void)0);
 return clockTicks;
}






inline double idTimer::Milliseconds( void ) const {
 ((void)0);
 return clockTicks / ( idLib::sys->ClockTicksPerSecond() * 0.001 );
}
# 205 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Timer.h"
class idTimerReport {
public:
     idTimerReport( void );
     ~idTimerReport( void );

 void SetReportName( const char *name );
 int AddReport( const char *name );
 void Clear( void );
 void Reset( void );
 void PrintReport( void );
 void AddTime( const char *name, idTimer *time );

private:
 idList<idTimer*>timers;
 idStrList names;
 idStr reportName;
};
# 243 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../idlib/Lib.h" 2
# 114 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/BuildVersion.h" 1
# 28 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/BuildVersion.h"
const int BUILD_NUMBER = 1304;
# 117 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/BuildDefines.h" 1
# 118 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Licensee.h" 1
# 119 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/CmdSystem.h" 1
# 48 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/CmdSystem.h"
typedef enum {
 CMD_FL_ALL = -1,
 CMD_FL_CHEAT = ( 1 << ( 0 ) ),
 CMD_FL_SYSTEM = ( 1 << ( 1 ) ),
 CMD_FL_RENDERER = ( 1 << ( 2 ) ),
 CMD_FL_SOUND = ( 1 << ( 3 ) ),
 CMD_FL_GAME = ( 1 << ( 4 ) ),
 CMD_FL_TOOL = ( 1 << ( 5 ) )
} cmdFlags_t;


typedef enum {
 CMD_EXEC_NOW,
 CMD_EXEC_INSERT,
 CMD_EXEC_APPEND
} cmdExecution_t;


typedef void (*cmdFunction_t)( const idCmdArgs &args );


typedef void (*argCompletion_t)( const idCmdArgs &args, void(*callback)( const char *s ) );


class idCmdSystem {
public:
 virtual ~idCmdSystem( void ) {}

 virtual void Init( void ) = 0;
 virtual void Shutdown( void ) = 0;


 virtual void AddCommand( const char *cmdName, cmdFunction_t function, int flags, const char *description, argCompletion_t argCompletion = __null ) = 0;

 virtual void RemoveCommand( const char *cmdName ) = 0;

 virtual void RemoveFlaggedCommands( int flags ) = 0;


 virtual void CommandCompletion( void(*callback)( const char *s ) ) = 0;
 virtual void ArgCompletion( const char *cmdString, void(*callback)( const char *s ) ) = 0;


 virtual void BufferCommandText( cmdExecution_t exec, const char *text ) = 0;



 virtual void ExecuteCommandBuffer( void ) = 0;


 virtual void ArgCompletion_FolderExtension( const idCmdArgs &args, void(*callback)( const char *s ), const char *folder, bool stripFolder, ... ) = 0;

 virtual void ArgCompletion_DeclName( const idCmdArgs &args, void(*callback)( const char *s ), int type ) = 0;


 virtual void BufferCommandArgs( cmdExecution_t exec, const idCmdArgs &args ) = 0;


 virtual void SetupReloadEngine( const idCmdArgs &args ) = 0;
 virtual bool PostReloadEngine( void ) = 0;


 static void ArgCompletion_Boolean( const idCmdArgs &args, void(*callback)( const char *s ) );
 template<int min,int max>
 static void ArgCompletion_Integer( const idCmdArgs &args, void(*callback)( const char *s ) );
 template<const char **strings>
 static void ArgCompletion_String( const idCmdArgs &args, void(*callback)( const char *s ) );
 template<int type>
 static void ArgCompletion_Decl( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_FileName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_MapName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_ModelName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_SoundName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_ImageName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_VideoName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_ConfigName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_SaveGame( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void ArgCompletion_DemoName( const idCmdArgs &args, void(*callback)( const char *s ) );
};

extern idCmdSystem * cmdSystem;


inline void idCmdSystem::ArgCompletion_Boolean( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 callback( va( "%s 0", args.Argv( 0 ) ) );
 callback( va( "%s 1", args.Argv( 0 ) ) );
}

template<int min,int max> inline void idCmdSystem::ArgCompletion_Integer( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 for ( int i = min; i <= max; i++ ) {
  callback( va( "%s %d", args.Argv( 0 ), i ) );
 }
}

template<const char **strings> inline void idCmdSystem::ArgCompletion_String( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 for ( int i = 0; strings[i]; i++ ) {
  callback( va( "%s %s", args.Argv( 0 ), strings[i] ) );
 }
}

template<int type> inline void idCmdSystem::ArgCompletion_Decl( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_DeclName( args, callback, type );
}

inline void idCmdSystem::ArgCompletion_FileName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "/", true, "", __null );
}

inline void idCmdSystem::ArgCompletion_MapName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "maps/", true, ".map", __null );
}

inline void idCmdSystem::ArgCompletion_ModelName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "models/", false, ".lwo", ".ase", ".md5mesh", ".ma", __null );
}

inline void idCmdSystem::ArgCompletion_SoundName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "sound/", false, ".wav", ".ogg", __null );
}

inline void idCmdSystem::ArgCompletion_ImageName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "/", false, ".tga", ".dds", ".jpg", ".pcx", __null );
}

inline void idCmdSystem::ArgCompletion_VideoName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "video/", false, ".roq", __null );
}

inline void idCmdSystem::ArgCompletion_ConfigName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "/", true, ".cfg", __null );
}

inline void idCmdSystem::ArgCompletion_SaveGame( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "SaveGames/", true, ".save", __null );
}

inline void idCmdSystem::ArgCompletion_DemoName( const idCmdArgs &args, void(*callback)( const char *s ) ) {
 cmdSystem->ArgCompletion_FolderExtension( args, callback, "demos/", true, ".demo", __null );
}
# 120 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/CVarSystem.h" 1
# 82 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/CVarSystem.h"
typedef enum {
 CVAR_ALL = -1,
 CVAR_BOOL = ( 1 << ( 0 ) ),
 CVAR_INTEGER = ( 1 << ( 1 ) ),
 CVAR_FLOAT = ( 1 << ( 2 ) ),
 CVAR_SYSTEM = ( 1 << ( 3 ) ),
 CVAR_RENDERER = ( 1 << ( 4 ) ),
 CVAR_SOUND = ( 1 << ( 5 ) ),
 CVAR_GUI = ( 1 << ( 6 ) ),
 CVAR_GAME = ( 1 << ( 7 ) ),
 CVAR_TOOL = ( 1 << ( 8 ) ),
 CVAR_USERINFO = ( 1 << ( 9 ) ),
 CVAR_SERVERINFO = ( 1 << ( 10 ) ),
 CVAR_NETWORKSYNC = ( 1 << ( 11 ) ),
 CVAR_STATIC = ( 1 << ( 12 ) ),
 CVAR_CHEAT = ( 1 << ( 13 ) ),
 CVAR_NOCHEAT = ( 1 << ( 14 ) ),
 CVAR_INIT = ( 1 << ( 15 ) ),
 CVAR_ROM = ( 1 << ( 16 ) ),
 CVAR_ARCHIVE = ( 1 << ( 17 ) ),
 CVAR_MODIFIED = ( 1 << ( 18 ) )
} cvarFlags_t;
# 114 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/CVarSystem.h"
class idCVar {
public:

       idCVar( void ) { ((void)0); }


       idCVar( const char *name, const char *value, int flags, const char *description,
         argCompletion_t valueCompletion = __null );
       idCVar( const char *name, const char *value, int flags, const char *description,
         float valueMin, float valueMax, argCompletion_t valueCompletion = __null );
       idCVar( const char *name, const char *value, int flags, const char *description,
         const char **valueStrings, argCompletion_t valueCompletion = __null );

 virtual ~idCVar( void ) {}

 const char * GetName( void ) const { return internalVar->name; }
 int GetFlags( void ) const { return internalVar->flags; }
 const char * GetDescription( void ) const { return internalVar->description; }
 float GetMinValue( void ) const { return internalVar->valueMin; }
 float GetMaxValue( void ) const { return internalVar->valueMax; }
 const char ** GetValueStrings( void ) const { return valueStrings; }
 argCompletion_t GetValueCompletion( void ) const { return valueCompletion; }

 bool IsModified( void ) const { return ( internalVar->flags & CVAR_MODIFIED ) != 0; }
 void SetModified( void ) { internalVar->flags |= CVAR_MODIFIED; }
 void ClearModified( void ) { internalVar->flags &= ~CVAR_MODIFIED; }

 const char * GetString( void ) const { return internalVar->value; }
 bool GetBool( void ) const { return ( internalVar->integerValue != 0 ); }
 int GetInteger( void ) const { return internalVar->integerValue; }
 float GetFloat( void ) const { return internalVar->floatValue; }

 void SetString( const char *value ) { internalVar->InternalSetString( value ); }
 void SetBool( const bool value ) { internalVar->InternalSetBool( value ); }
 void SetInteger( const int value ) { internalVar->InternalSetInteger( value ); }
 void SetFloat( const float value ) { internalVar->InternalSetFloat( value ); }

 void SetInternalVar( idCVar *cvar ) { internalVar = cvar; }

 static void RegisterStaticVars( void );

protected:
 const char * name;
 const char * value;
 const char * description;
 int flags;
 float valueMin;
 float valueMax;
 const char ** valueStrings;
 argCompletion_t valueCompletion;
 int integerValue;
 float floatValue;
 idCVar * internalVar;
 idCVar * next;

private:
 void Init( const char *name, const char *value, int flags, const char *description,
         float valueMin, float valueMax, const char **valueStrings, argCompletion_t valueCompletion );

 virtual void InternalSetString( const char *newValue ) {}
 virtual void InternalSetBool( const bool newValue ) {}
 virtual void InternalSetInteger( const int newValue ) {}
 virtual void InternalSetFloat( const float newValue ) {}

 static idCVar * staticVars;
};

inline idCVar::idCVar( const char *name, const char *value, int flags, const char *description,
       argCompletion_t valueCompletion ) {
 if ( !valueCompletion && ( flags & CVAR_BOOL ) ) {
  valueCompletion = idCmdSystem::ArgCompletion_Boolean;
 }
 Init( name, value, flags, description, 1, -1, __null, valueCompletion );
}

inline idCVar::idCVar( const char *name, const char *value, int flags, const char *description,
       float valueMin, float valueMax, argCompletion_t valueCompletion ) {
 Init( name, value, flags, description, valueMin, valueMax, __null, valueCompletion );
}

inline idCVar::idCVar( const char *name, const char *value, int flags, const char *description,
       const char **valueStrings, argCompletion_t valueCompletion ) {
 Init( name, value, flags, description, 1, -1, valueStrings, valueCompletion );
}
# 208 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/CVarSystem.h"
class idCVarSystem {
public:
 virtual ~idCVarSystem( void ) {}

 virtual void Init( void ) = 0;
 virtual void Shutdown( void ) = 0;
 virtual bool IsInitialized( void ) const = 0;


 virtual void Register( idCVar *cvar ) = 0;



 virtual idCVar * Find( const char *name ) = 0;


 virtual void SetCVarString( const char *name, const char *value, int flags = 0 ) = 0;
 virtual void SetCVarBool( const char *name, const bool value, int flags = 0 ) = 0;
 virtual void SetCVarInteger( const char *name, const int value, int flags = 0 ) = 0;
 virtual void SetCVarFloat( const char *name, const float value, int flags = 0 ) = 0;


 virtual const char * GetCVarString( const char *name ) const = 0;
 virtual bool GetCVarBool( const char *name ) const = 0;
 virtual int GetCVarInteger( const char *name ) const = 0;
 virtual float GetCVarFloat( const char *name ) const = 0;



 virtual bool Command( const idCmdArgs &args ) = 0;


 virtual void CommandCompletion( void(*callback)( const char *s ) ) = 0;
 virtual void ArgCompletion( const char *cmdString, void(*callback)( const char *s ) ) = 0;


 virtual void SetModifiedFlags( int flags ) = 0;
 virtual int GetModifiedFlags( void ) const = 0;
 virtual void ClearModifiedFlags( int flags ) = 0;


 virtual void ResetFlaggedVariables( int flags ) = 0;


 virtual void RemoveFlaggedAutoCompletion( int flags ) = 0;


 virtual void WriteFlaggedVariables( int flags, const char *setCmd, idFile *f ) const = 0;


 virtual const idDict * MoveCVarsToDict( int flags ) const = 0;
 virtual void SetCVarsFromDict( const idDict &dict ) = 0;
};

extern idCVarSystem * cvarSystem;
# 278 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/CVarSystem.h"
inline void idCVar::Init( const char *name, const char *value, int flags, const char *description,
       float valueMin, float valueMax, const char **valueStrings, argCompletion_t valueCompletion ) {
 this->name = name;
 this->value = value;
 this->flags = flags;
 this->description = description;
 this->flags = flags | CVAR_STATIC;
 this->valueMin = valueMin;
 this->valueMax = valueMax;
 this->valueStrings = valueStrings;
 this->valueCompletion = valueCompletion;
 this->integerValue = 0;
 this->floatValue = 0.0f;
 this->internalVar = this;
 if ( staticVars != (idCVar *)0xFFFFFFFF ) {
  this->next = staticVars;
  staticVars = this;
 } else {
  cvarSystem->Register( this );
 }
}

inline void idCVar::RegisterStaticVars( void ) {
 if ( staticVars != (idCVar *)0xFFFFFFFF ) {
  for ( idCVar *cvar = staticVars; cvar; cvar = cvar->next ) {
   cvarSystem->Register( cvar );
  }
  staticVars = (idCVar *)0xFFFFFFFF;
 }
}
# 121 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Common.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Common.h"
typedef enum {
 EDITOR_NONE = 0,
 EDITOR_RADIANT = ( 1 << ( 1 ) ),
 EDITOR_GUI = ( 1 << ( 2 ) ),
 EDITOR_DEBUGGER = ( 1 << ( 3 ) ),
 EDITOR_SCRIPT = ( 1 << ( 4 ) ),
 EDITOR_LIGHT = ( 1 << ( 5 ) ),
 EDITOR_SOUND = ( 1 << ( 6 ) ),
 EDITOR_DECL = ( 1 << ( 7 ) ),
 EDITOR_AF = ( 1 << ( 8 ) ),
 EDITOR_PARTICLE = ( 1 << ( 9 ) ),
 EDITOR_PDA = ( 1 << ( 10 ) ),
 EDITOR_AAS = ( 1 << ( 11 ) ),
 EDITOR_MATERIAL = ( 1 << ( 12 ) )
} toolFlag_t;




extern idCVar com_version;
extern idCVar com_skipRenderer;
extern idCVar com_asyncInput;
extern idCVar com_asyncSound;
extern idCVar com_machineSpec;
extern idCVar com_purgeAll;
extern idCVar com_developer;
extern idCVar com_allowConsole;
extern idCVar com_speeds;
extern idCVar com_showFPS;
extern idCVar com_showMemoryUsage;
extern idCVar com_showAsyncStats;
extern idCVar com_showSoundDecoders;
extern idCVar com_makingBuild;
extern idCVar com_updateLoadSize;
extern idCVar com_videoRam;

extern int time_gameFrame;
extern int time_gameDraw;
extern int time_frontend;
extern int time_backend;

extern int com_frameTime;
extern volatile int com_ticNumber;
extern int com_editors;
extern bool com_editorActive;
# 93 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Common.h"
struct MemInfo_t {
 idStr filebase;

 int total;
 int assetTotals;


 int memoryManagerTotal;


 int gameSubsystemTotal;
 int renderSubsystemTotal;


 int imageAssetsTotal;
 int modelAssetsTotal;
 int soundAssetsTotal;
};

class idCommon {
public:
 virtual ~idCommon( void ) {}




 virtual void Init( int argc, const char **argv, const char *cmdline ) = 0;


 virtual void Shutdown( void ) = 0;


 virtual void Quit( void ) = 0;


 virtual bool IsInitialized( void ) const = 0;


 virtual void Frame( void ) = 0;


 virtual void GUIFrame( bool execCmd, bool network ) = 0;



 virtual void Async( void ) = 0;





 virtual void StartupVariable( const char *match, bool once ) = 0;


 virtual void InitTool( const toolFlag_t tool, const idDict *dict ) = 0;


 virtual void ActivateTool( bool active ) = 0;


 virtual void WriteConfigToFile( const char *filename ) = 0;


 virtual void WriteFlaggedCVarsToFile( const char *filename, int flags, const char *setCmd ) = 0;


 virtual void BeginRedirect( char *buffer, int buffersize, void (*flush)( const char * ) ) = 0;


 virtual void EndRedirect( void ) = 0;


 virtual void SetRefreshOnPrint( bool set ) = 0;


 virtual void Printf( const char *fmt, ... )__attribute__((format(printf,2,3))) = 0;


 virtual void VPrintf( const char *fmt, va_list arg ) = 0;



 virtual void DPrintf( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;


 virtual void Warning( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;


 virtual void DWarning( const char *fmt, ...) __attribute__((format(printf,2,3))) = 0;


 virtual void PrintWarnings( void ) = 0;


 virtual void ClearWarnings( const char *reason ) = 0;



 virtual void Error( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;



 virtual void FatalError( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;


 virtual const idLangDict * GetLanguageDict( void ) = 0;


 virtual const char * KeysFromBinding( const char *bind ) = 0;


 virtual const char * BindingFromKey( const char *key ) = 0;


 virtual int ButtonState( int key ) = 0;


 virtual int KeyState( int key ) = 0;
};

extern idCommon * common;
# 122 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/File.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/File.h"
typedef enum {
 FS_SEEK_CUR,
 FS_SEEK_END,
 FS_SEEK_SET
} fsOrigin_t;

typedef enum {
 FILETYPE_INZIP,
 FILETYPE_BITMSG,
 FILETYPE_MEMORY,
 FILETYPE_PERMANENT,
 FILETYPE_WHATEVER
} idFileType_t;

class idFileSystemLocal;


class idFile {
public:
 virtual ~idFile( void ) {};


 virtual idFileType_t GetFileType(void) { return FILETYPE_WHATEVER; };

 virtual const char * GetName( void );

 virtual const char * GetFullPath( void );

 virtual int Read( void *buffer, int len );

 virtual int Write( const void *buffer, int len );

 virtual int Length( void );

 virtual time_t Timestamp( void );

 virtual int Tell( void );

 virtual void ForceFlush( void );

 virtual void Flush( void );

 virtual int Seek( long offset, fsOrigin_t origin );

 virtual void Rewind( void );

 virtual int Printf( const char *fmt, ... ) __attribute__((format(printf,2,3)));

 virtual int VPrintf( const char *fmt, va_list arg );

 virtual int WriteFloatString( const char *fmt, ... ) __attribute__((format(printf,2,3)));


 virtual int ReadInt( int &value );
 virtual int ReadUnsignedInt( unsigned int &value );
 virtual int ReadShort( short &value );
 virtual int ReadUnsignedShort( unsigned short &value );
 virtual int ReadChar( char &value );
 virtual int ReadUnsignedChar( unsigned char &value );
 virtual int ReadFloat( float &value );
 virtual int ReadBool( bool &value );
 virtual int ReadString( idStr &string );
 virtual int ReadVec2( idVec2 &vec );
 virtual int ReadVec3( idVec3 &vec );
 virtual int ReadVec4( idVec4 &vec );
 virtual int ReadVec6( idVec6 &vec );
 virtual int ReadMat3( idMat3 &mat );


 virtual int WriteInt( const int value );
 virtual int WriteUnsignedInt( const unsigned int value );
 virtual int WriteShort( const short value );
 virtual int WriteUnsignedShort( unsigned short value );
 virtual int WriteChar( const char value );
 virtual int WriteUnsignedChar( const unsigned char value );
 virtual int WriteFloat( const float value );
 virtual int WriteBool( const bool value );
 virtual int WriteString( const char *string );
 virtual int WriteVec2( const idVec2 &vec );
 virtual int WriteVec3( const idVec3 &vec );
 virtual int WriteVec4( const idVec4 &vec );
 virtual int WriteVec6( const idVec6 &vec );
 virtual int WriteMat3( const idMat3 &mat );
};


class idFile_Memory : public idFile {
 friend class idFileSystemLocal;

public:
       idFile_Memory( void );
       idFile_Memory( const char *name );
       idFile_Memory( const char *name, char *data, int length );
       idFile_Memory( const char *name, const char *data, int length );
 virtual ~idFile_Memory( void );

 virtual const char * GetName( void ) { return name.c_str(); }
 virtual const char * GetFullPath( void ) { return name.c_str(); }
 virtual int Read( void *buffer, int len );
 virtual int Write( const void *buffer, int len );
 virtual int Length( void );
 virtual time_t Timestamp( void );
 virtual int Tell( void );
 virtual void ForceFlush( void );
 virtual void Flush( void );
 virtual int Seek( long offset, fsOrigin_t origin );


 virtual void MakeReadOnly( void );

 virtual void Clear( bool freeMemory = true );

 idFileType_t GetFileType(void);

 void SetData( const char *data, int length );

 const char * GetDataPtr( void ) const { return filePtr; }

 void SetGranularity( int g ) { ((void)0); granularity = g; }

private:
 idStr name;
 int mode;
 int maxSize;
 int fileSize;
 int allocated;
 int granularity;
 char * filePtr;
 char * curPtr;
};


class idFile_BitMsg : public idFile {
 friend class idFileSystemLocal;

public:
       idFile_BitMsg( idBitMsg &msg );
       idFile_BitMsg( const idBitMsg &msg );
 virtual ~idFile_BitMsg( void );

 virtual const char * GetName( void ) { return name.c_str(); }
 virtual const char * GetFullPath( void ) { return name.c_str(); }
 virtual int Read( void *buffer, int len );
 virtual int Write( const void *buffer, int len );
 virtual int Length( void );
 virtual time_t Timestamp( void );
 virtual int Tell( void );
 virtual void ForceFlush( void );
 virtual void Flush( void );
 virtual int Seek( long offset, fsOrigin_t origin );
 idFileType_t GetFileType(void);

private:
 idStr name;
 int mode;
 idBitMsg * msg;
};


class idFile_Permanent : public idFile {
 friend class idFileSystemLocal;

public:
       idFile_Permanent( void );
 virtual ~idFile_Permanent( void );

 virtual const char * GetName( void ) { return name.c_str(); }
 virtual const char * GetFullPath( void ) { return fullPath.c_str(); }
 virtual int Read( void *buffer, int len );
 virtual int Write( const void *buffer, int len );
 virtual int Length( void );
 virtual time_t Timestamp( void );
 virtual int Tell( void );
 virtual void ForceFlush( void );
 virtual void Flush( void );
 virtual int Seek( long offset, fsOrigin_t origin );

 idFileType_t GetFileType(void);

 FILE * GetFilePtr( void ) { return o; }

private:
 idStr name;
 idStr fullPath;
 int mode;
 int fileSize;
 FILE * o;
 bool handleSync;
};


class idFile_InZip : public idFile {
 friend class idFileSystemLocal;

public:
       idFile_InZip( void );
 virtual ~idFile_InZip( void );

 virtual const char * GetName( void ) { return name.c_str(); }
 virtual const char * GetFullPath( void ) { return fullPath.c_str(); }
 virtual int Read( void *buffer, int len );
 virtual int Write( const void *buffer, int len );
 virtual int Length( void );
 virtual time_t Timestamp( void );
 virtual int Tell( void );
 virtual void ForceFlush( void );
 virtual void Flush( void );
 virtual int Seek( long offset, fsOrigin_t origin );
 idFileType_t GetFileType(void);

private:
 idStr name;
 idStr fullPath;
 int zipFilePos;
 int fileSize;
 void * z;
};
# 123 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/FileSystem.h" 1
# 55 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/FileSystem.h"
static const time_t FILE_NOT_FOUND_TIMESTAMP = 0xFFFFFFFF;
static const int MAX_PURE_PAKS = 128;
static const int MAX_OSPATH = 256;


typedef enum {
 FS_READ = 0,
 FS_WRITE = 1,
 FS_APPEND = 2
} fsMode_t;

typedef enum {
 PURE_OK,
 PURE_RESTART,
 PURE_MISSING,
 PURE_NODLL
} fsPureReply_t;

typedef enum {
 DLTYPE_URL,
 DLTYPE_FILE
} dlType_t;

typedef enum {
 DL_WAIT,
 DL_INPROGRESS,
 DL_DONE,
 DL_ABORTING,
 DL_FAILED
} dlStatus_t;

typedef enum {
 FILE_EXEC,
 FILE_OPEN
} dlMime_t;

typedef enum {
 FIND_NO,
 FIND_YES,
 FIND_ADDON
} findFile_t;

typedef struct urlDownload_s {
 idStr url;
 char dlerror[ 1024 ];
 int dltotal;
 int dlnow;
 int dlstatus;
 dlStatus_t status;
} urlDownload_t;

typedef struct fileDownload_s {
 int position;
 int length;
 void * buffer;
} fileDownload_t;

typedef struct backgroundDownload_s {
 struct backgroundDownload_s *next;
 dlType_t opcode;
 idFile * f;
 fileDownload_t file;
 urlDownload_t url;
 volatile bool completed;
} backgroundDownload_t;


class idFileList {
 friend class idFileSystemLocal;
public:
 const char * GetBasePath( void ) const { return basePath; }
 int GetNumFiles( void ) const { return list.Num(); }
 const char * GetFile( int index ) const { return list[index]; }
 const idStrList & GetList( void ) const { return list; }

private:
 idStr basePath;
 idStrList list;
};


class idModList {
 friend class idFileSystemLocal;
public:
 int GetNumMods( void ) const { return mods.Num(); }
 const char * GetMod( int index ) const { return mods[index]; }
 const char * GetDescription( int index ) const { return descriptions[index]; }

private:
 idStrList mods;
 idStrList descriptions;
};

class idFileSystem {
public:
 virtual ~idFileSystem() {}

 virtual void Init( void ) = 0;

 virtual void Restart( void ) = 0;

 virtual void Shutdown( bool reloading ) = 0;

 virtual bool IsInitialized( void ) const = 0;

 virtual bool PerformingCopyFiles( void ) const = 0;



 virtual idModList * ListMods( void ) = 0;

 virtual void FreeModList( idModList *modList ) = 0;





 virtual idFileList * ListFiles( const char *relativePath, const char *extension, bool sort = false, bool fullRelativePath = false, const char* gamedir = __null ) = 0;




 virtual idFileList * ListFilesTree( const char *relativePath, const char *extension, bool sort = false, const char* gamedir = __null ) = 0;

 virtual void FreeFileList( idFileList *fileList ) = 0;

 virtual const char * OSPathToRelativePath( const char *OSPath ) = 0;

 virtual const char * RelativePathToOSPath( const char *relativePath, const char *basePath = "fs_devpath" ) = 0;

 virtual const char * BuildOSPath( const char *base, const char *game, const char *relativePath ) = 0;

 virtual void CreateOSPath( const char *OSPath ) = 0;

 virtual bool FileIsInPAK( const char *relativePath ) = 0;


 virtual void UpdatePureServerChecksums( void ) = 0;

 virtual bool UpdateGamePakChecksums( void ) = 0;







 virtual fsPureReply_t SetPureServerChecksums( const int pureChecksums[ MAX_PURE_PAKS ], int gamePakChecksum, int missingChecksums[ MAX_PURE_PAKS ], int *missingGamePakChecksum ) = 0;


 virtual void GetPureServerChecksums( int checksums[ MAX_PURE_PAKS ], int OS, int *gamePakChecksum ) = 0;


 virtual void SetRestartChecksums( const int pureChecksums[ MAX_PURE_PAKS ], int gamePakChecksum ) = 0;

 virtual void ClearPureChecksums( void ) = 0;

 virtual int GetOSMask( void ) = 0;







 virtual int ReadFile( const char *relativePath, void **buffer, time_t *timestamp = __null ) = 0;

 virtual void FreeFile( void *buffer ) = 0;


 virtual int WriteFile( const char *relativePath, const void *buffer, int size, const char *basePath = "fs_savepath" ) = 0;

 virtual void RemoveFile( const char *relativePath ) = 0;

 virtual idFile * OpenFileRead( const char *relativePath, bool allowCopyFiles = true, const char* gamedir = __null ) = 0;

 virtual idFile * OpenFileWrite( const char *relativePath, const char *basePath = "fs_savepath" ) = 0;

 virtual idFile * OpenFileAppend( const char *filename, bool sync = false, const char *basePath = "fs_basepath" ) = 0;

 virtual idFile * OpenFileByMode( const char *relativePath, fsMode_t mode ) = 0;

 virtual idFile * OpenExplicitFileRead( const char *OSPath ) = 0;

 virtual idFile * OpenExplicitFileWrite( const char *OSPath ) = 0;

 virtual void CloseFile( idFile *f ) = 0;

 virtual void BackgroundDownload( backgroundDownload_t *bgl ) = 0;

 virtual void ResetReadCount( void ) = 0;

 virtual int GetReadCount( void ) = 0;

 virtual void AddToReadCount( int c ) = 0;

 virtual void FindDLL( const char *basename, char dllPath[ MAX_OSPATH ], bool updateChecksum ) = 0;



 virtual void ClearDirCache( void ) = 0;


 virtual bool HasD3XP( void ) = 0;

 virtual bool RunningD3XP( void ) = 0;


 virtual void CopyFile( const char *fromOSPath, const char *toOSPath ) = 0;


 virtual int ValidateDownloadPakForChecksum( int checksum, char path[ 1024 ], bool isGamePak ) = 0;

 virtual idFile * MakeTemporaryFile( void ) = 0;


 virtual int AddZipFile( const char *path ) = 0;



 virtual findFile_t FindFile( const char *path, bool scheduleAddons = false ) = 0;



 virtual int GetNumMaps() = 0;
 virtual const idDict * GetMapDecl( int i ) = 0;
 virtual void FindMapScreenshot( const char *path, char *buf, int len ) = 0;


 virtual bool FilenameCompare( const char *s1, const char *s2 ) const = 0;
};

extern idFileSystem * fileSystem;
# 124 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/UsercmdGen.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/UsercmdGen.h"
const int USERCMD_HZ = 60;
const int USERCMD_MSEC = 1000 / USERCMD_HZ;


const int BUTTON_ATTACK = ( 1 << ( 0 ) );
const int BUTTON_RUN = ( 1 << ( 1 ) );
const int BUTTON_ZOOM = ( 1 << ( 2 ) );
const int BUTTON_SCORES = ( 1 << ( 3 ) );
const int BUTTON_MLOOK = ( 1 << ( 4 ) );
const int BUTTON_5 = ( 1 << ( 5 ) );
const int BUTTON_6 = ( 1 << ( 6 ) );
const int BUTTON_7 = ( 1 << ( 7 ) );


const int IMPULSE_0 = 0;
const int IMPULSE_1 = 1;
const int IMPULSE_2 = 2;
const int IMPULSE_3 = 3;
const int IMPULSE_4 = 4;
const int IMPULSE_5 = 5;
const int IMPULSE_6 = 6;
const int IMPULSE_7 = 7;
const int IMPULSE_8 = 8;
const int IMPULSE_9 = 9;
const int IMPULSE_10 = 10;
const int IMPULSE_11 = 11;
const int IMPULSE_12 = 12;
const int IMPULSE_13 = 13;
const int IMPULSE_14 = 14;
const int IMPULSE_15 = 15;
const int IMPULSE_16 = 16;
const int IMPULSE_17 = 17;
const int IMPULSE_18 = 18;
const int IMPULSE_19 = 19;
const int IMPULSE_20 = 20;
const int IMPULSE_21 = 21;
const int IMPULSE_22 = 22;
const int IMPULSE_23 = 23;
const int IMPULSE_24 = 24;
const int IMPULSE_25 = 25;
const int IMPULSE_26 = 26;
const int IMPULSE_27 = 27;
const int IMPULSE_28 = 28;
const int IMPULSE_29 = 29;
const int IMPULSE_40 = 40;


const int UCF_IMPULSE_SEQUENCE = 0x0001;

class usercmd_t {
public:
 int gameFrame;
 int gameTime;
 int duplicateCount;
 byte buttons;
 signed char forwardmove;
 signed char rightmove;
 signed char upmove;
 short angles[3];
 short mx;
 short my;
 signed char impulse;
 byte flags;
 int sequence;

public:
 void ByteSwap();
 bool operator==( const usercmd_t &rhs ) const;
};

typedef enum {
 INHIBIT_SESSION = 0,
 INHIBIT_ASYNC
} inhibit_t;

const int MAX_BUFFERED_USERCMD = 64;

class idUsercmdGen {
public:
 virtual ~idUsercmdGen( void ) {}


 virtual void Init( void ) = 0;


 virtual void InitForNewMap( void ) = 0;


 virtual void Shutdown( void ) = 0;


 virtual void Clear( void ) = 0;


 virtual void ClearAngles( void ) = 0;



 virtual void InhibitUsercmd( inhibit_t subsystem, bool inhibit ) = 0;


 virtual usercmd_t TicCmd( int ticNumber ) = 0;


 virtual void UsercmdInterrupt( void ) = 0;


 virtual int CommandStringUsercmdData( const char *cmdString ) = 0;


 virtual int GetNumUserCommands( void ) = 0;


 virtual const char *GetUserCommandName( int index ) = 0;


 virtual void MouseState( int *x, int *y, int *button, bool *down ) = 0;


 virtual int ButtonState( int key ) = 0;


 virtual int KeyState( int key ) = 0;


 virtual usercmd_t GetDirectUsercmd( void ) = 0;
};

extern idUsercmdGen *usercmdGen;
# 125 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclManager.h" 1
# 65 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclManager.h"
typedef enum {
 DECL_TABLE = 0,
 DECL_MATERIAL,
 DECL_SKIN,
 DECL_SOUND,
 DECL_ENTITYDEF,
 DECL_MODELDEF,
 DECL_FX,
 DECL_PARTICLE,
 DECL_AF,
 DECL_PDA,
 DECL_VIDEO,
 DECL_AUDIO,
 DECL_EMAIL,
 DECL_MODELEXPORT,
 DECL_MAPDEF,



 DECL_MAX_TYPES = 32
} declType_t;

typedef enum {
 DS_UNPARSED,
 DS_DEFAULTED,
 DS_PARSED
} declState_t;

const int DECL_LEXER_FLAGS = LEXFL_NOSTRINGCONCAT |
        LEXFL_NOSTRINGESCAPECHARS |
        LEXFL_ALLOWPATHNAMES |
        LEXFL_ALLOWMULTICHARLITERALS |
        LEXFL_ALLOWBACKSLASHSTRINGCONCAT |
        LEXFL_NOFATALERRORS;


class idDeclBase {
public:
 virtual ~idDeclBase() {};
 virtual const char * GetName( void ) const = 0;
 virtual declType_t GetType( void ) const = 0;
 virtual declState_t GetState( void ) const = 0;
 virtual bool IsImplicit( void ) const = 0;
 virtual bool IsValid( void ) const = 0;
 virtual void Invalidate( void ) = 0;
 virtual void Reload( void ) = 0;
 virtual void EnsureNotPurged( void ) = 0;
 virtual int Index( void ) const = 0;
 virtual int GetLineNum( void ) const = 0;
 virtual const char * GetFileName( void ) const = 0;
 virtual void GetText( char *text ) const = 0;
 virtual int GetTextLength( void ) const = 0;
 virtual void SetText( const char *text ) = 0;
 virtual bool ReplaceSourceFileText( void ) = 0;
 virtual bool SourceFileChanged( void ) const = 0;
 virtual void MakeDefault( void ) = 0;
 virtual bool EverReferenced( void ) const = 0;
 virtual bool SetDefaultText( void ) = 0;
 virtual const char * DefaultDefinition( void ) const = 0;
 virtual bool Parse( const char *text, const int textLength ) = 0;
 virtual void FreeData( void ) = 0;
 virtual size_t Size( void ) const = 0;
 virtual void List( void ) const = 0;
 virtual void Print( void ) const = 0;
};


class idDecl {
public:


       idDecl( void ) { base = __null; }
 virtual ~idDecl( void ) {};


 const char * GetName( void ) const { return base->GetName(); }


 declType_t GetType( void ) const { return base->GetType(); }


 declState_t GetState( void ) const { return base->GetState(); }


 bool IsImplicit( void ) const { return base->IsImplicit(); }




 bool IsValid( void ) const { return base->IsValid(); }



 void Invalidate( void ) { base->Invalidate(); }



 void EnsureNotPurged( void ) { base->EnsureNotPurged(); }


 int Index( void ) const { return base->Index(); }


 int GetLineNum( void ) const { return base->GetLineNum(); }


 const char * GetFileName( void ) const { return base->GetFileName(); }


 void GetText( char *text ) const { base->GetText( text ); }


 int GetTextLength( void ) const { return base->GetTextLength(); }


 void SetText( const char *text ) { base->SetText( text ); }



 bool ReplaceSourceFileText( void ) { return base->ReplaceSourceFileText(); }


 bool SourceFileChanged( void ) const { return base->SourceFileChanged(); }


 void MakeDefault( void ) { base->MakeDefault(); }


 bool EverReferenced( void ) const { return base->EverReferenced(); }

public:




 virtual bool SetDefaultText( void ) { return base->SetDefaultText(); }






 virtual const char * DefaultDefinition( void ) const { return base->DefaultDefinition(); }






 virtual bool Parse( const char *text, const int textLength ) { return base->Parse( text, textLength ); }





 virtual void FreeData( void ) { base->FreeData(); }


 virtual size_t Size( void ) const { return base->Size(); }




 virtual void List( void ) const { base->List(); }




 virtual void Print( void ) const { base->Print(); }

public:
 idDeclBase * base;
};


template< class type >
inline idDecl *idDeclAllocator( void ) {
 return new type;
}


class idMaterial;
class idDeclSkin;


class idDeclManager {
public:
 virtual ~idDeclManager( void ) {}

 virtual void Init( void ) = 0;
 virtual void Shutdown( void ) = 0;
 virtual void Reload( bool force ) = 0;

 virtual void VirtualizeAll() = 0;
 virtual void BeginLevelLoad() = 0;
 virtual void EndLevelLoad() = 0;
 virtual void SetInsideLevelLoad() = 0;


 virtual void RegisterDeclType( const char *typeName, declType_t type, idDecl *(*allocator)( void ) ) = 0;


 virtual void RegisterDeclFolder( const char *folder, const char *extension, declType_t defaultType ) = 0;


 virtual int GetChecksum( void ) const = 0;


 virtual int GetNumDeclTypes( void ) const = 0;


 virtual const char * GetDeclNameFromType( declType_t type ) const = 0;


 virtual declType_t GetDeclTypeFromName( const char *typeName ) const = 0;




 virtual const idDecl * FindType( declType_t type, const char *name, bool makeDefault = true, bool keep = false ) = 0;

 virtual const idDecl* FindDeclWithoutParsing( declType_t type, const char *name, bool makeDefault = true ) = 0;

 virtual void ReloadFile( const char* filename, bool force ) = 0;


 virtual int GetNumDecls( declType_t type ) = 0;




 virtual const idDecl * DeclByIndex( declType_t type, int index, bool forceParse = true ) = 0;


 virtual void ListType( const idCmdArgs &args, declType_t type ) = 0;
 virtual void PrintType( const idCmdArgs &args, declType_t type ) = 0;



 virtual idDecl * CreateNewDecl( declType_t type, const char *name, const char *fileName ) = 0;


 virtual bool RenameDecl( declType_t type, const char* oldName, const char* newName ) = 0;



 virtual void MediaPrint( const char *fmt, ... ) __attribute__((format(printf,2,3))) = 0;

 virtual void WritePrecacheCommands( idFile *f ) = 0;


 virtual const idMaterial * FindMaterial( const char *name, bool makeDefault = true, bool keep = false ) = 0;


 virtual const idDeclSkin * FindSkin( const char *name, bool makeDefault = true ) = 0;


 virtual const idMaterial * MaterialByIndex( int index, bool forceParse = true ) = 0;
 virtual const idDeclSkin * SkinByIndex( int index, bool forceParse = true ) = 0;


};

extern idDeclManager * declManager;


template< declType_t type >
inline void idListDecls_f( const idCmdArgs &args ) {
 declManager->ListType( args, type );
}

template< declType_t type >
inline void idPrintDecls_f( const idCmdArgs &args ) {
 declManager->PrintType( args, type );
}
# 128 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclTable.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclTable.h"
class idDeclTable : public idDecl {
public:
 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 float TableLookup( float index ) const;

private:
 bool clamp;
 bool snap;
 idList<float> values;
};
# 129 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclSkin.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclSkin.h"
typedef struct {
 const idMaterial * from;
 const idMaterial * to;
} skinMapping_t;

class idDeclSkin : public idDecl {
public:
 virtual size_t Size( void ) const;
 virtual bool SetDefaultText( void );
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 const idMaterial * RemapShaderBySkin( const idMaterial *shader ) const;


 const int GetNumModelAssociations() const;
 const char * GetAssociatedModel( int index ) const;

private:
 idList<skinMapping_t> mappings;
 idStrList associatedModels;
};
# 130 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclEntityDef.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclEntityDef.h"
class idDeclEntityDef : public idDecl {
public:
 idDict dict;

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition() const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void );
};
# 131 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclFX.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclFX.h"
enum {
 FX_LIGHT,
 FX_PARTICLE,
 FX_DECAL,
 FX_MODEL,
 FX_SOUND,
 FX_SHAKE,
 FX_ATTACHLIGHT,
 FX_ATTACHENTITY,
 FX_LAUNCH,
 FX_SHOCKWAVE
};




typedef struct {
 int type;
 int sibling;

 idStr data;
 idStr name;
 idStr fire;

 float delay;
 float duration;
 float restart;
 float size;
 float fadeInTime;
 float fadeOutTime;
 float shakeTime;
 float shakeAmplitude;
 float shakeDistance;
 float shakeImpulse;
 float lightRadius;
 float rotate;
 float random1;
 float random2;

 idVec3 lightColor;
 idVec3 offset;
 idMat3 axis;

 bool soundStarted;
 bool shakeStarted;
 bool shakeFalloff;
 bool shakeIgnoreMaster;
 bool bindParticles;
 bool explicitAxis;
 bool noshadows;
 bool particleTrackVelocity;
 bool trackOrigin;
} idFXSingleAction;




class idDeclFX : public idDecl {
public:
 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 idList<idFXSingleAction>events;
 idStr joint;

private:
 void ParseSingleFXAction( idLexer &src, idFXSingleAction& FXAction );
};
# 132 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclParticle.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclParticle.h"
class idParticleParm {
public:
       idParticleParm( void ) { table = __null; from = to = 0.0f; }

 const idDeclTable * table;
 float from;
 float to;

 float Eval( float frac, idRandom &rand ) const;
 float Integrate( float frac, idRandom &rand ) const;
};


typedef enum {
 PDIST_RECT,
 PDIST_CYLINDER,
 PDIST_SPHERE


} prtDistribution_t;

typedef enum {
 PDIR_CONE,
 PDIR_OUTWARD
} prtDirection_t;

typedef enum {
 PPATH_STANDARD,
 PPATH_HELIX,
 PPATH_FLIES,
 PPATH_ORBIT,
 PPATH_DRIP
} prtCustomPth_t;

typedef enum {
 POR_VIEW,
 POR_AIMED,
 POR_X,
 POR_Y,
 POR_Z
} prtOrientation_t;

typedef struct renderEntity_s renderEntity_t;
typedef struct renderView_s renderView_t;

typedef struct {
 const renderEntity_t * renderEnt;
 const renderView_t * renderView;
 int index;
 float frac;
 idRandom random;
 idVec3 origin;
 idMat3 axis;


 float age;
 idRandom originalRandom;
 float animationFrameFrac;
} particleGen_t;





class idParticleStage {
public:
       idParticleStage( void );
 virtual ~idParticleStage( void ) {}

 void Default();
 virtual int NumQuadsPerParticle() const;

 virtual int CreateParticle( particleGen_t *g, idDrawVert *verts ) const;

 void ParticleOrigin( particleGen_t *g, idVec3 &origin ) const;
 int ParticleVerts( particleGen_t *g, const idVec3 origin, idDrawVert *verts ) const;
 void ParticleTexCoords( particleGen_t *g, idDrawVert *verts ) const;
 void ParticleColors( particleGen_t *g, idDrawVert *verts ) const;

 const char * GetCustomPathName();
 const char * GetCustomPathDesc();
 int NumCustomPathParms();
 void SetCustomPathType( const char *p );
 void operator=( const idParticleStage &src );




 const idMaterial * material;

 int totalParticles;
 float cycles;


 int cycleMsec;

 float spawnBunching;
 float particleLife;
 float timeOffset;
 float deadTime;



 prtDistribution_t distributionType;
 float distributionParms[4];

 prtDirection_t directionType;
 float directionParms[4];

 idParticleParm speed;
 float gravity;
 bool worldGravity;
 bool randomDistribution;
 bool entityColor;



 prtCustomPth_t customPathType;
 float customPathParms[8];



 idVec3 offset;

 int animationFrames;
 float animationRate;

 float initialAngle;
 idParticleParm rotationSpeed;

 prtOrientation_t orientation;
 float orientationParms[4];

 idParticleParm size;
 idParticleParm aspect;

 idVec4 color;
 idVec4 fadeColor;
 float fadeInFraction;
 float fadeOutFraction;
 float fadeIndexFraction;

 bool hidden;


 float boundsExpansion;

 idBounds bounds;
};





class idDeclParticle : public idDecl {
public:

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 bool Save( const char *fileName = __null );

 idList<idParticleStage *>stages;
 idBounds bounds;
 float depthHack;

private:
 bool RebuildTextSource( void );
 void GetStageBounds( idParticleStage *stage );
 idParticleStage * ParseParticleStage( idLexer &src );
 void ParseParms( idLexer &src, float *parms, int maxParms );
 void ParseParametric( idLexer &src, idParticleParm *parm );
 void WriteStage( idFile *f, idParticleStage *stage );
 void WriteParticleParm( idFile *f, idParticleParm *parm, const char *name );
};
# 133 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclAF.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclAF.h"
class idDeclAF;

typedef enum {
 DECLAF_CONSTRAINT_INVALID,
 DECLAF_CONSTRAINT_FIXED,
 DECLAF_CONSTRAINT_BALLANDSOCKETJOINT,
 DECLAF_CONSTRAINT_UNIVERSALJOINT,
 DECLAF_CONSTRAINT_HINGE,
 DECLAF_CONSTRAINT_SLIDER,
 DECLAF_CONSTRAINT_SPRING
} declAFConstraintType_t;

typedef enum {
 DECLAF_JOINTMOD_AXIS,
 DECLAF_JOINTMOD_ORIGIN,
 DECLAF_JOINTMOD_BOTH
} declAFJointMod_t;

typedef bool (*getJointTransform_t)( void *model, const idJointMat *frame, const char *jointName, idVec3 &origin, idMat3 &axis );

class idAFVector {
public:
 enum {
  VEC_COORDS = 0,
  VEC_JOINT,
  VEC_BONECENTER,
  VEC_BONEDIR
 } type;
 idStr joint1;
 idStr joint2;

public:
       idAFVector( void );

 bool Parse( idLexer &src );
 bool Finish( const char *fileName, const getJointTransform_t GetJointTransform, const idJointMat *frame, void *model ) const;
 bool Write( idFile *f ) const;
 const char * ToString( idStr &str, const int precision = 8 );
 const idVec3 & ToVec3( void ) const { return vec; }
 idVec3 & ToVec3( void ) { return vec; }

private:
 mutable idVec3 vec;
 bool negate;
};

class idDeclAF_Body {
public:
 idStr name;
 idStr jointName;
 declAFJointMod_t jointMod;
 int modelType;
 idAFVector v1, v2;
 int numSides;
 float width;
 float density;
 idAFVector origin;
 idAngles angles;
 int contents;
 int clipMask;
 bool selfCollision;
 idMat3 inertiaScale;
 float linearFriction;
 float angularFriction;
 float contactFriction;
 idStr containedJoints;
 idAFVector frictionDirection;
 idAFVector contactMotorDirection;
public:
 void SetDefault( const idDeclAF *file );
};

class idDeclAF_Constraint {
public:
 idStr name;
 idStr body1;
 idStr body2;
 declAFConstraintType_t type;
 float friction;
 float stretch;
 float compress;
 float damping;
 float restLength;
 float minLength;
 float maxLength;
 idAFVector anchor;
 idAFVector anchor2;
 idAFVector shaft[2];
 idAFVector axis;
 enum {
  LIMIT_NONE = -1,
  LIMIT_CONE,
  LIMIT_PYRAMID
 } limit;
 idAFVector limitAxis;
 float limitAngles[3];

public:
 void SetDefault( const idDeclAF *file );
};

class idDeclAF : public idDecl {
 friend class idAFFileManager;
public:
       idDeclAF( void );
 virtual ~idDeclAF( void );

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );

 virtual void Finish( const getJointTransform_t GetJointTransform, const idJointMat *frame, void *model ) const;

 bool Save( void );

 void NewBody( const char *name );
 void RenameBody( const char *oldName, const char *newName );
 void DeleteBody( const char *name );

 void NewConstraint( const char *name );
 void RenameConstraint( const char *oldName, const char *newName );
 void DeleteConstraint( const char *name );

 static int ContentsFromString( const char *str );
 static const char * ContentsToString( const int contents, idStr &str );

 static declAFJointMod_t JointModFromString( const char *str );
 static const char * JointModToString( declAFJointMod_t jointMod );

public:
 bool modified;
 idStr model;
 idStr skin;
 float defaultLinearFriction;
 float defaultAngularFriction;
 float defaultContactFriction;
 float defaultConstraintFriction;
 float totalMass;
 idVec2 suspendVelocity;
 idVec2 suspendAcceleration;
 float noMoveTime;
 float noMoveTranslation;
 float noMoveRotation;
 float minMoveTime;
 float maxMoveTime;
 int contents;
 int clipMask;
 bool selfCollision;
 idList<idDeclAF_Body *> bodies;
 idList<idDeclAF_Constraint *> constraints;

private:
 bool ParseContents( idLexer &src, int &c ) const;
 bool ParseBody( idLexer &src );
 bool ParseFixed( idLexer &src );
 bool ParseBallAndSocketJoint( idLexer &src );
 bool ParseUniversalJoint( idLexer &src );
 bool ParseHinge( idLexer &src );
 bool ParseSlider( idLexer &src );
 bool ParseSpring( idLexer &src );
 bool ParseSettings( idLexer &src );

 bool WriteBody( idFile *f, const idDeclAF_Body &body ) const;
 bool WriteFixed( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteBallAndSocketJoint( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteUniversalJoint( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteHinge( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteSlider( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteSpring( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteConstraint( idFile *f, const idDeclAF_Constraint &c ) const;
 bool WriteSettings( idFile *f ) const;

 bool RebuildTextSource( void );
};
# 134 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclPDA.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DeclPDA.h"
class idDeclEmail : public idDecl {
public:
       idDeclEmail() {}

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 const char * GetFrom() const { return from; }
 const char * GetBody() const { return text; }
 const char * GetSubject() const { return subject; }
 const char * GetDate() const { return date; }
 const char * GetTo() const { return to; }
 const char * GetImage() const { return image; }

private:
 idStr text;
 idStr subject;
 idStr date;
 idStr to;
 idStr from;
 idStr image;
};


class idDeclVideo : public idDecl {
public:
       idDeclVideo() {};

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 const char * GetRoq() const { return video; }
 const char * GetWave() const { return audio; }
 const char * GetVideoName() const { return videoName; }
 const char * GetInfo() const { return info; }
 const char * GetPreview() const { return preview; }

private:
 idStr preview;
 idStr video;
 idStr videoName;
 idStr info;
 idStr audio;
};


class idDeclAudio : public idDecl {
public:
       idDeclAudio() {};

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 const char * GetAudioName() const { return audioName; }
 const char * GetWave() const { return audio; }
 const char * GetInfo() const { return info; }
 const char * GetPreview() const { return preview; }

private:
 idStr audio;
 idStr audioName;
 idStr info;
 idStr preview;
};


class idDeclPDA : public idDecl {
public:
       idDeclPDA() { originalEmails = originalVideos = 0; };

 virtual size_t Size( void ) const;
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;
 virtual void List( void ) const;

 virtual void AddVideo( const char *name, bool unique = true ) const;
 virtual void AddAudio( const char *name, bool unique = true ) const;
 virtual void AddEmail( const char *name, bool unique = true ) const;
 virtual void RemoveAddedEmailsAndVideos() const;

 virtual const int GetNumVideos() const;
 virtual const int GetNumAudios() const;
 virtual const int GetNumEmails() const;
 virtual const idDeclVideo *GetVideoByIndex( int index ) const;
 virtual const idDeclAudio *GetAudioByIndex( int index ) const;
 virtual const idDeclEmail *GetEmailByIndex( int index ) const;

 virtual void SetSecurity( const char *sec ) const;

 const char * GetPdaName() const { return pdaName; }
 const char * GetSecurity() const {return security; }
 const char * GetFullName() const { return fullName; }
 const char * GetIcon() const { return icon; }
 const char * GetPost() const { return post; }
 const char * GetID() const { return id; }
 const char * GetTitle() const { return title; }

private:
 mutable idStrList videos;
 mutable idStrList audios;
 mutable idStrList emails;
 idStr pdaName;
 idStr fullName;
 idStr icon;
 idStr id;
 idStr post;
 idStr title;
 mutable idStr security;
 mutable int originalEmails;
 mutable int originalVideos;
};
# 135 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 143 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h"
const int MAX_EXPRESSION_OPS = 2048;
const int MAX_EXPRESSION_REGISTERS = 2048;



# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/qgl.h" 1
# 56 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/qgl.h"
# 1 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h" 1
# 133 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
extern "C" {
# 147 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef int GLsizei;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
# 774 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glClearIndex( GLfloat c );

__attribute__((visibility("default"))) void glClearColor( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha );

__attribute__((visibility("default"))) void glClear( GLbitfield mask );

__attribute__((visibility("default"))) void glIndexMask( GLuint mask );

__attribute__((visibility("default"))) void glColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha );

__attribute__((visibility("default"))) void glAlphaFunc( GLenum func, GLclampf ref );

__attribute__((visibility("default"))) void glBlendFunc( GLenum sfactor, GLenum dfactor );

__attribute__((visibility("default"))) void glLogicOp( GLenum opcode );

__attribute__((visibility("default"))) void glCullFace( GLenum mode );

__attribute__((visibility("default"))) void glFrontFace( GLenum mode );

__attribute__((visibility("default"))) void glPointSize( GLfloat size );

__attribute__((visibility("default"))) void glLineWidth( GLfloat width );

__attribute__((visibility("default"))) void glLineStipple( GLint factor, GLushort pattern );

__attribute__((visibility("default"))) void glPolygonMode( GLenum face, GLenum mode );

__attribute__((visibility("default"))) void glPolygonOffset( GLfloat factor, GLfloat units );

__attribute__((visibility("default"))) void glPolygonStipple( const GLubyte *mask );

__attribute__((visibility("default"))) void glGetPolygonStipple( GLubyte *mask );

__attribute__((visibility("default"))) void glEdgeFlag( GLboolean flag );

__attribute__((visibility("default"))) void glEdgeFlagv( const GLboolean *flag );

__attribute__((visibility("default"))) void glScissor( GLint x, GLint y, GLsizei width, GLsizei height);

__attribute__((visibility("default"))) void glClipPlane( GLenum plane, const GLdouble *equation );

__attribute__((visibility("default"))) void glGetClipPlane( GLenum plane, GLdouble *equation );

__attribute__((visibility("default"))) void glDrawBuffer( GLenum mode );

__attribute__((visibility("default"))) void glReadBuffer( GLenum mode );

__attribute__((visibility("default"))) void glEnable( GLenum cap );

__attribute__((visibility("default"))) void glDisable( GLenum cap );

__attribute__((visibility("default"))) GLboolean glIsEnabled( GLenum cap );


__attribute__((visibility("default"))) void glEnableClientState( GLenum cap );

__attribute__((visibility("default"))) void glDisableClientState( GLenum cap );


__attribute__((visibility("default"))) void glGetBooleanv( GLenum pname, GLboolean *params );

__attribute__((visibility("default"))) void glGetDoublev( GLenum pname, GLdouble *params );

__attribute__((visibility("default"))) void glGetFloatv( GLenum pname, GLfloat *params );

__attribute__((visibility("default"))) void glGetIntegerv( GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glPushAttrib( GLbitfield mask );

__attribute__((visibility("default"))) void glPopAttrib( void );


__attribute__((visibility("default"))) void glPushClientAttrib( GLbitfield mask );

__attribute__((visibility("default"))) void glPopClientAttrib( void );


__attribute__((visibility("default"))) GLint glRenderMode( GLenum mode );

__attribute__((visibility("default"))) GLenum glGetError( void );

__attribute__((visibility("default"))) const GLubyte * glGetString( GLenum name );

__attribute__((visibility("default"))) void glFinish( void );

__attribute__((visibility("default"))) void glFlush( void );

__attribute__((visibility("default"))) void glHint( GLenum target, GLenum mode );






__attribute__((visibility("default"))) void glClearDepth( GLclampd depth );

__attribute__((visibility("default"))) void glDepthFunc( GLenum func );

__attribute__((visibility("default"))) void glDepthMask( GLboolean flag );

__attribute__((visibility("default"))) void glDepthRange( GLclampd near_val, GLclampd far_val );






__attribute__((visibility("default"))) void glClearAccum( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );

__attribute__((visibility("default"))) void glAccum( GLenum op, GLfloat value );






__attribute__((visibility("default"))) void glMatrixMode( GLenum mode );

__attribute__((visibility("default"))) void glOrtho( GLdouble left, GLdouble right,
                                 GLdouble bottom, GLdouble top,
                                 GLdouble near_val, GLdouble far_val );

__attribute__((visibility("default"))) void glFrustum( GLdouble left, GLdouble right,
                                   GLdouble bottom, GLdouble top,
                                   GLdouble near_val, GLdouble far_val );

__attribute__((visibility("default"))) void glViewport( GLint x, GLint y,
                                    GLsizei width, GLsizei height );

__attribute__((visibility("default"))) void glPushMatrix( void );

__attribute__((visibility("default"))) void glPopMatrix( void );

__attribute__((visibility("default"))) void glLoadIdentity( void );

__attribute__((visibility("default"))) void glLoadMatrixd( const GLdouble *m );
__attribute__((visibility("default"))) void glLoadMatrixf( const GLfloat *m );

__attribute__((visibility("default"))) void glMultMatrixd( const GLdouble *m );
__attribute__((visibility("default"))) void glMultMatrixf( const GLfloat *m );

__attribute__((visibility("default"))) void glRotated( GLdouble angle,
                                   GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glRotatef( GLfloat angle,
                                   GLfloat x, GLfloat y, GLfloat z );

__attribute__((visibility("default"))) void glScaled( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glScalef( GLfloat x, GLfloat y, GLfloat z );

__attribute__((visibility("default"))) void glTranslated( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glTranslatef( GLfloat x, GLfloat y, GLfloat z );






__attribute__((visibility("default"))) GLboolean glIsList( GLuint list );

__attribute__((visibility("default"))) void glDeleteLists( GLuint list, GLsizei range );

__attribute__((visibility("default"))) GLuint glGenLists( GLsizei range );

__attribute__((visibility("default"))) void glNewList( GLuint list, GLenum mode );

__attribute__((visibility("default"))) void glEndList( void );

__attribute__((visibility("default"))) void glCallList( GLuint list );

__attribute__((visibility("default"))) void glCallLists( GLsizei n, GLenum type,
                                     const GLvoid *lists );

__attribute__((visibility("default"))) void glListBase( GLuint base );






__attribute__((visibility("default"))) void glBegin( GLenum mode );

__attribute__((visibility("default"))) void glEnd( void );


__attribute__((visibility("default"))) void glVertex2d( GLdouble x, GLdouble y );
__attribute__((visibility("default"))) void glVertex2f( GLfloat x, GLfloat y );
__attribute__((visibility("default"))) void glVertex2i( GLint x, GLint y );
__attribute__((visibility("default"))) void glVertex2s( GLshort x, GLshort y );

__attribute__((visibility("default"))) void glVertex3d( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glVertex3f( GLfloat x, GLfloat y, GLfloat z );
__attribute__((visibility("default"))) void glVertex3i( GLint x, GLint y, GLint z );
__attribute__((visibility("default"))) void glVertex3s( GLshort x, GLshort y, GLshort z );

__attribute__((visibility("default"))) void glVertex4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
__attribute__((visibility("default"))) void glVertex4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
__attribute__((visibility("default"))) void glVertex4i( GLint x, GLint y, GLint z, GLint w );
__attribute__((visibility("default"))) void glVertex4s( GLshort x, GLshort y, GLshort z, GLshort w );

__attribute__((visibility("default"))) void glVertex2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex2iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex2sv( const GLshort *v );

__attribute__((visibility("default"))) void glVertex3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex3iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex3sv( const GLshort *v );

__attribute__((visibility("default"))) void glVertex4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glVertex4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glVertex4iv( const GLint *v );
__attribute__((visibility("default"))) void glVertex4sv( const GLshort *v );


__attribute__((visibility("default"))) void glNormal3b( GLbyte nx, GLbyte ny, GLbyte nz );
__attribute__((visibility("default"))) void glNormal3d( GLdouble nx, GLdouble ny, GLdouble nz );
__attribute__((visibility("default"))) void glNormal3f( GLfloat nx, GLfloat ny, GLfloat nz );
__attribute__((visibility("default"))) void glNormal3i( GLint nx, GLint ny, GLint nz );
__attribute__((visibility("default"))) void glNormal3s( GLshort nx, GLshort ny, GLshort nz );

__attribute__((visibility("default"))) void glNormal3bv( const GLbyte *v );
__attribute__((visibility("default"))) void glNormal3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glNormal3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glNormal3iv( const GLint *v );
__attribute__((visibility("default"))) void glNormal3sv( const GLshort *v );


__attribute__((visibility("default"))) void glIndexd( GLdouble c );
__attribute__((visibility("default"))) void glIndexf( GLfloat c );
__attribute__((visibility("default"))) void glIndexi( GLint c );
__attribute__((visibility("default"))) void glIndexs( GLshort c );
__attribute__((visibility("default"))) void glIndexub( GLubyte c );

__attribute__((visibility("default"))) void glIndexdv( const GLdouble *c );
__attribute__((visibility("default"))) void glIndexfv( const GLfloat *c );
__attribute__((visibility("default"))) void glIndexiv( const GLint *c );
__attribute__((visibility("default"))) void glIndexsv( const GLshort *c );
__attribute__((visibility("default"))) void glIndexubv( const GLubyte *c );

__attribute__((visibility("default"))) void glColor3b( GLbyte red, GLbyte green, GLbyte blue );
__attribute__((visibility("default"))) void glColor3d( GLdouble red, GLdouble green, GLdouble blue );
__attribute__((visibility("default"))) void glColor3f( GLfloat red, GLfloat green, GLfloat blue );
__attribute__((visibility("default"))) void glColor3i( GLint red, GLint green, GLint blue );
__attribute__((visibility("default"))) void glColor3s( GLshort red, GLshort green, GLshort blue );
__attribute__((visibility("default"))) void glColor3ub( GLubyte red, GLubyte green, GLubyte blue );
__attribute__((visibility("default"))) void glColor3ui( GLuint red, GLuint green, GLuint blue );
__attribute__((visibility("default"))) void glColor3us( GLushort red, GLushort green, GLushort blue );

__attribute__((visibility("default"))) void glColor4b( GLbyte red, GLbyte green,
                                   GLbyte blue, GLbyte alpha );
__attribute__((visibility("default"))) void glColor4d( GLdouble red, GLdouble green,
                                   GLdouble blue, GLdouble alpha );
__attribute__((visibility("default"))) void glColor4f( GLfloat red, GLfloat green,
                                   GLfloat blue, GLfloat alpha );
__attribute__((visibility("default"))) void glColor4i( GLint red, GLint green,
                                   GLint blue, GLint alpha );
__attribute__((visibility("default"))) void glColor4s( GLshort red, GLshort green,
                                   GLshort blue, GLshort alpha );
__attribute__((visibility("default"))) void glColor4ub( GLubyte red, GLubyte green,
                                    GLubyte blue, GLubyte alpha );
__attribute__((visibility("default"))) void glColor4ui( GLuint red, GLuint green,
                                    GLuint blue, GLuint alpha );
__attribute__((visibility("default"))) void glColor4us( GLushort red, GLushort green,
                                    GLushort blue, GLushort alpha );


__attribute__((visibility("default"))) void glColor3bv( const GLbyte *v );
__attribute__((visibility("default"))) void glColor3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glColor3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glColor3iv( const GLint *v );
__attribute__((visibility("default"))) void glColor3sv( const GLshort *v );
__attribute__((visibility("default"))) void glColor3ubv( const GLubyte *v );
__attribute__((visibility("default"))) void glColor3uiv( const GLuint *v );
__attribute__((visibility("default"))) void glColor3usv( const GLushort *v );

__attribute__((visibility("default"))) void glColor4bv( const GLbyte *v );
__attribute__((visibility("default"))) void glColor4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glColor4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glColor4iv( const GLint *v );
__attribute__((visibility("default"))) void glColor4sv( const GLshort *v );
__attribute__((visibility("default"))) void glColor4ubv( const GLubyte *v );
__attribute__((visibility("default"))) void glColor4uiv( const GLuint *v );
__attribute__((visibility("default"))) void glColor4usv( const GLushort *v );


__attribute__((visibility("default"))) void glTexCoord1d( GLdouble s );
__attribute__((visibility("default"))) void glTexCoord1f( GLfloat s );
__attribute__((visibility("default"))) void glTexCoord1i( GLint s );
__attribute__((visibility("default"))) void glTexCoord1s( GLshort s );

__attribute__((visibility("default"))) void glTexCoord2d( GLdouble s, GLdouble t );
__attribute__((visibility("default"))) void glTexCoord2f( GLfloat s, GLfloat t );
__attribute__((visibility("default"))) void glTexCoord2i( GLint s, GLint t );
__attribute__((visibility("default"))) void glTexCoord2s( GLshort s, GLshort t );

__attribute__((visibility("default"))) void glTexCoord3d( GLdouble s, GLdouble t, GLdouble r );
__attribute__((visibility("default"))) void glTexCoord3f( GLfloat s, GLfloat t, GLfloat r );
__attribute__((visibility("default"))) void glTexCoord3i( GLint s, GLint t, GLint r );
__attribute__((visibility("default"))) void glTexCoord3s( GLshort s, GLshort t, GLshort r );

__attribute__((visibility("default"))) void glTexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
__attribute__((visibility("default"))) void glTexCoord4f( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
__attribute__((visibility("default"))) void glTexCoord4i( GLint s, GLint t, GLint r, GLint q );
__attribute__((visibility("default"))) void glTexCoord4s( GLshort s, GLshort t, GLshort r, GLshort q );

__attribute__((visibility("default"))) void glTexCoord1dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord1fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord1iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord1sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord2iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord2sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord3iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord3sv( const GLshort *v );

__attribute__((visibility("default"))) void glTexCoord4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glTexCoord4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glTexCoord4iv( const GLint *v );
__attribute__((visibility("default"))) void glTexCoord4sv( const GLshort *v );


__attribute__((visibility("default"))) void glRasterPos2d( GLdouble x, GLdouble y );
__attribute__((visibility("default"))) void glRasterPos2f( GLfloat x, GLfloat y );
__attribute__((visibility("default"))) void glRasterPos2i( GLint x, GLint y );
__attribute__((visibility("default"))) void glRasterPos2s( GLshort x, GLshort y );

__attribute__((visibility("default"))) void glRasterPos3d( GLdouble x, GLdouble y, GLdouble z );
__attribute__((visibility("default"))) void glRasterPos3f( GLfloat x, GLfloat y, GLfloat z );
__attribute__((visibility("default"))) void glRasterPos3i( GLint x, GLint y, GLint z );
__attribute__((visibility("default"))) void glRasterPos3s( GLshort x, GLshort y, GLshort z );

__attribute__((visibility("default"))) void glRasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
__attribute__((visibility("default"))) void glRasterPos4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
__attribute__((visibility("default"))) void glRasterPos4i( GLint x, GLint y, GLint z, GLint w );
__attribute__((visibility("default"))) void glRasterPos4s( GLshort x, GLshort y, GLshort z, GLshort w );

__attribute__((visibility("default"))) void glRasterPos2dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos2fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos2iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos2sv( const GLshort *v );

__attribute__((visibility("default"))) void glRasterPos3dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos3fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos3iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos3sv( const GLshort *v );

__attribute__((visibility("default"))) void glRasterPos4dv( const GLdouble *v );
__attribute__((visibility("default"))) void glRasterPos4fv( const GLfloat *v );
__attribute__((visibility("default"))) void glRasterPos4iv( const GLint *v );
__attribute__((visibility("default"))) void glRasterPos4sv( const GLshort *v );


__attribute__((visibility("default"))) void glRectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 );
__attribute__((visibility("default"))) void glRectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 );
__attribute__((visibility("default"))) void glRecti( GLint x1, GLint y1, GLint x2, GLint y2 );
__attribute__((visibility("default"))) void glRects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 );


__attribute__((visibility("default"))) void glRectdv( const GLdouble *v1, const GLdouble *v2 );
__attribute__((visibility("default"))) void glRectfv( const GLfloat *v1, const GLfloat *v2 );
__attribute__((visibility("default"))) void glRectiv( const GLint *v1, const GLint *v2 );
__attribute__((visibility("default"))) void glRectsv( const GLshort *v1, const GLshort *v2 );






__attribute__((visibility("default"))) void glVertexPointer( GLint size, GLenum type,
                                       GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glNormalPointer( GLenum type, GLsizei stride,
                                       const GLvoid *ptr );

__attribute__((visibility("default"))) void glColorPointer( GLint size, GLenum type,
                                      GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glIndexPointer( GLenum type, GLsizei stride,
                                      const GLvoid *ptr );

__attribute__((visibility("default"))) void glTexCoordPointer( GLint size, GLenum type,
                                         GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glEdgeFlagPointer( GLsizei stride, const GLvoid *ptr );

__attribute__((visibility("default"))) void glGetPointerv( GLenum pname, GLvoid **params );

__attribute__((visibility("default"))) void glArrayElement( GLint i );

__attribute__((visibility("default"))) void glDrawArrays( GLenum mode, GLint first, GLsizei count );

__attribute__((visibility("default"))) void glDrawElements( GLenum mode, GLsizei count,
                                      GLenum type, const GLvoid *indices );

__attribute__((visibility("default"))) void glInterleavedArrays( GLenum format, GLsizei stride,
                                           const GLvoid *pointer );





__attribute__((visibility("default"))) void glShadeModel( GLenum mode );

__attribute__((visibility("default"))) void glLightf( GLenum light, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glLighti( GLenum light, GLenum pname, GLint param );
__attribute__((visibility("default"))) void glLightfv( GLenum light, GLenum pname,
                                 const GLfloat *params );
__attribute__((visibility("default"))) void glLightiv( GLenum light, GLenum pname,
                                 const GLint *params );

__attribute__((visibility("default"))) void glGetLightfv( GLenum light, GLenum pname,
                                    GLfloat *params );
__attribute__((visibility("default"))) void glGetLightiv( GLenum light, GLenum pname,
                                    GLint *params );

__attribute__((visibility("default"))) void glLightModelf( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glLightModeli( GLenum pname, GLint param );
__attribute__((visibility("default"))) void glLightModelfv( GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glLightModeliv( GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glMaterialf( GLenum face, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glMateriali( GLenum face, GLenum pname, GLint param );
__attribute__((visibility("default"))) void glMaterialfv( GLenum face, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glMaterialiv( GLenum face, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetMaterialfv( GLenum face, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetMaterialiv( GLenum face, GLenum pname, GLint *params );

__attribute__((visibility("default"))) void glColorMaterial( GLenum face, GLenum mode );






__attribute__((visibility("default"))) void glPixelZoom( GLfloat xfactor, GLfloat yfactor );

__attribute__((visibility("default"))) void glPixelStoref( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glPixelStorei( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glPixelTransferf( GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glPixelTransferi( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glPixelMapfv( GLenum map, GLsizei mapsize,
                                    const GLfloat *values );
__attribute__((visibility("default"))) void glPixelMapuiv( GLenum map, GLsizei mapsize,
                                     const GLuint *values );
__attribute__((visibility("default"))) void glPixelMapusv( GLenum map, GLsizei mapsize,
                                     const GLushort *values );

__attribute__((visibility("default"))) void glGetPixelMapfv( GLenum map, GLfloat *values );
__attribute__((visibility("default"))) void glGetPixelMapuiv( GLenum map, GLuint *values );
__attribute__((visibility("default"))) void glGetPixelMapusv( GLenum map, GLushort *values );

__attribute__((visibility("default"))) void glBitmap( GLsizei width, GLsizei height,
                                GLfloat xorig, GLfloat yorig,
                                GLfloat xmove, GLfloat ymove,
                                const GLubyte *bitmap );

__attribute__((visibility("default"))) void glReadPixels( GLint x, GLint y,
                                    GLsizei width, GLsizei height,
                                    GLenum format, GLenum type,
                                    GLvoid *pixels );

__attribute__((visibility("default"))) void glDrawPixels( GLsizei width, GLsizei height,
                                    GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glCopyPixels( GLint x, GLint y,
                                    GLsizei width, GLsizei height,
                                    GLenum type );





__attribute__((visibility("default"))) void glStencilFunc( GLenum func, GLint ref, GLuint mask );

__attribute__((visibility("default"))) void glStencilMask( GLuint mask );

__attribute__((visibility("default"))) void glStencilOp( GLenum fail, GLenum zfail, GLenum zpass );

__attribute__((visibility("default"))) void glClearStencil( GLint s );







__attribute__((visibility("default"))) void glTexGend( GLenum coord, GLenum pname, GLdouble param );
__attribute__((visibility("default"))) void glTexGenf( GLenum coord, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexGeni( GLenum coord, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexGendv( GLenum coord, GLenum pname, const GLdouble *params );
__attribute__((visibility("default"))) void glTexGenfv( GLenum coord, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glTexGeniv( GLenum coord, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetTexGendv( GLenum coord, GLenum pname, GLdouble *params );
__attribute__((visibility("default"))) void glGetTexGenfv( GLenum coord, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexGeniv( GLenum coord, GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexEnvf( GLenum target, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexEnvi( GLenum target, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexEnvfv( GLenum target, GLenum pname, const GLfloat *params );
__attribute__((visibility("default"))) void glTexEnviv( GLenum target, GLenum pname, const GLint *params );

__attribute__((visibility("default"))) void glGetTexEnvfv( GLenum target, GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexEnviv( GLenum target, GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexParameterf( GLenum target, GLenum pname, GLfloat param );
__attribute__((visibility("default"))) void glTexParameteri( GLenum target, GLenum pname, GLint param );

__attribute__((visibility("default"))) void glTexParameterfv( GLenum target, GLenum pname,
                                          const GLfloat *params );
__attribute__((visibility("default"))) void glTexParameteriv( GLenum target, GLenum pname,
                                          const GLint *params );

__attribute__((visibility("default"))) void glGetTexParameterfv( GLenum target,
                                           GLenum pname, GLfloat *params);
__attribute__((visibility("default"))) void glGetTexParameteriv( GLenum target,
                                           GLenum pname, GLint *params );

__attribute__((visibility("default"))) void glGetTexLevelParameterfv( GLenum target, GLint level,
                                                GLenum pname, GLfloat *params );
__attribute__((visibility("default"))) void glGetTexLevelParameteriv( GLenum target, GLint level,
                                                GLenum pname, GLint *params );


__attribute__((visibility("default"))) void glTexImage1D( GLenum target, GLint level,
                                    GLint internalFormat,
                                    GLsizei width, GLint border,
                                    GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glTexImage2D( GLenum target, GLint level,
                                    GLint internalFormat,
                                    GLsizei width, GLsizei height,
                                    GLint border, GLenum format, GLenum type,
                                    const GLvoid *pixels );

__attribute__((visibility("default"))) void glGetTexImage( GLenum target, GLint level,
                                     GLenum format, GLenum type,
                                     GLvoid *pixels );




__attribute__((visibility("default"))) void glGenTextures( GLsizei n, GLuint *textures );

__attribute__((visibility("default"))) void glDeleteTextures( GLsizei n, const GLuint *textures);

__attribute__((visibility("default"))) void glBindTexture( GLenum target, GLuint texture );

__attribute__((visibility("default"))) void glPrioritizeTextures( GLsizei n,
                                            const GLuint *textures,
                                            const GLclampf *priorities );

__attribute__((visibility("default"))) GLboolean glAreTexturesResident( GLsizei n,
                                                  const GLuint *textures,
                                                  GLboolean *residences );

__attribute__((visibility("default"))) GLboolean glIsTexture( GLuint texture );


__attribute__((visibility("default"))) void glTexSubImage1D( GLenum target, GLint level,
                                       GLint xoffset,
                                       GLsizei width, GLenum format,
                                       GLenum type, const GLvoid *pixels );


__attribute__((visibility("default"))) void glTexSubImage2D( GLenum target, GLint level,
                                       GLint xoffset, GLint yoffset,
                                       GLsizei width, GLsizei height,
                                       GLenum format, GLenum type,
                                       const GLvoid *pixels );


__attribute__((visibility("default"))) void glCopyTexImage1D( GLenum target, GLint level,
                                        GLenum internalformat,
                                        GLint x, GLint y,
                                        GLsizei width, GLint border );


__attribute__((visibility("default"))) void glCopyTexImage2D( GLenum target, GLint level,
                                        GLenum internalformat,
                                        GLint x, GLint y,
                                        GLsizei width, GLsizei height,
                                        GLint border );


__attribute__((visibility("default"))) void glCopyTexSubImage1D( GLenum target, GLint level,
                                           GLint xoffset, GLint x, GLint y,
                                           GLsizei width );


__attribute__((visibility("default"))) void glCopyTexSubImage2D( GLenum target, GLint level,
                                           GLint xoffset, GLint yoffset,
                                           GLint x, GLint y,
                                           GLsizei width, GLsizei height );






__attribute__((visibility("default"))) void glMap1d( GLenum target, GLdouble u1, GLdouble u2,
                               GLint stride,
                               GLint order, const GLdouble *points );
__attribute__((visibility("default"))) void glMap1f( GLenum target, GLfloat u1, GLfloat u2,
                               GLint stride,
                               GLint order, const GLfloat *points );

__attribute__((visibility("default"))) void glMap2d( GLenum target,
       GLdouble u1, GLdouble u2, GLint ustride, GLint uorder,
       GLdouble v1, GLdouble v2, GLint vstride, GLint vorder,
       const GLdouble *points );
__attribute__((visibility("default"))) void glMap2f( GLenum target,
       GLfloat u1, GLfloat u2, GLint ustride, GLint uorder,
       GLfloat v1, GLfloat v2, GLint vstride, GLint vorder,
       const GLfloat *points );

__attribute__((visibility("default"))) void glGetMapdv( GLenum target, GLenum query, GLdouble *v );
__attribute__((visibility("default"))) void glGetMapfv( GLenum target, GLenum query, GLfloat *v );
__attribute__((visibility("default"))) void glGetMapiv( GLenum target, GLenum query, GLint *v );

__attribute__((visibility("default"))) void glEvalCoord1d( GLdouble u );
__attribute__((visibility("default"))) void glEvalCoord1f( GLfloat u );

__attribute__((visibility("default"))) void glEvalCoord1dv( const GLdouble *u );
__attribute__((visibility("default"))) void glEvalCoord1fv( const GLfloat *u );

__attribute__((visibility("default"))) void glEvalCoord2d( GLdouble u, GLdouble v );
__attribute__((visibility("default"))) void glEvalCoord2f( GLfloat u, GLfloat v );

__attribute__((visibility("default"))) void glEvalCoord2dv( const GLdouble *u );
__attribute__((visibility("default"))) void glEvalCoord2fv( const GLfloat *u );

__attribute__((visibility("default"))) void glMapGrid1d( GLint un, GLdouble u1, GLdouble u2 );
__attribute__((visibility("default"))) void glMapGrid1f( GLint un, GLfloat u1, GLfloat u2 );

__attribute__((visibility("default"))) void glMapGrid2d( GLint un, GLdouble u1, GLdouble u2,
                                   GLint vn, GLdouble v1, GLdouble v2 );
__attribute__((visibility("default"))) void glMapGrid2f( GLint un, GLfloat u1, GLfloat u2,
                                   GLint vn, GLfloat v1, GLfloat v2 );

__attribute__((visibility("default"))) void glEvalPoint1( GLint i );

__attribute__((visibility("default"))) void glEvalPoint2( GLint i, GLint j );

__attribute__((visibility("default"))) void glEvalMesh1( GLenum mode, GLint i1, GLint i2 );

__attribute__((visibility("default"))) void glEvalMesh2( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );






__attribute__((visibility("default"))) void glFogf( GLenum pname, GLfloat param );

__attribute__((visibility("default"))) void glFogi( GLenum pname, GLint param );

__attribute__((visibility("default"))) void glFogfv( GLenum pname, const GLfloat *params );

__attribute__((visibility("default"))) void glFogiv( GLenum pname, const GLint *params );






__attribute__((visibility("default"))) void glFeedbackBuffer( GLsizei size, GLenum type, GLfloat *buffer );

__attribute__((visibility("default"))) void glPassThrough( GLfloat token );

__attribute__((visibility("default"))) void glSelectBuffer( GLsizei size, GLuint *buffer );

__attribute__((visibility("default"))) void glInitNames( void );

__attribute__((visibility("default"))) void glLoadName( GLuint name );

__attribute__((visibility("default"))) void glPushName( GLuint name );

__attribute__((visibility("default"))) void glPopName( void );
# 1519 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glDrawRangeElements( GLenum mode, GLuint start,
 GLuint end, GLsizei count, GLenum type, const GLvoid *indices );

__attribute__((visibility("default"))) void glTexImage3D( GLenum target, GLint level,
                                      GLint internalFormat,
                                      GLsizei width, GLsizei height,
                                      GLsizei depth, GLint border,
                                      GLenum format, GLenum type,
                                      const GLvoid *pixels );

__attribute__((visibility("default"))) void glTexSubImage3D( GLenum target, GLint level,
                                         GLint xoffset, GLint yoffset,
                                         GLint zoffset, GLsizei width,
                                         GLsizei height, GLsizei depth,
                                         GLenum format,
                                         GLenum type, const GLvoid *pixels);

__attribute__((visibility("default"))) void glCopyTexSubImage3D( GLenum target, GLint level,
                                             GLint xoffset, GLint yoffset,
                                             GLint zoffset, GLint x,
                                             GLint y, GLsizei width,
                                             GLsizei height );

typedef void ( * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
typedef void ( * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 1629 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glColorTable( GLenum target, GLenum internalformat,
                                    GLsizei width, GLenum format,
                                    GLenum type, const GLvoid *table );

__attribute__((visibility("default"))) void glColorSubTable( GLenum target,
                                       GLsizei start, GLsizei count,
                                       GLenum format, GLenum type,
                                       const GLvoid *data );

__attribute__((visibility("default"))) void glColorTableParameteriv(GLenum target, GLenum pname,
                                              const GLint *params);

__attribute__((visibility("default"))) void glColorTableParameterfv(GLenum target, GLenum pname,
                                              const GLfloat *params);

__attribute__((visibility("default"))) void glCopyColorSubTable( GLenum target, GLsizei start,
                                           GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glCopyColorTable( GLenum target, GLenum internalformat,
                                        GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glGetColorTable( GLenum target, GLenum format,
                                       GLenum type, GLvoid *table );

__attribute__((visibility("default"))) void glGetColorTableParameterfv( GLenum target, GLenum pname,
                                                  GLfloat *params );

__attribute__((visibility("default"))) void glGetColorTableParameteriv( GLenum target, GLenum pname,
                                                  GLint *params );

__attribute__((visibility("default"))) void glBlendEquation( GLenum mode );

__attribute__((visibility("default"))) void glBlendColor( GLclampf red, GLclampf green,
                                    GLclampf blue, GLclampf alpha );

__attribute__((visibility("default"))) void glHistogram( GLenum target, GLsizei width,
       GLenum internalformat, GLboolean sink );

__attribute__((visibility("default"))) void glResetHistogram( GLenum target );

__attribute__((visibility("default"))) void glGetHistogram( GLenum target, GLboolean reset,
          GLenum format, GLenum type,
          GLvoid *values );

__attribute__((visibility("default"))) void glGetHistogramParameterfv( GLenum target, GLenum pname,
       GLfloat *params );

__attribute__((visibility("default"))) void glGetHistogramParameteriv( GLenum target, GLenum pname,
       GLint *params );

__attribute__((visibility("default"))) void glMinmax( GLenum target, GLenum internalformat,
    GLboolean sink );

__attribute__((visibility("default"))) void glResetMinmax( GLenum target );

__attribute__((visibility("default"))) void glGetMinmax( GLenum target, GLboolean reset,
                                   GLenum format, GLenum types,
                                   GLvoid *values );

__attribute__((visibility("default"))) void glGetMinmaxParameterfv( GLenum target, GLenum pname,
           GLfloat *params );

__attribute__((visibility("default"))) void glGetMinmaxParameteriv( GLenum target, GLenum pname,
           GLint *params );

__attribute__((visibility("default"))) void glConvolutionFilter1D( GLenum target,
 GLenum internalformat, GLsizei width, GLenum format, GLenum type,
 const GLvoid *image );

__attribute__((visibility("default"))) void glConvolutionFilter2D( GLenum target,
 GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
 GLenum type, const GLvoid *image );

__attribute__((visibility("default"))) void glConvolutionParameterf( GLenum target, GLenum pname,
 GLfloat params );

__attribute__((visibility("default"))) void glConvolutionParameterfv( GLenum target, GLenum pname,
 const GLfloat *params );

__attribute__((visibility("default"))) void glConvolutionParameteri( GLenum target, GLenum pname,
 GLint params );

__attribute__((visibility("default"))) void glConvolutionParameteriv( GLenum target, GLenum pname,
 const GLint *params );

__attribute__((visibility("default"))) void glCopyConvolutionFilter1D( GLenum target,
 GLenum internalformat, GLint x, GLint y, GLsizei width );

__attribute__((visibility("default"))) void glCopyConvolutionFilter2D( GLenum target,
 GLenum internalformat, GLint x, GLint y, GLsizei width,
 GLsizei height);

__attribute__((visibility("default"))) void glGetConvolutionFilter( GLenum target, GLenum format,
 GLenum type, GLvoid *image );

__attribute__((visibility("default"))) void glGetConvolutionParameterfv( GLenum target, GLenum pname,
 GLfloat *params );

__attribute__((visibility("default"))) void glGetConvolutionParameteriv( GLenum target, GLenum pname,
 GLint *params );

__attribute__((visibility("default"))) void glSeparableFilter2D( GLenum target,
 GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
 GLenum type, const GLvoid *row, const GLvoid *column );

__attribute__((visibility("default"))) void glGetSeparableFilter( GLenum target, GLenum format,
 GLenum type, GLvoid *row, GLvoid *column, GLvoid *span );

typedef void ( * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void ( * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void ( * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
typedef void ( * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXPROC) (GLenum target);
# 1883 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glActiveTexture( GLenum texture );

__attribute__((visibility("default"))) void glClientActiveTexture( GLenum texture );

__attribute__((visibility("default"))) void glCompressedTexImage1D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexImage2D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexImage3D( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glCompressedTexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data );

__attribute__((visibility("default"))) void glGetCompressedTexImage( GLenum target, GLint lod, GLvoid *img );

__attribute__((visibility("default"))) void glMultiTexCoord1d( GLenum target, GLdouble s );

__attribute__((visibility("default"))) void glMultiTexCoord1dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord1f( GLenum target, GLfloat s );

__attribute__((visibility("default"))) void glMultiTexCoord1fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord1i( GLenum target, GLint s );

__attribute__((visibility("default"))) void glMultiTexCoord1iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord1s( GLenum target, GLshort s );

__attribute__((visibility("default"))) void glMultiTexCoord1sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord2d( GLenum target, GLdouble s, GLdouble t );

__attribute__((visibility("default"))) void glMultiTexCoord2dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord2f( GLenum target, GLfloat s, GLfloat t );

__attribute__((visibility("default"))) void glMultiTexCoord2fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord2i( GLenum target, GLint s, GLint t );

__attribute__((visibility("default"))) void glMultiTexCoord2iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord2s( GLenum target, GLshort s, GLshort t );

__attribute__((visibility("default"))) void glMultiTexCoord2sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord3d( GLenum target, GLdouble s, GLdouble t, GLdouble r );

__attribute__((visibility("default"))) void glMultiTexCoord3dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord3f( GLenum target, GLfloat s, GLfloat t, GLfloat r );

__attribute__((visibility("default"))) void glMultiTexCoord3fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord3i( GLenum target, GLint s, GLint t, GLint r );

__attribute__((visibility("default"))) void glMultiTexCoord3iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord3s( GLenum target, GLshort s, GLshort t, GLshort r );

__attribute__((visibility("default"))) void glMultiTexCoord3sv( GLenum target, const GLshort *v );

__attribute__((visibility("default"))) void glMultiTexCoord4d( GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q );

__attribute__((visibility("default"))) void glMultiTexCoord4dv( GLenum target, const GLdouble *v );

__attribute__((visibility("default"))) void glMultiTexCoord4f( GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q );

__attribute__((visibility("default"))) void glMultiTexCoord4fv( GLenum target, const GLfloat *v );

__attribute__((visibility("default"))) void glMultiTexCoord4i( GLenum target, GLint s, GLint t, GLint r, GLint q );

__attribute__((visibility("default"))) void glMultiTexCoord4iv( GLenum target, const GLint *v );

__attribute__((visibility("default"))) void glMultiTexCoord4s( GLenum target, GLshort s, GLshort t, GLshort r, GLshort q );

__attribute__((visibility("default"))) void glMultiTexCoord4sv( GLenum target, const GLshort *v );


__attribute__((visibility("default"))) void glLoadTransposeMatrixd( const GLdouble m[16] );

__attribute__((visibility("default"))) void glLoadTransposeMatrixf( const GLfloat m[16] );

__attribute__((visibility("default"))) void glMultTransposeMatrixd( const GLdouble m[16] );

__attribute__((visibility("default"))) void glMultTransposeMatrixf( const GLfloat m[16] );

__attribute__((visibility("default"))) void glSampleCoverage( GLclampf value, GLboolean invert );

typedef void ( * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat *m);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble *m);
typedef void ( * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, void *img);
# 2066 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glActiveTextureARB(GLenum texture);
__attribute__((visibility("default"))) void glClientActiveTextureARB(GLenum texture);
__attribute__((visibility("default"))) void glMultiTexCoord1dARB(GLenum target, GLdouble s);
__attribute__((visibility("default"))) void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord1fARB(GLenum target, GLfloat s);
__attribute__((visibility("default"))) void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord1iARB(GLenum target, GLint s);
__attribute__((visibility("default"))) void glMultiTexCoord1ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord1sARB(GLenum target, GLshort s);
__attribute__((visibility("default"))) void glMultiTexCoord1svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
__attribute__((visibility("default"))) void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
__attribute__((visibility("default"))) void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
__attribute__((visibility("default"))) void glMultiTexCoord2ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
__attribute__((visibility("default"))) void glMultiTexCoord2svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
__attribute__((visibility("default"))) void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
__attribute__((visibility("default"))) void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
__attribute__((visibility("default"))) void glMultiTexCoord3ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
__attribute__((visibility("default"))) void glMultiTexCoord3svARB(GLenum target, const GLshort *v);
__attribute__((visibility("default"))) void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__attribute__((visibility("default"))) void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
__attribute__((visibility("default"))) void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__attribute__((visibility("default"))) void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
__attribute__((visibility("default"))) void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
__attribute__((visibility("default"))) void glMultiTexCoord4ivARB(GLenum target, const GLint *v);
__attribute__((visibility("default"))) void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
__attribute__((visibility("default"))) void glMultiTexCoord4svARB(GLenum target, const GLshort *v);

typedef void ( * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
# 2150 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
# 1 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h" 1




extern "C" {
# 3388 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 3389 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h" 2


typedef char GLchar;




typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;




typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;




typedef char GLcharARB;
typedef unsigned int GLhandleARB;




typedef unsigned short GLhalfARB;



typedef unsigned short GLhalfNV;
# 3454 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 1 3
# 16 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 3
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdint.h" 1 3 4


# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 1 3 4
# 13 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
extern "C" {
# 41 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed char int8_t ;
typedef unsigned char uint8_t ;




typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;




typedef signed short int16_t;
typedef unsigned short uint16_t;
# 67 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;
# 79 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed int int32_t;
typedef unsigned int uint32_t;
# 97 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;
# 119 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed long long int64_t;
typedef unsigned long long uint64_t;
# 129 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;
# 159 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef signed int int_fast8_t;
  typedef unsigned int uint_fast8_t;




  typedef signed int int_fast16_t;
  typedef unsigned int uint_fast16_t;




  typedef signed int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 213 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef int_least64_t int_fast64_t;
  typedef uint_least64_t uint_fast64_t;







  typedef long long int intmax_t;
# 231 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
  typedef long long unsigned int uintmax_t;
# 243 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
typedef signed int intptr_t;
typedef unsigned int uintptr_t;
# 490 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/stdint.h" 3 4
}
# 4 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stdint.h" 2 3 4
# 17 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 2 3

# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/include/stddef.h" 1 3 4
# 19 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 2 3
# 270 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/inttypes.h" 3
typedef struct {
  intmax_t quot;
  intmax_t rem;
} imaxdiv_t;


extern "C" {


extern intmax_t imaxabs(intmax_t j);
extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denomer);
extern intmax_t strtoimax(const char *__restrict, char **__restrict, int);
extern uintmax_t strtoumax(const char *__restrict, char **__restrict, int);
extern intmax_t wcstoimax(const wchar_t *__restrict, wchar_t **__restrict, int);
extern uintmax_t wcstoumax(const wchar_t *__restrict, wchar_t **__restrict, int);


}
# 3455 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h" 2




typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;
# 3692 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void ( * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void ( * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
typedef void ( * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVPROC) (const GLshort *v);
# 3762 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISQUERYPROC) (GLuint id);
typedef void ( * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLENDQUERYPROC) (GLenum target);
typedef void ( * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
typedef void ( * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
typedef void ( * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
typedef GLboolean ( * PFNGLISBUFFERPROC) (GLuint buffer);
typedef void ( * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
typedef void ( * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
typedef GLvoid* ( * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERPROC) (GLenum target);
typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid* *params);
# 3880 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum *bufs);
typedef void ( * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void ( * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar *name);
typedef void ( * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint ( * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint ( * PFNGLCREATESHADERPROC) (GLenum type);
typedef void ( * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void ( * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *obj);
typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void ( * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void ( * PFNGLGETSHADERSOURCEPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat *params);
typedef void ( * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean ( * PFNGLISSHADERPROC) (GLuint shader);
typedef void ( * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar* *string, const GLint *length);
typedef void ( * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
# 3985 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
# 4075 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);







typedef void ( * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
# 4108 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint level, GLvoid *img);
# 4127 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat *params);
# 4145 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLWEIGHTBVARBPROC) (GLint size, const GLbyte *weights);
typedef void ( * PFNGLWEIGHTSVARBPROC) (GLint size, const GLshort *weights);
typedef void ( * PFNGLWEIGHTIVARBPROC) (GLint size, const GLint *weights);
typedef void ( * PFNGLWEIGHTFVARBPROC) (GLint size, const GLfloat *weights);
typedef void ( * PFNGLWEIGHTDVARBPROC) (GLint size, const GLdouble *weights);
typedef void ( * PFNGLWEIGHTUBVARBPROC) (GLint size, const GLubyte *weights);
typedef void ( * PFNGLWEIGHTUSVARBPROC) (GLint size, const GLushort *weights);
typedef void ( * PFNGLWEIGHTUIVARBPROC) (GLint size, const GLuint *weights);
typedef void ( * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXBLENDARBPROC) (GLint count);
# 4166 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void ( * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, const GLubyte *indices);
typedef void ( * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, const GLushort *indices);
typedef void ( * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, const GLuint *indices);
typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 4221 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVARBPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVARBPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVARBPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVARBPROC) (const GLshort *v);
# 4305 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void ( * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void ( * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint *programs);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMARBPROC) (GLuint program);
# 4389 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint *buffers);
typedef void ( * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint *buffers);
typedef GLboolean ( * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void ( * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
typedef GLvoid* ( * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid* *params);
# 4414 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISQUERYARBPROC) (GLuint id);
typedef void ( * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void ( * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint *params);
# 4467 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void ( * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void ( * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB* *string, const GLint *length);
typedef void ( * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef void ( * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void ( * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void ( * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint *value);
typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint *params);
typedef void ( * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB *name);
typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
typedef void ( * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat *params);
typedef void ( * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint *params);
typedef void ( * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
# 4515 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
typedef void ( * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB *name);
# 4545 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum *bufs);
# 4557 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
# 4581 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);







typedef void ( * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
# 4602 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
# 4612 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat *weights);
typedef void ( * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);
# 4622 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
# 4635 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 4656 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXEXTPROC) (GLenum target);
# 4685 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
# 4715 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint *params);







typedef void ( * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
# 4742 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPIXELTEXGENPARAMETERISGISPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLPIXELTEXGENPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, GLint *params);
typedef void ( * PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, GLfloat *params);
# 4756 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
# 4778 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint *textures, GLboolean *residences);
typedef void ( * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void ( * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint *textures);
typedef void ( * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint *textures);
typedef GLboolean ( * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint *textures, const GLclampf *priorities);
# 4792 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
# 4802 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
# 4820 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
# 4841 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void ( * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void ( * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void ( * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
# 4881 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
# 4912 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, const GLint *params);
# 4928 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat *params);
# 4938 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPOINTPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
# 4952 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLint ( * PFNGLGETINSTRUMENTSSGIXPROC) (void);
typedef void ( * PFNGLINSTRUMENTSBUFFERSGIXPROC) (GLsizei size, GLint *buffer);
typedef GLint ( * PFNGLPOLLINSTRUMENTSSGIXPROC) (GLint *marker_p);
typedef void ( * PFNGLREADINSTRUMENTSSGIXPROC) (GLint marker);
typedef void ( * PFNGLSTARTINSTRUMENTSSGIXPROC) (void);
typedef void ( * PFNGLSTOPINSTRUMENTSSGIXPROC) (GLint marker);
# 4969 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);







typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
# 4988 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDEFORMATIONMAP3DSGIXPROC) (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
typedef void ( * PFNGLDEFORMATIONMAP3FSGIXPROC) (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
typedef void ( * PFNGLDEFORMSGIXPROC) (GLbitfield mask);
typedef void ( * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);







typedef void ( * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble *equation);







typedef void ( * PFNGLFLUSHRASTERSGIXPROC) (void);
# 5020 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat *points);
typedef void ( * PFNGLGETFOGFUNCSGISPROC) (GLfloat *points);
# 5038 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, GLfloat *params);
# 5060 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
# 5073 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLHINTPGIPROC) (GLenum target, GLint mode);
# 5084 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
# 5104 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, GLint *params);
typedef void ( * PFNGLLISTPARAMETERFSGIXPROC) (GLuint list, GLenum pname, GLfloat param);
typedef void ( * PFNGLLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLLISTPARAMETERISGIXPROC) (GLuint list, GLenum pname, GLint param);
typedef void ( * PFNGLLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, const GLint *params);
# 5137 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);







typedef void ( * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLclampf ref);
# 5158 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void ( * PFNGLUNLOCKARRAYSEXTPROC) (void);
# 5168 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble *params);
typedef void ( * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat *params);
# 5198 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, const GLint *params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint *params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint *params);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, GLint *params);
typedef void ( * PFNGLLIGHTENVISGIXPROC) (GLenum pname, GLint param);
# 5231 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
# 5249 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void ( * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void ( * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
# 5272 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint ( * PFNGLFINISHASYNCSGIXPROC) (GLuint *markerp);
typedef GLint ( * PFNGLPOLLASYNCSGIXPROC) (GLuint *markerp);
typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
# 5296 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
# 5314 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
# 5353 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);







typedef void ( * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
# 5386 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
# 5399 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
typedef void ( * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
# 5436 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTANGENT3BEXTPROC) (GLbyte tx, GLbyte ty, GLbyte tz);
typedef void ( * PFNGLTANGENT3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLTANGENT3DEXTPROC) (GLdouble tx, GLdouble ty, GLdouble tz);
typedef void ( * PFNGLTANGENT3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLTANGENT3FEXTPROC) (GLfloat tx, GLfloat ty, GLfloat tz);
typedef void ( * PFNGLTANGENT3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLTANGENT3IEXTPROC) (GLint tx, GLint ty, GLint tz);
typedef void ( * PFNGLTANGENT3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLTANGENT3SEXTPROC) (GLshort tx, GLshort ty, GLshort tz);
typedef void ( * PFNGLTANGENT3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLBINORMAL3BEXTPROC) (GLbyte bx, GLbyte by, GLbyte bz);
typedef void ( * PFNGLBINORMAL3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLBINORMAL3DEXTPROC) (GLdouble bx, GLdouble by, GLdouble bz);
typedef void ( * PFNGLBINORMAL3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLBINORMAL3FEXTPROC) (GLfloat bx, GLfloat by, GLfloat bz);
typedef void ( * PFNGLBINORMAL3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLBINORMAL3IEXTPROC) (GLint bx, GLint by, GLint bz);
typedef void ( * PFNGLBINORMAL3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLBINORMAL3SEXTPROC) (GLshort bx, GLshort by, GLshort bz);
typedef void ( * PFNGLBINORMAL3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
# 5481 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFINISHTEXTURESUNXPROC) (void);
# 5496 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
# 5517 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint *code);
typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort *code);
typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte *code);
typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const GLvoid* *pointer);
# 5570 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat *tc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint *rc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);







typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);







typedef void ( * PFNGLBLENDFUNCSEPARATEINGRPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 5671 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC) (const GLfloat *weight);
typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 5686 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void ( * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, const GLvoid *pointer);
# 5707 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint *params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint *params);
# 5743 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC) (void);
# 5774 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort *v);
typedef void ( * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble *v);
typedef void ( * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat *v);
typedef void ( * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLWINDOWPOS4IVMESAPROC) (const GLint *v);
typedef void ( * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort *v);
# 5810 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount, GLint modestride);
# 5826 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean* *pointer, GLint ptrstride);
typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
# 5865 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
# 5874 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
# 5899 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXTURECOLORMASKSGISPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);







typedef void ( * PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, const GLvoid *params);
# 5929 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint *fences);
typedef void ( * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint *fences);
typedef GLboolean ( * PFNGLISFENCENVPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint *params);
typedef void ( * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
# 5951 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
typedef void ( * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
# 5972 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat *params);
# 6064 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint *programs, GLboolean *residences);
typedef void ( * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat *params);
typedef void ( * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint *programs);
typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte *program);
typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean ( * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void ( * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble *v);
typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat *v);
typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLuint count, const GLdouble *v);
typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLuint count, const GLfloat *v);
typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
typedef void ( * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei count, const GLubyte *v);
# 6162 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, const GLint *param);
typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, const GLfloat *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
# 6186 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void ( * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat *value);
# 6208 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
# 6228 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const GLvoid *pointer, GLenum usage);
typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint *params);
typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint *params);
typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint *params);
# 6288 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void ( * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void ( * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void ( * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC) (GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
typedef void ( * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
typedef void ( * PFNGLVARIANTBVEXTPROC) (GLuint id, const GLbyte *addr);
typedef void ( * PFNGLVARIANTSVEXTPROC) (GLuint id, const GLshort *addr);
typedef void ( * PFNGLVARIANTIVEXTPROC) (GLuint id, const GLint *addr);
typedef void ( * PFNGLVARIANTFVEXTPROC) (GLuint id, const GLfloat *addr);
typedef void ( * PFNGLVARIANTDVEXTPROC) (GLuint id, const GLdouble *addr);
typedef void ( * PFNGLVARIANTUBVEXTPROC) (GLuint id, const GLubyte *addr);
typedef void ( * PFNGLVARIANTUSVEXTPROC) (GLuint id, const GLushort *addr);
typedef void ( * PFNGLVARIANTUIVEXTPROC) (GLuint id, const GLuint *addr);
typedef void ( * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, GLvoid* *data);
typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
# 6381 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
typedef void ( * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void ( * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort nx, GLshort ny, GLshort nz);
typedef void ( * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint nx, GLint ny, GLint nz);
typedef void ( * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
typedef void ( * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
typedef void ( * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void ( * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
# 6435 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const GLvoid *pointer);
typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);







typedef void ( * PFNGLDRAWMESHARRAYSSUNPROC) (GLenum mode, GLint first, GLsizei count, GLsizei width);
# 6471 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint *ids);
typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint *params);
# 6486 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
# 6507 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
# 6527 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const GLvoid *pointer);
typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
# 6546 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint *fences);
typedef void ( * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint *fences);
typedef void ( * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
typedef void ( * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
# 6564 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint *arrays);
typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, GLuint *arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
# 6577 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
# 6595 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum *bufs);
# 6628 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
# 6686 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEX2HNVPROC) (GLhalfNV x, GLhalfNV y);
typedef void ( * PFNGLVERTEX2HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEX3HNVPROC) (GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void ( * PFNGLVERTEX3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEX4HNVPROC) (GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void ( * PFNGLVERTEX4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLNORMAL3HNVPROC) (GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
typedef void ( * PFNGLNORMAL3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLCOLOR3HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void ( * PFNGLCOLOR3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLCOLOR4HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
typedef void ( * PFNGLCOLOR4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD1HNVPROC) (GLhalfNV s);
typedef void ( * PFNGLTEXCOORD1HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD2HNVPROC) (GLhalfNV s, GLhalfNV t);
typedef void ( * PFNGLTEXCOORD2HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD3HNVPROC) (GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void ( * PFNGLTEXCOORD3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLTEXCOORD4HNVPROC) (GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void ( * PFNGLTEXCOORD4HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalfNV s);
typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t);
typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalfNV *v);
typedef void ( * PFNGLFOGCOORDHNVPROC) (GLhalfNV fog);
typedef void ( * PFNGLFOGCOORDHVNVPROC) (const GLhalfNV *fog);
typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalfNV *v);
typedef void ( * PFNGLVERTEXWEIGHTHNVPROC) (GLhalfNV weight);
typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalfNV *weight);
typedef void ( * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalfNV x);
typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y);
typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
# 6740 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
# 6750 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC) (void);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
# 6768 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLvoid* ( * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
# 6778 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
# 6789 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint *params);
# 6803 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
# 6815 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
# 6867 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint *renderbuffers);
typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint *renderbuffers);
typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint *framebuffers);
typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint *framebuffers);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void ( * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);







typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const GLvoid *string);
# 6903 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLSTENCILCLEARTAGEXTPROC) (GLsizei stencilTagBits, GLuint stencilClearTag);
# 6915 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);







typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 6936 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);
# 6946 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
# 6956 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);
# 6980 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC) (GLenum target, GLuint index, GLint *params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC) (GLenum target, GLuint index, GLuint *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERIIVNVPROC) (GLenum target, GLuint index, GLint *params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC) (GLenum target, GLuint index, GLuint *params);
# 7006 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);







typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);
# 7047 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
# 7087 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
# 7106 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
# 7123 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 7145 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
typedef void ( * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void ( * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
# 7159 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 7177 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
# 7192 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum target, GLuint index, GLboolean *data);
typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLint *data);
typedef void ( * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
# 7215 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void ( * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
typedef void ( * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
# 7235 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);
typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
# 7250 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/glext.h"
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);
typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void ( * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);







typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC) (void);




}
# 2151 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h" 2
# 2165 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) GLhandleARB glCreateDebugObjectMESA (void);
__attribute__((visibility("default"))) void glClearDebugLogMESA (GLhandleARB obj, GLenum logType, GLenum shaderType);
__attribute__((visibility("default"))) void glGetDebugLogMESA (GLhandleARB obj, GLenum logType, GLenum shaderType, GLsizei maxLength,
                                         GLsizei *length, GLcharARB *debugLog);
__attribute__((visibility("default"))) GLsizei glGetDebugLogLengthMESA (GLhandleARB obj, GLenum logType, GLenum shaderType);
# 2204 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
typedef void (*GLprogramcallbackMESA)(GLenum target, GLvoid *data);

__attribute__((visibility("default"))) void glProgramCallbackMESA(GLenum target, GLprogramcallbackMESA callback, GLvoid *data);

__attribute__((visibility("default"))) void glGetProgramRegisterfvMESA(GLenum target, GLsizei len, const GLubyte *name, GLfloat *v);
# 2218 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
__attribute__((visibility("default"))) void glBlendEquationSeparateATI( GLenum modeRGB, GLenum modeA );
typedef void ( * PFNGLBLENDEQUATIONSEPARATEATIPROC) (GLenum modeRGB, GLenum modeA);
# 2249 "d:/Data/Nintendo/DoomGX/gl2gx/include/GL/gl.h"
}
# 57 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/qgl.h" 2
# 79 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/qgl.h"
typedef void (*GLExtension_t)(void);


 extern "C" {


GLExtension_t GLimp_ExtensionPointer( const char *name );


 }



extern void ( * qglMultiTexCoord2fARB )( GLenum texture, GLfloat s, GLfloat t );
extern void ( * qglMultiTexCoord2fvARB )( GLenum texture, GLfloat *st );
extern void ( * qglActiveTextureARB )( GLenum texture );
extern void ( * qglClientActiveTextureARB )( GLenum texture );


extern PFNGLBINDBUFFERARBPROC qglBindBufferARB;
extern PFNGLDELETEBUFFERSARBPROC qglDeleteBuffersARB;
extern PFNGLGENBUFFERSARBPROC qglGenBuffersARB;
extern PFNGLISBUFFERARBPROC qglIsBufferARB;
extern PFNGLBUFFERDATAARBPROC qglBufferDataARB;
extern PFNGLBUFFERSUBDATAARBPROC qglBufferSubDataARB;
extern PFNGLGETBUFFERSUBDATAARBPROC qglGetBufferSubDataARB;
extern PFNGLMAPBUFFERARBPROC qglMapBufferARB;
extern PFNGLUNMAPBUFFERARBPROC qglUnmapBufferARB;
extern PFNGLGETBUFFERPARAMETERIVARBPROC qglGetBufferParameterivARB;
extern PFNGLGETBUFFERPOINTERVARBPROC qglGetBufferPointervARB;



extern void ( *qglCombinerParameterfvNV )( GLenum pname, const GLfloat *params );
extern void ( *qglCombinerParameterivNV )( GLenum pname, const GLint *params );
extern void ( *qglCombinerParameterfNV )( GLenum pname, const GLfloat param );
extern void ( *qglCombinerParameteriNV )( GLenum pname, const GLint param );
extern void ( *qglCombinerInputNV )( GLenum stage, GLenum portion, GLenum variable, GLenum input,
             GLenum mapping, GLenum componentUsage );
extern void ( *qglCombinerOutputNV )( GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput,
              GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct,
              GLboolean cdDotProduct, GLboolean muxSum );
extern void ( *qglFinalCombinerInputNV )( GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage );


extern void ( *qglTexImage3D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);


extern void ( *qglColorTableEXT)( int, int, int, int, int, const void * );


extern PFNGLGENFRAGMENTSHADERSATIPROC qglGenFragmentShadersATI;
extern PFNGLBINDFRAGMENTSHADERATIPROC qglBindFragmentShaderATI;
extern PFNGLDELETEFRAGMENTSHADERATIPROC qglDeleteFragmentShaderATI;
extern PFNGLBEGINFRAGMENTSHADERATIPROC qglBeginFragmentShaderATI;
extern PFNGLENDFRAGMENTSHADERATIPROC qglEndFragmentShaderATI;
extern PFNGLPASSTEXCOORDATIPROC qglPassTexCoordATI;
extern PFNGLSAMPLEMAPATIPROC qglSampleMapATI;
extern PFNGLCOLORFRAGMENTOP1ATIPROC qglColorFragmentOp1ATI;
extern PFNGLCOLORFRAGMENTOP2ATIPROC qglColorFragmentOp2ATI;
extern PFNGLCOLORFRAGMENTOP3ATIPROC qglColorFragmentOp3ATI;
extern PFNGLALPHAFRAGMENTOP1ATIPROC qglAlphaFragmentOp1ATI;
extern PFNGLALPHAFRAGMENTOP2ATIPROC qglAlphaFragmentOp2ATI;
extern PFNGLALPHAFRAGMENTOP3ATIPROC qglAlphaFragmentOp3ATI;
extern PFNGLSETFRAGMENTSHADERCONSTANTATIPROC qglSetFragmentShaderConstantATI;


extern PFNGLACTIVESTENCILFACEEXTPROC qglActiveStencilFaceEXT;



extern PFNGLSTENCILOPSEPARATEATIPROC qglStencilOpSeparateATI;
extern PFNGLSTENCILFUNCSEPARATEATIPROC qglStencilFuncSeparateATI;


extern PFNGLCOMPRESSEDTEXIMAGE2DARBPROC qglCompressedTexImage2DARB;
extern PFNGLGETCOMPRESSEDTEXIMAGEARBPROC qglGetCompressedTexImageARB;


extern PFNGLVERTEXATTRIBPOINTERARBPROC qglVertexAttribPointerARB;
extern PFNGLENABLEVERTEXATTRIBARRAYARBPROC qglEnableVertexAttribArrayARB;
extern PFNGLDISABLEVERTEXATTRIBARRAYARBPROC qglDisableVertexAttribArrayARB;
extern PFNGLPROGRAMSTRINGARBPROC qglProgramStringARB;
extern PFNGLBINDPROGRAMARBPROC qglBindProgramARB;
extern PFNGLGENPROGRAMSARBPROC qglGenProgramsARB;
extern PFNGLPROGRAMENVPARAMETER4FVARBPROC qglProgramEnvParameter4fvARB;
extern PFNGLPROGRAMLOCALPARAMETER4FVARBPROC qglProgramLocalParameter4fvARB;


extern PFNGLDEPTHBOUNDSEXTPROC qglDepthBoundsEXT;






# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/qgl_linked.h" 1
# 176 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/qgl.h" 2
# 149 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Cinematic.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Cinematic.h"
typedef enum {
 FMV_IDLE,
 FMV_PLAY,
 FMV_EOF,
 FMV_ID_BLT,
 FMV_ID_IDLE,
 FMV_LOOPED,
 FMV_ID_WAIT
} cinStatus_t;


typedef struct {
 int imageWidth, imageHeight;
 const byte * image;
 int status;
} cinData_t;

class idCinematic {
public:

 static void InitCinematic( void );


 static void ShutdownCinematic( void );



 static idCinematic *Alloc();


 virtual ~idCinematic();


 virtual bool InitFromFile( const char *qpath, bool looping );


 virtual int AnimationLength();


 virtual cinData_t ImageForTime( int milliseconds );


 virtual void Close();


 virtual void ResetTime(int time);
};
# 100 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Cinematic.h"
class idSndWindow : public idCinematic {
public:

      idSndWindow() { showWaveform = false; }
      ~idSndWindow() {}

 bool InitFromFile( const char *qpath, bool looping );
 cinData_t ImageForTime( int milliseconds );
 int AnimationLength();

private:
 bool showWaveform;
};
# 150 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Material.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Material.h"
class idImage;
class idCinematic;
class idUserInterface;
class idMegaTexture;


typedef enum {
 TF_LINEAR,
 TF_NEAREST,
 TF_DEFAULT
} textureFilter_t;

typedef enum {
 TR_REPEAT,
 TR_CLAMP,
 TR_CLAMP_TO_BORDER,

 TR_CLAMP_TO_ZERO,

 TR_CLAMP_TO_ZERO_ALPHA

} textureRepeat_t;

typedef struct {
 int stayTime;
 int fadeTime;
 float start[4];
 float end[4];
} decalInfo_t;

typedef enum {
 DFRM_NONE,
 DFRM_SPRITE,
 DFRM_TUBE,
 DFRM_FLARE,
 DFRM_EXPAND,
 DFRM_MOVE,
 DFRM_EYEBALL,
 DFRM_PARTICLE,
 DFRM_PARTICLE2,
 DFRM_TURB
} deform_t;

typedef enum {
 DI_STATIC,
 DI_SCRATCH,
 DI_CUBE_RENDER,
 DI_MIRROR_RENDER,
 DI_XRAY_RENDER,
 DI_REMOTE_RENDER
} dynamicidImage_t;


typedef enum {
 OP_TYPE_ADD,
 OP_TYPE_SUBTRACT,
 OP_TYPE_MULTIPLY,
 OP_TYPE_DIVIDE,
 OP_TYPE_MOD,
 OP_TYPE_TABLE,
 OP_TYPE_GT,
 OP_TYPE_GE,
 OP_TYPE_LT,
 OP_TYPE_LE,
 OP_TYPE_EQ,
 OP_TYPE_NE,
 OP_TYPE_AND,
 OP_TYPE_OR,
 OP_TYPE_SOUND
} expOpType_t;

typedef enum {
 EXP_REG_TIME,

 EXP_REG_PARM0,
 EXP_REG_PARM1,
 EXP_REG_PARM2,
 EXP_REG_PARM3,
 EXP_REG_PARM4,
 EXP_REG_PARM5,
 EXP_REG_PARM6,
 EXP_REG_PARM7,
 EXP_REG_PARM8,
 EXP_REG_PARM9,
 EXP_REG_PARM10,
 EXP_REG_PARM11,

 EXP_REG_GLOBAL0,
 EXP_REG_GLOBAL1,
 EXP_REG_GLOBAL2,
 EXP_REG_GLOBAL3,
 EXP_REG_GLOBAL4,
 EXP_REG_GLOBAL5,
 EXP_REG_GLOBAL6,
 EXP_REG_GLOBAL7,

 EXP_REG_NUM_PREDEFINED
} expRegister_t;

typedef struct {
 expOpType_t opType;
 int a, b, c;
} expOp_t;

typedef struct {
 int registers[4];
} colorStage_t;

typedef enum {
 TG_EXPLICIT,
 TG_DIFFUSE_CUBE,
 TG_REFLECT_CUBE,
 TG_SKYBOX_CUBE,
 TG_WOBBLESKY_CUBE,
 TG_SCREEN,
 TG_SCREEN2,
 TG_GLASSWARP
} texgen_t;

typedef struct {
 idCinematic * cinematic;
 idImage * image;
 texgen_t texgen;
 bool hasMatrix;
 int matrix[2][3];


 dynamicidImage_t dynamic;
 int width, height;
 int dynamicFrameCount;
} textureStage_t;


typedef enum {
 SL_AMBIENT,
 SL_BUMP,
 SL_DIFFUSE,
 SL_SPECULAR
} stageLighting_t;



typedef enum {
 SVC_IGNORE,
 SVC_MODULATE,
 SVC_INVERSE_MODULATE
} stageVertexColor_t;

static const int MAX_FRAGMENT_IMAGES = 8;
static const int MAX_VERTEX_PARMS = 4;

typedef struct {
 int vertexProgram;
 int numVertexParms;
 int vertexParms[MAX_VERTEX_PARMS][4];

 int fragmentProgram;
 int numFragmentProgramImages;
 idImage * fragmentProgramImages[MAX_FRAGMENT_IMAGES];

 idMegaTexture *megaTexture;
} newShaderStage_t;

typedef struct {
 int conditionRegister;
 stageLighting_t lighting;
 int drawStateBits;
 colorStage_t color;
 bool hasAlphaTest;
 int alphaTestRegister;
 textureStage_t texture;
 stageVertexColor_t vertexColor;
 bool ignoreAlphaTest;

 float privatePolygonOffset;

 newShaderStage_t *newStage;
} shaderStage_t;

typedef enum {
 MC_BAD,
 MC_OPAQUE,
 MC_PERFORATED,
 MC_TRANSLUCENT
} materialCoverage_t;

typedef enum {
 SS_SUBVIEW = -3,
 SS_GUI = -2,
 SS_BAD = -1,
 SS_OPAQUE,

 SS_PORTAL_SKY,

 SS_DECAL,

 SS_FAR,
 SS_MEDIUM,
 SS_CLOSE,

 SS_ALMOST_NEAREST,

 SS_NEAREST,

 SS_POST_PROCESS = 100
} materialSort_t;

typedef enum {
 CT_FRONT_SIDED,
 CT_BACK_SIDED,
 CT_TWO_SIDED
} cullType_t;


const int MAX_SHADER_STAGES = 256;

const int MAX_TEXGEN_REGISTERS = 4;

const int MAX_ENTITY_SHADER_PARMS = 12;


typedef enum {
 MF_DEFAULTED = ( 1 << ( 0 ) ),
 MF_POLYGONOFFSET = ( 1 << ( 1 ) ),
 MF_NOSHADOWS = ( 1 << ( 2 ) ),
 MF_FORCESHADOWS = ( 1 << ( 3 ) ),
 MF_NOSELFSHADOW = ( 1 << ( 4 ) ),
 MF_NOPORTALFOG = ( 1 << ( 5 ) ),
 MF_EDITOR_VISIBLE = ( 1 << ( 6 ) )
} materialFlags_t;


typedef enum {
 CONTENTS_SOLID = ( 1 << ( 0 ) ),
 CONTENTS_OPAQUE = ( 1 << ( 1 ) ),
 CONTENTS_WATER = ( 1 << ( 2 ) ),
 CONTENTS_PLAYERCLIP = ( 1 << ( 3 ) ),
 CONTENTS_MONSTERCLIP = ( 1 << ( 4 ) ),
 CONTENTS_MOVEABLECLIP = ( 1 << ( 5 ) ),
 CONTENTS_IKCLIP = ( 1 << ( 6 ) ),
 CONTENTS_BLOOD = ( 1 << ( 7 ) ),
 CONTENTS_BODY = ( 1 << ( 8 ) ),
 CONTENTS_PROJECTILE = ( 1 << ( 9 ) ),
 CONTENTS_CORPSE = ( 1 << ( 10 ) ),
 CONTENTS_RENDERMODEL = ( 1 << ( 11 ) ),
 CONTENTS_TRIGGER = ( 1 << ( 12 ) ),
 CONTENTS_AAS_SOLID = ( 1 << ( 13 ) ),
 CONTENTS_AAS_OBSTACLE = ( 1 << ( 14 ) ),
 CONTENTS_FLASHLIGHT_TRIGGER = ( 1 << ( 15 ) ),


 CONTENTS_AREAPORTAL = ( 1 << ( 20 ) ),
 CONTENTS_NOCSG = ( 1 << ( 21 ) ),

 CONTENTS_REMOVE_UTIL = ~(CONTENTS_AREAPORTAL|CONTENTS_NOCSG)
} contentsFlags_t;


const int NUM_SURFACE_BITS = 4;
const int MAX_SURFACE_TYPES = 1 << NUM_SURFACE_BITS;

typedef enum {
 SURFTYPE_NONE,
    SURFTYPE_METAL,
 SURFTYPE_STONE,
 SURFTYPE_FLESH,
 SURFTYPE_WOOD,
 SURFTYPE_CARDBOARD,
 SURFTYPE_LIQUID,
 SURFTYPE_GLASS,
 SURFTYPE_PLASTIC,
 SURFTYPE_RICOCHET,
 SURFTYPE_10,
 SURFTYPE_11,
 SURFTYPE_12,
 SURFTYPE_13,
 SURFTYPE_14,
 SURFTYPE_15
} surfTypes_t;


typedef enum {
 SURF_TYPE_BIT0 = ( 1 << ( 0 ) ),
 SURF_TYPE_BIT1 = ( 1 << ( 1 ) ),
 SURF_TYPE_BIT2 = ( 1 << ( 2 ) ),
 SURF_TYPE_BIT3 = ( 1 << ( 3 ) ),
 SURF_TYPE_MASK = ( 1 << NUM_SURFACE_BITS ) - 1,

 SURF_NODAMAGE = ( 1 << ( 4 ) ),
 SURF_SLICK = ( 1 << ( 5 ) ),
 SURF_COLLISION = ( 1 << ( 6 ) ),
 SURF_LADDER = ( 1 << ( 7 ) ),
 SURF_NOIMPACT = ( 1 << ( 8 ) ),
 SURF_NOSTEPS = ( 1 << ( 9 ) ),
 SURF_DISCRETE = ( 1 << ( 10 ) ),
 SURF_NOFRAGMENT = ( 1 << ( 11 ) ),
 SURF_NULLNORMAL = ( 1 << ( 12 ) )

} surfaceFlags_t;

class idSoundEmitter;

class idMaterial : public idDecl {
public:
      idMaterial();
 virtual ~idMaterial();

 virtual size_t Size( void ) const;
 virtual bool SetDefaultText( void );
 virtual const char *DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void Print( void ) const;


 bool Save( const char *fileName = __null );




 virtual const char *ImageName( void ) const;

 void ReloadImages( bool force ) const;


 const int GetNumStages( void ) const { return numStages; }


 const shaderStage_t *GetStage( const int index ) const { ((void)0); return &stages[index]; }



 const shaderStage_t *GetBumpStage( void ) const;





 bool IsDrawn( void ) const { return ( numStages > 0 || entityGui != 0 || gui != __null ); }


 bool HasAmbient( void ) const { return ( numAmbientStages > 0 ); }


 bool HasGui( void ) const { return ( entityGui != 0 || gui != __null ); }



 bool HasSubview( void ) const { return hasSubview; }



 bool SurfaceCastsShadow( void ) const { return TestMaterialFlag( MF_FORCESHADOWS ) || !TestMaterialFlag( MF_NOSHADOWS ); }



 bool ReceivesFog( void ) const { return ( IsDrawn() && !noFog && coverage != MC_TRANSLUCENT ); }




 bool ReceivesLighting( void ) const { return numAmbientStages != numStages; }



 bool ReceivesLightingOnBackSides( void ) const { return ( materialFlags & (MF_NOSELFSHADOW|MF_NOSHADOWS) ) != 0; }






 bool ShouldCreateBackSides( void ) const { return shouldCreateBackSides; }




 bool UseUnsmoothedTangents( void ) const { return unsmoothedTangents; }




 bool AllowOverlays( void ) const { return allowOverlays; }





 materialCoverage_t Coverage( void ) const { return coverage; }


 bool HasHigherDmapPriority( const idMaterial &other ) const { return ( IsDrawn() && !other.IsDrawn() ) ||
                      ( Coverage() < other.Coverage() ); }


 idUserInterface * GlobalGui( void ) const { return gui; }





 bool IsDiscrete( void ) const { return ( entityGui || gui || deform != DFRM_NONE || sort == SS_SUBVIEW ||
            ( surfaceFlags & SURF_DISCRETE ) != 0 ); }
# 452 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Material.h"
 bool NoFragment( void ) const { return ( surfaceFlags & SURF_NOFRAGMENT ) != 0; }





 bool IsFogLight() const { return fogLight; }


 bool IsBlendLight() const { return blendLight; }


 bool IsAmbientLight() const { return ambientLight; }



 bool LightCastsShadows() const { return TestMaterialFlag( MF_FORCESHADOWS ) ||
        ( !fogLight && !ambientLight && !blendLight && !TestMaterialFlag( MF_NOSHADOWS ) ); }







 bool LightEffectsBackSides() const { return fogLight || ambientLight || blendLight; }


 idImage * LightFalloffImage() const { return lightFalloffImage; }




 const char * GetRenderBump() const { return renderBump; };


 void SetMaterialFlag( const int flag ) const { materialFlags |= flag; }


 void ClearMaterialFlag( const int flag ) const { materialFlags &= ~flag; }


 bool TestMaterialFlag( const int flag ) const { return ( materialFlags & flag ) != 0; }


 const int GetContentFlags( void ) const { return contentFlags; }


 const int GetSurfaceFlags( void ) const { return surfaceFlags; }


 const surfTypes_t GetSurfaceType( void ) const { return static_cast<surfTypes_t>( surfaceFlags & SURF_TYPE_MASK ); }


 const char * GetDescription( void ) const { return desc; }


 const float GetSort( void ) const { return sort; }



 void SetSort( float s ) const { sort = s; };


 deform_t Deform( void ) const { return deform; }


 const int GetDeformRegister( int index ) const { return deformRegisters[index]; }


 const idDecl *GetDeformDecl( void ) const { return deformDecl; }


 texgen_t Texgen() const;


 const int * GetTexGenRegisters( void ) const { return texGenRegisters; }


 const cullType_t GetCullType( void ) const { return cullType; }

 float GetEditorAlpha( void ) const { return editorAlpha; }

 int GetEntityGui( void ) const { return entityGui; }

 decalInfo_t GetDecalInfo( void ) const { return decalInfo; }



 int Spectrum( void ) const { return spectrum; }

 float GetPolygonOffset( void ) const { return polygonOffset; }

 float GetSurfaceArea( void ) const { return surfaceArea; }
 void AddToSurfaceArea( float area ) { surfaceArea += area; }





 int CinematicLength( void ) const;

 void CloseCinematic( void ) const;

 void ResetCinematicTime( int time ) const;

 void UpdateCinematic( int time ) const;




 idImage * GetEditorImage( void ) const;
 int GetImageWidth( void ) const;
 int GetImageHeight( void ) const;

 void SetGui( const char *_gui ) const;


 void SetImageClassifications( int tag ) const;




 const int GetNumRegisters() const { return numRegisters; }


 void EvaluateRegisters( float *regs, const float entityParms[MAX_ENTITY_SHADER_PARMS],
           const struct viewDef_s *view, idSoundEmitter *soundEmitter = __null ) const;




 const float * ConstantRegisters() const;

 bool SuppressInSubview() const { return suppressInSubview; };
 bool IsPortalSky() const { return portalSky; };
 void AddReference();

private:

 void CommonInit();
 void ParseMaterial( idLexer &src );
 bool MatchToken( idLexer &src, const char *match );
 void ParseSort( idLexer &src );
 void ParseBlend( idLexer &src, shaderStage_t *stage );
 void ParseVertexParm( idLexer &src, newShaderStage_t *newStage );
 void ParseFragmentMap( idLexer &src, newShaderStage_t *newStage );
 void ParseStage( idLexer &src, const textureRepeat_t trpDefault = TR_REPEAT );
 void ParseDeform( idLexer &src );
 void ParseDecalInfo( idLexer &src );
 bool CheckSurfaceParm( idToken *token );
 int GetExpressionConstant( float f );
 int GetExpressionTemporary( void );
 expOp_t * GetExpressionOp( void );
 int EmitOp( int a, int b, expOpType_t opType );
 int ParseEmitOp( idLexer &src, int a, expOpType_t opType, int priority );
 int ParseTerm( idLexer &src );
 int ParseExpressionPriority( idLexer &src, int priority );
 int ParseExpression( idLexer &src );
 void ClearStage( shaderStage_t *ss );
 int NameToSrcBlendMode( const idStr &name );
 int NameToDstBlendMode( const idStr &name );
 void MultiplyTextureMatrix( textureStage_t *ts, int registers[2][3] );
 void SortInteractionStages();
 void AddImplicitStages( const textureRepeat_t trpDefault = TR_REPEAT );
 void CheckForConstantRegisters();

private:
 idStr desc;
 idStr renderBump;

 idImage * lightFalloffImage;

 int entityGui;

 mutable idUserInterface *gui;

 bool noFog;

 int spectrum;

 float polygonOffset;

 int contentFlags;
 int surfaceFlags;
 mutable int materialFlags;

 decalInfo_t decalInfo;


 mutable float sort;
 deform_t deform;
 int deformRegisters[4];
 const idDecl *deformDecl;

 int texGenRegisters[MAX_TEXGEN_REGISTERS];

 materialCoverage_t coverage;
 cullType_t cullType;
 bool shouldCreateBackSides;

 bool fogLight;
 bool blendLight;
 bool ambientLight;
 bool unsmoothedTangents;
 bool hasSubview;
 bool allowOverlays;

 int numOps;
 expOp_t * ops;

 int numRegisters;
 float * expressionRegisters;

 float * constantRegisters;

 int numStages;
 int numAmbientStages;

 shaderStage_t * stages;

 struct mtrParsingData_s *pd;

 float surfaceArea;




 idStr editorImageName;
 mutable idImage * editorImage;
 float editorAlpha;

 bool suppressInSubview;
 bool portalSky;
 int refCount;
};

typedef idList<const idMaterial *> idMatList;
# 151 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Model.h" 1
# 52 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Model.h"
typedef int glIndex_t;
# 62 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Model.h"
typedef struct {

 glIndex_t p1, p2;
 glIndex_t v1, v2;
} silEdge_t;


typedef struct dominantTri_s {
 glIndex_t v2, v3;
 float normalizationScale[3];
} dominantTri_t;

typedef struct lightingCache_s {
 idVec3 localLightVector;

} lightingCache_t;

typedef struct shadowCache_s {
 idVec4 xyz;
} shadowCache_t;

const int SHADOW_CAP_INFINITE = 64;


typedef struct srfTriangles_s {
 idBounds bounds;

 int ambientViewCount;

 bool generateNormals;
 bool tangentsCalculated;
 bool facePlanesCalculated;
 bool perfectHull;
 bool deformedSurface;


 int numVerts;
 idDrawVert * verts;

 int numIndexes;
 glIndex_t * indexes;

 glIndex_t * silIndexes;

 int numMirroredVerts;
 int * mirroredVerts;

 int numDupVerts;
 int * dupVerts;

 int numSilEdges;
 silEdge_t * silEdges;

 idPlane * facePlanes;

 dominantTri_t * dominantTris;

 int numShadowIndexesNoFrontCaps;
 int numShadowIndexesNoCaps;

 int shadowCapPlaneBits;




 shadowCache_t * shadowVertexes;


 struct srfTriangles_s * ambientSurface;


 struct srfTriangles_s * nextDeferredFree;


 struct vertCache_s * indexCache;
 struct vertCache_s * ambientCache;
 struct vertCache_s * lightingCache;
 struct vertCache_s * shadowCache;
} srfTriangles_t;

typedef idList<srfTriangles_t *> idTriList;

typedef struct modelSurface_s {
 int id;
 const idMaterial * shader;
 srfTriangles_t * geometry;
} modelSurface_t;

typedef enum {
 DM_STATIC,
 DM_CACHED,
 DM_CONTINUOUS
} dynamicModel_t;

typedef enum {
 INVALID_JOINT = -1
} jointHandle_t;

class idMD5Joint {
public:
        idMD5Joint() { parent = __null; }
 idStr name;
 const idMD5Joint * parent;
};





class idRenderModel {
public:
 virtual ~idRenderModel() {};


 virtual void InitFromFile( const char *fileName ) = 0;



 virtual void PartialInitFromFile( const char *fileName ) = 0;



 virtual void InitEmpty( const char *name, const char *filename = __null, int fileoffset = 0 ) = 0;




 virtual void AddSurface( modelSurface_t surface ) = 0;






 virtual void FinishSurfaces() = 0;



 virtual void PurgeModel() = 0;



 virtual void Reset() = 0;



 virtual void LoadModel() = 0;


 virtual bool IsLoaded() = 0;
 virtual void SetLevelLoadReferenced( bool referenced ) = 0;
 virtual bool IsLevelLoadReferenced() = 0;




 virtual void TouchData() = 0;


 virtual void FreeVertexCache() = 0;


 virtual const char * Name() const = 0;
 virtual const char * GetFileName() const = 0;
 virtual int GetFileOffset() const = 0;


 virtual void Print() const = 0;


 virtual void List() const = 0;


 virtual int Memory() const = 0;


 virtual time_t Timestamp() const = 0;


 virtual int NumSurfaces() const = 0;


 virtual int NumBaseSurfaces() const = 0;


 virtual const modelSurface_t *Surface( int surfaceNum ) const = 0;





 virtual srfTriangles_t * AllocSurfaceTriangles( int numVerts, int numIndexes ) const = 0;


 virtual void FreeSurfaceTriangles( srfTriangles_t *tris ) const = 0;





 virtual srfTriangles_t * ShadowHull() const = 0;


 virtual bool IsStaticWorldModel() const = 0;



 virtual bool IsReloadable() const = 0;


 virtual dynamicModel_t IsDynamicModel() const = 0;


 virtual bool IsDefaultModel() const = 0;



 virtual idBounds Bounds( const struct renderEntity_s *ent = __null ) const = 0;


 virtual float DepthHack() const = 0;
# 291 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/Model.h"
 virtual idRenderModel * InstantiateDynamicModel( const struct renderEntity_s *ent, const struct viewDef_s *view, idRenderModel *cachedModel ) = 0;


 virtual int NumJoints( void ) const = 0;


 virtual const idMD5Joint * GetJoints( void ) const = 0;


 virtual jointHandle_t GetJointHandle( const char *name ) const = 0;


 virtual const char * GetJointName( jointHandle_t handle ) const = 0;


 virtual const idJointQuat * GetDefaultPose( void ) const = 0;


 virtual int NearestJoint( int surfaceNum, int a, int c, int b ) const = 0;


 virtual void ReadFromDemoFile( class idDemoFile *f ) = 0;
 virtual void WriteToDemoFile( class idDemoFile *f ) = 0;
};
# 152 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/ModelManager.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/ModelManager.h"
class idRenderModelManager {
public:
 virtual ~idRenderModelManager() {}


 virtual void Init() = 0;


 virtual void Shutdown() = 0;


 virtual void BeginLevelLoad() = 0;


 virtual void EndLevelLoad() = 0;


 virtual idRenderModel * AllocModel() = 0;


 virtual void FreeModel( idRenderModel *model ) = 0;



 virtual idRenderModel * FindModel( const char *modelName ) = 0;


 virtual idRenderModel * CheckModel( const char *modelName ) = 0;


 virtual idRenderModel * DefaultModel() = 0;


 virtual void AddModel( idRenderModel *model ) = 0;




 virtual void RemoveModel( idRenderModel *model ) = 0;


 virtual void VirtualizeAll( void ) = 0;



 virtual void ReloadModels( bool forceAll = false ) = 0;


 virtual void WritePrecacheCommands( idFile *f ) = 0;


 virtual void FreeModelVertexCaches() = 0;


 virtual void PrintMemInfo( MemInfo_t *mi ) = 0;
};


extern idRenderModelManager *renderModelManager;
# 153 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderSystem.h" 1
# 33 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderSystem.h"
# 1 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 1 3
# 39 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3
       
# 40 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 93 "c:\\utils\\devkitpro\\devkitppc\\bin\\../lib/gcc/powerpc-eabi/4.6.3/../../../../powerpc-eabi/include/c++/4.6.3/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 34 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderSystem.h" 2
using namespace std;
# 50 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderSystem.h"
typedef struct glconfig_s {
 const char *renderer_string;
 const char *vendor_string;
 const char *version_string;
 const char *extensions_string;
 const char *wgl_extensions_string;

 float glVersion;


 int maxTextureSize;
 int maxTextureUnits;
 int maxTextureCoords;
 int maxTextureImageUnits;
 float maxTextureAnisotropy;

 int colorBits, depthBits, stencilBits;

 bool multitextureAvailable;
 bool textureCompressionAvailable;
 bool anisotropicAvailable;
 bool textureLODBiasAvailable;
 bool textureEnvAddAvailable;
 bool textureEnvCombineAvailable;
 bool registerCombinersAvailable;
 bool cubeMapAvailable;
 bool envDot3Available;
 bool texture3DAvailable;
 bool sharedTexturePaletteAvailable;
 bool ARBVertexBufferObjectAvailable;
 bool ARBVertexProgramAvailable;
 bool ARBFragmentProgramAvailable;
 bool twoSidedStencilAvailable;
 bool textureNonPowerOfTwoAvailable;
 bool depthBoundsTestAvailable;


 bool atiFragmentShaderAvailable;


 bool atiTwoSidedStencilAvailable;

 int vidWidth, vidHeight;

 int displayFrequency;

 bool isFullscreen;

 bool allowNV30Path;
 bool allowNV20Path;
 bool allowNV10Path;
 bool allowR200Path;
 bool allowARB2Path;

 bool isInitialized;
} glconfig_t;



const int GLYPH_START = 0;
const int GLYPH_END = 255;
const int GLYPH_CHARSTART = 32;
const int GLYPH_CHAREND = 127;
const int GLYPHS_PER_FONT = GLYPH_END - GLYPH_START + 1;

typedef struct {
 int height;
 int top;
 int bottom;
 int pitch;
 int xSkip;
 int imageWidth;
 int imageHeight;
 float s;
 float t;
 float s2;
 float t2;
 const idMaterial * glyph;
 char shaderName[32];
} glyphInfo_t;

typedef struct {
 glyphInfo_t glyphs [GLYPHS_PER_FONT];
 float glyphScale;
 char name[64];
} fontInfo_t;


class fontInfoEx_t {
public:

 fontInfoEx_t(void);
 ~fontInfoEx_t(void) {};

 static void * operator new(size_t size) throw(std::bad_alloc);
 static void operator delete(void *pMem) throw();
 static void * operator new[](size_t size) throw(std::bad_alloc);
 static void operator delete[](void *pMem) throw();

 fontInfo_t fontInfoSmall;
 fontInfo_t fontInfoMedium;
 fontInfo_t fontInfoLarge;
 int maxHeight;
 int maxWidth;
 int maxHeightSmall;
 int maxWidthSmall;
 int maxHeightMedium;
 int maxWidthMedium;
 int maxHeightLarge;
 int maxWidthLarge;
 char name[64];
};
# 179 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderSystem.h"
const int SMALLCHAR_WIDTH = 8;
const int SMALLCHAR_HEIGHT = 16;
const int BIGCHAR_WIDTH = 16;
const int BIGCHAR_HEIGHT = 16;



const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;

class idRenderWorld;


class idRenderSystem {
public:

 virtual ~idRenderSystem() {};



 virtual void Init( void ) = 0;


 virtual void Shutdown( void ) = 0;

 virtual void InitOpenGL( void ) = 0;

 virtual void ShutdownOpenGL( void ) = 0;

 virtual bool IsOpenGLRunning( void ) const = 0;

 virtual bool IsFullScreen( void ) const = 0;
 virtual int GetScreenWidth( void ) const = 0;
 virtual int GetScreenHeight( void ) const = 0;


 virtual idRenderWorld * AllocRenderWorld( void ) = 0;
 virtual void FreeRenderWorld( idRenderWorld * rw ) = 0;





 virtual void BeginLevelLoad( void ) = 0;
 virtual void EndLevelLoad( void ) = 0;


 virtual bool RegisterFont( const char *fontName, fontInfoEx_t &font ) = 0;


 virtual void SetColor( const idVec4 &rgba ) = 0;
 virtual void SetColor4( float r, float g, float b, float a ) = 0;

 virtual void DrawStretchPic( const idDrawVert *verts, const glIndex_t *indexes, int vertCount, int indexCount, const idMaterial *material,
           bool clip = true, float min_x = 0.0f, float min_y = 0.0f, float max_x = 640.0f, float max_y = 480.0f ) = 0;
 virtual void DrawStretchPic( float x, float y, float w, float h, float s1, float t1, float s2, float t2, const idMaterial *material ) = 0;

 virtual void DrawStretchTri ( idVec2 p1, idVec2 p2, idVec2 p3, idVec2 t1, idVec2 t2, idVec2 t3, const idMaterial *material ) = 0;
 virtual void GlobalToNormalizedDeviceCoordinates( const idVec3 &global, idVec3 &ndc ) = 0;
 virtual void GetGLSettings( int& width, int& height ) = 0;
 virtual void PrintMemInfo( MemInfo_t *mi ) = 0;

 virtual void DrawSmallChar( int x, int y, int ch, const idMaterial *material ) = 0;
 virtual void DrawSmallStringExt( int x, int y, const char *string, const idVec4 &setColor, bool forceColor, const idMaterial *material ) = 0;
 virtual void DrawBigChar( int x, int y, int ch, const idMaterial *material ) = 0;
 virtual void DrawBigStringExt( int x, int y, const char *string, const idVec4 &setColor, bool forceColor, const idMaterial *material ) = 0;


 virtual void WriteDemoPics() = 0;


 virtual void DrawDemoPics() = 0;






 virtual void BeginFrame( int windowWidth, int windowHeight ) = 0;


 virtual void EndFrame( int *frontEndMsec, int *backEndMsec ) = 0;
# 269 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderSystem.h"
 virtual void TakeScreenshot( int width, int height, const char *fileName, int samples, struct renderView_s *ref ) = 0;
# 280 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderSystem.h"
 virtual void CropRenderSize( int width, int height, bool makePowerOfTwo = false, bool forceDimensions = false ) = 0;
 virtual void CaptureRenderToImage( const char *imageName ) = 0;


 virtual void CaptureRenderToFile( const char *fileName, bool fixAlpha = false ) = 0;
 virtual void UnCrop() = 0;
 virtual void GetCardCaps( bool &oldCard, bool &nv10or20 ) = 0;




 virtual bool UploadImage( const char *imageName, const byte *data, int width, int height ) = 0;
};

extern idRenderSystem * renderSystem;






void R_RenderLightFrustum( const struct renderLight_s &renderLight, idPlane lightFrustum[6] );


void R_LightProjectionMatrix( const idVec3 &origin, const idPlane &rearPlane, idVec4 mat[4] );


void R_ScreenshotFilename( int &lastNumber, const char *base, idStr &fileName );
# 154 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderWorld.h" 1
# 44 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderWorld.h"
const int MAX_GLOBAL_SHADER_PARMS = 12;

const int SHADERPARM_RED = 0;
const int SHADERPARM_GREEN = 1;
const int SHADERPARM_BLUE = 2;
const int SHADERPARM_ALPHA = 3;
const int SHADERPARM_TIMESCALE = 3;
const int SHADERPARM_TIMEOFFSET = 4;
const int SHADERPARM_DIVERSITY = 5;
const int SHADERPARM_MODE = 7;
const int SHADERPARM_TIME_OF_DEATH = 7;


const int SHADERPARM_MD5_SKINSCALE = 8;

const int SHADERPARM_MD3_FRAME = 8;
const int SHADERPARM_MD3_LASTFRAME = 9;
const int SHADERPARM_MD3_BACKLERP = 10;

const int SHADERPARM_BEAM_END_X = 8;
const int SHADERPARM_BEAM_END_Y = 9;
const int SHADERPARM_BEAM_END_Z = 10;
const int SHADERPARM_BEAM_WIDTH = 11;

const int SHADERPARM_SPRITE_WIDTH = 8;
const int SHADERPARM_SPRITE_HEIGHT = 9;

const int SHADERPARM_PARTICLE_STOPTIME = 8;


const int MAX_RENDERENTITY_GUI = 3;


typedef bool(*deferredEntityCallback_t)( renderEntity_s *, const renderView_s * );


typedef struct renderEntity_s {
 idRenderModel * hModel;

 int entityNum;
 int bodyId;
# 95 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderWorld.h"
 idBounds bounds;
 deferredEntityCallback_t callback;

 void * callbackData;





 int suppressSurfaceInViewID;
 int suppressShadowInViewID;



 int suppressShadowInLightID;



 int allowSurfaceInViewID;





 idVec3 origin;
 idMat3 axis;


 const idMaterial * customShader;
 const idMaterial * referenceShader;
 const idDeclSkin * customSkin;
 class idSoundEmitter * referenceSound;
 float shaderParms[ MAX_ENTITY_SHADER_PARMS ];


 class idUserInterface * gui[ MAX_RENDERENTITY_GUI ];

 struct renderView_s * remoteRenderView;

 int numJoints;
 idJointMat * joints;


 float modelDepthHack;


 bool noSelfShadow;
 bool noShadow;

 bool noDynamicInteractions;




 bool weaponDepthHack;

 int forceUpdate;
 int timeGroup;
 int xrayIndex;
} renderEntity_t;


typedef struct renderLight_s {
 idMat3 axis;
 idVec3 origin;




 int suppressLightInViewID;



 int allowLightInViewID;




 bool noShadows;
 bool noSpecular;

 bool pointLight;
 bool parallel;
 idVec3 lightRadius;
 idVec3 lightCenter;





 idVec3 target;
 idVec3 right;
 idVec3 up;
 idVec3 start;
 idVec3 end;




 idRenderModel * prelightModel;


 int lightId;


 const idMaterial * shader;
 float shaderParms[MAX_ENTITY_SHADER_PARMS];
 idSoundEmitter * referenceSound;
} renderLight_t;


typedef struct renderView_s {


 int viewID;


 int x, y, width, height;

 float fov_x, fov_y;
 idVec3 vieworg;
 idMat3 viewaxis;

 bool cramZNear;
 bool forceUpdate;


 int time;
 float shaderParms[MAX_GLOBAL_SHADER_PARMS];
 const idMaterial *globalMaterial;
} renderView_t;



typedef struct {
 int areas[2];
 const idWinding * w;
 int blockingBits;
 qhandle_t portalHandle;
} exitPortal_t;



typedef struct {
 float x, y;
 int guiId;
} guiPoint_t;



typedef struct modelTrace_s {
 float fraction;
 idVec3 point;
 idVec3 normal;
 const idMaterial * material;
 const renderEntity_t * entity;
 int jointNumber;
} modelTrace_t;


static const int NUM_PORTAL_ATTRIBUTES = 3;

typedef enum {
 PS_BLOCK_NONE = 0,

 PS_BLOCK_VIEW = 1,
 PS_BLOCK_LOCATION = 2,
 PS_BLOCK_AIR = 4,

 PS_BLOCK_ALL = (1<<NUM_PORTAL_ATTRIBUTES)-1
} portalConnection_t;


class idRenderWorld {
public:
 virtual ~idRenderWorld() {};

 virtual bool ReloadModelFromMapFile( idRenderModel * model ) = 0;


 virtual bool InitFromMap( const char *mapName ) = 0;






 virtual qhandle_t AddEntityDef( const renderEntity_t *re ) = 0;
 virtual void UpdateEntityDef( qhandle_t entityHandle, const renderEntity_t *re ) = 0;
 virtual void FreeEntityDef( qhandle_t entityHandle ) = 0;
 virtual const renderEntity_t *GetRenderEntity( qhandle_t entityHandle ) const = 0;

 virtual qhandle_t AddLightDef( const renderLight_t *rlight ) = 0;
 virtual void UpdateLightDef( qhandle_t lightHandle, const renderLight_t *rlight ) = 0;
 virtual void FreeLightDef( qhandle_t lightHandle ) = 0;
 virtual const renderLight_t *GetRenderLight( qhandle_t lightHandle ) const = 0;



 virtual void GenerateAllInteractions() = 0;


 virtual bool CheckAreaForPortalSky( int areaNum ) = 0;
# 306 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderWorld.h"
 virtual void ProjectDecalOntoWorld( const idFixedWinding &winding, const idVec3 &projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime ) = 0;


 virtual void ProjectDecal( qhandle_t entityHandle, const idFixedWinding &winding, const idVec3 &projectionOrigin, const bool parallel, const float fadeDepth, const idMaterial *material, const int startTime ) = 0;


 virtual void ProjectOverlay( qhandle_t entityHandle, const idPlane localTextureAxis[2], const idMaterial *material ) = 0;


 virtual void RemoveDecals( qhandle_t entityHandle ) = 0;





 virtual void SetRenderView( const renderView_t *renderView ) = 0;




 virtual void RenderScene( const renderView_t *renderView ) = 0;




 virtual int NumPortals( void ) const = 0;





 virtual qhandle_t FindPortal( const idBounds &b ) const = 0;



 virtual void SetPortalState( qhandle_t portal, int blockingBits ) = 0;
 virtual int GetPortalState( qhandle_t portal ) = 0;



 virtual bool AreasAreConnected( int areaNum1, int areaNum2, portalConnection_t connection ) = 0;



 virtual int NumAreas( void ) const = 0;



 virtual int PointInArea( const idVec3 &point ) const = 0;



 virtual int BoundsInAreas( const idBounds &bounds, int *areas, int maxAreas ) const = 0;


 virtual int NumPortalsInArea( int areaNum ) = 0;


 virtual exitPortal_t GetPortal( int areaNum, int portalNum ) = 0;







 virtual guiPoint_t GuiTrace( qhandle_t entityHandle, const idVec3 start, const idVec3 end ) const = 0;


 virtual bool ModelTrace( modelTrace_t &trace, qhandle_t entityHandle, const idVec3 &start, const idVec3 &end, const float radius ) const = 0;


 virtual bool Trace( modelTrace_t &trace, const idVec3 &start, const idVec3 &end, const float radius, bool skipDynamic = true, bool skipPlayer = false ) const = 0;


 virtual bool FastWorldTrace( modelTrace_t &trace, const idVec3 &start, const idVec3 &end ) const = 0;




 virtual void StartWritingDemo( idDemoFile *demo ) = 0;
 virtual void StopWritingDemo() = 0;
# 396 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../renderer/RenderWorld.h"
 virtual bool ProcessDemoCommand( idDemoFile *readDemo, renderView_t *demoRenderView, int *demoTimeOffset ) = 0;



 virtual void RegenerateWorld() = 0;




 virtual void DebugClearLines( int time ) = 0;
 virtual void DebugLine( const idVec4 &color, const idVec3 &start, const idVec3 &end, const int lifetime = 0, const bool depthTest = false ) = 0;
 virtual void DebugArrow( const idVec4 &color, const idVec3 &start, const idVec3 &end, int size, const int lifetime = 0 ) = 0;
 virtual void DebugWinding( const idVec4 &color, const idWinding &w, const idVec3 &origin, const idMat3 &axis, const int lifetime = 0, const bool depthTest = false ) = 0;
 virtual void DebugCircle( const idVec4 &color, const idVec3 &origin, const idVec3 &dir, const float radius, const int numSteps, const int lifetime = 0, const bool depthTest = false ) = 0;
 virtual void DebugSphere( const idVec4 &color, const idSphere &sphere, const int lifetime = 0, bool depthTest = false ) = 0;
 virtual void DebugBounds( const idVec4 &color, const idBounds &bounds, const idVec3 &org = vec3_origin, const int lifetime = 0 ) = 0;
 virtual void DebugBox( const idVec4 &color, const idBox &box, const int lifetime = 0 ) = 0;
 virtual void DebugFrustum( const idVec4 &color, const idFrustum &frustum, const bool showFromOrigin = false, const int lifetime = 0 ) = 0;
 virtual void DebugCone( const idVec4 &color, const idVec3 &apex, const idVec3 &dir, float radius1, float radius2, const int lifetime = 0 ) = 0;
 virtual void DebugAxis( const idVec3 &origin, const idMat3 &axis ) = 0;


 virtual void DebugClearPolygons( int time ) = 0;
 virtual void DebugPolygon( const idVec4 &color, const idWinding &winding, const int lifeTime = 0, const bool depthTest = false ) = 0;


 virtual void DrawText( const char *text, const idVec3 &origin, float scale, const idVec4 &color, const idMat3 &viewAxis, const int align = 1, const int lifetime = 0, bool depthTest = false ) = 0;
};
# 155 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sound/sound.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sound/sound.h"
const float DOOM_TO_METERS = 0.0254f;
const float METERS_TO_DOOM = (1.0f/DOOM_TO_METERS);

class idSoundSample;


static const int SSF_PRIVATE_SOUND = ( 1 << ( 0 ) );
static const int SSF_ANTI_PRIVATE_SOUND =( 1 << ( 1 ) );
static const int SSF_NO_OCCLUSION = ( 1 << ( 2 ) );
static const int SSF_GLOBAL = ( 1 << ( 3 ) );
static const int SSF_OMNIDIRECTIONAL = ( 1 << ( 4 ) );
static const int SSF_LOOPING = ( 1 << ( 5 ) );
static const int SSF_PLAY_ONCE = ( 1 << ( 6 ) );
static const int SSF_UNCLAMPED = ( 1 << ( 7 ) );
static const int SSF_NO_FLICKER = ( 1 << ( 8 ) );
static const int SSF_NO_DUPS = ( 1 << ( 9 ) );


typedef struct {
 float minDistance;
 float maxDistance;
 float volume;
 float shakes;
 int soundShaderFlags;
 int soundClass;
} soundShaderParms_t;


const int SOUND_MAX_LIST_WAVS = 32;



const int SOUND_MAX_CLASSES = 4;



class idSoundShader : public idDecl {
public:
       idSoundShader( void );
 virtual ~idSoundShader( void );

 virtual size_t Size( void ) const;
 virtual bool SetDefaultText( void );
 virtual const char * DefaultDefinition( void ) const;
 virtual bool Parse( const char *text, const int textLength );
 virtual void FreeData( void );
 virtual void List( void ) const;

 virtual const char * GetDescription() const;



 virtual float GetMinDistance() const;
 virtual float GetMaxDistance() const;



 virtual const idSoundShader *GetAltSound() const;

 virtual bool HasDefaultSound() const;

 virtual const soundShaderParms_t *GetParms() const;
 virtual int GetNumSounds() const;
 virtual const char * GetSound( int index ) const;

 virtual bool CheckShakesAndOgg( void ) const;

private:
 friend class idSoundWorldLocal;
 friend class idSoundEmitterLocal;
 friend class idSoundChannel;
 friend class idSoundCache;


 soundShaderParms_t parms;

 bool onDemand;
 int speakerMask;
 const idSoundShader * altSound;
 idStr desc;
 bool errorDuringParse;
 float leadinVolume;

 idSoundSample * leadins[SOUND_MAX_LIST_WAVS];
 int numLeadins;
 idSoundSample * entries[SOUND_MAX_LIST_WAVS];
 int numEntries;

private:
 void Init( void );
 bool ParseShader( idLexer &src );
};
# 144 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sound/sound.h"
static const int SCHANNEL_ANY = 0;

static const int SCHANNEL_ONE = 1;
typedef int s_channelType;


class idSoundEmitter {
public:
 virtual ~idSoundEmitter( void ) {}




 virtual void Free( bool immediate ) = 0;



 virtual void UpdateEmitter( const idVec3 &origin, int listenerId, const soundShaderParms_t *parms ) = 0;


 virtual int StartSound( const idSoundShader *shader, const s_channelType channel, float diversity = 0, int shaderFlags = 0, bool allowSlow = true ) = 0;


 virtual void ModifySound( const s_channelType channel, const soundShaderParms_t *parms ) = 0;
 virtual void StopSound( const s_channelType channel ) = 0;

 virtual void FadeSound( const s_channelType channel, float to, float over ) = 0;




 virtual bool CurrentlyPlaying( void ) const = 0;




 virtual float CurrentAmplitude( void ) = 0;


 virtual int Index( void ) const = 0;
};
# 197 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sound/sound.h"
class idSoundWorld {
public:
 virtual ~idSoundWorld( void ) {}


 virtual void ClearAllSoundEmitters( void ) = 0;
 virtual void StopAllSounds( void ) = 0;


 virtual idSoundEmitter *AllocSoundEmitter( void ) = 0;


 virtual idSoundEmitter *EmitterForIndex( int index ) = 0;


 virtual float CurrentShakeAmplitudeForPosition( const int time, const idVec3 &listenerPosition ) = 0;





 virtual void PlaceListener( const idVec3 &origin, const idMat3 &axis, const int listenerId, const int gameTime, const idStr& areaName ) = 0;



 virtual void FadeSoundClasses( const int soundClass, const float to, const float over ) = 0;


 virtual void PlayShaderDirectly( const char *name, int channel = -1 ) = 0;


 virtual void StartWritingDemo( idDemoFile *demo ) = 0;
 virtual void StopWritingDemo() = 0;


 virtual void ProcessDemoCommand( idDemoFile *demo ) = 0;


 virtual void Pause( void ) = 0;
 virtual void UnPause( void ) = 0;
 virtual bool IsPaused( void ) = 0;
# 248 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sound/sound.h"
 virtual void AVIOpen( const char *path, const char *name ) = 0;
 virtual void AVIClose( void ) = 0;


 virtual void WriteToSaveGame( idFile *savefile ) = 0;
 virtual void ReadFromSaveGame( idFile *savefile ) = 0;

 virtual void SetSlowmo( bool active ) = 0;
 virtual void SetSlowmoSpeed( float speed ) = 0;
 virtual void SetEnviroSuit( bool active ) = 0;
};
# 269 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../sound/sound.h"
typedef struct {
 idStr name;
 idStr format;
 int numChannels;
 int numSamplesPerSecond;
 int num44kHzSamples;
 int numBytes;
 bool looping;
 float lastVolume;
 int start44kHzTime;
 int current44kHzTime;
} soundDecoderInfo_t;


class idSoundSystem {
public:
 virtual ~idSoundSystem( void ) {}


 virtual void Init( void ) = 0;


 virtual void Shutdown( void ) = 0;




 virtual void ClearBuffer( void ) = 0;


 virtual bool InitHW( void ) = 0;
 virtual bool ShutdownHW( void ) = 0;


 virtual int AsyncUpdate( int time ) = 0;


 virtual int AsyncUpdateWrite( int time ) = 0;




 virtual void SetMute( bool mute ) = 0;


 virtual cinData_t ImageForTime( const int milliseconds, const bool waveform ) = 0;


 virtual int GetSoundDecoderInfo( int index, soundDecoderInfo_t &decoderInfo ) = 0;


 virtual idSoundWorld * AllocSoundWorld( idRenderWorld *rw ) = 0;


 virtual void SetPlayingSoundWorld( idSoundWorld *soundWorld ) = 0;



 virtual idSoundWorld * GetPlayingSoundWorld( void ) = 0;



 virtual void BeginLevelLoad( void ) = 0;




 virtual void EndLevelLoad( const char *mapString ) = 0;


 virtual int AsyncMix( int soundTime, float *mixBuffer ) = 0;


 virtual void PrintMemInfo( MemInfo_t *mi ) = 0;


 virtual int IsEAXAvailable( void ) = 0;
};

extern idSoundSystem *soundSystem;
# 158 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/NetworkSystem.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/NetworkSystem.h"
class idNetworkSystem {
public:
 virtual ~idNetworkSystem( void ) {}

 virtual void ServerSendReliableMessage( int clientNum, const idBitMsg &msg );
 virtual void ServerSendReliableMessageExcluding( int clientNum, const idBitMsg &msg );
 virtual int ServerGetClientPing( int clientNum );
 virtual int ServerGetClientPrediction( int clientNum );
 virtual int ServerGetClientTimeSinceLastPacket( int clientNum );
 virtual int ServerGetClientTimeSinceLastInput( int clientNum );
 virtual int ServerGetClientOutgoingRate( int clientNum );
 virtual int ServerGetClientIncomingRate( int clientNum );
 virtual float ServerGetClientIncomingPacketLoss( int clientNum );

 virtual void ClientSendReliableMessage( const idBitMsg &msg );
 virtual int ClientGetPrediction( void );
 virtual int ClientGetTimeSinceLastPacket( void );
 virtual int ClientGetOutgoingRate( void );
 virtual int ClientGetIncomingRate( void );
 virtual float ClientGetIncomingPacketLoss( void );
};

extern idNetworkSystem * networkSystem;
# 161 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../ui/ListGUI.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../ui/ListGUI.h"
class idListGUI {
public:
 virtual ~idListGUI() { }

 virtual void Config( idUserInterface *pGUI, const char *name ) = 0;
 virtual void Add( int id, const idStr& s ) = 0;

 virtual void Push( const idStr& s ) = 0;
 virtual bool Del( int id ) = 0;
 virtual void Clear( void ) = 0;
 virtual int Num( void ) = 0;
 virtual int GetSelection( char *s, int size, int sel = 0 ) const = 0;
 virtual void SetSelection( int sel ) = 0;
 virtual int GetNumSelections() = 0;
 virtual bool IsConfigured( void ) const = 0;

 virtual void SetStateChanges( bool enable ) = 0;
 virtual void Shutdown( void ) = 0;
};
# 164 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../ui/UserInterface.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../ui/UserInterface.h"
class idFile;
class idDemoFile;


class idUserInterface {
public:
 virtual ~idUserInterface() {};


 virtual const char * Name() const = 0;


 virtual const char * Comment() const = 0;


 virtual bool IsInteractive() const = 0;

 virtual bool IsUniqued() const = 0;

 virtual void SetUniqued( bool b ) = 0;

 virtual bool InitFromFile( const char *qpath, bool rebuild = true, bool cache = true ) = 0;



 virtual const char * HandleEvent( const sysEvent_t *event, int time, bool *updateVisuals = __null ) = 0;


 virtual void HandleNamedEvent( const char *eventName ) = 0;


 virtual void Redraw( int time ) = 0;


 virtual void DrawCursor() = 0;


 virtual const idDict & State() const = 0;


 virtual void DeleteStateVar( const char *varName ) = 0;


 virtual void SetStateString( const char *varName, const char *value ) = 0;
 virtual void SetStateBool( const char *varName, const bool value ) = 0;
 virtual void SetStateInt( const char *varName, const int value ) = 0;
 virtual void SetStateFloat( const char *varName, const float value ) = 0;


 virtual const char* GetStateString( const char *varName, const char* defaultString = "" ) const = 0;
 virtual bool GetStateBool( const char *varName, const char* defaultString = "0" ) const = 0;
 virtual int GetStateInt( const char *varName, const char* defaultString = "0" ) const = 0;
 virtual float GetStateFloat( const char *varName, const char* defaultString = "0" ) const = 0;


 virtual void StateChanged( int time, bool redraw = false ) = 0;


 virtual const char * Activate( bool activate, int time ) = 0;


 virtual void Trigger( int time ) = 0;

 virtual void ReadFromDemoFile( class idDemoFile *f ) = 0;
 virtual void WriteToDemoFile( class idDemoFile *f ) = 0;

 virtual bool WriteToSaveGame( idFile *savefile ) const = 0;
 virtual bool ReadFromSaveGame( idFile *savefile ) = 0;
 virtual void SetKeyBindingNames( void ) = 0;

 virtual void SetCursor( float x, float y ) = 0;
 virtual float CursorX() = 0;
 virtual float CursorY() = 0;
};


class idUserInterfaceManager {
public:
 virtual ~idUserInterfaceManager( void ) {};

 virtual void Init() = 0;
 virtual void Shutdown() = 0;
 virtual void Touch( const char *name ) = 0;
 virtual void WritePrecacheCommands( idFile *f ) = 0;


 virtual void SetSize( float width, float height ) = 0;

 virtual void VirtualizeAll() = 0;
 virtual void BeginLevelLoad() = 0;
 virtual void EndLevelLoad() = 0;


 virtual void Reload( bool all ) = 0;


 virtual void ListGuis() const = 0;


 virtual bool CheckGui( const char *qpath ) const = 0;


 virtual idUserInterface * Alloc( void ) const = 0;


 virtual void DeAlloc( idUserInterface *gui ) = 0;


 virtual idUserInterface * FindGui( const char *qpath, bool autoLoad = false, bool needUnique = false, bool forceUnique = false ) = 0;


 virtual idUserInterface * FindDemoGui( const char *qpath ) = 0;


 virtual idListGUI * AllocListGUI( void ) const = 0;


 virtual void FreeListGUI( idListGUI *listgui ) = 0;
};

extern idUserInterfaceManager * uiManager;
# 165 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../cm/CollisionModel.h" 1
# 52 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../cm/CollisionModel.h"
typedef enum {
 CONTACT_NONE,
 CONTACT_EDGE,
 CONTACT_MODELVERTEX,
 CONTACT_TRMVERTEX
} contactType_t;


typedef struct {
 contactType_t type;
 idVec3 point;
 idVec3 normal;
 float dist;
 int contents;
 const idMaterial * material;
 int modelFeature;
 int trmFeature;
 int entityNum;
 int id;
} contactInfo_t;


typedef struct trace_s {
 float fraction;
 idVec3 endpos;
 idMat3 endAxis;
 contactInfo_t c;
} trace_t;

typedef int cmHandle_t;





class idCollisionModelManager {
public:
 virtual ~idCollisionModelManager( void ) {}


 virtual void LoadMap( const idMapFile *mapFile ) = 0;

 virtual void FreeMap( void ) = 0;

 virtual void virtualizeAll( void ) = 0;

 virtual cmHandle_t LoadModel( const char *modelName, const bool precache ) = 0;

 virtual cmHandle_t SetupTrmModel( const idTraceModel &trm, const idMaterial *material ) = 0;

 virtual bool TrmFromModel( const char *modelName, idTraceModel &trm ) = 0;


 virtual const char * GetModelName( cmHandle_t model ) const = 0;

 virtual bool GetModelBounds( cmHandle_t model, idBounds &bounds ) const = 0;

 virtual bool GetModelContents( cmHandle_t model, int &contents ) const = 0;

 virtual bool GetModelVertex( cmHandle_t model, int vertexNum, idVec3 &vertex ) const = 0;

 virtual bool GetModelEdge( cmHandle_t model, int edgeNum, idVec3 &start, idVec3 &end ) const = 0;

 virtual bool GetModelPolygon( cmHandle_t model, int polygonNum, idFixedWinding &winding ) const = 0;


 virtual void Translation( trace_t *results, const idVec3 &start, const idVec3 &end,
        const idTraceModel *trm, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis ) = 0;

 virtual void Rotation( trace_t *results, const idVec3 &start, const idRotation &rotation,
        const idTraceModel *trm, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis ) = 0;

 virtual int Contents( const idVec3 &start,
        const idTraceModel *trm, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis ) = 0;

 virtual int Contacts( contactInfo_t *contacts, const int maxContacts, const idVec3 &start, const idVec6 &dir, const float depth,
        const idTraceModel *trm, const idMat3 &trmAxis, int contentMask,
        cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis ) = 0;


 virtual void DebugOutput( const idVec3 &origin ) = 0;

 virtual void DrawModel( cmHandle_t model, const idVec3 &modelOrigin, const idMat3 &modelAxis,
            const idVec3 &viewOrigin, const float radius ) = 0;

 virtual void ModelInfo( cmHandle_t model ) = 0;

 virtual void ListModels( void ) = 0;

 virtual bool WriteCollisionModelForMapEntity( const idMapEntity *mapEnt, const char *filename, const bool testTraceModel = true ) = 0;
};

extern idCollisionModelManager * collisionModelManager;
# 168 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/compilers/aas/AASFile.h" 1
# 93 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/compilers/aas/AASFile.h"
class idReachability {
public:
 int travelType;
 short toAreaNum;
 short fromAreaNum;
 idVec3 start;
 idVec3 end;
 int edgeNum;
 unsigned short travelTime;
 byte number;
 byte disableCount;
 idReachability * next;
 idReachability * rev_next;
 unsigned short * areaTravelTimes;
public:
 void CopyBase( idReachability &reach );
};

class idReachability_Walk : public idReachability {
};

class idReachability_BarrierJump : public idReachability {
};

class idReachability_WaterJump : public idReachability {
};

class idReachability_WalkOffLedge : public idReachability {
};

class idReachability_Swim : public idReachability {
};

class idReachability_Fly : public idReachability {
};

class idReachability_Special : public idReachability {
public:
 idDict dict;
};


typedef int aasIndex_t;


typedef idVec3 aasVertex_t;


typedef struct aasEdge_s {
 int vertexNum[2];
} aasEdge_t;


typedef struct aasFace_s {
 unsigned short planeNum;
 unsigned short flags;
 int numEdges;
 int firstEdge;
 short areas[2];
} aasFace_t;


typedef struct aasArea_s {
 int numFaces;
 int firstFace;
 idBounds bounds;
 idVec3 center;
 unsigned short flags;
 unsigned short contents;
 short cluster;
 short clusterAreaNum;
 int travelFlags;
 idReachability * reach;
 idReachability * rev_reach;
} aasArea_t;


typedef struct aasNode_s {
 unsigned short planeNum;
 int children[2];
} aasNode_t;


typedef struct aasPortal_s {
 short areaNum;
 short clusters[2];
 short clusterAreaNum[2];
 unsigned short maxAreaTravelTime;
} aasPortal_t;


typedef struct aasCluster_s {
 int numAreas;
 int numReachableAreas;
 int numPortals;
 int firstPortal;
} aasCluster_t;


typedef struct aasTrace_s {

 int flags;
 int travelFlags;
 int maxAreas;
 int getOutOfSolid;

 float fraction;
 idVec3 endpos;
 int planeNum;
 int lastAreaNum;
 int blockingAreaNum;
 int numAreas;
 int * areas;
 idVec3 * points;
        aasTrace_s( void ) { areas = __null; points = __null; getOutOfSolid = false; flags = travelFlags = maxAreas = 0; }
} aasTrace_t;


class idAASSettings {
public:

 int numBoundingBoxes;
 idBounds boundingBoxes[4];
 bool usePatches;
 bool writeBrushMap;
 bool playerFlood;
 bool noOptimize;
 bool allowSwimReachabilities;
 bool allowFlyReachabilities;
 idStr fileExtension;

 idVec3 gravity;
 idVec3 gravityDir;
 idVec3 invGravityDir;
 float gravityValue;
 float maxStepHeight;
 float maxBarrierHeight;
 float maxWaterJumpHeight;
 float maxFallHeight;
 float minFloorCos;

 int tt_barrierJump;
 int tt_startCrouching;
 int tt_waterJump;
 int tt_startWalkOffLedge;

public:
        idAASSettings( void );

 bool FromFile( const idStr &fileName );
 bool FromParser( idLexer &src );
 bool FromDict( const char *name, const idDict *dict );
 bool WriteToFile( idFile *fp ) const;
 bool ValidForBounds( const idBounds &bounds ) const;
 bool ValidEntity( const char *classname ) const;

private:
 bool ParseBool( idLexer &src, bool &b );
 bool ParseInt( idLexer &src, int &i );
 bool ParseFloat( idLexer &src, float &f );
 bool ParseVector( idLexer &src, idVec3 &vec );
 bool ParseBBoxes( idLexer &src );
};
# 282 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/compilers/aas/AASFile.h"
class idAASFile {
public:
 virtual ~idAASFile( void ) {}

 const char * GetName( void ) const { return name.c_str(); }
 unsigned int GetCRC( void ) const { return crc; }

 int GetNumPlanes( void ) const { return planeList.Num(); }
 const idPlane & GetPlane( int index ) const { return planeList[index]; }
 int GetNumVertices( void ) const { return vertices.Num(); }
 const aasVertex_t & GetVertex( int index ) const { return vertices[index]; }
 int GetNumEdges( void ) const { return edges.Num(); }
 const aasEdge_t & GetEdge( int index ) const { return edges[index]; }
 int GetNumEdgeIndexes( void ) const { return edgeIndex.Num(); }
 const aasIndex_t & GetEdgeIndex( int index ) const { return edgeIndex[index]; }
 int GetNumFaces( void ) const { return faces.Num(); }
 const aasFace_t & GetFace( int index ) const { return faces[index]; }
 int GetNumFaceIndexes( void ) const { return faceIndex.Num(); }
 const aasIndex_t & GetFaceIndex( int index ) const { return faceIndex[index]; }
 int GetNumAreas( void ) const { return areas.Num(); }
 const aasArea_t & GetArea( int index ) { return areas[index]; }
 int GetNumNodes( void ) const { return nodes.Num(); }
 const aasNode_t & GetNode( int index ) const { return nodes[index]; }
 int GetNumPortals( void ) const { return portals.Num(); }
 const aasPortal_t & GetPortal( int index ) { return portals[index]; }
 int GetNumPortalIndexes( void ) const { return portalIndex.Num(); }
 const aasIndex_t & GetPortalIndex( int index ) const { return portalIndex[index]; }
 int GetNumClusters( void ) const { return clusters.Num(); }
 const aasCluster_t & GetCluster( int index ) const { return clusters[index]; }

 const idAASSettings & GetSettings( void ) const { return settings; }

 void SetPortalMaxTravelTime( int index, int time ) { portals[index].maxAreaTravelTime = time; }
 void SetAreaTravelFlag( int index, int flag ) { areas[index].travelFlags |= flag; }
 void RemoveAreaTravelFlag( int index, int flag ) { areas[index].travelFlags &= ~flag; }

 virtual idVec3 EdgeCenter( int edgeNum ) const = 0;
 virtual idVec3 FaceCenter( int faceNum ) const = 0;
 virtual idVec3 AreaCenter( int areaNum ) const = 0;

 virtual idBounds EdgeBounds( int edgeNum ) const = 0;
 virtual idBounds FaceBounds( int faceNum ) const = 0;
 virtual idBounds AreaBounds( int areaNum ) const = 0;

 virtual int PointAreaNum( const idVec3 &origin ) const = 0;
 virtual int PointReachableAreaNum( const idVec3 &origin, const idBounds &searchBounds, const int areaFlags, const int excludeTravelFlags ) const = 0;
 virtual int BoundsReachableAreaNum( const idBounds &bounds, const int areaFlags, const int excludeTravelFlags ) const = 0;
 virtual void PushPointIntoAreaNum( int areaNum, idVec3 &point ) const = 0;
 virtual bool Trace( aasTrace_t &trace, const idVec3 &start, const idVec3 &end ) const = 0;
 virtual void PrintInfo( void ) const = 0;

protected:
 idStr name;
 unsigned int crc;

 idPlaneSet planeList;
 idList<aasVertex_t> vertices;
 idList<aasEdge_t> edges;
 idList<aasIndex_t> edgeIndex;
 idList<aasFace_t> faces;
 idList<aasIndex_t> faceIndex;
 idList<aasArea_t> areas;
 idList<aasNode_t> nodes;
 idList<aasPortal_t> portals;
 idList<aasIndex_t> portalIndex;
 idList<aasCluster_t> clusters;
 idAASSettings settings;
};
# 171 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/compilers/aas/AASFileManager.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/compilers/aas/AASFileManager.h"
class idAASFileManager {
public:
 virtual ~idAASFileManager( void ) {}

 virtual idAASFile * LoadAAS( const char *fileName, unsigned int mapFileCRC ) = 0;
 virtual void FreeAAS( idAASFile *file ) = 0;
};

extern idAASFileManager * AASFileManager;
# 172 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2





# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../game/Game.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../game/Game.h"
typedef struct {
 char sessionCommand[1024];
 int consistencyHash;
 int health;
 int heartRate;
 int stamina;
 int combat;
 bool syncNextGameFrame;

} gameReturn_t;

typedef enum {
 ALLOW_YES = 0,
 ALLOW_BADPASS,
 ALLOW_NOTYET,
 ALLOW_NO
} allowReply_t;

typedef enum {
 ESC_IGNORE = 0,
 ESC_MAIN,
 ESC_GUI
} escReply_t;




class idGame {
public:
 virtual ~idGame() {}


 virtual void Init( void ) = 0;


 virtual void Shutdown( void ) = 0;


 virtual void SetLocalClient( int clientNum ) = 0;




 virtual const idDict * SetUserInfo( int clientNum, const idDict &userInfo, bool isClient, bool canModify ) = 0;


 virtual const idDict * GetUserInfo( int clientNum ) = 0;


 virtual void ThrottleUserInfo( void ) = 0;


 virtual void SetServerInfo( const idDict &serverInfo ) = 0;


 virtual const idDict & GetPersistentPlayerInfo( int clientNum ) = 0;


 virtual void SetPersistentPlayerInfo( int clientNum, const idDict &playerInfo ) = 0;


 virtual void InitFromNewMap( const char *mapName, idRenderWorld *renderWorld, idSoundWorld *soundWorld, bool isServer, bool isClient, int randseed ) = 0;


 virtual bool InitFromSaveGame( const char *mapName, idRenderWorld *renderWorld, idSoundWorld *soundWorld, idFile *saveGameFile ) = 0;


 virtual void SaveGame( idFile *saveGameFile ) = 0;


 virtual void MapShutdown( void ) = 0;


 virtual void CacheDictionaryMedia( const idDict *dict ) = 0;


 virtual void SpawnPlayer( int clientNum ) = 0;


 virtual gameReturn_t RunFrame( const usercmd_t *clientCmds ) = 0;


 virtual bool Draw( int clientNum ) = 0;


 virtual escReply_t HandleESC( idUserInterface **gui ) = 0;


 virtual idUserInterface * StartMenu() = 0;



 virtual const char * HandleGuiCommands( const char *menuCommand ) = 0;


 virtual void HandleMainMenuCommands( const char *menuCommand, idUserInterface *gui ) = 0;


 virtual allowReply_t ServerAllowClient( int numClients, const char *IP, const char *guid, const char *password, char reason[1024] ) = 0;


 virtual void ServerClientConnect( int clientNum, const char *guid ) = 0;


 virtual void ServerClientBegin( int clientNum ) = 0;


 virtual void ServerClientDisconnect( int clientNum ) = 0;


 virtual void ServerWriteInitialReliableMessages( int clientNum ) = 0;


 virtual void ServerWriteSnapshot( int clientNum, int sequence, idBitMsg &msg, byte *clientInPVS, int numPVSClients ) = 0;


 virtual bool ServerApplySnapshot( int clientNum, int sequence ) = 0;


 virtual void ServerProcessReliableMessage( int clientNum, const idBitMsg &msg ) = 0;


 virtual void ClientReadSnapshot( int clientNum, int sequence, const int gameFrame, const int gameTime, const int dupeUsercmds, const int aheadOfServer, const idBitMsg &msg ) = 0;


 virtual bool ClientApplySnapshot( int clientNum, int sequence ) = 0;


 virtual void ClientProcessReliableMessage( int clientNum, const idBitMsg &msg ) = 0;


 virtual gameReturn_t ClientPrediction( int clientNum, const usercmd_t *clientCmds, bool lastPredictFrame ) = 0;


 virtual void SelectTimeGroup( int timeGroup ) = 0;
 virtual int GetTimeGroupTime( int timeGroup ) = 0;

 virtual void GetBestGameType( const char* map, const char* gametype, char buf[ 1024 ] ) = 0;


 virtual void GetClientStats( int clientNum, char *data, const int len ) = 0;


 virtual void SwitchTeam( int clientNum, int team ) = 0;

 virtual bool DownloadRequest( const char *IP, const char *guid, const char *paks, char urls[ 1024 ] ) = 0;

 virtual void GetMapLoadingGUI( char gui[ 1024 ] ) = 0;
};

extern idGame * game;
# 206 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../game/Game.h"
typedef struct {
 idSoundEmitter * referenceSound;

 idVec3 origin;
 int listenerId;

 const idSoundShader * shader;
 float diversity;

 bool waitfortrigger;
 soundShaderParms_t parms;
} refSound_t;

enum {
 TEST_PARTICLE_MODEL = 0,
 TEST_PARTICLE_IMPACT,
 TEST_PARTICLE_MUZZLE,
 TEST_PARTICLE_FLIGHT,
 TEST_PARTICLE_SELECTED
};

class idEntity;
class idMD5Anim;


class idGameEdit {
public:
 virtual ~idGameEdit( void ) {}


 virtual void ParseSpawnArgsToRenderLight( const idDict *args, renderLight_t *renderLight );
 virtual void ParseSpawnArgsToRenderEntity( const idDict *args, renderEntity_t *renderEntity );
 virtual void ParseSpawnArgsToRefSound( const idDict *args, refSound_t *refSound );


 virtual idRenderModel * ANIM_GetModelFromEntityDef( const char *classname );
 virtual const idVec3 &ANIM_GetModelOffsetFromEntityDef( const char *classname );
 virtual idRenderModel * ANIM_GetModelFromEntityDef( const idDict *args );
 virtual idRenderModel * ANIM_GetModelFromName( const char *modelName );
 virtual const idMD5Anim * ANIM_GetAnimFromEntityDef( const char *classname, const char *animname );
 virtual int ANIM_GetNumAnimsFromEntityDef( const idDict *args );
 virtual const char * ANIM_GetAnimNameFromEntityDef( const idDict *args, int animNum );
 virtual const idMD5Anim * ANIM_GetAnim( const char *fileName );
 virtual int ANIM_GetLength( const idMD5Anim *anim );
 virtual int ANIM_GetNumFrames( const idMD5Anim *anim );
 virtual void ANIM_CreateAnimFrame( const idRenderModel *model, const idMD5Anim *anim, int numJoints, idJointMat *frame, int time, const idVec3 &offset, bool remove_origin_offset );
 virtual idRenderModel * ANIM_CreateMeshForAnim( idRenderModel *model, const char *classname, const char *animname, int frame, bool remove_origin_offset );


 virtual bool AF_SpawnEntity( const char *fileName );
 virtual void AF_UpdateEntities( const char *fileName );
 virtual void AF_UndoChanges( void );
 virtual idRenderModel * AF_CreateMesh( const idDict &args, idVec3 &meshOrigin, idMat3 &meshAxis, bool &poseIsSet );



 virtual void ClearEntitySelection( void );
 virtual int GetSelectedEntities( idEntity *list[], int max );
 virtual void AddSelectedEntity( idEntity *ent );


 virtual void TriggerSelected();


 virtual const idDict * FindEntityDefDict( const char *name, bool makeDefault = true ) const;
 virtual void SpawnEntityDef( const idDict &args, idEntity **ent );
 virtual idEntity * FindEntity( const char *name ) const;
 virtual const char * GetUniqueEntityName( const char *classname ) const;


 virtual void EntityGetOrigin( idEntity *ent, idVec3 &org ) const;
 virtual void EntityGetAxis( idEntity *ent, idMat3 &axis ) const;
 virtual void EntitySetOrigin( idEntity *ent, const idVec3 &org );
 virtual void EntitySetAxis( idEntity *ent, const idMat3 &axis );
 virtual void EntityTranslate( idEntity *ent, const idVec3 &org );
 virtual const idDict * EntityGetSpawnArgs( idEntity *ent ) const;
 virtual void EntityUpdateChangeableSpawnArgs( idEntity *ent, const idDict *dict );
 virtual void EntityChangeSpawnArgs( idEntity *ent, const idDict *newArgs );
 virtual void EntityUpdateVisuals( idEntity *ent );
 virtual void EntitySetModel( idEntity *ent, const char *val );
 virtual void EntityStopSound( idEntity *ent );
 virtual void EntityDelete( idEntity *ent );
 virtual void EntitySetColor( idEntity *ent, const idVec3 color );


 virtual bool PlayerIsValid() const;
 virtual void PlayerGetOrigin( idVec3 &org ) const;
 virtual void PlayerGetAxis( idMat3 &axis ) const;
 virtual void PlayerGetViewAngles( idAngles &angles ) const;
 virtual void PlayerGetEyePosition( idVec3 &org ) const;


 virtual const idDict * MapGetEntityDict( const char *name ) const;
 virtual void MapSave( const char *path = __null ) const;
 virtual void MapSetEntityKeyVal( const char *name, const char *key, const char *val ) const ;
 virtual void MapCopyDictToEntity( const char *name, const idDict *dict ) const;
 virtual int MapGetUniqueMatchingKeyVals( const char *key, const char *list[], const int max ) const;
 virtual void MapAddEntity( const idDict *dict ) const;
 virtual int MapGetEntitiesMatchingClassWithString( const char *classname, const char *match, const char *list[], const int max ) const;
 virtual void MapRemoveEntity( const char *name ) const;
 virtual void MapEntityTranslate( const char *name, const idVec3 &v ) const;

};

extern idGameEdit * gameEdit;
# 321 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../game/Game.h"
const int GAME_API_VERSION = 8;

typedef struct {

 int version;
 idSys * sys;
 idCommon * common;
 idCmdSystem * cmdSystem;
 idCVarSystem * cvarSystem;
 idFileSystem * fileSystem;
 idNetworkSystem * networkSystem;
 idRenderSystem * renderSystem;
 idSoundSystem * soundSystem;
 idRenderModelManager * renderModelManager;
 idUserInterfaceManager * uiManager;
 idDeclManager * declManager;
 idAASFileManager * AASFileManager;
 idCollisionModelManager * collisionModelManager;

} gameImport_t;

typedef struct {

 int version;
 idGame * game;
 idGameEdit * gameEdit;

} gameExport_t;

extern "C" {
typedef gameExport_t * (*GetGameAPI_t)( gameImport_t *import );
}
# 178 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 195 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h"
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DemoChecksum.h" 1
# 196 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Compressor.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Compressor.h"
class idCompressor : public idFile {
public:

 static idCompressor * AllocNoCompression( void );
 static idCompressor * AllocBitStream( void );
 static idCompressor * AllocRunLength( void );
 static idCompressor * AllocRunLength_ZeroBased( void );
 static idCompressor * AllocHuffman( void );
 static idCompressor * AllocArithmetic( void );
 static idCompressor * AllocLZSS( void );
 static idCompressor * AllocLZSS_WordAligned( void );
 static idCompressor * AllocLZW( void );


 virtual void Init( idFile *f, bool compress, int wordLength ) = 0;
 virtual void FinishCompress( void ) = 0;
 virtual float GetCompressionRatio( void ) const = 0;


 virtual const char * GetName( void ) = 0;
 virtual const char * GetFullPath( void ) = 0;
 virtual int Read( void *outData, int outLength ) = 0;
 virtual int Write( const void *inData, int inLength ) = 0;
 virtual int Length( void ) = 0;
 virtual time_t Timestamp( void ) = 0;
 virtual int Tell( void ) = 0;
 virtual void ForceFlush( void ) = 0;
 virtual void Flush( void ) = 0;
 virtual int Seek( long offset, fsOrigin_t origin ) = 0;
};
# 199 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/EventLoop.h" 1
# 42 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/EventLoop.h"
const int MAX_PUSHED_EVENTS = 64;

class idEventLoop {
public:
     idEventLoop( void );
     ~idEventLoop( void );

 void Init( void );


 void Shutdown( void );



 sysEvent_t GetEvent( void );


 int RunEventLoop( bool commandExecution = true );



 int Milliseconds( void );


 int JournalLevel( void ) const;


 idFile * com_journalFile;
 idFile * com_journalDataFile;

private:

 int initialTimeOffset;

 int com_pushedEventsHead, com_pushedEventsTail;
 sysEvent_t com_pushedEvents[MAX_PUSHED_EVENTS];

 static idCVar com_journal;

 sysEvent_t GetRealEvent( void );
 void ProcessEvent( sysEvent_t ev );
 void PushEvent( sysEvent_t *event );
};

extern idEventLoop *eventLoop;
# 200 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/KeyInput.h" 1
# 46 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/KeyInput.h"
typedef enum {
 K_TAB = 9,
 K_ENTER = 13,
 K_ESCAPE = 27,
 K_SPACE = 32,

 K_BACKSPACE = 127,

 K_COMMAND = 128,
 K_CAPSLOCK,
 K_SCROLL,
 K_POWER,
 K_PAUSE,

 K_UPARROW = 133,
 K_DOWNARROW,
 K_LEFTARROW,
 K_RIGHTARROW,


 K_LWIN = 137,
 K_RWIN,
 K_MENU,

 K_ALT = 140,
 K_CTRL,
 K_SHIFT,
 K_INS,
 K_DEL,
 K_PGDN,
 K_PGUP,
 K_HOME,
 K_END,

 K_F1 = 149,
 K_F2,
 K_F3,
 K_F4,
 K_F5,
 K_F6,
 K_F7,
 K_F8,
 K_F9,
 K_F10,
 K_F11,
 K_F12,
 K_INVERTED_EXCLAMATION = 161,
 K_F13,
 K_F14,
 K_F15,

 K_KP_HOME = 165,
 K_KP_UPARROW,
 K_KP_PGUP,
 K_KP_LEFTARROW,
 K_KP_5,
 K_KP_RIGHTARROW,
 K_KP_END,
 K_KP_DOWNARROW,
 K_KP_PGDN,
 K_KP_ENTER,
 K_KP_INS,
 K_KP_DEL,
 K_KP_SLASH,
 K_SUPERSCRIPT_TWO = 178,
 K_KP_MINUS,
 K_ACUTE_ACCENT = 180,
 K_KP_PLUS,
 K_KP_NUMLOCK,
 K_KP_STAR,
 K_KP_EQUALS,

 K_MASCULINE_ORDINATOR = 186,

 K_MOUSE1 = 187,
 K_MOUSE2,
 K_MOUSE3,
 K_MOUSE4,
 K_MOUSE5,
 K_MOUSE6,
 K_MOUSE7,
 K_MOUSE8,

 K_MWHEELDOWN = 195,
 K_MWHEELUP,

 K_JOY1 = 197,
 K_JOY2,
 K_JOY3,
 K_JOY4,
 K_JOY5,
 K_JOY6,
 K_JOY7,
 K_JOY8,
 K_JOY9,
 K_JOY10,
 K_JOY11,
 K_JOY12,
 K_JOY13,
 K_JOY14,
 K_JOY15,
 K_JOY16,
 K_JOY17,
 K_JOY18,
 K_JOY19,
 K_JOY20,
 K_JOY21,
 K_JOY22,
 K_JOY23,
 K_JOY24,
 K_JOY25,
 K_JOY26,
 K_JOY27,
 K_GRAVE_A = 224,
 K_JOY28,
 K_JOY29,
 K_JOY30,
 K_JOY31,
 K_JOY32,

 K_AUX1 = 230,
 K_CEDILLA_C = 231,
 K_GRAVE_E = 232,
 K_AUX2,
 K_AUX3,
 K_AUX4,
 K_GRAVE_I = 236,
 K_AUX5,
 K_AUX6,
 K_AUX7,
 K_AUX8,
 K_TILDE_N = 241,
 K_GRAVE_O = 242,
 K_AUX9,
 K_AUX10,
 K_AUX11,
 K_AUX12,
 K_AUX13,
 K_AUX14,
 K_GRAVE_U = 249,
 K_AUX15,
 K_AUX16,

 K_PRINT_SCR = 252,
 K_RIGHT_ALT = 253,
 K_LAST_KEY = 254
} keyNum_t;


class idKeyInput {
public:
 static void Init( void );
 static void Shutdown( void );

 static void ArgCompletion_KeyName( const idCmdArgs &args, void(*callback)( const char *s ) );
 static void PreliminaryKeyEvent( int keyNum, bool down );
 static bool IsDown( int keyNum );
 static int GetUsercmdAction( int keyNum );
 static bool GetOverstrikeMode( void );
 static void SetOverstrikeMode( bool state );
 static void ClearStates( void );
 static int StringToKeyNum( const char *str );
 static const char * KeyNumToString( int keyNum, bool localized );

 static void SetBinding( int keyNum, const char *binding );
 static const char * GetBinding( int keyNum );
 static bool UnbindBinding( const char *bind );
 static int NumBinds( const char *binding );
 static bool ExecKeyBinding( int keyNum );
 static const char * KeysFromBinding( const char *bind );
 static const char * BindingFromKey( const char *key );
 static bool KeyIsBoundTo( int keyNum, const char *binding );
 static void WriteBindings( idFile *f );
};
# 201 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/EditField.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/EditField.h"
const int MAX_EDIT_LINE = 256;

typedef struct autoComplete_s {
 bool valid;
 int length;
 char completionString[MAX_EDIT_LINE];
 char currentMatch[MAX_EDIT_LINE];
 int matchCount;
 int matchIndex;
 int findMatchIndex;
} autoComplete_t;

class idEditField {
public:
     idEditField();
     ~idEditField();

 void Clear( void );
 void SetWidthInChars( int w );
 void SetCursor( int c );
 int GetCursor( void ) const;
 void ClearAutoComplete( void );
 int GetAutoCompleteLength( void ) const;
 void AutoComplete( void );
 void CharEvent( int c );
 void KeyDownEvent( int key );
 void Paste( void );
 char * GetBuffer( void );
 void Draw( int x, int y, int width, bool showCursor, const idMaterial *material );
 void SetBuffer( const char *buffer );

private:
 int cursor;
 int scroll;
 int widthInChars;
 char buffer[MAX_EDIT_LINE];
 autoComplete_t autoComplete;
};
# 202 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Console.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Console.h"
class idConsole {
public:
 virtual ~idConsole( void ) {}

 virtual void Init( void ) = 0;
 virtual void Shutdown( void ) = 0;


 virtual void LoadGraphics() = 0;

 virtual bool ProcessEvent( const sysEvent_t *event, bool forceAccept ) = 0;


 virtual bool Active( void ) = 0;


 virtual void ClearNotifyLines( void ) = 0;


 virtual void Close( void ) = 0;

 virtual void Draw( bool forceFullScreen ) = 0;
 virtual void Print( const char *text ) = 0;
};

extern idConsole * console;
# 203 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DemoFile.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/DemoFile.h"
typedef enum {
 DS_FINISHED,
 DS_RENDER,
 DS_SOUND,
 DS_VERSION
} demoSystem_t;

class idDemoFile : public idFile {
public:
     idDemoFile();
     ~idDemoFile();

 const char * GetName( void ) { return (f?f->GetName():""); }
 const char * GetFullPath( void ) { return (f?f->GetFullPath():""); }

 void SetLog( bool b, const char *p );
 void Log( const char *p );
 bool OpenForReading( const char *fileName );
 bool OpenForWriting( const char *fileName );
 void Close();

 const char * ReadHashString();
 void WriteHashString( const char *str );

 void ReadDict( idDict &dict );
 void WriteDict( const idDict &dict );

 int Read( void *buffer, int len );
 int Write( const void *buffer, int len );

private:
 static idCompressor *AllocCompressor( int type );

 bool writing;
 byte * fileImage;
 idFile * f;
 idCompressor * compressor;

 idList<idStr*> demoStrings;
 idFile * fLog;
 bool log;
 idStr logStr;

 static idCVar com_logDemos;
 static idCVar com_compressDemos;
 static idCVar com_preloadDemos;
};
# 204 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Session.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/Session.h"
typedef struct {
 short health;
 short heartRate;
 short stamina;
 short combat;
} logStats_t;




static const int MAX_LOGGED_STATS = 2 * 120;


typedef enum {
 MSG_OK,
 MSG_ABORT,
 MSG_OKCANCEL,
 MSG_YESNO,
 MSG_PROMPT,
 MSG_CDKEY,
 MSG_INFO,
 MSG_WAIT
} msgBoxType_t;

typedef const char * (*HandleGuiCommand_t)( const char * );

class idSession {
public:
 virtual ~idSession() {}



 virtual void Init() = 0;


 virtual void Shutdown() = 0;


 virtual void Stop() = 0;





 virtual void UpdateScreen( bool outOfSequence = true ) = 0;



 virtual void PacifierUpdate() = 0;




 virtual void Frame() = 0;



 virtual bool IsMultiplayer() = 0;


 virtual bool ProcessEvent( const sysEvent_t *event ) = 0;


 virtual void StartMenu( bool playIntro = false ) = 0;

 virtual void SetGUI( idUserInterface *gui, HandleGuiCommand_t handle ) = 0;


 virtual void GuiFrameEvents() = 0;





 virtual const char *MessageBox( msgBoxType_t type, const char *message, const char *title = __null, bool wait = false, const char *fire_yes = __null, const char *fire_no = __null, bool network = false ) = 0;
 virtual void StopBox( void ) = 0;

 virtual void DownloadProgressBox( backgroundDownload_t *bgl, const char *title, int progress_start = 0, int progress_end = 100 ) = 0;

 virtual void SetPlayingSoundWorld() = 0;



 virtual void TimeHitch( int msec ) = 0;



 virtual void ReadCDKey( void ) = 0;
 virtual void WriteCDKey( void ) = 0;


 virtual const char *GetCDKey( bool xp ) = 0;



 virtual bool CheckKey( const char *key, bool netConnect, bool offline_valid[ 2 ] ) = 0;



 virtual bool CDKeysAreValid( bool strict ) = 0;

 virtual void ClearCDKey( bool valid[ 2 ] ) = 0;


 virtual void SetCDKeyGuiVars( void ) = 0;

 virtual bool WaitingForGameAuth( void ) = 0;


 virtual void CDKeysAuthReply( bool valid, const char *auth_msg ) = 0;

 virtual const char *GetCurrentMapName( void ) = 0;

 virtual int GetSaveGameVersion( void ) = 0;


 idRenderWorld * rw;
 idSoundWorld * sw;



 idDemoFile * readDemo;
 idDemoFile * writeDemo;
 int renderdemoVersion;
};

extern idSession * session;
# 205 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncNetwork.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncNetwork.h"
const int ASYNC_PROTOCOL_MINOR = 41;
const int ASYNC_PROTOCOL_VERSION = ( 1 << 16 ) + ASYNC_PROTOCOL_MINOR;



const int MAX_ASYNC_CLIENTS = 4;




const int MAX_USERCMD_BACKUP = 256;
const int MAX_USERCMD_DUPLICATION = 25;
const int MAX_USERCMD_RELAY = 10;



const int MAX_MASTER_SERVERS = 5;

const int MAX_NICKLEN = 32;


const int MAX_SERVER_PORTS = 8;


const int GAME_INIT_ID_INVALID = -1;
const int GAME_INIT_ID_MAP_LOAD = -2;


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/MsgChannel.h" 1
# 56 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/MsgChannel.h"
class idMsgQueue {
public:
     idMsgQueue();

 void Init( int sequence );

 bool Add( const byte *data, const int size );
 bool Get( byte *data, int &size );
 int GetTotalSize( void ) const;
 int GetSpaceLeft( void ) const;
 int GetFirst( void ) const { return first; }
 int GetLast( void ) const { return last; }
 void CopyToBuffer( byte *buf ) const;

private:
 byte buffer[16384];
 int first;
 int last;
 int startIndex;
 int endIndex;

 void WriteByte( byte b );
 byte ReadByte( void );
 void WriteShort( int s );
 int ReadShort( void );
 void WriteLong( int l );
 int ReadLong( void );
 void WriteData( const byte *data, const int size );
 void ReadData( byte *data, const int size );
};


class idMsgChannel {
public:
     idMsgChannel();

 void Init( const netadr_t adr, const int id );
 void Shutdown( void );
 void ResetRate( void );


 void SetMaxOutgoingRate( int rate ) { maxRate = rate; }


 int GetMaxOutgoingRate( void ) { return maxRate; }


 netadr_t GetRemoteAddress( void ) const { return remoteAddress; }


 int GetOutgoingRate( void ) const { return outgoingRateBytes; }


 int GetIncomingRate( void ) const { return incomingRateBytes; }


 float GetOutgoingCompression( void ) const { return outgoingCompression; }


 float GetIncomingCompression( void ) const { return incomingCompression; }


 float GetIncomingPacketLoss( void ) const;


 bool ReadyToSend( const int time ) const;


 int SendMessage( idPort &port, const int time, const idBitMsg &msg );


 void SendNextFragment( idPort &port, const int time );


 bool UnsentFragmentsLeft( void ) const { return unsentFragments; }





 bool Process( const netadr_t from, int time, idBitMsg &msg, int &sequence );


 bool SendReliableMessage( const idBitMsg &msg );


 bool GetReliableMessage( idBitMsg &msg );


 void ClearReliableMessages( void );

private:
 netadr_t remoteAddress;
 int id;
 int maxRate;
 idCompressor * compressor;


 int lastSendTime;
 int lastDataBytes;


 int outgoingRateTime;
 int outgoingRateBytes;
 int incomingRateTime;
 int incomingRateBytes;


 float outgoingCompression;
 float incomingCompression;


 float incomingReceivedPackets;
 float incomingDroppedPackets;
 int incomingPacketLossTime;


 int outgoingSequence;
 int incomingSequence;


 bool unsentFragments;
 int unsentFragmentStart;
 byte unsentBuffer[16384];
 idBitMsg unsentMsg;


 int fragmentSequence;
 int fragmentLength;
 byte fragmentBuffer[16384];


 idMsgQueue reliableSend;
 idMsgQueue reliableReceive;

private:
 void WriteMessageData( idBitMsg &out, const idBitMsg &msg );
 bool ReadMessageData( idBitMsg &out, const idBitMsg &msg );

 void UpdateOutgoingRate( const int time, const int size );
 void UpdateIncomingRate( const int time, const int size );

 void UpdatePacketLoss( const int time, const int numReceived, const int numDropped );
};
# 69 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncNetwork.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncServer.h" 1
# 45 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncServer.h"
const int MAX_CHALLENGES = 64;



const int AUTHORIZE_TIMEOUT = 5000;


typedef enum {
 CDK_WAIT = 0,


 CDK_OK,
 CDK_ONLYLAN,
 CDK_PUREWAIT,
 CDK_PUREOK,
 CDK_MAXSTATES
} authState_t;


typedef enum {
 AUTH_NONE = 0,
 AUTH_OK,
 AUTH_WAIT,
 AUTH_DENY,
 AUTH_MAXSTATES
} authReply_t;



typedef enum {
 AUTH_REPLY_WAITING = 0,
 AUTH_REPLY_UNKNOWN,
 AUTH_REPLY_DENIED,
 AUTH_REPLY_PRINT,
 AUTH_REPLY_SRVWAIT,
 AUTH_REPLY_MAXSTATES
} authReplyMsg_t;

typedef struct challenge_s {
 netadr_t address;
 int clientId;
 int challenge;
 int time;
 int pingTime;
 bool connected;
 authState_t authState;
 authReply_t authReply;
 authReplyMsg_t authReplyMsg;
 idStr authReplyPrint;
 char guid[12];
 int OS;
} challenge_t;

typedef enum {
 SCS_FREE,
 SCS_ZOMBIE,
 SCS_PUREWAIT,
 SCS_CONNECTED,
 SCS_INGAME
} serverClientState_t;

typedef struct serverClient_s {
 int OS;
 int clientId;
 serverClientState_t clientState;
 int clientPrediction;
 int clientAheadTime;
 int clientRate;
 int clientPing;

 int gameInitSequence;
 int gameFrame;
 int gameTime;

 idMsgChannel channel;
 int lastConnectTime;
 int lastEmptyTime;
 int lastPingTime;
 int lastSnapshotTime;
 int lastPacketTime;
 int lastInputTime;
 int snapshotSequence;
 int acknowledgeSnapshotSequence;
 int numDuplicatedUsercmds;

 char guid[12];

} serverClient_t;


class idAsyncServer {
public:
      idAsyncServer();

 bool InitPort( void );
 void ClosePort( void );
 void Spawn( void );
 void Kill( void );
 void ExecuteMapChange( void );

 int GetPort( void ) const;
 netadr_t GetBoundAdr( void ) const;
 bool IsActive( void ) const { return active; }
 int GetDelay( void ) const { return gameTimeResidual; }
 int GetOutgoingRate( void ) const;
 int GetIncomingRate( void ) const;
 bool IsClientInGame( int clientNum ) const;
 int GetClientPing( int clientNum ) const;
 int GetClientPrediction( int clientNum ) const;
 int GetClientTimeSinceLastPacket( int clientNum ) const;
 int GetClientTimeSinceLastInput( int clientNum ) const;
 int GetClientOutgoingRate( int clientNum ) const;
 int GetClientIncomingRate( int clientNum ) const;
 float GetClientOutgoingCompression( int clientNum ) const;
 float GetClientIncomingCompression( int clientNum ) const;
 float GetClientIncomingPacketLoss( int clientNum ) const;
 int GetNumClients( void ) const;
 int GetNumIdleClients( void ) const;
 int GetLocalClientNum( void ) const { return localClientNum; }

 void RunFrame( void );
 void ProcessConnectionLessMessages( void );
 void RemoteConsoleOutput( const char *string );
 void SendReliableGameMessage( int clientNum, const idBitMsg &msg );
 void SendReliableGameMessageExcluding( int clientNum, const idBitMsg &msg );
 void LocalClientSendReliableMessage( const idBitMsg &msg );

 void MasterHeartbeat( bool force = false );
 void DropClient( int clientNum, const char *reason );

 void PacifierUpdate( void );

 void UpdateUI( int clientNum );

 void UpdateAsyncStatsAvg( void );
 void GetAsyncStatsAvgMsg( idStr &msg );

 void PrintLocalServerInfo( void );

private:
 bool active;
 int realTime;

 int serverTime;
 idPort serverPort;
 int serverId;
 int serverDataChecksum;
 int localClientNum;

 challenge_t challenges[MAX_CHALLENGES];
 serverClient_t clients[MAX_ASYNC_CLIENTS];
 usercmd_t userCmds[MAX_USERCMD_BACKUP][MAX_ASYNC_CLIENTS];

 int gameInitId;
 int gameFrame;
 int gameTime;
 int gameTimeResidual;

 netadr_t rconAddress;

 int nextHeartbeatTime;
 int nextAsyncStatsTime;

 bool serverReloadingEngine;

 bool noRconOutput;

 int lastAuthTime;



 static const int stats_numsamples = 60;
 int stats_outrate[ stats_numsamples ];
 int stats_current;
 int stats_average_sum;
 int stats_max;
 int stats_max_index;

 void PrintOOB( const netadr_t to, int opcode, const char *string );
 void DuplicateUsercmds( int frame, int time );
 void ClearClient( int clientNum );
 void InitClient( int clientNum, int clientId, int clientRate );
 void InitLocalClient( int clientNum );
 void BeginLocalClient( void );
 void LocalClientInput( void );
 void CheckClientTimeouts( void );
 void SendPrintBroadcast( const char *string );
 void SendPrintToClient( int clientNum, const char *string );
 void SendUserInfoBroadcast( int userInfoNum, const idDict &info, bool sendToAll = false );
 void SendUserInfoToClient( int clientNum, int userInfoNum, const idDict &info );
 void SendSyncedCvarsBroadcast( const idDict &cvars );
 void SendSyncedCvarsToClient( int clientNum, const idDict &cvars );
 void SendApplySnapshotToClient( int clientNum, int sequence );
 bool SendEmptyToClient( int clientNum, bool force = false );
 bool SendPingToClient( int clientNum );
 void SendGameInitToClient( int clientNum );
 bool SendSnapshotToClient( int clientNum );
 void ProcessUnreliableClientMessage( int clientNum, const idBitMsg &msg );
 void ProcessReliableClientMessages( int clientNum );
 void ProcessChallengeMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessConnectMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessRemoteConsoleMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessGetInfoMessage( const netadr_t from, const idBitMsg &msg );
 bool ConnectionlessMessage( const netadr_t from, const idBitMsg &msg );
 bool ProcessMessage( const netadr_t from, idBitMsg &msg );
 void ProcessAuthMessage( const idBitMsg &msg );
 bool SendPureServerMessage( const netadr_t to, int OS );
 void ProcessPureMessage( const netadr_t from, const idBitMsg &msg );
 int ValidateChallenge( const netadr_t from, int challenge, int clientId );
 bool SendReliablePureToClient( int clientNum );
 void ProcessReliablePure( int clientNum, const idBitMsg &msg );
 bool VerifyChecksumMessage( int clientNum, const netadr_t *from, const idBitMsg &msg, idStr &reply, int OS );
 void SendReliableMessage( int clientNum, const idBitMsg &msg );
 int UpdateTime( int clamp );
 void SendEnterGameToClient( int clientNum );
 void ProcessDownloadRequestMessage( const netadr_t from, const idBitMsg &msg );
};
# 70 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncNetwork.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/ServerScan.h" 1
# 43 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/ServerScan.h"
typedef struct {
 netadr_t adr;
 int id;
 int time;
} inServer_t;


typedef struct {
 netadr_t adr;
 idDict serverInfo;
 int ping;
 int id;
 int clients;
 char nickname[ MAX_NICKLEN ][ MAX_ASYNC_CLIENTS ];
 short pings[ MAX_ASYNC_CLIENTS ];
 int rate[ MAX_ASYNC_CLIENTS ];
 int OSMask;
    int challenge;
} networkServer_t;

typedef enum {
 SORT_PING,
 SORT_SERVERNAME,
 SORT_PLAYERS,
 SORT_GAMETYPE,
 SORT_MAP,
 SORT_GAME
} serverSort_t;

class idServerScan : public idList<networkServer_t> {
public:
      idServerScan( );

 int InfoResponse( networkServer_t &server );


 void AddServer( int id, const char *srv );



 void StartServers( bool timeout );

 void EndServers( );


 void NetScan( );


 void Clear( );


 void RunFrame( );

 typedef enum {
  IDLE = 0,
  WAIT_ON_INIT,
  LAN_SCAN,
  NET_SCAN
 } scan_state_t;

 scan_state_t GetState() { return scan_state; }
 void SetState( scan_state_t );

 bool GetBestPing( networkServer_t &serv );


 void SetupLANScan( );

 void GUIConfig( idUserInterface *pGUI, const char *name );

 void GUIUpdateSelected( void );

 void Shutdown( );

 void ApplyFilter( );


 void SetSorting( serverSort_t sort );

 int GetChallenge( );

private:
 static const int MAX_PINGREQUESTS = 32;
 static const int REPLY_TIMEOUT = 999;
 static const int INCOMING_TIMEOUT = 1500;
 static const int REFRESH_START = 10000;

 scan_state_t scan_state;

 bool incoming_net;
 bool incoming_useTimeout;
 int incoming_lastTime;

 int lan_pingtime;




 idDict net_info;

 idList<inServer_t> net_servers;


 int cur_info;

 idUserInterface *m_pGUI;
 idListGUI * listGUI;

 serverSort_t m_sort;
 bool m_sortAscending;
 idList<int> m_sortedServers;

 idStr screenshot;
 int challenge;

 int endWaitTime;

private:
 void LocalClear( );

 void EmitGetInfo( netadr_t &serv );
 void GUIAdd( int id, const networkServer_t server );
 bool IsFiltered( const networkServer_t server );

 static int Cmp( const int *a, const int *b );
};
# 71 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncNetwork.h" 2
# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncClient.h" 1
# 40 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncClient.h"
typedef enum {
 CS_DISCONNECTED,
 CS_PURERESTART,
 CS_CHALLENGING,
 CS_CONNECTING,
 CS_CONNECTED,
 CS_INGAME
} clientState_t;

typedef enum {
 AUTHKEY_BADKEY,
 AUTHKEY_GUID
} authKeyMsg_t;

typedef enum {
 AUTHKEY_BAD_INVALID,
 AUTHKEY_BAD_BANNED,
 AUTHKEY_BAD_INUSE,
 AUTHKEY_BAD_MSG
} authBadKeyStatus_t;

typedef enum {
 UPDATE_NONE,
 UPDATE_SENT,
 UPDATE_READY,
 UPDATE_DLING,
 UPDATE_DONE
} clientUpdateState_t;

typedef struct {
 idStr url;
 idStr filename;
 int size;
 int checksum;
} pakDlEntry_t;

class idAsyncClient {
public:
      idAsyncClient();

 void Shutdown( void );
 bool InitPort( void );
 void ClosePort( void );
 void ConnectToServer( const netadr_t adr );
 void ConnectToServer( const char *address );
 void Reconnect( void );
 void DisconnectFromServer( void );
 void GetServerInfo( const netadr_t adr );
 void GetServerInfo( const char *address );
 void GetLANServers( void );
 void GetNETServers( void );
 void ListServers( void );
 void ClearServers( void );
 void RemoteConsole( const char *command );
 bool IsPortInitialized() { return clientPort.GetPort() != 0; }

 bool IsActive( void ) const { return active; }
 int GetLocalClientNum( void ) const { return clientNum; }
 int GetPrediction( void ) const;
 int GetTimeSinceLastPacket( void ) const;
 int GetOutgoingRate( void ) const;
 int GetIncomingRate( void ) const;
 float GetOutgoingCompression( void ) const;
 float GetIncomingCompression( void ) const;
 float GetIncomingPacketLoss( void ) const;
 int GetPredictedFrames( void ) const { return lastFrameDelta; }

 void RunFrame( void );
 void SendReliableGameMessage( const idBitMsg &msg );

 void SendVersionCheck( bool fromMenu = false );


 bool SendAuthCheck( const char *cdkey, const char *xpkey );

 void PacifierUpdate( void );

 idServerScan serverList;

private:
 bool active;
 int realTime;

 int clientTime;
 idPort clientPort;
 int clientId;
 int clientDataChecksum;
 int clientNum;
 clientState_t clientState;
 int clientPrediction;
 int clientPredictTime;

 netadr_t serverAddress;
 int serverId;
 int serverChallenge;
 int serverMessageSequence;

 netadr_t lastRconAddress;
 int lastRconTime;

 idMsgChannel channel;
 int lastConnectTime;
 int lastEmptyTime;
 int lastPacketTime;
 int lastSnapshotTime;

 int snapshotSequence;
 int snapshotGameFrame;
 int snapshotGameTime;

 int gameInitId;
 int gameFrame;
 int gameTime;
 int gameTimeResidual;

 usercmd_t userCmds[MAX_USERCMD_BACKUP][MAX_ASYNC_CLIENTS];

 idUserInterface * guiNetMenu;

 clientUpdateState_t updateState;
 int updateSentTime;
 idStr updateMSG;
 idStr updateURL;
 bool updateDirectDownload;
 idStr updateFile;
 dlMime_t updateMime;
 idStr updateFallback;
 bool showUpdateMessage;

 backgroundDownload_t backgroundDownload;
 int dltotal;
 int dlnow;

 int lastFrameDelta;

 int dlRequest;
 int dlChecksums[ MAX_PURE_PAKS ];
 int dlCount;
 idList<pakDlEntry_t>dlList;
 int currentDlSize;
 int totalDlSize;

 void Clear( void );
 void ClearPendingPackets( void );
 void DuplicateUsercmds( int frame, int time );
 void SendUserInfoToServer( void );
 void SendEmptyToServer( bool force = false, bool mapLoad = false );
 void SendPingResponseToServer( int time );
 void SendUsercmdsToServer( void );
 void InitGame( int serverGameInitId, int serverGameFrame, int serverGameTime, const idDict &serverSI );
 void ProcessUnreliableServerMessage( const idBitMsg &msg );
 void ProcessReliableServerMessages( void );
 void ProcessChallengeResponseMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessConnectResponseMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessDisconnectMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessInfoResponseMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessPrintMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessServersListMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessAuthKeyMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessVersionMessage( const netadr_t from, const idBitMsg &msg );
 void ConnectionlessMessage( const netadr_t from, const idBitMsg &msg );
 void ProcessMessage( const netadr_t from, idBitMsg &msg );
 void SetupConnection( void );
 void ProcessPureMessage( const netadr_t from, const idBitMsg &msg );
 bool ValidatePureServerChecksums( const netadr_t from, const idBitMsg &msg );
 void ProcessReliableMessagePure( const idBitMsg &msg );
 static const char* HandleGuiCommand( const char *cmd );
 const char* HandleGuiCommandInternal( const char *cmd );
 void SendVersionDLUpdate( int state );
 void HandleDownloads( void );
 void Idle( void );
 int UpdateTime( int clamp );
 void ReadLocalizedServerString( const idBitMsg &msg, char* out, int maxLen );
 bool CheckTimeout( void );
 void ProcessDownloadInfoMessage( const netadr_t from, const idBitMsg &msg );
 int GetDownloadRequest( const int checksums[ MAX_PURE_PAKS ], int count, int gamePakChecksum );
};
# 72 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncNetwork.h" 2
# 83 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../framework/async/AsyncNetwork.h"
enum {
 SERVER_UNRELIABLE_MESSAGE_EMPTY = 0,
 SERVER_UNRELIABLE_MESSAGE_PING,
 SERVER_UNRELIABLE_MESSAGE_GAMEINIT,
 SERVER_UNRELIABLE_MESSAGE_SNAPSHOT
};


enum {
 SERVER_RELIABLE_MESSAGE_PURE = 0,
 SERVER_RELIABLE_MESSAGE_RELOAD,
 SERVER_RELIABLE_MESSAGE_CLIENTINFO,
 SERVER_RELIABLE_MESSAGE_SYNCEDCVARS,
 SERVER_RELIABLE_MESSAGE_PRINT,
 SERVER_RELIABLE_MESSAGE_DISCONNECT,
 SERVER_RELIABLE_MESSAGE_APPLYSNAPSHOT,
 SERVER_RELIABLE_MESSAGE_GAME,
 SERVER_RELIABLE_MESSAGE_ENTERGAME
};


enum {
 CLIENT_UNRELIABLE_MESSAGE_EMPTY = 0,
 CLIENT_UNRELIABLE_MESSAGE_PINGRESPONSE,
 CLIENT_UNRELIABLE_MESSAGE_USERCMD
};


enum {
 CLIENT_RELIABLE_MESSAGE_PURE = 0,
 CLIENT_RELIABLE_MESSAGE_CLIENTINFO,
 CLIENT_RELIABLE_MESSAGE_PRINT,
 CLIENT_RELIABLE_MESSAGE_DISCONNECT,
 CLIENT_RELIABLE_MESSAGE_GAME
};


enum {
 SERVER_PRINT_MISC = 0,
 SERVER_PRINT_BADPROTOCOL,
 SERVER_PRINT_RCON,
 SERVER_PRINT_GAMEDENY,
 SERVER_PRINT_BADCHALLENGE
};

enum {
 SERVER_DL_REDIRECT = 1,
 SERVER_DL_LIST,
 SERVER_DL_NONE
};

enum {
 SERVER_PAK_NO = 0,
 SERVER_PAK_YES,
 SERVER_PAK_END
};

typedef struct master_s {
 idCVar * var;
 netadr_t address;
 bool resolved;
} master_t;


class idAsyncNetwork {
public:
       idAsyncNetwork();

 static void Init( void );
 static void Shutdown( void );
 static bool IsActive( void ) { return ( server.IsActive() || client.IsActive() ); }
 static void RunFrame( void );

 static void WriteUserCmdDelta( idBitMsg &msg, const usercmd_t &cmd, const usercmd_t *base );
 static void ReadUserCmdDelta( const idBitMsg &msg, usercmd_t &cmd, const usercmd_t *base );

 static bool DuplicateUsercmd( const usercmd_t &previousUserCmd, usercmd_t &currentUserCmd, int frame, int time );
 static bool UsercmdInputChanged( const usercmd_t &previousUserCmd, const usercmd_t &currentUserCmd );


 static bool GetMasterAddress( int index, netadr_t &adr );

 static netadr_t GetMasterAddress( void );

 static void GetNETServers( );

 static void ExecuteSessionCommand( const char *sessCmd );

 static idAsyncServer server;
 static idAsyncClient client;

 static idCVar verbose;
 static idCVar allowCheats;
 static idCVar serverDedicated;
 static idCVar serverSnapshotDelay;
 static idCVar serverMaxClientRate;
 static idCVar clientMaxRate;
 static idCVar serverMaxUsercmdRelay;
 static idCVar serverZombieTimeout;
 static idCVar serverClientTimeout;
 static idCVar clientServerTimeout;
 static idCVar serverDrawClient;
 static idCVar serverRemoteConsolePassword;
 static idCVar clientPrediction;
 static idCVar clientMaxPrediction;
 static idCVar clientUsercmdBackup;
 static idCVar clientRemoteConsoleAddress;
 static idCVar clientRemoteConsolePassword;
 static idCVar master0;
 static idCVar master1;
 static idCVar master2;
 static idCVar master3;
 static idCVar master4;
 static idCVar LANServer;
 static idCVar serverReloadEngine;
 static idCVar serverAllowServerMod;
 static idCVar idleServer;
 static idCVar clientDownload;


 static void BuildInvalidKeyMsg( idStr &msg, bool valid[ 2 ] );

private:
 static int realTime;
 static master_t masters[ MAX_MASTER_SERVERS];

 static void SpawnServer_f( const idCmdArgs &args );
 static void NextMap_f( const idCmdArgs &args );
 static void Connect_f( const idCmdArgs &args );
 static void Reconnect_f( const idCmdArgs &args );
 static void GetServerInfo_f( const idCmdArgs &args );
 static void GetLANServers_f( const idCmdArgs &args );
 static void ListServers_f( const idCmdArgs &args );
 static void RemoteConsole_f( const idCmdArgs &args );
 static void Heartbeat_f( const idCmdArgs &args );
 static void Kick_f( const idCmdArgs &args );
 static void CheckNewVersion_f( const idCmdArgs &args );
 static void UpdateUI_f( const idCmdArgs &args );
};
# 208 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2



# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/edit_public.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/edit_public.h"
class idProgram;
class idInterpreter;



void RadiantInit( void );
void RadiantShutdown( void );
void RadiantRun( void );
void RadiantPrint( const char *text );
void RadiantSync( const char *mapName, const idVec3 &viewOrg, const idAngles &viewAngles );



void LightEditorInit( const idDict *spawnArgs );
void LightEditorShutdown( void );
void LightEditorRun( void );



void SoundEditorInit( const idDict *spawnArgs );
void SoundEditorShutdown( void );
void SoundEditorRun( void );



void AFEditorInit( const idDict *spawnArgs );
void AFEditorShutdown( void );
void AFEditorRun( void );



void ParticleEditorInit( const idDict *spawnArgs );
void ParticleEditorShutdown( void );
void ParticleEditorRun( void );



void PDAEditorInit( const idDict *spawnArgs );
void PDAEditorShutdown( void );
void PDAEditorRun( void );



void ScriptEditorInit( const idDict *spawnArgs );
void ScriptEditorShutdown( void );
void ScriptEditorRun( void );



void DeclBrowserInit( const idDict *spawnArgs );
void DeclBrowserShutdown( void );
void DeclBrowserRun( void );
void DeclBrowserReloadDeclarations( void );



void GUIEditorInit( void );
void GUIEditorShutdown( void );
void GUIEditorRun( void );
bool GUIEditorHandleMessage( void *msg );



void DebuggerClientLaunch( void );
void DebuggerClientInit( const char *cmdline );
bool DebuggerServerInit( void );
void DebuggerServerShutdown( void );
void DebuggerServerPrint( const char *text );
void DebuggerServerCheckBreakpoint( idInterpreter *interpreter, idProgram *program, int instructionPointer );


void MaterialEditorInit( void );
void MaterialEditorRun( void );
void MaterialEditorShutdown( void );
void MaterialEditorPrintConsole( const char *msg );
# 212 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2


# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/compilers/compiler_public.h" 1
# 41 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/../tools/compilers/compiler_public.h"
void Dmap_f( const idCmdArgs &args );


void RenderBump_f( const idCmdArgs &args );
void RenderBumpFlat_f( const idCmdArgs &args );


void RunAAS_f( const idCmdArgs &args );
void RunAASDir_f( const idCmdArgs &args );
void RunReach_f( const idCmdArgs &args );


void RoQFileEncode_f( const idCmdArgs &args );
# 215 "d:/Data/Nintendo/DoomGX/src/framework/async/../../idlib/precompiled.h" 2
# 30 "d:/Data/Nintendo/DoomGX/src/framework/async/AsyncServer.cpp" 2
#pragma hdrstop

# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/AsyncNetwork.h" 1
# 33 "d:/Data/Nintendo/DoomGX/src/framework/async/AsyncServer.cpp" 2

# 1 "d:/Data/Nintendo/DoomGX/src/framework/async/../Session_local.h" 1
# 53 "d:/Data/Nintendo/DoomGX/src/framework/async/../Session_local.h"
typedef struct {
 usercmd_t cmd;
 int consistencyHash;
} logCmd_t;

struct fileTIME_T {
 int index;
 time_t timeStamp;

     operator int() const { return timeStamp; }
};

typedef struct {
 idDict serverInfo;
 idDict syncedCVars;
 idDict userInfo[MAX_ASYNC_CLIENTS];
 idDict persistentPlayerInfo[MAX_ASYNC_CLIENTS];
 usercmd_t mapSpawnUsercmd[MAX_ASYNC_CLIENTS];
} mapSpawnData_t;

typedef enum {
 TD_NO,
 TD_YES,
 TD_YES_THEN_QUIT
} timeDemo_t;

const int USERCMD_PER_DEMO_FRAME = 2;
const int CONNECT_TRANSMIT_TIME = 1000;



const int MAX_LOGGED_USERCMDS = 60*60*2;


class idSessionLocal : public idSession {
public:

      idSessionLocal();
 virtual ~idSessionLocal();

 virtual void Init();

 virtual void Shutdown();

 virtual void Stop();

 virtual void UpdateScreen( bool outOfSequence = true );

 virtual void PacifierUpdate();

 virtual void Frame();

 virtual bool IsMultiplayer();

 virtual bool ProcessEvent( const sysEvent_t *event );

 virtual void StartMenu( bool playIntro = false );
 virtual void ExitMenu();
 virtual void GuiFrameEvents();
 virtual void SetGUI( idUserInterface *gui, HandleGuiCommand_t handle );

 virtual const char *MessageBox( msgBoxType_t type, const char *message, const char *title = __null, bool wait = false, const char *fire_yes = __null, const char *fire_no = __null, bool network = false );
 virtual void StopBox( void );
 virtual void DownloadProgressBox( backgroundDownload_t *bgl, const char *title, int progress_start = 0, int progress_end = 100 );
 virtual void SetPlayingSoundWorld();

 virtual void TimeHitch( int msec );

 virtual void ReadCDKey( void );
 virtual void WriteCDKey( void );
 virtual const char *GetCDKey( bool xp );
 virtual bool CheckKey( const char *key, bool netConnect, bool offline_valid[ 2 ] );
 virtual bool CDKeysAreValid( bool strict );
 virtual void ClearCDKey( bool valid[ 2 ] );
 virtual void SetCDKeyGuiVars( void );
 virtual bool WaitingForGameAuth( void );
 virtual void CDKeysAuthReply( bool valid, const char *auth_msg );

 virtual int GetSaveGameVersion( void );

 virtual const char *GetCurrentMapName();



 int GetLocalClientNum();

 void MoveToNewMap( const char *mapName );


 void StartNewGame( const char *mapName, bool devmap = false );
 void PlayIntroGui();

 void LoadSession( const char *name );
 void SaveSession( const char *name );


 void DrawWipeModel();
 void StartWipe( const char *materialName, bool hold = false);
 void CompleteWipe();
 void ClearWipe();

 void ShowLoadingGui();

 void ScrubSaveGameFileName( idStr &saveFileName ) const;
 idStr GetAutoSaveName( const char *mapName ) const;

 bool LoadGame(const char *saveName);
 bool SaveGame(const char *saveName, bool autosave = false);

 const char *GetAuthMsg( void );



 static idCVar com_showAngles;
 static idCVar com_showTics;
 static idCVar com_minTics;
 static idCVar com_fixedTic;
 static idCVar com_showDemo;
 static idCVar com_skipGameDraw;
 static idCVar com_aviDemoWidth;
 static idCVar com_aviDemoHeight;
 static idCVar com_aviDemoSamples;
 static idCVar com_aviDemoTics;
 static idCVar com_wipeSeconds;
 static idCVar com_guid;

 static idCVar gui_configServerRate;

 int timeHitch;

 bool menuActive;
 idSoundWorld * menuSoundWorld;

 bool insideExecuteMapChange;

 int bytesNeededForMapLoad;



 int lastPacifierTime;



 mapSpawnData_t mapSpawnData;
 idStr currentMapName;
 bool mapSpawned;

 int numClients;

 int logIndex;
 logCmd_t loggedUsercmds[MAX_LOGGED_USERCMDS];
 int statIndex;
 logStats_t loggedStats[MAX_LOGGED_STATS];
 int lastSaveIndex;


 bool insideUpdateScreen;

 bool loadingSaveGame;
 idFile * savegameFile;
 int savegameVersion;

 idFile * cmdDemoFile;

 int latchedTicNumber;
 int lastGameTic;
 int lastDemoTic;
 bool syncNextGameFrame;


 bool aviCaptureMode;
 idStr aviDemoShortName;
 float aviDemoFrameCount;
 int aviTicStart;

 timeDemo_t timeDemo;
 int timeDemoStartTime;
 int numDemoFrames;
 int demoTimeOffset;
 renderView_t currentDemoRenderView;




 idUserInterface * guiActive;
 HandleGuiCommand_t guiHandle;

 bool isDemoVersion;
 idUserInterface * guiInGame;
 idUserInterface * guiMainMenu;
 idListGUI * guiMainMenu_MapList;
 idUserInterface * guiRestartMenu;
 idUserInterface * guiLoading;
 idUserInterface * guiIntro;
 idUserInterface * guiGameOver;
 idUserInterface * guiTest;
 idUserInterface * guiTakeNotes;

 idUserInterface * guiMsg;
 idUserInterface * guiMsgRestore;
 idStr msgFireBack[ 2 ];
 bool msgRunning;
 int msgRetIndex;
 bool msgIgnoreButtons;

 bool waitingOnBind;

 const idMaterial * whiteMaterial;

 const idMaterial * wipeMaterial;
 int wipeStartTic;
 int wipeStopTic;
 bool wipeHold;






 void Clear();

 void DrawCmdGraph();
 void Draw();

 void WriteCmdDemo( const char *name, bool save = false);
 void StartPlayingCmdDemo( const char *demoName);
 void TimeCmdDemo( const char *demoName);
 void SaveCmdDemoToFile(idFile *file);
 void LoadCmdDemoFromFile(idFile *file);
 void StartRecordingRenderDemo( const char *name );
 void StopRecordingRenderDemo();
 void StartPlayingRenderDemo( idStr name );
 void StopPlayingRenderDemo();
 void CompressDemoFile( const char *scheme, const char *name );
 void TimeRenderDemo( const char *name, bool twice = false );
 void AVIRenderDemo( const char *name );
 void AVICmdDemo( const char *name );
 void AVIGame( const char *name );
 void BeginAVICapture( const char *name );
 void EndAVICapture();

 void AdvanceRenderDemo( bool singleFrameOnly );
 void RunGameTic();

 void FinishCmdLoad();
 void LoadLoadingGui(const char *mapName);

 void DemoShot( const char *name );

 void TestGUI( const char *name );

 int GetBytesNeededForMapLoad( const char *mapName );
 void SetBytesNeededForMapLoad( const char *mapName, int bytesNeeded );

 void ExecuteMapChange( bool noFadeWipe = false );
 void UnloadMap();


 bool MaybeWaitOnCDKey( void );




 idStrList loadGameList;
 idStrList modsList;

 idUserInterface * GetActiveMenu();

 void DispatchCommand( idUserInterface *gui, const char *menuCommand, bool doIngame = true );
 void MenuEvent( const sysEvent_t *event );
 bool HandleSaveGameMenuCommand( idCmdArgs &args, int &icmd );
 void HandleInGameCommands( const char *menuCommand );
 void HandleMainMenuCommands( const char *menuCommand );
 void HandleChatMenuCommands( const char *menuCommand );
 void HandleIntroMenuCommands( const char *menuCommand );
 void HandleRestartMenuCommands( const char *menuCommand );
 void HandleMsgCommands( const char *menuCommand );
 void HandleNoteCommands( const char *menuCommand );
 void GetSaveGameList( idStrList &fileList, idList<fileTIME_T> &fileTimes );
 void TakeNotes( const char * p, bool extended = false );
 void UpdateMPLevelShot( void );

 void SetSaveGameGuiVars( void );
 void SetMainMenuGuiVars( void );
 void SetModsMenuGuiVars( void );
 void SetMainMenuSkin( void );
 void SetPbMenuGuiVars( void );

private:
 bool BoxDialogSanityCheck( void );
 void EmitGameAuth( void );

 typedef enum {
  CDKEY_UNKNOWN,
  CDKEY_INVALID,
  CDKEY_OK,
  CDKEY_CHECKING,
  CDKEY_NA
 } cdKeyState_t;

 static const int CDKEY_BUF_LEN = 17;
 static const int CDKEY_AUTH_TIMEOUT = 5000;

 char cdkey[ CDKEY_BUF_LEN ];
 cdKeyState_t cdkey_state;
 char xpkey[ CDKEY_BUF_LEN ];
 cdKeyState_t xpkey_state;
 int authEmitTimeout;
 bool authWaitBox;

 idStr authMsg;
};

extern idSessionLocal sessLocal;
# 35 "d:/Data/Nintendo/DoomGX/src/framework/async/AsyncServer.cpp" 2

const int MIN_RECONNECT_TIME = 2000;
const int EMPTY_RESEND_TIME = 500;
const int PING_RESEND_TIME = 500;
const int NOINPUT_IDLE_TIME = 30000;

const int HEARTBEAT_MSEC = 5*60*1000;


const char* authReplyMsg[] = {

 "#str_07204",

 "#str_07205",

 "#str_07206",

 "#str_07207",

 "#str_07208"
};

const char* authReplyStr[] = {
 "AUTH_NONE",
 "AUTH_OK",
 "AUTH_WAIT",
 "AUTH_DENY"
};






idAsyncServer::idAsyncServer( void ) {

    Sys_DebugPrintf("idAsyncServer::idAsyncServer( void ) size %d\r\n", sizeof(*this));


 int i;

 active = false;
 realTime = 0;
 serverTime = 0;
 serverId = 0;
 serverDataChecksum = 0;
 localClientNum = -1;
 gameInitId = 0;
 gameFrame = 0;
 gameTime = 0;
 gameTimeResidual = 0;
 memset( challenges, 0, sizeof( challenges ) );
 memset( userCmds, 0, sizeof( userCmds ) );
 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  ClearClient( i );
 }
 serverReloadingEngine = false;
 nextHeartbeatTime = 0;
 nextAsyncStatsTime = 0;
 noRconOutput = true;
 lastAuthTime = 0;

 memset( stats_outrate, 0, sizeof( stats_outrate ) );
 stats_current = 0;
 stats_average_sum = 0;
 stats_max = 0;
 stats_max_index = 0;
}






bool idAsyncServer::InitPort( void ) {
 int lastPort;


 if ( !serverPort.GetPort() ) {
  if ( cvarSystem->GetCVarInteger( "net_port" ) != 0 ) {
   if ( !serverPort.InitForPort( cvarSystem->GetCVarInteger( "net_port" ) ) ) {
    common->Printf( "Unable to open server on port %d (net_port)\n", cvarSystem->GetCVarInteger( "net_port" ) );
    return false;
   }
  } else {

   for ( lastPort = 0; lastPort < 4; lastPort++ ) {
    if ( serverPort.InitForPort( 27666 + lastPort ) ) {
     break;
    }
   }
   if ( lastPort >= 4 ) {
    common->Printf( "Unable to open server network port.\n" );
    return false;
   }
  }
 }

 return true;
}






void idAsyncServer::ClosePort( void ) {
 int i;

 serverPort.Close();
 for ( i = 0; i < MAX_CHALLENGES; i++ ) {
  challenges[ i ].authReplyPrint.Clear();
 }
}






void idAsyncServer::Spawn( void ) {
 int i, size;
 byte msgBuf[16384];
 netadr_t from;


 session->Stop();

 if ( active ) {
  return;
 }

 if ( !InitPort() ) {
  return;
 }


 while( serverPort.GetPacket( from, msgBuf, size, sizeof( msgBuf ) ) ) {
 }


 if ( !idAsyncNetwork::allowCheats.GetBool() ) {
  cvarSystem->ResetFlaggedVariables( CVAR_CHEAT );
 }

 memset( challenges, 0, sizeof( challenges ) );
 memset( userCmds, 0, sizeof( userCmds ) );
 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  ClearClient( i );
 }

 common->Printf( "Server spawned on port %i.\n", serverPort.GetPort() );


 serverDataChecksum = declManager->GetChecksum();


 serverId = Sys_Milliseconds() & 0x7FFF;

 active = true;

 nextHeartbeatTime = 0;
 nextAsyncStatsTime = 0;

 ExecuteMapChange();
}






void idAsyncServer::Kill( void ) {
 int i, j;

 if ( !active ) {
  return;
 }


 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  DropClient( i, "#str_07135" );
 }


 for ( j = 0; j < 4; j++ ) {
  for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
   if ( clients[i].clientState == SCS_ZOMBIE ) {
    if ( clients[i].channel.UnsentFragmentsLeft() ) {
     clients[i].channel.SendNextFragment( serverPort, serverTime );
    } else {
     SendEmptyToClient( i, true );
    }
   }
  }
  Sys_Sleep( 10 );
 }


 fileSystem->ClearPureChecksums();

 active = false;


 session->Stop();
}






void idAsyncServer::ExecuteMapChange( void ) {
 int i;
 idBitMsg msg;
 byte msgBuf[16384];
 idStr mapName;
 findFile_t ff;
 bool addonReload = false;
 char bestGameType[ 1024 ];

 ((void)0);


 fileSystem->ClearPureChecksums();


 game->GetBestGameType( cvarSystem->GetCVarString("si_map"), cvarSystem->GetCVarString("si_gametype"), bestGameType );
 cvarSystem->SetCVarString("si_gametype", bestGameType );


 cmdSystem->BufferCommandText( CMD_EXEC_NOW, "rescanSI" );

 sprintf( mapName, "maps/%s", sessLocal.mapSpawnData.serverInfo.GetString( "si_map" ) );
 mapName.SetFileExtension( ".map" );
 ff = fileSystem->FindFile( mapName, !serverReloadingEngine );
 switch( ff ) {
 case FIND_NO:
  common->Printf( "Can't find map %s\n", mapName.c_str() );
  cmdSystem->BufferCommandText( CMD_EXEC_APPEND, "disconnect\n" );
  return;
 case FIND_ADDON:


  common->Printf( "map %s is in an addon pak - reloading\n", mapName.c_str() );
  addonReload = true;
  break;
 default:
  break;
 }


 if ( !serverReloadingEngine && ( addonReload || idAsyncNetwork::serverReloadEngine.GetInteger() != 0 ) ) {
  if ( idAsyncNetwork::serverReloadEngine.GetInteger() != 0 ) {
   common->Printf( "net_serverReloadEngine enabled - doing a full reload\n" );
  }





  for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
   if ( clients[ i ].clientState >= SCS_PUREWAIT && i != localClientNum ) {
    msg.Init( msgBuf, sizeof( msgBuf ) );
    msg.WriteByte( SERVER_RELIABLE_MESSAGE_RELOAD );
    SendReliableMessage( i, msg );
    clients[ i ].clientState = SCS_ZOMBIE;
   }
  }
  cmdSystem->BufferCommandText( CMD_EXEC_NOW, "reloadEngine" );
  serverReloadingEngine = true;
  cmdSystem->BufferCommandText( CMD_EXEC_APPEND, "spawnServer\n" );

  if ( idAsyncNetwork::serverReloadEngine.GetInteger() > 0 ) {
   idAsyncNetwork::serverReloadEngine.SetInteger( idAsyncNetwork::serverReloadEngine.GetInteger() - 1 );
  }
  return;
 }
 serverReloadingEngine = false;

 serverTime = 0;


 gameInitId ^= Sys_Milliseconds();
 gameFrame = 0;
 gameTime = 0;
 gameTimeResidual = 0;
 memset( userCmds, 0, sizeof( userCmds ) );

 if ( idAsyncNetwork::serverDedicated.GetInteger() == 0 ) {
  InitLocalClient( 0 );
 } else {
  localClientNum = -1;
 }


 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[i].clientState >= SCS_PUREWAIT && i != localClientNum ) {

   InitClient( i, clients[i].clientId, clients[i].clientRate );

   SendGameInitToClient( i );

   if ( sessLocal.mapSpawnData.serverInfo.GetBool( "si_pure" ) ) {
    clients[ i ].clientState = SCS_PUREWAIT;
   }
  }
 }



 if ( sessLocal.mapSpawnData.serverInfo.GetInt( "si_pure" ) ) {
  if ( !fileSystem->UpdateGamePakChecksums( ) ) {
   session->MessageBox( MSG_OK, common->GetLanguageDict()->GetString ( "#str_04337" ), common->GetLanguageDict()->GetString ( "#str_04338" ), true );
   cmdSystem->BufferCommandText( CMD_EXEC_APPEND, "disconnect\n" );
   return;
  }
 }


 sessLocal.ExecuteMapChange();

 if ( localClientNum >= 0 ) {
  BeginLocalClient();
 } else {
  game->SetLocalClient( -1 );
 }

 if ( sessLocal.mapSpawnData.serverInfo.GetInt( "si_pure" ) ) {

  fileSystem->UpdatePureServerChecksums( );

  for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
   if ( clients[ i ].clientState == SCS_PUREWAIT ) {
    if ( !SendReliablePureToClient( i ) ) {
     clients[ i ].clientState = SCS_CONNECTED;
    }
   }
  }
 }


 MasterHeartbeat( true );
}






int idAsyncServer::GetPort( void ) const {
 return serverPort.GetPort();
}






netadr_t idAsyncServer::GetBoundAdr( void ) const {
 return serverPort.GetAdr();
}






int idAsyncServer::GetOutgoingRate( void ) const {
 int i, rate;

 rate = 0;
 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  const serverClient_t &client = clients[i];

  if ( client.clientState >= SCS_CONNECTED ) {
   rate += client.channel.GetOutgoingRate();
  }
 }
 return rate;
}






int idAsyncServer::GetIncomingRate( void ) const {
 int i, rate;

 rate = 0;
 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  const serverClient_t &client = clients[i];

  if ( client.clientState >= SCS_CONNECTED ) {
   rate += client.channel.GetIncomingRate();
  }
 }
 return rate;
}






bool idAsyncServer::IsClientInGame( int clientNum ) const {
 return ( clients[clientNum].clientState >= SCS_INGAME );
}






int idAsyncServer::GetClientPing( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return 99999;
 } else {
  return client.clientPing;
 }
}






int idAsyncServer::GetClientPrediction( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return 99999;
 } else {
  return client.clientPrediction;
 }
}






int idAsyncServer::GetClientTimeSinceLastPacket( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return 99999;
 } else {
  return serverTime - client.lastPacketTime;
 }
}






int idAsyncServer::GetClientTimeSinceLastInput( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return 99999;
 } else {
  return serverTime - client.lastInputTime;
 }
}






int idAsyncServer::GetClientOutgoingRate( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return -1;
 } else {
  return client.channel.GetOutgoingRate();
 }
}






int idAsyncServer::GetClientIncomingRate( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return -1;
 } else {
  return client.channel.GetIncomingRate();
 }
}






float idAsyncServer::GetClientOutgoingCompression( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return 0.0f;
 } else {
  return client.channel.GetOutgoingCompression();
 }
}






float idAsyncServer::GetClientIncomingCompression( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return 0.0f;
 } else {
  return client.channel.GetIncomingCompression();
 }
}






float idAsyncServer::GetClientIncomingPacketLoss( int clientNum ) const {
 const serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return 0.0f;
 } else {
  return client.channel.GetIncomingPacketLoss();
 }
}






int idAsyncServer::GetNumClients( void ) const {
 int ret = 0;
 for ( int i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[ i ].clientState >= SCS_CONNECTED ) {
   ret++;
  }
 }
 return ret;
}






int idAsyncServer::GetNumIdleClients( void ) const {
 int ret = 0;
 for ( int i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[ i ].clientState >= SCS_CONNECTED ) {
   if ( serverTime - clients[ i ].lastInputTime > NOINPUT_IDLE_TIME ) {
    ret++;
   }
  }
 }
 return ret;
}






void idAsyncServer::DuplicateUsercmds( int frame, int time ) {
 int i, previousIndex, currentIndex;

 previousIndex = ( frame - 1 ) & ( MAX_USERCMD_BACKUP - 1 );
 currentIndex = frame & ( MAX_USERCMD_BACKUP - 1 );


 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[i].clientState == SCS_FREE ) {
   continue;
  }

  if ( idAsyncNetwork::DuplicateUsercmd( userCmds[previousIndex][i], userCmds[currentIndex][i], frame, time ) ) {
   clients[i].numDuplicatedUsercmds++;
  }
 }
}






void idAsyncServer::ClearClient( int clientNum ) {
 serverClient_t &client = clients[clientNum];
 client.clientId = 0;
 client.clientState = SCS_FREE;
 client.clientPrediction = 0;
 client.clientAheadTime = 0;
 client.clientRate = 0;
 client.clientPing = 0;
 client.gameInitSequence = 0;
 client.gameFrame = 0;
 client.gameTime = 0;
 client.channel.Shutdown();
 client.lastConnectTime = 0;
 client.lastEmptyTime = 0;
 client.lastPingTime = 0;
 client.lastSnapshotTime = 0;
 client.lastPacketTime = 0;
 client.lastInputTime = 0;
 client.snapshotSequence = 0;
 client.acknowledgeSnapshotSequence = 0;
 client.numDuplicatedUsercmds = 0;
}






void idAsyncServer::InitClient( int clientNum, int clientId, int clientRate ) {
 int i;


 sessLocal.mapSpawnData.userInfo[ clientNum ].Clear();


 serverClient_t &client = clients[clientNum];
 client.clientId = clientId;
 client.clientState = SCS_CONNECTED;
 client.clientPrediction = 0;
 client.clientAheadTime = 0;
 client.gameInitSequence = -1;
 client.gameFrame = 0;
 client.gameTime = 0;
 client.channel.ResetRate();
 client.clientRate = clientRate ? clientRate : idAsyncNetwork::serverMaxClientRate.GetInteger();
 client.channel.SetMaxOutgoingRate( Min( idAsyncNetwork::serverMaxClientRate.GetInteger(), client.clientRate ) );
 client.clientPing = 0;
 client.lastConnectTime = serverTime;
 client.lastEmptyTime = serverTime;
 client.lastPingTime = serverTime;
 client.lastSnapshotTime = serverTime;
 client.lastPacketTime = serverTime;
 client.lastInputTime = serverTime;
 client.acknowledgeSnapshotSequence = 0;
 client.numDuplicatedUsercmds = 0;


 for ( i = 0; i < MAX_USERCMD_BACKUP; i++ ) {
  memset( &userCmds[i][clientNum], 0, sizeof( userCmds[i][clientNum] ) );
 }


 game->ServerClientConnect( clientNum, client.guid );
}






void idAsyncServer::InitLocalClient( int clientNum ) {
 netadr_t badAddress;

 localClientNum = clientNum;
 InitClient( clientNum, 0, 0 );
 memset( &badAddress, 0, sizeof( badAddress ) );
 badAddress.type = NA_BAD;
 clients[clientNum].channel.Init( badAddress, serverId );
 clients[clientNum].clientState = SCS_INGAME;
 sessLocal.mapSpawnData.userInfo[clientNum] = *cvarSystem->MoveCVarsToDict( CVAR_USERINFO );
}






void idAsyncServer::BeginLocalClient( void ) {
 game->SetLocalClient( localClientNum );
 game->SetUserInfo( localClientNum, sessLocal.mapSpawnData.userInfo[localClientNum], false, false );
 game->ServerClientBegin( localClientNum );
}






void idAsyncServer::LocalClientInput( void ) {
 int index;

 if ( localClientNum < 0 ) {
  return;
 }

 index = gameFrame & ( MAX_USERCMD_BACKUP - 1 );
 userCmds[index][localClientNum] = usercmdGen->GetDirectUsercmd();
 userCmds[index][localClientNum].gameFrame = gameFrame;
 userCmds[index][localClientNum].gameTime = gameTime;
 if ( idAsyncNetwork::UsercmdInputChanged( userCmds[( gameFrame - 1 ) & ( MAX_USERCMD_BACKUP - 1 )][localClientNum], userCmds[index][localClientNum] ) ) {
  clients[localClientNum].lastInputTime = serverTime;
 }
 clients[localClientNum].gameFrame = gameFrame;
 clients[localClientNum].gameTime = gameTime;
 clients[localClientNum].lastPacketTime = serverTime;
}






void idAsyncServer::DropClient( int clientNum, const char *reason ) {
 int i;
 idBitMsg msg;
 byte msgBuf[16384];

 serverClient_t &client = clients[clientNum];

 if ( client.clientState <= SCS_ZOMBIE ) {
  return;
 }

 if ( client.clientState >= SCS_PUREWAIT && clientNum != localClientNum ) {
  msg.Init( msgBuf, sizeof( msgBuf ) );
  msg.WriteByte( SERVER_RELIABLE_MESSAGE_DISCONNECT );
  msg.WriteLong( clientNum );
  msg.WriteString( reason );
  for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {

   if ( i == clientNum || clients[i].clientState >= SCS_CONNECTED ) {
    SendReliableMessage( i, msg );
   }
  }
 }

 reason = common->GetLanguageDict()->GetString( reason );
 common->Printf( "client %d %s\n", clientNum, reason );
 cmdSystem->BufferCommandText( CMD_EXEC_NOW, va( "addChatLine \"%s^0 %s\"", sessLocal.mapSpawnData.userInfo[ clientNum ].GetString( "ui_name" ), reason ) );


 game->ServerClientDisconnect( clientNum );

 client.clientState = SCS_ZOMBIE;
}






void idAsyncServer::SendReliableMessage( int clientNum, const idBitMsg &msg ) {
 if ( clientNum == localClientNum ) {
  return;
 }
 if ( !clients[ clientNum ].channel.SendReliableMessage( msg ) ) {
  clients[ clientNum ].channel.ClearReliableMessages();
  DropClient( clientNum, "#str_07136" );
 }
}






void idAsyncServer::CheckClientTimeouts( void ) {
 int i, zombieTimeout, clientTimeout;

 zombieTimeout = serverTime - idAsyncNetwork::serverZombieTimeout.GetInteger() * 1000;
 clientTimeout = serverTime - idAsyncNetwork::serverClientTimeout.GetInteger() * 1000;

 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  serverClient_t &client = clients[i];

  if ( i == localClientNum ) {
   continue;
  }

  if ( client.lastPacketTime > serverTime ) {
   client.lastPacketTime = serverTime;
   continue;
  }

  if ( client.clientState == SCS_ZOMBIE && client.lastPacketTime < zombieTimeout ) {
   client.channel.Shutdown();
   client.clientState = SCS_FREE;
   continue;
  }

  if ( client.clientState >= SCS_PUREWAIT && client.lastPacketTime < clientTimeout ) {
   DropClient( i, "#str_07137" );
   continue;
  }
 }
}






void idAsyncServer::SendPrintBroadcast( const char *string ) {
 int i;
 idBitMsg msg;
 byte msgBuf[16384];

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_PRINT );
 msg.WriteString( string );

 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[i].clientState >= SCS_CONNECTED ) {
   SendReliableMessage( i, msg );
  }
 }
}






void idAsyncServer::SendPrintToClient( int clientNum, const char *string ) {
 idBitMsg msg;
 byte msgBuf[16384];

 serverClient_t &client = clients[clientNum];

 if ( client.clientState < SCS_CONNECTED ) {
  return;
 }

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_PRINT );
 msg.WriteString( string );

 SendReliableMessage( clientNum, msg );
}






void idAsyncServer::SendUserInfoBroadcast( int userInfoNum, const idDict &info, bool sendToAll ) {
 idBitMsg msg;
 byte msgBuf[16384];
 const idDict *gameInfo;
 bool gameModifiedInfo;

 gameInfo = game->SetUserInfo( userInfoNum, info, false, true );
 if ( gameInfo ) {
  gameModifiedInfo = true;
 } else {
  gameModifiedInfo = false;
  gameInfo = &info;
 }

 if ( userInfoNum == localClientNum ) {
  common->DPrintf( "local user info modified by server\n" );
  cvarSystem->SetCVarsFromDict( *gameInfo );
  cvarSystem->ClearModifiedFlags( CVAR_USERINFO );
 }

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_CLIENTINFO );
 msg.WriteByte( userInfoNum );
 if ( gameModifiedInfo || sendToAll ) {
  msg.WriteBits( 0, 1 );
 } else {
  msg.WriteBits( 1, 1 );
 }







 if ( gameModifiedInfo || sendToAll ) {
  msg.WriteDeltaDict( *gameInfo, __null );
 } else {
  msg.WriteDeltaDict( *gameInfo, &sessLocal.mapSpawnData.userInfo[userInfoNum] );
 }

 for ( int i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[i].clientState >= SCS_CONNECTED && ( sendToAll || i != userInfoNum || gameModifiedInfo ) ) {
   SendReliableMessage( i, msg );
  }
 }

 sessLocal.mapSpawnData.userInfo[userInfoNum] = *gameInfo;
}
# 953 "d:/Data/Nintendo/DoomGX/src/framework/async/AsyncServer.cpp"
void idAsyncServer::UpdateUI( int clientNum ) {
 const idDict *info = game->GetUserInfo( clientNum );

 if ( !info ) {
  common->Warning( "idAsyncServer::UpdateUI: no info from game\n" );
  return;
 }

 SendUserInfoBroadcast( clientNum, *info, true );
}






void idAsyncServer::SendUserInfoToClient( int clientNum, int userInfoNum, const idDict &info ) {
 idBitMsg msg;
 byte msgBuf[16384];

 if ( clients[clientNum].clientState < SCS_CONNECTED ) {
  return;
 }

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_CLIENTINFO );
 msg.WriteByte( userInfoNum );
 msg.WriteBits( 0, 1 );






 msg.WriteDeltaDict( info, __null );

 SendReliableMessage( clientNum, msg );
}






void idAsyncServer::SendSyncedCvarsBroadcast( const idDict &cvars ) {
 idBitMsg msg;
 byte msgBuf[16384];
 int i;

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_SYNCEDCVARS );
 msg.WriteDeltaDict( cvars, &sessLocal.mapSpawnData.syncedCVars );

 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[i].clientState >= SCS_CONNECTED ) {
   SendReliableMessage( i, msg );
  }
 }

 sessLocal.mapSpawnData.syncedCVars = cvars;
}






void idAsyncServer::SendSyncedCvarsToClient( int clientNum, const idDict &cvars ) {
 idBitMsg msg;
 byte msgBuf[16384];

 if ( clients[clientNum].clientState < SCS_CONNECTED ) {
  return;
 }

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_SYNCEDCVARS );
 msg.WriteDeltaDict( cvars, __null );

 SendReliableMessage( clientNum, msg );
}






void idAsyncServer::SendApplySnapshotToClient( int clientNum, int sequence ) {
 idBitMsg msg;
 byte msgBuf[16384];

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_APPLYSNAPSHOT );
 msg.WriteLong( sequence );

 SendReliableMessage( clientNum, msg );
}






bool idAsyncServer::SendEmptyToClient( int clientNum, bool force ) {
 idBitMsg msg;
 byte msgBuf[16384];

 serverClient_t &client = clients[clientNum];

 if ( client.lastEmptyTime > realTime ) {
  client.lastEmptyTime = realTime;
 }

 if ( !force && ( realTime - client.lastEmptyTime < EMPTY_RESEND_TIME ) ) {
  return false;
 }

 if ( idAsyncNetwork::verbose.GetInteger() ) {
  common->Printf( "sending empty to client %d: gameInitId = %d, gameFrame = %d, gameTime = %d\n", clientNum, gameInitId, gameFrame, gameTime );
 }

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteLong( gameInitId );
 msg.WriteByte( SERVER_UNRELIABLE_MESSAGE_EMPTY );

 client.channel.SendMessage( serverPort, serverTime, msg );

 client.lastEmptyTime = realTime;

 return true;
}






bool idAsyncServer::SendPingToClient( int clientNum ) {
 idBitMsg msg;
 byte msgBuf[16384];

 serverClient_t &client = clients[clientNum];

 if ( client.lastPingTime > realTime ) {
  client.lastPingTime = realTime;
 }

 if ( realTime - client.lastPingTime < PING_RESEND_TIME ) {
  return false;
 }

 if ( idAsyncNetwork::verbose.GetInteger() == 2 ) {
  common->Printf( "pinging client %d: gameInitId = %d, gameFrame = %d, gameTime = %d\n", clientNum, gameInitId, gameFrame, gameTime );
 }

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteLong( gameInitId );
 msg.WriteByte( SERVER_UNRELIABLE_MESSAGE_PING );
 msg.WriteLong( realTime );

 client.channel.SendMessage( serverPort, serverTime, msg );

 client.lastPingTime = realTime;

 return true;
}






void idAsyncServer::SendGameInitToClient( int clientNum ) {
 idBitMsg msg;
 byte msgBuf[16384];

 if ( idAsyncNetwork::verbose.GetInteger() ) {
  common->Printf( "sending gameinit to client %d: gameInitId = %d, gameFrame = %d, gameTime = %d\n", clientNum, gameInitId, gameFrame, gameTime );
 }

 serverClient_t &client = clients[clientNum];


 while( client.channel.UnsentFragmentsLeft() ) {
  client.channel.SendNextFragment( serverPort, serverTime );
 }

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteLong( gameInitId );
 msg.WriteByte( SERVER_UNRELIABLE_MESSAGE_GAMEINIT );
 msg.WriteLong( gameFrame );
 msg.WriteLong( gameTime );
 msg.WriteDeltaDict( sessLocal.mapSpawnData.serverInfo, __null );
 client.gameInitSequence = client.channel.SendMessage( serverPort, serverTime, msg );
}






bool idAsyncServer::SendSnapshotToClient( int clientNum ) {
 int i, j, index, numUsercmds;
 idBitMsg msg;
 byte msgBuf[16384];
 usercmd_t * last;
 byte clientInPVS[MAX_ASYNC_CLIENTS >> 3];

 serverClient_t &client = clients[clientNum];

 if ( serverTime - client.lastSnapshotTime < idAsyncNetwork::serverSnapshotDelay.GetInteger() ) {
  return false;
 }

 if ( idAsyncNetwork::verbose.GetInteger() == 2 ) {
  common->Printf( "sending snapshot to client %d: gameInitId = %d, gameFrame = %d, gameTime = %d\n", clientNum, gameInitId, gameFrame, gameTime );
 }


 client.clientAheadTime = client.gameTime - ( gameTime + gameTimeResidual );


 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteLong( gameInitId );
 msg.WriteByte( SERVER_UNRELIABLE_MESSAGE_SNAPSHOT );
 msg.WriteLong( client.snapshotSequence );
 msg.WriteLong( gameFrame );
 msg.WriteLong( gameTime );
 msg.WriteByte( idMath::ClampChar( client.numDuplicatedUsercmds ) );
 msg.WriteShort( idMath::ClampShort( client.clientAheadTime ) );


 game->ServerWriteSnapshot( clientNum, client.snapshotSequence, msg, clientInPVS, MAX_ASYNC_CLIENTS );


 for ( last = __null, i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  serverClient_t &client = clients[i];

  if ( client.clientState == SCS_FREE || i == clientNum ) {
   continue;
  }


  if ( !( clientInPVS[i >> 3] & ( 1 << ( i & 7 ) ) ) ) {
   continue;
  }

  int maxRelay = idMath::ClampInt( 1, MAX_USERCMD_RELAY, idAsyncNetwork::serverMaxUsercmdRelay.GetInteger() );


  numUsercmds = Max( 1, Min( client.gameFrame, gameFrame + maxRelay ) - gameFrame );
  msg.WriteByte( i );
  msg.WriteByte( numUsercmds );
  for ( j = 0; j < numUsercmds; j++ ) {
   index = ( gameFrame + j ) & ( MAX_USERCMD_BACKUP - 1 );
   idAsyncNetwork::WriteUserCmdDelta( msg, userCmds[index][i], last );
   last = &userCmds[index][i];
  }
 }
 msg.WriteByte( MAX_ASYNC_CLIENTS );

 client.channel.SendMessage( serverPort, serverTime, msg );

 client.lastSnapshotTime = serverTime;
 client.snapshotSequence++;
 client.numDuplicatedUsercmds = 0;

 return true;
}






void idAsyncServer::ProcessUnreliableClientMessage( int clientNum, const idBitMsg &msg ) {
 int i, id, acknowledgeSequence, clientGameInitId, clientGameFrame, numUsercmds, index;
 usercmd_t *last;

 serverClient_t &client = clients[clientNum];

 if ( client.clientState == SCS_ZOMBIE ) {
  return;
 }

 acknowledgeSequence = msg.ReadLong();
 clientGameInitId = msg.ReadLong();


 if ( clientGameInitId == GAME_INIT_ID_MAP_LOAD ) {
  if ( idAsyncNetwork::verbose.GetInteger() ) {
   common->Printf( "ignore unreliable msg from client %d, gameInitId == ID_MAP_LOAD\n", clientNum );
  }
  return;
 }


 if ( clientGameInitId != gameInitId ) {
  if ( acknowledgeSequence > client.gameInitSequence ) {

   client.clientState = SCS_CONNECTED;


   SendGameInitToClient( clientNum );

   if ( sessLocal.mapSpawnData.serverInfo.GetBool( "si_pure" ) ) {
    client.clientState = SCS_PUREWAIT;
    if ( !SendReliablePureToClient( clientNum ) ) {
     client.clientState = SCS_CONNECTED;
    }
   }
  } else if ( idAsyncNetwork::verbose.GetInteger() ) {
   common->Printf( "ignore unreliable msg from client %d, wrong gameInit, old sequence\n", clientNum );
  }
  return;
 }

 client.acknowledgeSnapshotSequence = msg.ReadLong();

 if ( client.clientState == SCS_CONNECTED ) {


  client.clientState = SCS_INGAME;


  for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
   if ( clients[i].clientState >= SCS_CONNECTED && i != clientNum ) {
    SendUserInfoToClient( clientNum, i, sessLocal.mapSpawnData.userInfo[i] );
   }
  }


  SendSyncedCvarsToClient( clientNum, sessLocal.mapSpawnData.syncedCVars );

  SendEnterGameToClient( clientNum );


  game->ServerClientBegin( clientNum );


  game->ServerWriteInitialReliableMessages( clientNum );
 } else if ( client.clientState == SCS_INGAME ) {


  if ( game->ServerApplySnapshot( clientNum, client.acknowledgeSnapshotSequence ) ) {
   SendApplySnapshotToClient( clientNum, client.acknowledgeSnapshotSequence );
  }
 }


 id = msg.ReadByte();
 switch( id ) {
  case CLIENT_UNRELIABLE_MESSAGE_EMPTY: {
   if ( idAsyncNetwork::verbose.GetInteger() ) {
    common->Printf( "received empty message for client %d\n", clientNum );
   }
   break;
  }
  case CLIENT_UNRELIABLE_MESSAGE_PINGRESPONSE: {
   client.clientPing = realTime - msg.ReadLong();
   break;
  }
  case CLIENT_UNRELIABLE_MESSAGE_USERCMD: {

   client.clientPrediction = msg.ReadShort();


   clientGameFrame = msg.ReadLong();
   numUsercmds = msg.ReadByte();
   for ( last = __null, i = clientGameFrame - numUsercmds + 1; i <= clientGameFrame; i++ ) {
    index = i & ( MAX_USERCMD_BACKUP - 1 );
    idAsyncNetwork::ReadUserCmdDelta( msg, userCmds[index][clientNum], last );
    userCmds[index][clientNum].gameFrame = i;
    userCmds[index][clientNum].duplicateCount = 0;
    if ( idAsyncNetwork::UsercmdInputChanged( userCmds[( i - 1 ) & ( MAX_USERCMD_BACKUP - 1 )][clientNum], userCmds[index][clientNum] ) ) {
     client.lastInputTime = serverTime;
    }
    last = &userCmds[index][clientNum];
   }

   if ( last ) {
    client.gameFrame = last->gameFrame;
    client.gameTime = last->gameTime;
   }

   if ( idAsyncNetwork::verbose.GetInteger() == 2 ) {
    common->Printf( "received user command for client %d, gameInitId = %d, gameFrame, %d gameTime %d\n", clientNum, clientGameInitId, client.gameFrame, client.gameTime );
   }
   break;
  }
  default: {
   common->Printf( "unknown unreliable message %d from client %d\n", id, clientNum );
   break;
  }
 }
}






void idAsyncServer::ProcessReliableClientMessages( int clientNum ) {
 idBitMsg msg;
 byte msgBuf[16384];
 byte id;

 serverClient_t &client = clients[clientNum];

 msg.Init( msgBuf, sizeof( msgBuf ) );

 while ( client.channel.GetReliableMessage( msg ) ) {
  id = msg.ReadByte();
  switch( id ) {
   case CLIENT_RELIABLE_MESSAGE_CLIENTINFO: {
    idDict info;
    msg.ReadDeltaDict( info, &sessLocal.mapSpawnData.userInfo[clientNum] );
    SendUserInfoBroadcast( clientNum, info );
    break;
   }
   case CLIENT_RELIABLE_MESSAGE_PRINT: {
    char string[1024];
    msg.ReadString( string, sizeof( string ) );
    common->Printf( "%s\n", string );
    break;
   }
   case CLIENT_RELIABLE_MESSAGE_DISCONNECT: {
    DropClient( clientNum, "#str_07138" );
    break;
   }
   case CLIENT_RELIABLE_MESSAGE_PURE: {

    ProcessReliablePure( clientNum, msg );
    break;
   }
   default: {

    game->ServerProcessReliableMessage( clientNum, msg );
    break;
   }
  }
 }
}






void idAsyncServer::ProcessAuthMessage( const idBitMsg &msg ) {
 netadr_t client_from;
 char client_guid[ 12 ], string[ 1024 ];
 int i, clientId;
 authReply_t reply;
 authReplyMsg_t replyMsg = AUTH_REPLY_WAITING;
 idStr replyPrintMsg;

 reply = (authReply_t)msg.ReadByte();
 if ( reply <= 0 || reply >= AUTH_MAXSTATES ) {
  common->DPrintf( "auth: invalid reply %d\n", reply );
  return;
 }
 clientId = msg.ReadShort( );
 msg.ReadNetadr( &client_from );
 msg.ReadString( client_guid, sizeof( client_guid ) );
 if ( reply != AUTH_OK ) {
  replyMsg = (authReplyMsg_t)msg.ReadByte();
  if ( replyMsg <= 0 || replyMsg >= AUTH_REPLY_MAXSTATES ) {
   common->DPrintf( "auth: invalid reply msg %d\n", replyMsg );
   return;
  }
  if ( replyMsg == AUTH_REPLY_PRINT ) {
   msg.ReadString( string, 1024 );
   replyPrintMsg = string;
  }
 }

 lastAuthTime = serverTime;



 for ( i = 0; i < MAX_CHALLENGES; i++ ) {
  if ( !challenges[i].connected && challenges[ i ].clientId == clientId ) {


   if ( !strlen( challenges[ i ].guid ) ) {
    common->DPrintf( "auth: client %s has no guid yet\n", Sys_NetAdrToString( challenges[ i ].address ) );
    return;
   }
   if ( idStr::Cmp( challenges[ i ].guid, client_guid ) ) {
    common->DPrintf( "auth: client %s %s not matched, auth server says guid %s\n", Sys_NetAdrToString( challenges[ i ].address ), challenges[i].guid, client_guid );
    return;
   }
   if ( !Sys_CompareNetAdrBase( client_from, challenges[i].address ) ) {

    common->DPrintf( "auth: matched guid '%s' for != IPs %s and %s\n", client_guid, Sys_NetAdrToString( client_from ), Sys_NetAdrToString( challenges[i].address ) );
   }
   break;
  }
 }
 if ( i >= MAX_CHALLENGES ) {
  common->DPrintf( "auth: failed client lookup %s %s\n", Sys_NetAdrToString( client_from ), client_guid );
  return;
 }

 if ( challenges[ i ].authState != CDK_WAIT ) {
  common->DWarning( "auth: challenge 0x%x %s authState %d != CDK_WAIT", challenges[ i ].challenge, Sys_NetAdrToString( challenges[ i ].address ), challenges[ i ].authState );
  return;
 }

 idStr::snPrintf( challenges[ i ].guid, 12, client_guid );
 if ( reply == AUTH_OK ) {
  challenges[ i ].authState = CDK_OK;
  common->Printf( "client %s %s is authed\n", Sys_NetAdrToString( client_from ), client_guid );
 } else {
  const char *msg;
  if ( replyMsg != AUTH_REPLY_PRINT ) {
   msg = authReplyMsg[ replyMsg ];
  } else {
   msg = replyPrintMsg.c_str();
  }

  const char *l_msg = common->GetLanguageDict()->GetString( msg );
  common->DPrintf( "auth: client %s %s - %s %s\n", Sys_NetAdrToString( client_from ), client_guid, authReplyStr[ reply ], l_msg );
  challenges[ i ].authReply = reply;
  challenges[ i ].authReplyMsg = replyMsg;
  challenges[ i ].authReplyPrint = replyPrintMsg;
 }
}






void idAsyncServer::ProcessChallengeMessage( const netadr_t from, const idBitMsg &msg ) {
 int i, clientId, oldest, oldestTime;
 idBitMsg outMsg;
 byte msgBuf[16384];

 clientId = msg.ReadLong();

 oldest = 0;
 oldestTime = 0x7fffffff;


 for ( i = 0; i < MAX_CHALLENGES; i++ ) {
  if ( !challenges[i].connected && Sys_CompareNetAdrBase( from, challenges[i].address ) && clientId == challenges[i].clientId ) {
   break;
  }
  if ( challenges[i].time < oldestTime ) {
   oldestTime = challenges[i].time;
   oldest = i;
  }
 }

 if ( i >= MAX_CHALLENGES ) {

  i = oldest;
  challenges[i].address = from;
  challenges[i].clientId = clientId;
  challenges[i].challenge = ( (rand() << 16) ^ rand() ) ^ serverTime;
  challenges[i].time = serverTime;
  challenges[i].connected = false;
  challenges[i].authState = CDK_WAIT;
  challenges[i].authReply = AUTH_NONE;
  challenges[i].authReplyMsg = AUTH_REPLY_WAITING;
  challenges[i].authReplyPrint = "";
  challenges[i].guid[0] = '\0';
 }
 challenges[i].pingTime = serverTime;

 common->Printf( "sending challenge 0x%x to %s\n", challenges[i].challenge, Sys_NetAdrToString( from ) );

 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteShort( -1 );
 outMsg.WriteString( "challengeResponse" );
 outMsg.WriteLong( challenges[i].challenge );
 outMsg.WriteShort( serverId );
 outMsg.WriteString( cvarSystem->GetCVarString( "fs_game_base" ) );
 outMsg.WriteString( cvarSystem->GetCVarString( "fs_game" ) );

 serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );

 if ( Sys_IsLANAddress( from ) ) {

  challenges[i].authState = CDK_OK;
 } else {
  if ( idAsyncNetwork::LANServer.GetBool() ) {
   common->Printf( "net_LANServer is enabled. Client %s is not a LAN address, will be rejected\n", Sys_NetAdrToString( from ) );
   challenges[ i ].authState = CDK_ONLYLAN;
  } else {

   outMsg.BeginWriting();
   outMsg.WriteShort( -1 );
   outMsg.WriteString( "srvAuth" );
   outMsg.WriteLong( ASYNC_PROTOCOL_VERSION );
   outMsg.WriteNetadr( from );
   outMsg.WriteLong( -1 );

   outMsg.WriteByte( fileSystem->RunningD3XP() );
   serverPort.SendPacket( idAsyncNetwork::GetMasterAddress(), outMsg.GetData(), outMsg.GetSize() );
  }
 }
}






bool idAsyncServer::SendPureServerMessage( const netadr_t to, int OS ) {
 idBitMsg outMsg;
 byte msgBuf[ 16384 ];
 int serverChecksums[ MAX_PURE_PAKS ];
 int gamePakChecksum;
 int i;

 fileSystem->GetPureServerChecksums( serverChecksums, OS, &gamePakChecksum );
 if ( !serverChecksums[ 0 ] ) {

  common->Warning( "pure server has no pak files referenced" );
  return false;
 }
 common->DPrintf( "client %s: sending pure pak list\n", Sys_NetAdrToString( to ) );


 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteShort( -1 );
 outMsg.WriteString( "pureServer" );

 i = 0;
 while ( serverChecksums[ i ] ) {
  outMsg.WriteLong( serverChecksums[ i++ ] );
 }
 outMsg.WriteLong( 0 );


 outMsg.WriteLong( gamePakChecksum );

 serverPort.SendPacket( to, outMsg.GetData(), outMsg.GetSize() );
 return true;
}






bool idAsyncServer::SendReliablePureToClient( int clientNum ) {
 idBitMsg msg;
 byte msgBuf[ 16384 ];
 int serverChecksums[ MAX_PURE_PAKS ];
 int i;
 int gamePakChecksum;

 fileSystem->GetPureServerChecksums( serverChecksums, clients[ clientNum ].OS, &gamePakChecksum );
 if ( !serverChecksums[ 0 ] ) {

  common->Warning( "pure server has no pak files referenced" );
  return false;
 }

 common->DPrintf( "client %d: sending pure pak list (reliable channel) @ gameInitId %d\n", clientNum, gameInitId );

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_PURE );

 msg.WriteLong( gameInitId );

 i = 0;
 while ( serverChecksums[ i ] ) {
  msg.WriteLong( serverChecksums[ i++ ] );
 }
 msg.WriteLong( 0 );
 msg.WriteLong( gamePakChecksum );

 SendReliableMessage( clientNum, msg );

 return true;
}






int idAsyncServer::ValidateChallenge( const netadr_t from, int challenge, int clientId ) {
 int i;
 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  const serverClient_t &client = clients[i];

  if ( client.clientState == SCS_FREE ) {
   continue;
  }
  if ( Sys_CompareNetAdrBase( from, client.channel.GetRemoteAddress() ) &&
     ( clientId == client.clientId || from.port == client.channel.GetRemoteAddress().port ) ) {
   if ( serverTime - client.lastConnectTime < MIN_RECONNECT_TIME ) {
    common->Printf( "%s: reconnect rejected : too soon\n", Sys_NetAdrToString( from ) );
    return -1;
   }
   break;
  }
 }

 for ( i = 0; i < MAX_CHALLENGES; i++ ) {
  if ( Sys_CompareNetAdrBase( from, challenges[i].address ) && from.port == challenges[i].address.port ) {
   if ( challenge == challenges[i].challenge ) {
    break;
   }
  }
 }
 if ( i == MAX_CHALLENGES ) {
  PrintOOB( from, SERVER_PRINT_BADCHALLENGE, "#str_04840" );
  return -1;
 }
 return i;
}






void idAsyncServer::ProcessConnectMessage( const netadr_t from, const idBitMsg &msg ) {
 int clientNum, protocol, clientDataChecksum, challenge, clientId, ping, clientRate;
 idBitMsg outMsg;
 byte msgBuf[ 16384 ];
 char guid[ 12 ];
 char password[ 17 ];
 int i, ichallenge, islot, OS, numClients;

 protocol = msg.ReadLong();
 OS = msg.ReadShort();


 if ( protocol != ASYNC_PROTOCOL_VERSION ) {

  PrintOOB( from, SERVER_PRINT_BADPROTOCOL, va( "server uses protocol %d.%d\n", 1, ASYNC_PROTOCOL_MINOR ) );
  return;
 }

 clientDataChecksum = msg.ReadLong();
 challenge = msg.ReadLong();
 clientId = msg.ReadShort();
 clientRate = msg.ReadLong();


 if ( !sessLocal.mapSpawnData.serverInfo.GetInt( "si_pure" ) && clientDataChecksum != serverDataChecksum ) {
  PrintOOB( from, SERVER_PRINT_MISC, "#str_04842" );
  return;
 }

 if ( ( ichallenge = ValidateChallenge( from, challenge, clientId ) ) == -1 ) {
  return;
 }
 challenges[ ichallenge ].OS = OS;

 msg.ReadString( guid, sizeof( guid ) );

 switch ( challenges[ ichallenge ].authState ) {
  case CDK_PUREWAIT:
   SendPureServerMessage( from, OS );
   return;
  case CDK_ONLYLAN:
   common->DPrintf( "%s: not a lan client\n", Sys_NetAdrToString( from ) );
   PrintOOB( from, SERVER_PRINT_MISC, "#str_04843" );
   return;
  case CDK_WAIT:
   if ( challenges[ ichallenge ].authReply == AUTH_NONE && Min( serverTime - lastAuthTime, serverTime - challenges[ ichallenge ].time ) > AUTHORIZE_TIMEOUT ) {
    common->DPrintf( "%s: Authorize server timed out\n", Sys_NetAdrToString( from ) );
    break;
   }
   const char *msg, *l_msg;
   if ( challenges[ ichallenge ].authReplyMsg != AUTH_REPLY_PRINT ) {
    msg = authReplyMsg[ challenges[ ichallenge ].authReplyMsg ];
   } else {
    msg = challenges[ ichallenge ].authReplyPrint.c_str();
   }
   l_msg = common->GetLanguageDict()->GetString( msg );

   common->DPrintf( "%s: %s\n", Sys_NetAdrToString( from ), l_msg );

   if ( challenges[ ichallenge ].authReplyMsg == AUTH_REPLY_UNKNOWN || challenges[ ichallenge ].authReplyMsg == AUTH_REPLY_WAITING ) {


    idBitMsg outMsg;
    byte msgBuf[ 16384 ];
    outMsg.Init( msgBuf, sizeof( msgBuf ) );
    outMsg.WriteShort( -1 );
    outMsg.WriteString( "authrequired" );
    serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );
   }

   PrintOOB( from, SERVER_PRINT_MISC, msg );


   idStr::snPrintf( challenges[ ichallenge ].guid, sizeof( challenges[ ichallenge ].guid ), guid );


   if ( challenges[ ichallenge ].authReply != AUTH_DENY ) {

    outMsg.Init( msgBuf, sizeof( msgBuf ) );
    outMsg.WriteShort( -1 );
    outMsg.WriteString( "srvAuth" );
    outMsg.WriteLong( ASYNC_PROTOCOL_VERSION );
    outMsg.WriteNetadr( from );
    outMsg.WriteLong( clientId );
    outMsg.WriteString( guid );

    outMsg.WriteByte( fileSystem->RunningD3XP() );
    serverPort.SendPacket( idAsyncNetwork::GetMasterAddress(), outMsg.GetData(), outMsg.GetSize() );
   }
   return;
  default:
   ((void)0);
 }

 numClients = 0;
 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  serverClient_t &client = clients[ i ];
  if ( client.clientState >= SCS_PUREWAIT ) {
   numClients++;
  }
 }




 msg.ReadString( password, sizeof( password ) );
 char reason[1024];
 allowReply_t reply = game->ServerAllowClient( numClients, Sys_NetAdrToString( from ), guid, password, reason );
 if ( reply != ALLOW_YES ) {
  common->DPrintf( "game denied connection for %s\n", Sys_NetAdrToString( from ) );


  outMsg.Init( msgBuf, sizeof( msgBuf ) );
  outMsg.WriteShort( -1 );
  outMsg.WriteString( "print" );
  outMsg.WriteLong( SERVER_PRINT_GAMEDENY );
  outMsg.WriteLong( reply );
  outMsg.WriteString( reason );
  serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );

  return;
 }


 if ( sessLocal.mapSpawnData.serverInfo.GetInt( "si_pure" ) && challenges[ ichallenge ].authState != CDK_PUREOK ) {
  if ( SendPureServerMessage( from, OS ) ) {
   challenges[ ichallenge ].authState = CDK_PUREWAIT;
   return;
  }
 }


 if ( sessLocal.mapSpawnData.serverInfo.GetInt( "si_pure" ) && clientDataChecksum != serverDataChecksum ) {
  PrintOOB( from, SERVER_PRINT_MISC, "#str_04844" );
  return;
 }

 ping = serverTime - challenges[ ichallenge ].pingTime;
 common->Printf( "challenge from %s connecting with %d ping\n", Sys_NetAdrToString( from ), ping );
 challenges[ ichallenge ].connected = true;


 for ( islot = 0; islot < 3; islot++ ) {
  for ( clientNum = 0; clientNum < MAX_ASYNC_CLIENTS; clientNum++ ) {
   serverClient_t &client = clients[ clientNum ];

   if ( islot == 0 ) {

    if ( Sys_CompareNetAdrBase( from, client.channel.GetRemoteAddress() ) &&
      ( clientId == client.clientId || from.port == client.channel.GetRemoteAddress().port ) ) {
     break;
    }
   } else if ( islot == 1 ) {

    if ( client.clientState >= SCS_PUREWAIT ) {
     continue;
    }
    if ( Sys_CompareNetAdrBase( from, client.channel.GetRemoteAddress() ) ) {
     break;
    }
   } else if ( islot == 2 ) {

    if ( client.clientState == SCS_FREE ) {
     break;
    }
   }
  }

  if ( clientNum < MAX_ASYNC_CLIENTS ) {

   clients[ clientNum ].channel.Init( from, serverId );
   clients[ clientNum ].OS = OS;
   strncpy( clients[ clientNum ].guid, guid, 12 );
   clients[ clientNum ].guid[11] = 0;
   break;
  }
 }


 if ( clientNum >= MAX_ASYNC_CLIENTS ) {
  PrintOOB( from, SERVER_PRINT_MISC, "#str_04845" );
  return;
 }

 common->Printf( "sending connect response to %s\n", Sys_NetAdrToString( from ) );


 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteShort( -1 );
 outMsg.WriteString( "connectResponse" );
 outMsg.WriteLong( clientNum );
 outMsg.WriteLong( gameInitId );
 outMsg.WriteLong( gameFrame );
 outMsg.WriteLong( gameTime );
 outMsg.WriteDeltaDict( sessLocal.mapSpawnData.serverInfo, __null );

 serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );

 InitClient( clientNum, clientId, clientRate );

 clients[clientNum].gameInitSequence = 1;
 clients[clientNum].snapshotSequence = 1;


 memset( &challenges[ ichallenge ], 0, sizeof( challenge_t ) );
}






bool idAsyncServer::VerifyChecksumMessage( int clientNum, const netadr_t *from, const idBitMsg &msg, idStr &reply, int OS ) {
 int i, numChecksums;
 int checksums[ MAX_PURE_PAKS ];
 int gamePakChecksum;
 int serverChecksums[ MAX_PURE_PAKS ];
 int serverGamePakChecksum;


 numChecksums = 0;
 do {
  i = msg.ReadLong( );
  checksums[ numChecksums++ ] = i;

  if ( numChecksums >= MAX_PURE_PAKS ) {
   common->Warning( "MAX_PURE_PAKS ( %d ) exceeded in idAsyncServer::ProcessPureMessage\n", MAX_PURE_PAKS );
   sprintf( reply, "#str_07144" );
   return false;
  }
 } while ( i );
 numChecksums--;


 gamePakChecksum = msg.ReadLong( );

 fileSystem->GetPureServerChecksums( serverChecksums, OS, &serverGamePakChecksum );
 ((void)0);


 if ( serverGamePakChecksum != gamePakChecksum ) {
  common->Printf( "client %s: invalid game code pak ( 0x%x )\n", from ? Sys_NetAdrToString( *from ) : va( "%d", clientNum ), gamePakChecksum );
  sprintf( reply, "#str_07145" );
  return false;
 }
 for ( i = 0; serverChecksums[ i ] != 0; i++ ) {
  if ( checksums[ i ] != serverChecksums[ i ] ) {
   common->DPrintf( "client %s: pak missing ( 0x%x )\n", from ? Sys_NetAdrToString( *from ) : va( "%d", clientNum ), serverChecksums[ i ] );
   sprintf( reply, "pak missing ( 0x%x )\n", serverChecksums[ i ] );
   return false;
  }
 }
 if ( checksums[ i ] != 0 ) {
  common->DPrintf( "client %s: extra pak file referenced ( 0x%x )\n", from ? Sys_NetAdrToString( *from ) : va( "%d", clientNum ), checksums[ i ] );
  sprintf( reply, "extra pak file referenced ( 0x%x )\n", checksums[ i ] );
  return false;
 }
 return true;
}






void idAsyncServer::ProcessPureMessage( const netadr_t from, const idBitMsg &msg ) {
 int iclient, challenge, clientId;
 idStr reply;

 challenge = msg.ReadLong();
 clientId = msg.ReadShort();

 if ( ( iclient = ValidateChallenge( from, challenge, clientId ) ) == -1 ) {
  return;
 }

 if ( challenges[ iclient ].authState != CDK_PUREWAIT ) {
  common->DPrintf( "client %s: got pure message, not in CDK_PUREWAIT\n", Sys_NetAdrToString( from ) );
  return;
 }

 if ( !VerifyChecksumMessage( iclient, &from, msg, reply, challenges[ iclient ].OS ) ) {
  PrintOOB( from, SERVER_PRINT_MISC, reply );
  return;
 }

 common->DPrintf( "client %s: passed pure checks\n", Sys_NetAdrToString( from ) );
 challenges[ iclient ].authState = CDK_PUREOK;
}






void idAsyncServer::ProcessReliablePure( int clientNum, const idBitMsg &msg ) {
 idStr reply;
 idBitMsg outMsg;
 byte msgBuf[16384];
 int clientGameInitId;

 clientGameInitId = msg.ReadLong();
 if ( clientGameInitId != gameInitId ) {
  common->DPrintf( "client %d: ignoring reliable pure from an old gameInit (%d)\n", clientNum, clientGameInitId );
  return;
 }

 if ( clients[ clientNum ].clientState != SCS_PUREWAIT ) {

  common->DPrintf( "client %d: got reliable pure while != SCS_PUREWAIT, sending a reload\n", clientNum );
  outMsg.Init( msgBuf, sizeof( msgBuf ) );
  outMsg.WriteByte( SERVER_RELIABLE_MESSAGE_RELOAD );
  SendReliableMessage( clientNum, msg );

  clients[ clientNum ].clientState = SCS_CONNECTED;
  return;
 }

 if ( !VerifyChecksumMessage( clientNum, __null, msg, reply, clients[ clientNum ].OS ) ) {
  DropClient( clientNum, reply );
  return;
 }
 common->DPrintf( "client %d: passed pure checks (reliable channel)\n", clientNum );
 clients[ clientNum ].clientState = SCS_CONNECTED;
}






void idAsyncServer::RemoteConsoleOutput( const char *string ) {
 noRconOutput = false;
 PrintOOB( rconAddress, SERVER_PRINT_RCON, string );
}






void RConRedirect( const char *string ) {
 idAsyncNetwork::server.RemoteConsoleOutput( string );
}






void idAsyncServer::ProcessRemoteConsoleMessage( const netadr_t from, const idBitMsg &msg ) {
 idBitMsg outMsg;
 byte msgBuf[952];
 char string[1024];

 if ( idAsyncNetwork::serverRemoteConsolePassword.GetString()[0] == '\0' ) {
  PrintOOB( from, SERVER_PRINT_MISC, "#str_04846" );
  return;
 }

 msg.ReadString( string, sizeof( string ) );

 if ( idStr::Icmp( string, idAsyncNetwork::serverRemoteConsolePassword.GetString() ) != 0 ) {
  PrintOOB( from, SERVER_PRINT_MISC, "#str_04847" );
  return;
 }

 msg.ReadString( string, sizeof( string ) );

 common->Printf( "rcon from %s: %s\n", Sys_NetAdrToString( from ), string );

 rconAddress = from;
 noRconOutput = true;
 common->BeginRedirect( (char *)msgBuf, sizeof( msgBuf ), RConRedirect );

 cmdSystem->BufferCommandText( CMD_EXEC_NOW, string );

 common->EndRedirect();

 if ( noRconOutput ) {
  PrintOOB( rconAddress, SERVER_PRINT_RCON, "#str_04848" );
 }
}






void idAsyncServer::ProcessGetInfoMessage( const netadr_t from, const idBitMsg &msg ) {
 int i, challenge;
 idBitMsg outMsg;
 byte msgBuf[16384];

 if ( !IsActive() ) {
  return;
 }

 common->DPrintf( "Sending info response to %s\n", Sys_NetAdrToString( from ) );

 challenge = msg.ReadLong();

 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteShort( -1 );
 outMsg.WriteString( "infoResponse" );
 outMsg.WriteLong( challenge );
 outMsg.WriteLong( ASYNC_PROTOCOL_VERSION );
 outMsg.WriteDeltaDict( sessLocal.mapSpawnData.serverInfo, __null );

 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  serverClient_t &client = clients[i];

  if ( client.clientState < SCS_CONNECTED ) {
   continue;
  }

  outMsg.WriteByte( i );
  outMsg.WriteShort( client.clientPing );
  outMsg.WriteLong( client.channel.GetMaxOutgoingRate() );
  outMsg.WriteString( sessLocal.mapSpawnData.userInfo[i].GetString( "ui_name", "Player" ) );
 }
 outMsg.WriteByte( MAX_ASYNC_CLIENTS );
 outMsg.WriteLong( fileSystem->GetOSMask() );

 serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );
}







void idAsyncServer::PrintLocalServerInfo( void ) {
 int i;

 common->Printf( "server '%s' IP = %s\nprotocol %d.%d OS mask 0x%x\n",
     sessLocal.mapSpawnData.serverInfo.GetString( "si_name" ),
     Sys_NetAdrToString( serverPort.GetAdr() ),
     1,
     ASYNC_PROTOCOL_MINOR,
     fileSystem->GetOSMask() );
 sessLocal.mapSpawnData.serverInfo.Print();
 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  serverClient_t &client = clients[i];
  if ( client.clientState < SCS_CONNECTED ) {
   continue;
  }
  common->Printf( "client %2d: %s, ping = %d, rate = %d\n", i,
      sessLocal.mapSpawnData.userInfo[i].GetString( "ui_name", "Player" ),
      client.clientPing, client.channel.GetMaxOutgoingRate() );
 }
}






bool idAsyncServer::ConnectionlessMessage( const netadr_t from, const idBitMsg &msg ) {
 char string[1024*2];

 msg.ReadString( string, sizeof( string ) );


 if ( idStr::Icmp( string, "getInfo" ) == 0 ) {
  ProcessGetInfoMessage( from, msg );
  return false;
 }


 if ( idStr::Icmp( string, "rcon" ) == 0 ) {
  ProcessRemoteConsoleMessage( from, msg );
  return true;
 }

 if ( !active ) {
  PrintOOB( from, SERVER_PRINT_MISC, "#str_04849" );
  return false;
 }


 if ( idStr::Icmp( string, "challenge" ) == 0 ) {
  ProcessChallengeMessage( from, msg );
  return false;
 }


 if ( idStr::Icmp( string, "connect" ) == 0 ) {
  ProcessConnectMessage( from, msg );
  return false;
 }


 if ( idStr::Icmp( string, "pureClient" ) == 0 ) {
  ProcessPureMessage( from, msg );
  return false;
 }


 if ( idStr::Icmp( string, "downloadRequest" ) == 0 ) {
  ProcessDownloadRequestMessage( from, msg );
 }


 if ( idStr::Icmp( string, "auth" ) == 0 ) {
  if ( !Sys_CompareNetAdrBase( from, idAsyncNetwork::GetMasterAddress() ) ) {
   common->Printf( "auth: bad source %s\n", Sys_NetAdrToString( from ) );
   return false;
  }
  if ( idAsyncNetwork::LANServer.GetBool() ) {
   common->Printf( "auth message from master. net_LANServer is enabled, ignored.\n" );
  }
  ProcessAuthMessage( msg );
  return false;
 }

 return false;
}






bool idAsyncServer::ProcessMessage( const netadr_t from, idBitMsg &msg ) {
 int i, id, sequence;
 idBitMsg outMsg;
 byte msgBuf[16384];

 id = msg.ReadShort();


 if ( id == -1 ) {
  return ConnectionlessMessage( from, msg );
 }

 if ( msg.GetRemaingData() < 4 ) {
  common->DPrintf( "%s: tiny packet\n", Sys_NetAdrToString( from ) );
  return false;
 }


 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  serverClient_t &client = clients[i];

  if ( client.clientState == SCS_FREE ) {
   continue;
  }



  if ( !Sys_CompareNetAdrBase( from, client.channel.GetRemoteAddress() ) || id != client.clientId ) {
   continue;
  }


  if ( !client.channel.Process( from, serverTime, msg, sequence ) ) {
   return false;
  }



  if ( client.clientState == SCS_ZOMBIE ) {
   return false;
  }

  client.lastPacketTime = serverTime;

  ProcessReliableClientMessages( i );
  ProcessUnreliableClientMessage( i, msg );

  return false;
 }



 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteShort( -1 );
 outMsg.WriteString( "disconnect" );
 serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );

 return false;
}






void idAsyncServer::SendReliableGameMessage( int clientNum, const idBitMsg &msg ) {
 int i;
 idBitMsg outMsg;
 byte msgBuf[16384];

 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteByte( SERVER_RELIABLE_MESSAGE_GAME );
 outMsg.WriteData( msg.GetData(), msg.GetSize() );

 if ( clientNum >= 0 && clientNum < MAX_ASYNC_CLIENTS ) {
  if ( clients[clientNum].clientState == SCS_INGAME ) {
   SendReliableMessage( clientNum, outMsg );
  }
  return;
 }

 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[i].clientState != SCS_INGAME ) {
   continue;
  }
  SendReliableMessage( i, outMsg );
 }
}






void idAsyncServer::SendReliableGameMessageExcluding( int clientNum, const idBitMsg &msg ) {
 int i;
 idBitMsg outMsg;
 byte msgBuf[16384];

 ((void)0);

 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteByte( SERVER_RELIABLE_MESSAGE_GAME );
 outMsg.WriteData( msg.GetData(), msg.GetSize() );

 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( i == clientNum ) {
   continue;
  }
  if ( clients[i].clientState != SCS_INGAME ) {
   continue;
  }
  SendReliableMessage( i, outMsg );
 }
}






void idAsyncServer::LocalClientSendReliableMessage( const idBitMsg &msg ) {
 if ( localClientNum < 0 ) {
  common->Printf( "LocalClientSendReliableMessage: no local client\n" );
  return;
 }
 game->ServerProcessReliableMessage( localClientNum, msg );
}






void idAsyncServer::ProcessConnectionLessMessages( void ) {
 int size, id;
 idBitMsg msg;
 byte msgBuf[16384];
 netadr_t from;

 if ( !serverPort.GetPort() ) {
  return;
 }

 while( serverPort.GetPacket( from, msgBuf, size, sizeof( msgBuf ) ) ) {
  msg.Init( msgBuf, sizeof( msgBuf ) );
  msg.SetSize( size );
  msg.BeginReading();
  id = msg.ReadShort();
  if ( id == -1 ) {
   ConnectionlessMessage( from, msg );
  }
 }
}






int idAsyncServer::UpdateTime( int clamp ) {
 int time, msec;

 time = Sys_Milliseconds();
 msec = idMath::ClampInt( 0, clamp, time - realTime );
 realTime = time;
 serverTime += msec;
 return msec;
}






void idAsyncServer::RunFrame( void ) {
 int i, msec, size;
 bool newPacket;
 idBitMsg msg;
 byte msgBuf[16384];
 netadr_t from;
 int outgoingRate, incomingRate;
 float outgoingCompression, incomingCompression;
Sys_Printf(">>> idAsyncServer::RunFrame\r\n");
 msec = UpdateTime( 100 );

 if ( !serverPort.GetPort() ) {
  return;
 }

 if ( !active ) {
  ProcessConnectionLessMessages();
  return;
 }

 gameTimeResidual += msec;


 do {

  do {


   newPacket = serverPort.GetPacketBlocking( from, msgBuf, size, sizeof( msgBuf ), USERCMD_MSEC - gameTimeResidual - 1 );
   if ( newPacket ) {
    msg.Init( msgBuf, sizeof( msgBuf ) );
    msg.SetSize( size );
    msg.BeginReading();
    if ( ProcessMessage( from, msg ) ) {
     return;
    }
   }

   msec = UpdateTime( 100 );
   gameTimeResidual += msec;

  } while( newPacket );

 } while( gameTimeResidual < USERCMD_MSEC );


 MasterHeartbeat();


 CheckClientTimeouts();

 if ( idAsyncNetwork::idleServer.GetBool() == ( !GetNumClients() || GetNumIdleClients() != GetNumClients() ) ) {
  idAsyncNetwork::idleServer.SetBool( !idAsyncNetwork::idleServer.GetBool() );

  sessLocal.mapSpawnData.serverInfo.Set( "si_idleServer", idAsyncNetwork::idleServer.GetString() );
  game->SetServerInfo( sessLocal.mapSpawnData.serverInfo );
 }


 if ( serverTime > 0x70000000 ) {
  ExecuteMapChange();
  return;
 }


 if ( cvarSystem->GetModifiedFlags() & CVAR_NETWORKSYNC ) {
  idDict newCvars;
  newCvars = *cvarSystem->MoveCVarsToDict( CVAR_NETWORKSYNC );
  SendSyncedCvarsBroadcast( newCvars );
  cvarSystem->ClearModifiedFlags( CVAR_NETWORKSYNC );
 }


 if ( cvarSystem->GetModifiedFlags() & CVAR_USERINFO ) {
  if ( localClientNum >= 0 ) {
   idDict newInfo;
   game->ThrottleUserInfo( );
   newInfo = *cvarSystem->MoveCVarsToDict( CVAR_USERINFO );
   SendUserInfoBroadcast( localClientNum, newInfo );
  }
  cvarSystem->ClearModifiedFlags( CVAR_USERINFO );
 }


 while( gameTimeResidual >= USERCMD_MSEC ) {


  LocalClientInput();


  DuplicateUsercmds( gameFrame, gameTime );


  gameReturn_t ret = game->RunFrame( userCmds[gameFrame & ( MAX_USERCMD_BACKUP - 1 ) ] );

  idAsyncNetwork::ExecuteSessionCommand( ret.sessionCommand );


  gameFrame++;
  gameTime += USERCMD_MSEC;
  gameTimeResidual -= USERCMD_MSEC;
 }


 DuplicateUsercmds( gameFrame, gameTime );


 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  serverClient_t &client = clients[i];

  if ( client.clientState == SCS_FREE || i == localClientNum ) {
   continue;
  }


  if ( idAsyncNetwork::serverMaxClientRate.IsModified() ) {
   client.channel.SetMaxOutgoingRate( Min( client.clientRate, idAsyncNetwork::serverMaxClientRate.GetInteger() ) );
  }


  if ( !client.channel.ReadyToSend( serverTime ) ) {
   continue;
  }


  if ( client.channel.UnsentFragmentsLeft() ) {
   client.channel.SendNextFragment( serverPort, serverTime );
   continue;
  }

  if ( client.clientState == SCS_INGAME ) {
   if ( !SendSnapshotToClient( i ) ) {
    SendPingToClient( i );
   }
  } else {
   SendEmptyToClient( i );
  }
 }

 if ( com_showAsyncStats.GetBool() ) {

  UpdateAsyncStatsAvg();


  if ( idAsyncNetwork::serverDedicated.GetBool() && serverTime >= nextAsyncStatsTime ) {
   common->Printf( "delay = %d msec, total outgoing rate = %d KB/s, total incoming rate = %d KB/s\n", GetDelay(),
       GetOutgoingRate() >> 10, GetIncomingRate() >> 10 );

   for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {

    outgoingRate = GetClientOutgoingRate( i );
    incomingRate = GetClientIncomingRate( i );
    outgoingCompression = GetClientOutgoingCompression( i );
    incomingCompression = GetClientIncomingCompression( i );

    if ( outgoingRate != -1 && incomingRate != -1 ) {
     common->Printf( "client %d: out rate = %d B/s (% -2.1f%%), in rate = %d B/s (% -2.1f%%)\n",
         i, outgoingRate, outgoingCompression, incomingRate, incomingCompression );
    }
   }

   idStr msg;
   GetAsyncStatsAvgMsg( msg );
   common->Printf( va( "%s\n", msg.c_str() ) );

   nextAsyncStatsTime = serverTime + 1000;
  }
 }

 idAsyncNetwork::serverMaxClientRate.ClearModified();
}






void idAsyncServer::PacifierUpdate( void ) {
 int i;

 if ( !IsActive() ) {
  return;
 }
 realTime = Sys_Milliseconds();
 ProcessConnectionLessMessages();
 for ( i = 0; i < MAX_ASYNC_CLIENTS; i++ ) {
  if ( clients[i].clientState >= SCS_PUREWAIT ) {
   if ( clients[i].channel.UnsentFragmentsLeft() ) {
    clients[i].channel.SendNextFragment( serverPort, serverTime );
   } else {
    SendEmptyToClient( i );
   }
  }
 }
}






void idAsyncServer::PrintOOB( const netadr_t to, int opcode, const char *string ) {
 idBitMsg outMsg;
 byte msgBuf[ 16384 ];

 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteShort( -1 );
 outMsg.WriteString( "print" );
 outMsg.WriteLong( opcode );
 outMsg.WriteString( string );
 serverPort.SendPacket( to, outMsg.GetData(), outMsg.GetSize() );
}






void idAsyncServer::MasterHeartbeat( bool force ) {
 if ( idAsyncNetwork::LANServer.GetBool() ) {
  if ( force ) {
   common->Printf( "net_LANServer is enabled. Not sending heartbeats\n" );
  }
  return;
 }
 if ( force ) {
  nextHeartbeatTime = 0;
 }

 if ( serverTime < nextHeartbeatTime ) {
  return;
 }
 nextHeartbeatTime = serverTime + HEARTBEAT_MSEC;
 for ( int i = 0 ; i < MAX_MASTER_SERVERS ; i++ ) {
  netadr_t adr;
  if ( idAsyncNetwork::GetMasterAddress( i, adr ) ) {
   common->Printf( "Sending heartbeat to %s\n", Sys_NetAdrToString( adr ) );
   idBitMsg outMsg;
   byte msgBuf[ 16384 ];
   outMsg.Init( msgBuf, sizeof( msgBuf ) );
   outMsg.WriteShort( -1 );
   outMsg.WriteString( "heartbeat" );
   serverPort.SendPacket( adr, outMsg.GetData(), outMsg.GetSize() );
  }
 }
}






void idAsyncServer::SendEnterGameToClient( int clientNum ) {
 idBitMsg msg;
 byte msgBuf[ 16384 ];

 msg.Init( msgBuf, sizeof( msgBuf ) );
 msg.WriteByte( SERVER_RELIABLE_MESSAGE_ENTERGAME );
 SendReliableMessage( clientNum, msg );
}






void idAsyncServer::UpdateAsyncStatsAvg( void ) {
 stats_average_sum -= stats_outrate[ stats_current ];
 stats_outrate[ stats_current ] = idAsyncNetwork::server.GetOutgoingRate();
 if ( stats_outrate[ stats_current ] > stats_max ) {
  stats_max = stats_outrate[ stats_current ];
  stats_max_index = stats_current;
 } else if ( stats_current == stats_max_index ) {

  int i;
  stats_max = 0;
  for ( i = 0; i < stats_numsamples ; i++ ) {
   if ( stats_outrate[ i ] > stats_max ) {
    stats_max = stats_outrate[ i ];
    stats_max_index = i;
   }
  }
 }
 stats_average_sum += stats_outrate[ stats_current ];
 stats_current++; stats_current %= stats_numsamples;
}






void idAsyncServer::GetAsyncStatsAvgMsg( idStr &msg ) {
 sprintf( msg, "avrg out: %d B/s - max %d B/s ( over %d ms )", stats_average_sum / stats_numsamples, stats_max, idAsyncNetwork::serverSnapshotDelay.GetInteger() * stats_numsamples );
}






void idAsyncServer::ProcessDownloadRequestMessage( const netadr_t from, const idBitMsg &msg ) {
 int challenge, clientId, iclient, numPaks, i;
 int dlGamePak;
 int dlPakChecksum;
 int dlSize[ MAX_PURE_PAKS ];
 idStrList pakNames;
 idStrList pakURLs;
 char pakbuf[ 1024 ];
 idStr paklist;
 byte msgBuf[ 16384 ];
 byte tmpBuf[ 16384 ];
 idBitMsg outMsg, tmpMsg;
 int dlRequest;
 int voidSlots = 0;

 challenge = msg.ReadLong();
 clientId = msg.ReadShort();
 dlRequest = msg.ReadLong();

 if ( ( iclient = ValidateChallenge( from, challenge, clientId ) ) == -1 ) {
  return;
 }

 if ( challenges[ iclient ].authState != CDK_PUREWAIT ) {
  common->DPrintf( "client %s: got download request message, not in CDK_PUREWAIT\n", Sys_NetAdrToString( from ) );
  return;
 }


 dlGamePak = msg.ReadLong();
 if ( dlGamePak ) {
  if ( !( dlSize[ 0 ] = fileSystem->ValidateDownloadPakForChecksum( dlGamePak, pakbuf, true ) ) ) {
   common->Warning( "client requested unknown game pak 0x%x", dlGamePak );
   pakbuf[ 0 ] = '\0';
   voidSlots++;
  }
 } else {
  pakbuf[ 0 ] = '\0';
  voidSlots++;
 }
 pakNames.Append( pakbuf );
 numPaks = 1;


 dlPakChecksum = msg.ReadLong();
 while ( dlPakChecksum ) {
  if ( !( dlSize[ numPaks ] = fileSystem->ValidateDownloadPakForChecksum( dlPakChecksum, pakbuf, false ) ) ) {

   common->Warning( "client requested an unknown pak 0x%x", dlPakChecksum );
   pakbuf[ 0 ] = '\0';
   voidSlots++;
  }
  pakNames.Append( pakbuf );
  numPaks++;
  dlPakChecksum = msg.ReadLong();
 }

 for ( i = 0; i < pakNames.Num(); i++ ) {
  if ( i > 0 ) {
   paklist += ";";
  }
  paklist += pakNames[ i ].c_str();
 }


 common->DPrintf( "got download request for %d paks - %s\n", numPaks - voidSlots, paklist.c_str() );

 outMsg.Init( msgBuf, sizeof( msgBuf ) );
 outMsg.WriteShort( -1 );
 outMsg.WriteString( "downloadInfo" );
 outMsg.WriteLong( dlRequest );
 if ( !game->DownloadRequest( Sys_NetAdrToString( from ), challenges[ iclient ].guid, paklist.c_str(), pakbuf ) ) {
  common->DPrintf( "game: no downloads\n" );
  outMsg.WriteByte( SERVER_DL_NONE );
  serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );
  return;
 }

 char *token, *next;
 int type = 0;

 token = pakbuf;
 next = strchr( token, ';' );
 while ( token ) {
  if ( next ) {
   *next = '\0';
  }

  if ( type == 0 ) {
   type = atoi( token );
  } else if ( type == SERVER_DL_REDIRECT ) {
   common->DPrintf( "download request: redirect to URL %s\n", token );
   outMsg.WriteByte( SERVER_DL_REDIRECT );
   outMsg.WriteString( token );
   serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );
   return;
  } else if ( type == SERVER_DL_LIST ) {
   pakURLs.Append( token );
  } else {
   common->DPrintf( "wrong op type %d\n", type );
   next = token = __null;
  }

  if ( next ) {
   token = next + 1;
   next = strchr( token, ';' );
  } else {
   token = __null;
  }
 }

 if ( type == SERVER_DL_LIST ) {
  int totalDlSize = 0;
  int numActualPaks = 0;


  outMsg.WriteByte( SERVER_DL_LIST );

  tmpMsg.Init( tmpBuf, 16384 );

  for ( i = 0; i < pakURLs.Num(); i++ ) {
   tmpMsg.BeginWriting();
   if ( !dlSize[ i ] || !pakURLs[ i ].Length() ) {

    tmpMsg.WriteByte( SERVER_PAK_NO );
    tmpMsg.WriteString( pakNames[ i ] );
   } else {
    totalDlSize += dlSize[ i ];
    numActualPaks++;
    tmpMsg.WriteByte( SERVER_PAK_YES );
    tmpMsg.WriteString( pakNames[ i ] );
    tmpMsg.WriteString( pakURLs[ i ] );
    tmpMsg.WriteLong( dlSize[ i ] );
   }


   if ( outMsg.GetRemainingSpace() - tmpMsg.GetSize() > 5 ) {
    outMsg.WriteData( tmpMsg.GetData(), tmpMsg.GetSize() );
   } else {
    outMsg.WriteByte( SERVER_PAK_END );
    break;
   }
  }
  if ( i == pakURLs.Num() ) {

   outMsg.WriteByte( SERVER_PAK_END );
  }
  common->DPrintf( "download request: download %d paks, %d bytes\n", numActualPaks, totalDlSize );

  serverPort.SendPacket( from, outMsg.GetData(), outMsg.GetSize() );
 }
}
